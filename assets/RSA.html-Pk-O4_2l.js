import{_ as p}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as o,o as i,c as l,a as n,b as a,d as e,e as t}from"./app-D0nkxfln.js";const r={},c=t('<h1 id="rsa算法" tabindex="-1"><a class="header-anchor" href="#rsa算法" aria-hidden="true">#</a> RSA算法</h1><h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景:</h2><p>RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。 RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。 今天只有短的RSA钥匙才可能被强力方式解破。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。但在分布式计算和量子计算机理论日趋成熟的今天，RSA加密安全性受到了挑战。 RSA算法基于一个十分简单的数论事实：<strong>将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</strong> RSA算法是现今使用最广泛的公钥密码算法，也是号称地球上最安全的加密算法。在了解RSA算法之前，先熟悉下几个术语 根据密钥的使用方法，可以将密码分为对称密码和公钥密码 🍬对称密码：加密和解密使用同一种密钥的方式 🍬公钥密码：加密和解密使用不同的密码的方式，因此公钥密码通常也称为非对称密码。</p><h2 id="了解知识点" tabindex="-1"><a class="header-anchor" href="#了解知识点" aria-hidden="true">#</a> 了解知识点</h2><p>费马小定理</p><ul><li><p>a为整数 p 为质数 那么就满足</p><figure><img src="https://awaqwqa.github.io/img/RSA/image-20240704014527546.png" alt="image-20240704014527546" tabindex="0" loading="lazy"><figcaption>image-20240704014527546</figcaption></figure><ul><li><p>当a是p的倍数 所以a的p次方也是p的倍数 所以a就等于0 ----？</p></li><li><p>如果a不是p的质数的话 则</p><figure><img src="https://awaqwqa.github.io/img/RSA/image-20240704014620377.png" alt="image-20240704014620377" tabindex="0" loading="lazy"><figcaption>image-20240704014620377</figcaption></figure></li></ul></li></ul><p>，欧拉函数，欧拉定理</p><h2 id="计算方式" tabindex="-1"><a class="header-anchor" href="#计算方式" aria-hidden="true">#</a> 计算方式</h2>',8),u={href:"https://blog.csdn.net/qq_43695957/article/details/116062333",target:"_blank",rel:"noopener noreferrer"},d=n("p",null,"质数(prime number)又称素数，有无限个。一个大于1的自然数，除了1和它本身外，不能被其他自然数整除，换句话说就是该数除了1和它本身以外不再有其他的因数;否则称为合数。",-1),k={href:"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%95%B8%E8%AB%96",target:"_blank",rel:"noopener noreferrer"},h={href:"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B8",target:"_blank",rel:"noopener noreferrer"},g=n("em",null,"n",-1),m=n("em",null,"n",-1),_=n("em",null,"n",-1),b={href:"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E4%BA%92%E8%B3%AA",target:"_blank",rel:"noopener noreferrer"},f={href:"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0_(%E6%95%B0%E5%AD%A6)",target:"_blank",rel:"noopener noreferrer"},v={href:"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89",target:"_blank",rel:"noopener noreferrer"},E={href:"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%8D%A1%E7%88%BE%C2%B7%E5%BC%97%E9%87%8C%E5%BE%B7%E9%87%8C%E5%B8%8C%C2%B7%E9%AB%98%E6%96%AF",target:"_blank",rel:"noopener noreferrer"},A=n("strong",null,"互素",-1),w={href:"https://zh.wikipedia.org/wiki/%E6%95%B8%E8%AB%96",target:"_blank",rel:"noopener noreferrer"},y={href:"https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B8",target:"_blank",rel:"noopener noreferrer"},x={href:"https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B8",target:"_blank",rel:"noopener noreferrer"},B=n("strong",null,"互质",-1),q=n("p",null,[n("code",null,"扩展欧几里得")],-1),z=t('<li><p>选择两个大素数p和q典型值为1024位</p><ul><li><p>判断素数</p><figure><img src="https://awaqwqa.github.io/img/RSA/image-20240704014311077.png" alt="image-20240704014311077" tabindex="0" loading="lazy"><figcaption>image-20240704014311077</figcaption></figure></li></ul></li><li><p>计算<code>n=p*q</code>和<code>z=(p-1)*(q-1)</code></p><figure><img src="https://img2020.cnblogs.com/blog/1959611/202005/1959611-20200521153315122-2088406130.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li>这里的n就代表欧拉函数 也就是phi(n)</li></ul></li><li><p>找到一个e 也就是<strong>1&lt; e &lt; φ(n)，且e与φ(n) 互质。</strong> 实际运用中常常选择常常选择 <strong>65537</strong></p></li>',3),S=n("p",null,[n("strong",null,"计算e对于φ(n)的模反元素d(逆元)。")],-1),R={href:"http://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0",target:"_blank",rel:"noopener noreferrer"},C=n("code",null,"ed ≡ 1 (mod φ(n))",-1),D=n("code",null,"　ed - 1 = kφ(n)",-1),N={href:"http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95",target:"_blank",rel:"noopener noreferrer"},V=n("li",null,[n("p",null,"然后公开密钥为:(e,n),私有密钥为(d,n)")],-1),F=t(`<p>实际应用:</p><figure><img src="https://awaqwqa.github.io/img/RSA/image-20240704024340068.png" alt="image-20240704024340068" tabindex="0" loading="lazy"><figcaption>image-20240704024340068</figcaption></figure><ul><li>比如加密:ｍe ≡ c (mod n) 公钥: (e n) <ul><li>所以c = me - kn</li></ul></li><li>然后解密:cd = m (mod n) 私钥:(d,n) <ul><li>所以c=me-kn带入得到 (me-kn)d = m(mod n) 所以等价为:med = m (mod n)</li><li>因为ed = 1(mod phi n)</li></ul></li></ul><h2 id="安全性" tabindex="-1"><a class="header-anchor" href="#安全性" aria-hidden="true">#</a> 安全性</h2><p>有办法通过公钥 也就是n e推到出d吗 因为私钥就是(d,n)知道了私钥就有办法通过密文解密出原文 上述一共提及了几个字母:<code>p</code>,<code>q</code>,<code>n</code>,<code>phi n</code>,<code>e</code>,<code>d</code></p><ol><li>比如我们推算d的公式:ed=1mod(phi n ) 所以也就是如果知道了e和phi n就可以算出d</li><li>phi n = (p-1)(q-1) 所以知道了p和q就知道了phi n</li><li>n=pq 也就是能够将n因式分解就可以算出p和q</li></ol><p>那么首先就可以很容易想到通过逆推3-&gt;2-&gt;1 所以我们可以将n因式分解就可以得到pq然后得到phin 我们本来就拥有e所以就可以算出d 但是还记得我们最开始说的吗 rsa的难点就在于大数的因式分解 所以一般不会这样简单</p><ul><li>所以我们一般通过额外的一些信息来进行安全攻击</li></ul><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现" aria-hidden="true">#</a> 代码实现</h2><ul><li><p><strong>扩展欧几里得算法</strong></p><p>因为ed = 1(mod phi n) 所以ed - kphi n = 1 已经知道e和phi 丢入则得到d和k</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">ext_gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> gcd <span class="token operator">=</span> ext_gcd<span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span>
        x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">//</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> y<span class="token punctuation">)</span>
        <span class="token keyword">return</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> gcd

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li></li></ul><h2 id="ctf中常见题型" tabindex="-1"><a class="header-anchor" href="#ctf中常见题型" aria-hidden="true">#</a> CTF中常见题型</h2><ul><li>rsa中通常还有个<strong>签名消息</strong>也就是校验码,确定密文是否被修改过</li></ul><ol><li><p>已经知道p,q,e求d</p><p>ed=1(mod phi n)所以利用<strong>扩展欧几里得算法</strong> 函数:gmpy2.invert 按照e phi_n顺序丢入</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> gmpy2


<span class="token keyword">def</span> <span class="token function">ext_gcd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> gcd <span class="token operator">=</span> ext_gcd<span class="token punctuation">(</span>b<span class="token punctuation">,</span> a <span class="token operator">%</span> b<span class="token punctuation">)</span>
        x<span class="token punctuation">,</span> y <span class="token operator">=</span> y<span class="token punctuation">,</span> <span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token punctuation">(</span>a <span class="token operator">//</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> y<span class="token punctuation">)</span>
        <span class="token keyword">return</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> gcd

p <span class="token operator">=</span> <span class="token number">38456719616722997</span>
q <span class="token operator">=</span> <span class="token number">44106885765559411</span>
e <span class="token operator">=</span> <span class="token number">65537</span>

phi_n <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>ext_gcd<span class="token punctuation">(</span>phi_n<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
d <span class="token operator">=</span> gmpy2<span class="token punctuation">.</span>invert<span class="token punctuation">(</span>e<span class="token punctuation">,</span>phi_n<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol>`,13),I=n("p",null,"已经知道n比较小,e求d?",-1),L={href:"https://zh.numberempire.com/factoringcalculator.php",target:"_blank",rel:"noopener noreferrer"},T=n("p",null,"通过分解n得到p,q然后根据e 得到d",-1),O=n("li",null,[n("p",null,[n("strong",null,"已知密文文件 flag.enc / cipher.bin /flag.b64和 公钥文件 pubkey.pem /key.pem /key.pub求解明文 m？")]),n("p",null,"使用RsaCtfTool")],-1),j=n("li",null,[n("p",null,"已知 c ,e,n非常大 和dp dq求解m"),n("p",null,"领航杯2019的一道题")],-1);function G(H,J){const s=o("ExternalLinkIcon");return i(),l("div",null,[c,n("blockquote",null,[n("p",null,[a("参考文章:"),n("a",u,[a("素数（质数）判断的五种方法_判断质数-CSDN博客"),e(s)])]),d,n("p",null,[a("欧拉函数：在"),n("a",k,[a("数论"),e(s)]),a("中，对正"),n("a",h,[a("整数"),e(s)]),g,a("，"),n("strong",null,[a("欧拉函数φ(n)"),n("strong",null,[a("是小于或等于"),m,a("的正整数中与"),_,n("a",b,[a("互质"),e(s)]),a("的数的数目,此"),n("a",f,[a("函数"),e(s)]),a("以其首名研究者"),n("a",v,[a("欧拉"),e(s)]),a("命名，它又称为")]),a("φ函数")]),a("（由"),n("a",E,[a("高斯"),e(s)]),a("所命名）")]),n("p",null,[a("互质:又称"),A,a("在"),n("a",w,[a("数论"),e(s)]),a("中，如果两个或两个以上的"),n("a",y,[a("整数"),e(s)]),a("的"),n("a",x,[a("最大公约数"),e(s)]),a("是1，则称它们为"),B,a("。")]),q]),n("ul",null,[z,n("li",null,[S,n("ul",null,[n("li",null,[a("所谓"),n("a",R,[a('"模反元素"'),e(s)]),a("就是指有一个整数d，可以使得ed被φ(n)除的余数为1。 ed%φ(n) == 1 也就是:"),C]),n("li",null,[a("同时也等价为:"),D,a(" 所以找到d本质上是对ex+yφ(n)=1求解(x替换d,y替换k) 这里求解就用"),n("a",N,[a('"扩展欧几里得算法"'),e(s)]),a(" 就可以求解到x与y")])])]),V]),F,n("ul",null,[n("li",null,[I,n("p",null,[a("也就是通过n的分解（"),n("a",L,[a("因式分解工具 (numberempire.com)"),e(s)]),a("）")]),T]),O,j])])}const P=p(r,[["render",G],["__file","RSA.html.vue"]]);export{P as default};
