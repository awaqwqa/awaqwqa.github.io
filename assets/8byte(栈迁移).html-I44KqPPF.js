import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as i,e as l}from"./app--zBhGYdQ.js";const o={},d=l(`<h1 id="_8byte-简单栈迁移" tabindex="-1"><a class="header-anchor" href="#_8byte-简单栈迁移" aria-hidden="true">#</a> 8byte（简单栈迁移）</h1><h2 id="栈迁移" tabindex="-1"><a class="header-anchor" href="#栈迁移" aria-hidden="true">#</a> 栈迁移</h2><blockquote><p>这里好好学一下栈迁移这个知识点 确实重要 因为已经遇到了很多次了</p></blockquote><h3 id="栈迁移的大致操作" tabindex="-1"><a class="header-anchor" href="#栈迁移的大致操作" aria-hidden="true">#</a> 栈迁移的大致操作</h3><ul><li>通过将<code>ebp</code>覆盖成构造的<code>fake_ebp</code> ，再利用<code>leave_ret</code>这个<code>gadget</code>将<code>esp</code>劫持到<code>fake_ebp</code>的地址上。</li></ul><blockquote><p>这里写个小插曲 因为大多数时候我都是去ida直接找的这个gadget 但是好像可以用命令行来解决这个问题<br>比如我们这里用指令</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ ROPgadget <span class="token parameter variable">--binary</span> pwn <span class="token parameter variable">--only</span> <span class="token string">&quot;leave|ret&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><h3 id="栈迁移核心" tabindex="-1"><a class="header-anchor" href="#栈迁移核心" aria-hidden="true">#</a> 栈迁移核心</h3><blockquote><p>因为我们常使用leave_ret gadget链来实现</p></blockquote><ul><li><p><code> leave</code>指令</p><ul><li><p>首先是依靠这个指令来实现把<code>rbp</code>寄存器值变为我们希望的一个地址 这样就可以实现栈的移动</p><blockquote><p>这里说一下我自己的浅薄理解 因为我们使用的栈其实本质就是基于rbp/rsp定位的 所以我们只需要把寄存器的值改变就实现了<code>栈迁移</code> 新的fake 地址后面的内容会被当成栈</p></blockquote></li><li><p>那么这个指令的本质:</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov esp,ebp;
pop ebp;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li><li><p><code>ret</code> 指令</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>pop eip
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>那么下面是实现原理图</p><figure><img src="https://awaqwqa.github.io/img/栈迁移/原理.png" alt="原理" tabindex="0" loading="lazy"><figcaption>原理</figcaption></figure><ul><li><p>这里是执行<code>mov esp ,ebp;</code>这个操作之前的栈结构 我们在<code>ebp</code>这个位置放入我们我们希望这个栈最终<code>落脚点</code> 然后就会执行</p></li><li><p>​ <img src="https://awaqwqa.github.io/img/栈迁移/原理2.png" alt="原理2" loading="lazy"></p></li><li><p>这里就是<code>pop ebp;</code>这个操作 因为 pop操作我们的rsp向下移动一格 ebp寄存器 存入fake_ebp1_addr</p></li><li><p>然后执行指令<code>ret--&gt; pop eip;</code> 这个指令 那么同理 rsp向下移动一格 eip存入我们的read_plt</p><blockquote><p>这里需要注意eip这个寄存器很特殊 这个寄存器是存入的我们下一条执行的指令地址 所以当执行完ret后整个程序流程就跑到了read_plt这里</p></blockquote></li></ul></li><li><p>那么 到现在我们就可以理清楚了核心需要实现的部分:</p><ul><li>将rbp寄存器改值 ---- &gt;栈迁移</li><li>将rip寄存器改值 ------ &gt;劫持程序流程</li></ul><blockquote><p>换句话说 我们只要能够实现这两个部分就可以了</p></blockquote></li><li><p>接下来我们需要理解 栈的指针寄存器:<code>rsp</code> 还任然留在了原地 以及最容易理解错的是 当我们执行read函数的时候 程序会自动保存下一个指令的地址 这是<code>函数的调用约定</code>所以当我们执行完后read函数后 我们来到了leave_ret指令的地方</p><ul><li><p>此时我们<code>rsp = rbp</code> 那么我们的rsp也成功完成了迁移工作 来到了 fake_ebp的地方</p></li><li><p>然后 把fake_ebp2的地址给了rbp rsp向下跑一下</p></li><li><figure><img src="https://awaqwqa.github.io/img/栈迁移/原理3.png" alt="原理3" tabindex="0" loading="lazy"><figcaption>原理3</figcaption></figure><blockquote><p>所以这里我们是需要构造第二个fake_ebp的</p></blockquote><ul><li>然后我们就成功完成了一次栈迁移</li></ul></li></ul></li></ul>`,9),p=[d];function c(t,s){return a(),i("div",null,p)}const b=e(o,[["render",c],["__file","8byte(栈迁移).html.vue"]]);export{b as default};
