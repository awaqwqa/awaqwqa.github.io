import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as s,c as e,e as n}from"./app--zBhGYdQ.js";const i={},l=n(`<h1 id="linux内核学习-2-dirty-pipe-cow学习" tabindex="-1"><a class="header-anchor" href="#linux内核学习-2-dirty-pipe-cow学习" aria-hidden="true">#</a> linux内核学习(2) dirty pipe/cow学习</h1><blockquote><p>参考文章:https://blog.csdn.net/jasonliuvip/article/details/22600569</p><p>https://zhuanlan.zhihu.com/p/25918300</p><p>https://blog.csdn.net/hbhgyu/article/details/106245182</p><p>mmap函数:https://blog.csdn.net/qq_41687938/article/details/119901916</p><p>脏页面:https://blog.csdn.net/shift_wwx/article/details/122497891</p><p>匿名页:https://blog.csdn.net/jasonchen_gbd/article/details/79462014</p><p>linux下的特殊文件:https://blog.csdn.net/pi9nc/article/details/18257593</p><p>反向映射机制:https://zhuanlan.zhihu.com/p/363319174</p><p>madvise函数:https://blog.csdn.net/sz66cm/article/details/139334306</p></blockquote><h2 id="前置知识" tabindex="-1"><a class="header-anchor" href="#前置知识" aria-hidden="true">#</a> 前置知识</h2><h3 id="脏页面" tabindex="-1"><a class="header-anchor" href="#脏页面" aria-hidden="true">#</a> 脏页面</h3><p>当你通过任何一种方式从磁盘读文件时(read/mmap)，内核都会给你申请一个<strong>page cache</strong>来缓存硬盘上的内容</p><p>linux一般修改的文件数据并不会马上同步到磁盘，会缓存在内存的page cache中 我们把这种和磁盘数据不一致的页称为脏页 然后linux会标记这种内存页为<code>dirty</code></p><h3 id="splice函数" tabindex="-1"><a class="header-anchor" href="#splice函数" aria-hidden="true">#</a> splice函数</h3><p><strong>splice</strong> 用于在两个文件描述符之间移动数据， 也是零拷贝（sendfile）splice其实一般用于管道的读取或者输出,从管道里面读取数据或者将数据放入管道里面 也就是fn_in到fd_outx</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token class-name">ssize_t</span> <span class="token function">splice</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd_in<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off_in<span class="token punctuation">,</span> <span class="token keyword">int</span> fd_out<span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span>off_out<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>Fd_in参数是待输入描述符</p></li><li><p>Off_in表示从输入的数据流何处开始读取</p></li><li><p>Off_out 也就是表示从输出数据流何处开始读取</p></li><li><p>len表示移动数据的长度</p></li><li><p>flags参数表示数据移动的方式</p><ul><li><p><code>SPLICE_F_NONBLOCK</code> 其实重点在后面的noneblock 也就是splice操作不堵塞</p></li><li><p><code>SPLICE_F_MORE</code> 告诉内核下一个splice调用会有更多的数据穿入</p></li><li><p><code>SPLICE_F_MOVE</code>如果输出是文件，那么就会让kernel尝试从输入管道的缓冲区直接将数据读入输出地址空间,这个过程无任何数据拷贝发生</p></li></ul></li><li><p>失败返回值为-1</p></li></ul><h3 id="proc-self-mem" tabindex="-1"><a class="header-anchor" href="#proc-self-mem" aria-hidden="true">#</a> /proc/self/mem</h3><blockquote><p>/proc/self算是一个链接,也就是进程可以通过这个链接获取到当前进程的信息 等效成/proc/pid</p></blockquote><p><code>Proc</code>用户可以用于拿来查询linux kernel相关的信息,文件流访问进程的信息</p><ul><li><p>/proc/pid/cmdline 开始进程的命令</p></li><li><p>/proc/pid/cwd 也就是进程的工作目录的链接</p></li><li><p>/proc/pid/environ 进程可用环境变量信息</p></li><li><p>/proc/pid/fd 也就是进程打开的所有文件链接</p></li><li><p>/proc/pid/mem 包含了进程在内存的内容</p><ul><li>可以通过读写这个文件来实现直接读写虚拟内存空间 无视内存映射的权限设置</li></ul></li><li><p>/proc/pid/stat (status 包含了进程的状态信息</p></li><li><p>/proc/pid/statm (status memory)包含了进程的内存使用信息</p></li></ul><h3 id="cow" tabindex="-1"><a class="header-anchor" href="#cow" aria-hidden="true">#</a> COW</h3><p>主要执行三个重要步骤:</p><ul><li>制作映射内存的副本</li><li>更新页表,让虚拟内存重定位到新创建的物理内存内</li><li>写入内存</li></ul><p>一般操作的时候，我们需要保证操作是原子性的,否则就容易被条件竞争，这也就是dirty cow的漏洞成因</p><h3 id="mmap" tabindex="-1"><a class="header-anchor" href="#mmap" aria-hidden="true">#</a> mmap</h3><blockquote><p>参考文章:https://blog.csdn.net/qq_41687938/article/details/119901916</p><p>linux内核使用vm_area_struct结构来表示一个独立的虚拟内存区域 因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域 比如一个vm_area_struct结构体就代表了text段一样 vm_area_struct主要是包含了一个区域的<strong>起始</strong> 和<strong>结束</strong> 并且包含<strong>vm_ops</strong>指针可以引用所有针对这个区域可以使用的系统调用函数</p></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>start<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token class-name">off_t</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>Start, length无需多言</p></li><li><p>prot 表示映射区域的保护模式</p><ul><li><p>PROT_EXEC 可执行</p></li><li><p>PROT_READ 可读</p></li><li><p>PROT_WRITE 可写</p></li><li><p>PROT_NONE 不能存取</p></li></ul></li><li><p>Flags 表示映射区域的各种特性,</p><ul><li>MAP_FIXED start参数所指地址无法成功建立映射的时候,直接放弃映射,并且不对地址做修正</li><li>MAP_SHARED 对映射区的写入操作会复制回文件内,而且允许其他映射文件的进程共享</li><li>MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制,即私人<strong>cow</strong> 因为会额外copy一个新的内存页所以任何修改都不会写回原本的文件内容(不知道会不会)</li><li>MAP_ANONYMOUS 建立匿名映射,此时回直接忽略fd,不涉及文件,而且也会和其他进程进行共享</li><li>MAP_DENYWRITE(deny write) 只允许对映射区域进行写入</li><li>MAP_LOCAKED 将映射区域锁定住,表示不会产生swap（置换）</li></ul></li><li><p>Fd 也就是要映射到内存中的文件描述符</p><ul><li>如果是匿名内存映射,就要设置<code>MAP_ANONYMOUS</code> flags参数 然后将fd设置为-1</li><li>如果有些系统不支持匿名内存映射,可以通过fopen(&quot;/dev/zero&quot;)然后对这个的文件描述符进行映射 也是可以实现匿名内存映射的 <ul><li><code>/dev/zero</code>全是空白字符,可以利用这个创建一片干净的内存区域</li><li><code>/dev/null</code>只能往里面写入,但是读取会EOF,所以可以当作垃圾桶 比如<strong>cat flag &gt;&gt; /dev/null</strong>这样就可以把数据丢进/dev/null里面</li></ul></li></ul></li></ul><h4 id="mmap映射的文件页" tabindex="-1"><a class="header-anchor" href="#mmap映射的文件页" aria-hidden="true">#</a> mmap映射的文件页</h4><blockquote><p>参考文章:https://blog.csdn.net/shift_wwx/article/details/122497891</p><p>正反向映射:https://zhuanlan.zhihu.com/p/363319174</p></blockquote><ul><li><p>第一次访问文件页时,发生缺页后读文件页到<code>page cache</code>里面,如果是写则设置页表项为<code>dirty</code>,可以写</p></li><li><p>脏页回写的时候,会通过<strong>反向映射机制</strong>(流程较为复杂),查找映射这个页的每一个vma,设置相应进程的页表项为只读,清理脏标</p><ul><li><p><code>正向映射</code> 就是当访问<strong>虚拟地址</strong>的时候需要转化为<strong>物理地址</strong></p></li><li><p><code>反向映射</code> 在以前为了找到一个物理页面的对应页表项 需要去遍历<code>mm</code>（mm_struct 用于管理进程虚拟内存空间的全部信息）然后再遍历<code>mm</code>的<code>vma</code>(vm_area_struct 也就是各种匿名内存页的详细信息) 导致效率及其低下。 所以后面设计出来了**反向映射 比如struct ano_vma 我们匿名页面的<code>page</code>和<code>mapping</code>指向结构体</p></li></ul></li><li><p>若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。</p></li></ul><h3 id="madvise函数" tabindex="-1"><a class="header-anchor" href="#madvise函数" aria-hidden="true">#</a> madvise函数</h3><blockquote><p>参考文章:https://blog.csdn.net/sz66cm/article/details/139334306</p></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">madvise</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> advice<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>也就是向内核提建议</li><li>给addr到addr+len的内存区域的建议 <ul><li>MADV_NORMAL：默认的内存访问行为，不需要特别的优化。</li><li>MADV_RANDOM：进程将以随机顺序访问指定的内存区域。内核可以优化分页算法以适应这种访问模式。</li><li>MADV_SEQUENTIAL：进程将以顺序方式访问指定的内存区域。内核可以优化分页算法以适应这种访问模式。</li><li>MADV_WILLNEED：进程将很快访问指定的内存区域。内核会尝试预读这些页面以减少缺页异常。</li><li>MADV_DONTNEED：进程不再需要指定的内存区域。内核可以释放这些页面，但在以后访问时会重新分配。</li><li>MADV_FREE：告知内核此内存区域可以丢弃，但如果没有内存压力，则保留当前内容，直到进程再次写入。这对于短期内可能会再次使用的内存区域很有用。</li><li>MADV_REMOVE：请求将指定的内存区域中的内容丢弃，并释放相关的物理内存。</li><li>MADV_DONTFORK：在 fork() 系统调用时，不复制指定的内存区域。</li><li>MADV_DOFORK：撤销 MADV_DONTFORK 设置，使 fork() 复制该内存区域。</li><li>MADV_MERGEABLE：将内存区域标记为可合并，内核将尝试将具有相同内容的内存页面合并。</li><li>MADV_UNMERGEABLE：撤销 MADV_MERGEABLE 设置。</li></ul></li></ul><h2 id="dirtycow漏洞成因" tabindex="-1"><a class="header-anchor" href="#dirtycow漏洞成因" aria-hidden="true">#</a> DirtyCOW漏洞成因</h2><h3 id="mmap-cow" tabindex="-1"><a class="header-anchor" href="#mmap-cow" aria-hidden="true">#</a> mmap cow</h3><p>前面提及过mmap再<code>MAP_PRIVATE</code>flags的时候会产生一个映射复制也就是<strong>cow</strong></p><ul><li>此时允许程序通过<code>write</code>系统调用向这块私有进程进行写入操作,但是只会改变映射内存的副本不会改变映射内存本身</li></ul><h3 id="madvise" tabindex="-1"><a class="header-anchor" href="#madvise" aria-hidden="true">#</a> madvise</h3><p>前面的madvise有个flags也就是：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>MADV_DONTNEED：进程不再需要指定的内存区域。内核可以释放这些页面，但在以后访问时会重新分配。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>告知内核不再需要声明地址的内存,让内核释放内存地址的资源,并且进程的页表指向原始物理内存</li></ul><h3 id="结合" tabindex="-1"><a class="header-anchor" href="#结合" aria-hidden="true">#</a> 结合</h3><p>mmap cow的过程是：</p><ul><li>创建内存副本</li><li>进程页表指向原始物理内存的副本</li><li>向副本写入数据</li></ul><p>然后在第二部的时候如果我们恰好能执行madvise从而让副本释放掉,就会将进程的页表重新指向原始的映射内存物理块,那么再次写入数据的时候就会导致只读文件被写入数据</p><h2 id="dirtypipe漏洞成因" tabindex="-1"><a class="header-anchor" href="#dirtypipe漏洞成因" aria-hidden="true">#</a> DirtyPipe漏洞成因</h2>`,42),p=[l];function t(o,c){return s(),e("div",null,p)}const u=a(i,[["render",t],["__file","linux_kernel2.html.vue"]]);export{u as default};
