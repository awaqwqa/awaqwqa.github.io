import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as s,o as i,c as l,a,b as n,d as o,e}from"./app-lvxgbCuj.js";const r={},d=e('<h1 id="c2018-hitcon-gundam-tcahe机制-泄露libc地址" tabindex="-1"><a class="header-anchor" href="#c2018-hitcon-gundam-tcahe机制-泄露libc地址" aria-hidden="true">#</a> c2018-HitCon-gundam(tcahe机制+泄露libc地址)</h1><h2 id="重要知识点" tabindex="-1"><a class="header-anchor" href="#重要知识点" aria-hidden="true">#</a> 重要知识点</h2><blockquote><p>由于linux中使用<code>free()</code>进行内存释放时，不大于 <code>max_fast</code> （默认值为 64B）的 chunk 被释放后，首先会被放到 <code>fast bins</code>中，大于<code>max_fast</code>的chunk或者<code>fast bins</code> 中的空闲 chunk 合并后会被放入<code>unsorted bin</code>中。而在fastbin为空时，<code>unsortbin</code>的fd和bk指向自身<code>main_arena</code>中，该地址的相对偏移值存放在libc.so中，可以通过use after free后打印出<code>main_arena</code>的实际地址，结合偏移值从而得到libc的加载地址。</p></blockquote><h3 id="tcahe机制" tabindex="-1"><a class="header-anchor" href="#tcahe机制" aria-hidden="true">#</a> tcahe机制</h3>',4),p={href:"https://blog.csdn.net/qq_40890756/article/details/102560506",target:"_blank",rel:"noopener noreferrer"},u=e(`<ul><li><p>一共有64个bins</p></li><li><p>Tcache缓存的是<strong>非Large Chunk的chunk</strong>。</p></li><li><p>首先是<code>tcahe</code>是单链表结构,每条链上最多可以有7个chunk</p></li><li><p><code>free</code>后 当对应的tcahe bin放满了 才会放入fastbin,unsorted bin</p></li><li><p><code>malloc</code>的时候优先去tcahe中找</p></li></ul><h4 id="机制" tabindex="-1"><a class="header-anchor" href="#机制" aria-hidden="true">#</a> 机制</h4><ul><li><p>代码:</p><blockquote><p>这里tcache_perthread_struct 首先</p><ul><li>counts代表着每个bin当前所有的chunk数量</li><li>tcache_entry代表着当前bin的首个chunk</li><li>由于是单链形式 所以结构体属性就是下一个chunk的指针</li></ul></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tcache_entry</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">tcache_entry</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
<span class="token punctuation">}</span> tcache_entry<span class="token punctuation">;</span>

<span class="token comment">/* There is one of these for each thread, which contains the
   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping
   overall size low is mildly important.  Note that COUNTS and ENTRIES
   are redundant (we could have just counted the linked list each
   time), this is for performance reasons.  */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tcache_perthread_struct</span>
<span class="token punctuation">{</span>
  <span class="token keyword">char</span> counts<span class="token punctuation">[</span>TCACHE_MAX_BINS<span class="token punctuation">]</span><span class="token punctuation">;</span>
  tcache_entry <span class="token operator">*</span>entries<span class="token punctuation">[</span>TCACHE_MAX_BINS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> tcache_perthread_struct<span class="token punctuation">;</span>

<span class="token keyword">static</span> __thread tcache_perthread_struct <span class="token operator">*</span>tcache <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>结构图</p></li></ul><figure><img src="https://awaqwqa.github.io/img/tcahe/tcahe结构体.png" alt="机制" tabindex="0" loading="lazy"><figcaption>机制</figcaption></figure><h4 id="利用tcache泄露地址" tabindex="-1"><a class="header-anchor" href="#利用tcache泄露地址" aria-hidden="true">#</a> 利用tcache泄露地址</h4><blockquote><p><code>tcache</code>位于heap最前端 也属于一个堆块</p></blockquote><ul><li><p>用vmmap指令查找heap最开始的位置<img src="https://awaqwqa.github.io/img/tcahe/vmmap.png" alt="vmmap" loading="lazy"></p></li><li><p>用x/26gx 指令来查看对应地址 堆结构 （<code>x/26gx 0x55e22cd98000+0x10</code>）</p><figure><img src="https://awaqwqa.github.io/img/tcahe/tcache_heap.png" alt="heap" tabindex="0" loading="lazy"><figcaption>heap</figcaption></figure><blockquote><p>也就是最后一个加入tcache的chunk</p></blockquote></li><li><p>我们通过连续申请8个gundam,让第八个gundam出现在unsorted bin里面 那么我们如何找到它呢?</p></li><li><p>我们这里知道了第七个地址 那么第八个的地址:<strong>x/26gx 0x000055e22cd98a10+0x30+0x110-0x10</strong></p><ul><li>一个gundam包含两个chunk,大小为0x30,另一个为0x110</li></ul></li><li><p>那么输入指令后我们找到了这个chunk</p><figure><img src="https://awaqwqa.github.io/img/tcahe/unsorted_bin.png" alt="unsorted_bins" tabindex="0" loading="lazy"><figcaption>unsorted_bins</figcaption></figure><ul><li>我们可以发现这个地方fd和bk都指向了 同一个地址 也就是<strong>main_arena+88</strong>(unsortedbin头结点)</li></ul></li><li><p>然后我们就得到了main_arena的地址</p></li><li><p>再去查找libc的基地址 <strong>vmmap</strong>得到的:<img src="https://awaqwqa.github.io/img/tcahe/libc_addr.png" alt="libc_addr" loading="lazy"></p></li><li><p>计算:</p><ul><li>0x7f566befac78-libc基地址0x7f566bb4f000=偏移0x3ac78</li><li>这里我们就得到了偏移 这样在远程服务器的时候就可以利用这个偏移获取libc基地址</li></ul></li></ul>`,7);function h(b,m){const c=s("ExternalLinkIcon");return i(),l("div",null,[d,a("blockquote",null,[a("p",null,[n("学习文章:"),a("a",p,[n("glibc Tcache机制-CSDN博客"),o(c)])])]),u])}const g=t(r,[["render",h],["__file","c2018-HitCon-gundam(tcahe机制_泄露libc地址).html.vue"]]);export{g as default};
