import{_ as l}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as o,o as c,c as i,a as n,b as s,d as e,e as t}from"./app-mtXdL8hD.js";const p={},r=n("h1",{id:"不好看的linux内核安全学习-1-复现d3ctf-2022-d3kheap",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#不好看的linux内核安全学习-1-复现d3ctf-2022-d3kheap","aria-hidden":"true"},"#"),s(" 不好看的linux内核安全学习 (1) - 复现d3ctf 2022 d3kheap")],-1),d=n("h2",{id:"题目启动",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#题目启动","aria-hidden":"true"},"#"),s(" 题目启动")],-1),u=n("p",null,"本blog大量内容都是对参考文章的摘录汇总，方便本人查看（ 所以更推荐直接看参考文章",-1),k=n("p",null,"以及这道题有较多的知识点所以整个文章会有点冗余",-1),m=n("p",null,"可能往后linux内核学习的文章都是这样的形式,通过一个cve或者一个题来学习大量知识点,这样会导致文章都很冗余(充斥大量copy内容),所以我给这个系列叫做《不好看的linux内核安全学习》",-1),h=n("p",null,"内核题在比赛时一般是上传 C 语言程序的 base64 编码到服务器，然后运行",-1),b={href:"https://blog.csdn.net/LEON1741/article/details/78159754",target:"_blank",rel:"noopener noreferrer"},_={href:"https://blog.csdn.net/hanxuefan/article/details/7454352",target:"_blank",rel:"noopener noreferrer"},v={href:"https://xz.aliyun.com/t/11370?time__1311=Cq0xR70QeiuDlxGgx%2BOADgGEoKK7T4FpD",target:"_blank",rel:"noopener noreferrer"},g={href:"https://blog.csdn.net/weixin_39871788/article/details/123250595",target:"_blank",rel:"noopener noreferrer"},f={href:"https://kiprey.github.io/2021/10/kernel_pwn_introduction/#%E4%BA%8C%E3%80%81%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE",target:"_blank",rel:"noopener noreferrer"},x={href:"https://blog.csdn.net/dba_monkey/article/details/60767147",target:"_blank",rel:"noopener noreferrer"},y={href:"https://blog.csdn.net/qq_38880380/article/details/79227760",target:"_blank",rel:"noopener noreferrer"},w={href:"https://blog.csdn.net/yexiangCSDN/article/details/82828055",target:"_blank",rel:"noopener noreferrer"},q={href:"https://blog.csdn.net/qq_33406883/article/details/100071183",target:"_blank",rel:"noopener noreferrer"},L=n("p",null,"[【Linux驱动开发100问】什么是模块？如何编写和使用模块？_什么是谷歌挂载模块程序-CSDN博客](https://blog.csdn.net/qq_45172832/article/details/129228731#:~:text=在Linux内核中，模块可以被动态地插入和卸载，因此模块通常被用来扩展内核的功能。,而驱动则是一种特殊的模块，用于管理硬件设备，控制硬件设备的操作。 在Linux中，驱动通常也以模块的形式存在于内核中，从而使得内核可以支持更多的硬件设备。)",-1),I=n("p",null,"[Linux内核的ioctl函数学习 - the_tops - 博客园 (cnblogs.com)](https://www.cnblogs.com/the-tops/p/6738089.html#:~:text=ioctl是设备驱动程序中对设备的I%2FO通道进行管理的函数。 所谓对I%2FO通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。 它的调用个数如下： int ioctl (int,fd%2C ind cmd%2C …)； 其中fd就是用户程序打开设备时使用open函数返回的文件标示符，cmd就是用户程序对设备的控制命令，至于后面的省略号，那是一些补充参数，一般最多一个，有或没有是和cmd的意义相关的。 ioctl函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数控制设备的I%2FO通道。)",-1),z={href:"https://blog.csdn.net/ljl113/article/details/127013196",target:"_blank",rel:"noopener noreferrer"},S={href:"https://www.freebuf.com/articles/system/227357.html",target:"_blank",rel:"noopener noreferrer"},C={href:"http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/",target:"_blank",rel:"noopener noreferrer"},E=n("p",null,"userfaultfd学习:https://brieflyx.me/2020/linux-tools/userfaultfd-internals/",-1),N=n("p",null,"https://blog.jcix.top/2018-10-01/userfaultfd_intro/",-1),j=n("p",null,"https://blog.csdn.net/seaaseesa/article/details/104650794",-1),A=n("p",null,"sk_buff结构体:https://blog.csdn.net/wangquan1992/article/details/112572572",-1),D=n("p",null,"d3kheap复现:https://ywhkkx.github.io/2022/06/30/msg_msg-sk_buff%E7%9A%84%E7%BB%84%E5%90%88%E5%88%A9%E7%94%A8+pipe_buffer%20attack/",-1),T=n("p",null,"msg_msg CVE-2021-22555 :https://www.freebuf.com/articles/system/286366.html",-1),F=t(`<h3 id="文件类型" tabindex="-1"><a class="header-anchor" href="#文件类型" aria-hidden="true">#</a> 文件类型</h3><p><code>rootfs</code>：根文件系统只是文件系统中的一种比较特殊的形式</p><ul><li><p>cpio -idmv &lt; XXX.cpio 可以解压得到整个系统文件</p></li><li><p>根文件系统是内核启动所挂载( mount 在 Linux 中将一个文件系统与一个存储设备关联起来的过程称为挂载 )的第一个文件系统,并且内核代码的<code>映像文件</code>保存在根文件系统中,随后启动一些初始化脚本。</p><ul><li><code>init进程</code>的应用必须运行在根文件系统上</li><li>根文件系统提供了根目录<code>/</code></li><li>shell命令程序必须运行在根文件系统上</li></ul></li><li><p>根文件系统必须包含的目录</p><ul><li><code>/etc</code>：存储重要的配置文件。</li><li><code>/bin</code>：存储常用且开机时必须用到的执行文件。</li><li><code>/sbin</code>：存储着开机过程中所需的系统执行文件。</li><li><code>/lib</code>：存储/bin/及/sbin/的执行文件所需的链接库，以及Linux的内核模块。</li><li><code>/dev</code>：存储设备文件。须</li></ul></li></ul><p><code>bzImage</code>内核文件</p><ul><li>vmlinux 编译出来的最原始的内核文件，未压缩。</li><li>zImage 是vmlinux经过gzip压缩后的文件</li><li>bzimage zImage解压缩内核到低端内存(第一个640K)，bzImage解压缩内核到高端内存(1M以上)。如果内核比较小，那么采用zImage或bzImage都行，如果比较大应该用bzImage。</li><li>vmlinuz 是bzImage/zImage文件的拷贝或指向bzImage/zImage的链接</li></ul><p><code>ko</code> （kernel object）内核模块 (下方单独拿一个板块进行分析ko)</p><ul><li>该文件的意义就是把内核的一些功能移动到内核外边， 需要的时候插入内核，不需要时卸载。</li><li>加载驱动的方法 <ul><li>insmod xxx.ko （<strong>insmod命令</strong>用于将给定的模块加载到内核中 rmmod就是卸载模块 属于动态加载）</li><li>卸载模块:rmmod xxx.ko</li><li>查看已经加载的模块 : lsmod</li></ul></li></ul><h3 id="构建环境" tabindex="-1"><a class="header-anchor" href="#构建环境" aria-hidden="true">#</a> 构建环境</h3><ul><li>题目启动脚本</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># 设置退出指令是ctl+c</span>
stty intr ^<span class="token punctuation">]</span>
<span class="token builtin class-name">cd</span> <span class="token variable"><span class="token variable">\`</span><span class="token function">dirname</span> $0<span class="token variable">\`</span></span>
qemu-system-x86_64 <span class="token punctuation">\\</span>
	<span class="token parameter variable">-m</span> 256M <span class="token punctuation">\\</span>
	<span class="token parameter variable">-cpu</span> kvm64,+smep,+smap <span class="token punctuation">\\</span>
    <span class="token parameter variable">-smp</span> <span class="token assign-left variable">cores</span><span class="token operator">=</span><span class="token number">2</span>,threads<span class="token operator">=</span><span class="token number">2</span> <span class="token punctuation">\\</span>
	<span class="token parameter variable">-kernel</span> bzImage <span class="token punctuation">\\</span>
	<span class="token parameter variable">-initrd</span> ./rootfs.cpio <span class="token punctuation">\\</span>
    <span class="token parameter variable">-nographic</span> <span class="token punctuation">\\</span>
	<span class="token parameter variable">-monitor</span> /dev/null <span class="token punctuation">\\</span>
	<span class="token parameter variable">-snapshot</span> <span class="token punctuation">\\</span>
	<span class="token parameter variable">-append</span> <span class="token string">&quot;console=ttyS0 kaslr pti=on quiet oops=panic panic=1&quot;</span> <span class="token punctuation">\\</span>
	-no-reboot <span class="token punctuation">\\</span>
    <span class="token parameter variable">-s</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接在安装了qemu的linux环境下运行run.sh即可就可以得到环境了</p><h4 id="qemu启动参数" tabindex="-1"><a class="header-anchor" href="#qemu启动参数" aria-hidden="true">#</a> <code>Qemu</code>启动参数</h4><blockquote><p>如果要加载vmlinx符号表,必须在-append的时候指定为<code>nokaslr</code>关闭kernel ASLR功能</p><p>如果Qemu用-s -S <code>调试模式</code>打开了 那么我们就可以用gdb -q -ex &quot;target remote localhost:1234&quot;进行链接</p></blockquote><ul><li><p>内存大小(-m)</p></li><li><p>核心数（-smp）</p></li><li><p>取消仿真GUI（-nographic）</p></li><li><p>gdb调试(-gdb tcp::1234 -S 或者-s -S)</p></li><li><p>快照模式(-snapshot)这样qemu启动虚拟机创建一个写时拷贝（cow）的临时层 所有对虚拟机磁盘的写操作都会被写入到这个临时层，而不会影响底层的原始磁盘映像。也就是说，虚拟机运行期间的所有更改都是暂时的，一旦虚拟机关闭或重启，这些更改就会被丢弃。</p></li><li><p>向内核传递参数(-append)</p><ul><li><p>console=tty50 指定内核的控制台输出使用串行端口tty50 这很重要因为在-nographic情况下</p></li><li><p>kaslr 开启linux kaslr功能 也就是内核随机化内存布局</p></li><li><p>pti=on 也就是启动页表隔离</p></li><li><p>quiet减少内核启动的日志输出,只显示关键信息,隐藏一般性日志</p></li><li><p>oops=panic也就是当内核出现非致命内核错误的时候立刻触发panic（调试）</p></li><li><p>关闭自动重启虚拟机 -no-reboott</p></li><li><p>设置内核文件 -kernel</p></li><li><p>设置根文件系统 -initrd</p></li></ul></li></ul><h4 id="gdb附着" tabindex="-1"><a class="header-anchor" href="#gdb附着" aria-hidden="true">#</a> gdb附着</h4><p>然后可以用<code>gdb -q -ex &quot;target remote localhost:1234&quot;</code>进行连接</p><h2 id="前置知识" tabindex="-1"><a class="header-anchor" href="#前置知识" aria-hidden="true">#</a> 前置知识</h2><h3 id="模块-ko" tabindex="-1"><a class="header-anchor" href="#模块-ko" aria-hidden="true">#</a> 模块(ko)</h3><blockquote><p>先将rootfs利用指令进行解压(上文提到了),然后将文件传输出来,找到*.ko文件,拖入ida进行分析</p><p>模块机制的完整叫法应该是动态可加载内核模块(Loadable Kernel Module)或 LKM</p><p>模块可以是设备驱动、文件系统、网络协议、安全模块等</p></blockquote><ul><li><p>Linux操作系统的内核是单一体系结构(monolithic kernel) 整个内核是一个单独的非常大的程序</p></li><li><p>Windows NT采用的就是微内核体系结构 操作系统的核心部分是一个很小的内核，实现一些最基本的服务，如创建和删除进程、内存管理、中断管理等等 而文件系统、网络协议等其它部分都在微内核外的用户空间里运行</p></li><li><p>模块是一种目标对象文件 无链接 不能独立运行 模块不是作为一个进程进行运行 而是相当于静态连接的内核函数</p></li><li><p>内核是运行在内核空间的</p></li></ul><h4 id="正式编写" tabindex="-1"><a class="header-anchor" href="#正式编写" aria-hidden="true">#</a> 正式编写</h4><ul><li><p>首先导入&lt;linux/moudule.h&gt;头文件（当然还有很多其他必要的头文件） 包含了我们编写内核模块所必须的结构定义等内容</p><ul><li>跟模块有关的数据结构存放在include/linux/module.h中 比如struct module</li><li>在内核中每一个内核模块都由一个module对象描述</li><li>所有module对象连成一个链表，链表第一个元素为: static LIST_HEAD(modules)</li><li>还有<code>skernel_symbol</code>存储着内核符号</li></ul></li><li><p>然后定义 <code>init_module</code>和<code>cleanup_module</code>函数</p><ul><li><p>init_module主要是向内核注册新功能 也就是<code>insmod</code>模块的时候触发</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">// 初始化函数</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ALERT <span class="token string">&quot;Hello, world!\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 打印信息</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>clearnup_moudule主要是注销模块注册的功能 也就是<code>rmmod</code>模块的时候触发</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">// 退出函数</span>
<span class="token punctuation">{</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_ALERT <span class="token string">&quot;Goodbye, cruel world!\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印信息</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ul><h4 id="内核符号表" tabindex="-1"><a class="header-anchor" href="#内核符号表" aria-hidden="true">#</a> 内核符号表(?)</h4><ul><li>内核的符号表存放的符号 所有的模块都可以访问 模块声明的<code>全局符号</code>都会加入<code>内核符号表</code></li><li><code>内核符号表</code>所处位置:<code>/proc/kallsyms</code></li><li><code>内核符号表</code>处于内核代码段的<code>_skymtab</code>部分 其开始地址和结束地址是由C编译器所产生的两个符号来指定：<code>__start___ksymtab</code>和<code>__stop___ksymtab</code>。</li></ul><h3 id="file-operations结构体" tabindex="-1"><a class="header-anchor" href="#file-operations结构体" aria-hidden="true">#</a> file_operations结构体</h3><blockquote><p>Linux 内核文件 <strong>include/linux/fs.h</strong> 中有个叫做 <strong>file_operations</strong> 的结构体。通过这个结构体可以指定系统调用对应的驱动函数。</p></blockquote><p>每一个系统调用都会对应一个驱动程序中的函数。如系统调用的open会对应驱动程序中的一个open，用户使用的系统调用open在进入到内核空间后实际上执行的就是驱动程序中与open对应的函数。</p><h4 id="ioctl函数" tabindex="-1"><a class="header-anchor" href="#ioctl函数" aria-hidden="true">#</a> ioctl函数</h4><blockquote><p>用户程序可以通过调用ioctl函数来实现将一个cmd传给内核，而内核驱动根据switch case来实现预先设定好cmd对应执行的相关程序</p><p>在内核题里面基本都有<code>ioctl</code>函数,ioctl是设备驱动程序中对设备的I/O通道进行管理的函数</p><p>也就是驱动程序写好ioctl接口,然后用户态程序open对应的/dev/驱动,就可以根据对应的fd进行传参数</p></blockquote><p>我们常说的驱动实际上就是驱动程序。以字符设备为例，驱动函数在加载成功后，会在/dev目录下生成一个驱动名称的文件夹，即/dev/xx。应用程序通过系统调用open()打开这个文件夹，然后通过对这个文件的操作来调用相应的驱动程序去控制硬件</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">ioctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> ind cmd<span class="token punctuation">,</span> …<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>fd是用户程序打开设备时使用open函数返回的文件描述符</li><li>cmd是用户程序对设备的控制命令</li><li>一般ioctl函数中有一个类似于switch case结构每一个case对应一个命令码</li></ul><h3 id="linux内核管理" tabindex="-1"><a class="header-anchor" href="#linux内核管理" aria-hidden="true">#</a> linux内核管理</h3>`,33),B=n("p",null,"内存的结构不过多重复,主要了解slub分配器",-1),K={href:"https://blog.csdn.net/u012489236/article/details/108188375",target:"_blank",rel:"noopener noreferrer"},O={href:"https://blog.csdn.net/csdn546229768/article/details/128795525",target:"_blank",rel:"noopener noreferrer"},Q=t(`<ul><li>内核管理内存主要使用两种算法,<code>伙伴算法</code>和<code>slub算法</code> 伙伴算法以<code>页</code>为单位管理内存,然后通过slub进行</li></ul><h4 id="slub结构" tabindex="-1"><a class="header-anchor" href="#slub结构" aria-hidden="true">#</a> slub结构</h4><p>slub把内存分组管理，每个组分别包含 8、64、512、…2048个字节,以及96b 192b两个分组 总计11组 也就是<code>kmallloc_caches</code>结构体</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>kmalloc_caches<span class="token punctuation">[</span>KMALLOC_SHIFT_HIGH <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 12</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>每个kmalloc_caches有两个大部分 <ul><li>Kmem_cache_node(类似于仓库) <code>慢速通道</code></li><li>Kmem_cache_cpu 一般情况就保留一个<code>slab</code>(也就是kmem_cache批发的连续整页内存 一个slab可能包含多个连续的内存页) <code>快速通道</code></li></ul></li></ul><h4 id="slub分配" tabindex="-1"><a class="header-anchor" href="#slub分配" aria-hidden="true">#</a> slub分配</h4><blockquote><p>可以通过cat /proc/slabinfo来查看slab的信息</p></blockquote><p>因为物理页面被按照对象大小组织成单向链表,kmem_cache</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">kmem_cache_node</span> <span class="token punctuation">{</span>
	<span class="token class-name">spinlock_t</span> list_lock<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLAB</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> slabs_partial<span class="token punctuation">;</span>	<span class="token comment">/* partial list first, better asm code */</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> slabs_full<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> slabs_free<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> total_slabs<span class="token punctuation">;</span>	<span class="token comment">/* length of all slab lists */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> free_slabs<span class="token punctuation">;</span>	<span class="token comment">/* length of free slab list only */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> free_objects<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> free_limit<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> colour_next<span class="token punctuation">;</span>	<span class="token comment">/* Per-node cache coloring */</span>
	<span class="token keyword">struct</span> <span class="token class-name">array_cache</span> <span class="token operator">*</span>shared<span class="token punctuation">;</span>	<span class="token comment">/* shared per node */</span>
	<span class="token keyword">struct</span> <span class="token class-name">alien_cache</span> <span class="token operator">*</span><span class="token operator">*</span>alien<span class="token punctuation">;</span>	<span class="token comment">/* on other nodes */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> next_reap<span class="token punctuation">;</span>	<span class="token comment">/* updated without locking */</span>
	<span class="token keyword">int</span> free_touched<span class="token punctuation">;</span>		<span class="token comment">/* updated without locking */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB</span></span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> nr_partial<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> partial<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB_DEBUG</span></span>
	<span class="token class-name">atomic_long_t</span> nr_slabs<span class="token punctuation">;</span>
	<span class="token class-name">atomic_long_t</span> total_objects<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> full<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">kmem_cache_cpu</span> <span class="token punctuation">{</span>
	<span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>freelist<span class="token punctuation">;</span>	<span class="token comment">/* Pointer to next available object */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> tid<span class="token punctuation">;</span>	<span class="token comment">/* Globally unique transaction id */</span>
	<span class="token keyword">struct</span> <span class="token class-name">slab</span> <span class="token operator">*</span>slab<span class="token punctuation">;</span>	<span class="token comment">/* The slab from which we are allocating */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB_CPU_PARTIAL</span></span>
	<span class="token keyword">struct</span> <span class="token class-name">slab</span> <span class="token operator">*</span>partial<span class="token punctuation">;</span>	<span class="token comment">/* Partially allocated frozen slabs */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token class-name">local_lock_t</span> lock<span class="token punctuation">;</span>	<span class="token comment">/* Protects the fields above */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_SLUB_STATS</span></span>
	<span class="token keyword">unsigned</span> stat<span class="token punctuation">[</span>NR_SLUB_STAT_ITEMS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>slub系统刚刚创建 第一次申请slub内存 <ul><li>回去向伙伴内存中申请可用的内存项,并且把页面分成很多object,取出一个object标记为占用</li></ul></li><li>当kmem_cache_cpu有slab并且有空闲的object可以使用 则把空闲的object给用户 然后把<code>freelist</code>指向下一个空闲<code>object</code></li><li>当kmem_cache_cpu没有空闲的object,但是kmem_cache_node中<code>partial</code>有空闲的object 则从<code>kmem_cache_node</code>的partial变量里面获取空闲的object的slab,并且把空闲的object返回给用户</li></ul><h4 id="slub的释放" tabindex="-1"><a class="header-anchor" href="#slub的释放" aria-hidden="true">#</a> slub的释放</h4><ul><li>当kmem_cache_cpu缓存的slab就是object所在的slab的时候 就直接把slab加入<code>kmem_cache_cpu</code>的<code>free_list</code>即可</li><li>当kmem_cache_cpu缓存的slab不是object所在的slab的时候直接把object释放到object所在的slab里面</li></ul><figure><img src="https://i-blog.csdnimg.cn/blog_migrate/d0a5b45aa34a19ea774453d799220834.png" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><h4 id="kmem-cache-alloc-trace-todo" tabindex="-1"><a class="header-anchor" href="#kmem-cache-alloc-trace-todo" aria-hidden="true">#</a> kmem_cache_alloc_trace（TODO）</h4><blockquote><p><code>kmem_cache_alloc_trace</code>函数就是<code>kmem_cache_create + kmem_cache_alloc</code>这样就通过<code>slub分配器</code>分配了一块内存了</p></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token operator">*</span>
<span class="token function">kmem_cache_alloc_trace</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> <span class="token class-name">gfp_t</span> flags<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>ret<span class="token punctuation">;</span>

	ret <span class="token operator">=</span> <span class="token function">slab_alloc</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> flags<span class="token punctuation">,</span> size<span class="token punctuation">,</span> _RET_IP_<span class="token punctuation">)</span><span class="token punctuation">;</span>

	ret <span class="token operator">=</span> <span class="token function">kasan_kmalloc</span><span class="token punctuation">(</span>cachep<span class="token punctuation">,</span> ret<span class="token punctuation">,</span> size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">trace_kmalloc</span><span class="token punctuation">(</span>_RET_IP_<span class="token punctuation">,</span> ret<span class="token punctuation">,</span> cachep<span class="token punctuation">,</span>
		      size<span class="token punctuation">,</span> cachep<span class="token operator">-&gt;</span>size<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>Kmem_cache_create</p></li><li><p>Kmem_cache_alloc</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kmem_cache_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kmem_cache</span> <span class="token operator">*</span>cachep<span class="token punctuation">,</span> <span class="token class-name">gfp_t</span> flags<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>cachep是给定的缓存的结构指针 也就是kmalloc_caches</li><li>flags是分配的标志</li></ul></li></ul><h2 id="d3kheap复现" tabindex="-1"><a class="header-anchor" href="#d3kheap复现" aria-hidden="true">#</a> d3kheap复现</h2><h3 id="信息" tabindex="-1"><a class="header-anchor" href="#信息" aria-hidden="true">#</a> 信息</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Linux <span class="token punctuation">(</span>none<span class="token punctuation">)</span> <span class="token number">5.13</span>.19 <span class="token comment">#1 SMP Thu Feb 17 08:21:42 PST 2022 x86_64 GNU/Linux</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="申请chunk" tabindex="-1"><a class="header-anchor" href="#申请chunk" aria-hidden="true">#</a> 申请chunk</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">kmem_cache_alloc_trace</span><span class="token punctuation">(</span>kmalloc_caches<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3264LL</span><span class="token punctuation">,</span> <span class="token number">1024LL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>这里是kamlloc_caches[10]也就是2的10次方 1024也就是0x400大小的chunk</li></ul><h3 id="msg-msg堆喷-uaf" tabindex="-1"><a class="header-anchor" href="#msg-msg堆喷-uaf" aria-hidden="true">#</a> Msg_msg堆喷 UAF</h3><blockquote><p>msg_msg消息队列通常用于进行进程之间的相互沟通,由于其可以在内核中申请任意大小的堆的原因,这个结构体在内核利用中是比较好使的.</p><p>https://www.freebuf.com/articles/system/286366.html参考文章:</p></blockquote><p>这里的应用其实很简单,由于<strong>msg_msg</strong>可以先创建大量消息队列</p><p><strong>msgget</strong>函数(对应内核<strong>ksys_msgget</strong>)会创建一个<code>msg_queue</code>结构体当消息队列<code>msg_msg</code>双向循环链表的起始节点 然后将我们后续发送的消息变成<strong>msg_msg</strong>结构体与这个<strong>msg_queue</strong>链接起来构成双循环链表</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">msg_queue</span> <span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">kern_ipc_perm</span> q_perm<span class="token punctuation">;</span>
	<span class="token class-name">time64_t</span> q_stime<span class="token punctuation">;</span>		<span class="token comment">/* last msgsnd time */</span>
	<span class="token class-name">time64_t</span> q_rtime<span class="token punctuation">;</span>		<span class="token comment">/* last msgrcv time */</span>
	<span class="token class-name">time64_t</span> q_ctime<span class="token punctuation">;</span>		<span class="token comment">/* last change time */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> q_cbytes<span class="token punctuation">;</span>		<span class="token comment">/* current number of bytes on queue */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> q_qnum<span class="token punctuation">;</span>		<span class="token comment">/* number of messages in queue */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> q_qbytes<span class="token punctuation">;</span>		<span class="token comment">/* max number of bytes on queue */</span>
	<span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>q_lspid<span class="token punctuation">;</span>		<span class="token comment">/* pid of last msgsnd */</span>
	<span class="token keyword">struct</span> <span class="token class-name">pid</span> <span class="token operator">*</span>q_lrpid<span class="token punctuation">;</span>		<span class="token comment">/* last receive pid */</span>

	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> q_messages<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> q_receivers<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> q_senders<span class="token punctuation">;</span>
<span class="token punctuation">}</span> __randomize_layout<span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后<strong>msg_msg</strong>的存储逻辑是当我们发送了消息后会直接申请<strong>一整页</strong>(0x1000)以内的内存页面</p><p>当<strong>msg_msg</strong>结构体+我们的消息大于<strong>pagesize</strong>的时候,会去主动分配一个新的内存页面也就是<strong>msg_msgseg</strong> 类似于下面的状态</p><figure><img src="https://awaqwqa.github.io/img/linux_kernel1/QQ_1729066251434.png" alt="QQ_1729066251434" tabindex="0" loading="lazy"><figcaption>QQ_1729066251434</figcaption></figure><p>然后<strong>msg_msg</strong>又是和<strong>msg_queue</strong>构成双向循环链表 类似于下方. (这很类似于largebin的形式)</p><figure><img src="https://awaqwqa.github.io/img/linux_kernel1/QQ_1729066349724.png" alt="QQ_1729066349724" tabindex="0" loading="lazy"><figcaption>QQ_1729066349724</figcaption></figure><p>这就给我们申请小于0x1000大小的任意主消息和副消息的能力了,这很适合用于堆喷!!!</p><p>所以如果我们有一个<strong>double free</strong>的机会,就可以先申请一个chunk,然后free掉这个chunk。通过堆喷合适大小的<strong>msg_msg</strong>,让<strong>msg_msg</strong>副消息去捕获到这个消息。然后再次free从而实现<strong>UAF</strong>。</p><p>那么这个时候这个chunk处于freelist链中,但是chunk也被msg_msg正在使用.我们就可以让一些特殊结构体申请到这个内存页面,从而实现泄漏信息或者触发ROP链子 这里是很巧妙的做法</p><p>但是这里有个问题我们并不知道到底是哪个chunk抓到了我们的free的chunk,我们需要借助一下其他小trcik才行.这里是利用的<strong>sk_buf</strong>结构体进行堆喷</p><h3 id="sk-buf-堆喷-定位" tabindex="-1"><a class="header-anchor" href="#sk-buf-堆喷-定位" aria-hidden="true">#</a> sk_buf 堆喷 定位</h3><blockquote><p><strong>sk_buf</strong>也可以进行申请区间较大的内存堆,从而可以实现堆喷到被释放的那个<strong>msg_msg</strong>,然后就可以往里面写入数据了.</p></blockquote><p>当我们<strong>sk_buf</strong>捕获到那个chunk后,向里面写入数据让<strong>msgrcv</strong>函数返回错误,但是不触发<strong>kernel panic</strong>从而定位到谁被捕获了。然后再利用<strong>sk_buf</strong>自己本身的释放机制,让chunk再次进入freelist链好让我们进行进一步的<strong>UAF</strong>操作</p><p>那么此时我们就成功可以伪造一个<strong>msg_msg</strong>了</p>`,41);function G(P,U){const a=o("ExternalLinkIcon");return c(),i("div",null,[r,d,n("blockquote",null,[u,k,m,h,n("p",null,[s("参考文章:"),n("a",b,[s("浅谈linux中的根文件系统（rootfs的原理和介绍）-CSDN博客"),e(a)])]),n("p",null,[n("a",_,[s("几种linux内核文件的区别(vmlinux、zImage、bzImage、uImage、vmlinuz、initrd )_zimage是什么-CSDN博客"),e(a)])]),n("p",null,[n("a",v,[s("D3CTF2022 - Pwn - d3kheap 题解 - 先知社区 (aliyun.com)"),e(a)])]),n("p",null,[n("a",g,[s("qemu常用参数选项说明_qemu 参数-CSDN博客"),e(a)])]),n("p",null,[n("a",f,[s("Kernel pwn CTF 入门 | Kiprey's Blog"),e(a)])]),n("p",null,[n("a",x,[s("cpio文件系统的解压和制作方法_window cpio文件直接添加文件-CSDN博客"),e(a)])]),n("p",null,[n("a",y,[s("Linux下编写和加载 .ko 文件（驱动模块文件）_qt 加载 .ko-CSDN博客"),e(a)])]),n("p",null,[n("a",w,[s("Linux 系统设置 : insmod 命令详解_linx如何进入insmod-CSDN博客"),e(a)])]),n("p",null,[n("a",q,[s("Linux内核模块详解_linux编写内核模块-CSDN博客"),e(a)])]),L,I,n("p",null,[n("a",z,[s("内核与用户空间的通信实现——ioctl（驱动+用户程序）_ioctl 释放设备-CSDN博客"),e(a)])]),n("p",null,[s("linux kernel漏洞系列文章:"),n("a",S,[s("Pwn In Kernel（一）：基础知识 - FreeBuf网络安全行业门户"),e(a)])]),n("p",null,[s("linux内核源码:"),n("a",C,[s("Index of /sites/ftp.kernel.org/pub/linux/kernel/ (sjtu.edu.cn)"),e(a)])]),E,N,j,A,D,T]),F,n("blockquote",null,[B,n("p",null,[n("a",K,[s("linux内存管理笔记(二十八）----内存管理 slub算法_linux的slub分配算法-CSDN博客"),e(a)])]),n("p",null,[n("a",O,[s("linux内核-内存管理_kmem cache alloc trace-CSDN博客"),e(a)])])]),Q])}const H=l(p,[["render",G],["__file","linux_kernel1.html.vue"]]);export{H as default};
