import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as c,o,c as n,a as l,b as e,d,e as r}from"./app-D0nkxfln.js";const s={},t=l("h1",{id:"记一次patchelf的使用-浅理解ld和libc",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#记一次patchelf的使用-浅理解ld和libc","aria-hidden":"true"},"#"),e(" 记一次patchelf的使用+浅理解ld和libc")],-1),u=l("br",null,null,-1),h={href:"https://blog.csdn.net/byxdaz/article/details/89405588",target:"_blank",rel:"noopener noreferrer"},b={href:"https://blog.csdn.net/Longyu_wlz/article/details/108511931",target:"_blank",rel:"noopener noreferrer"},p=l("br",null,null,-1),_={href:"https://www.cnblogs.com/jiqingwu/p/linux_binary_load_and_run.html",target:"_blank",rel:"noopener noreferrer"},g=r(`<h2 id="程序寻找libc的顺序" tabindex="-1"><a class="header-anchor" href="#程序寻找libc的顺序" aria-hidden="true">#</a> 程序寻找libc的顺序</h2><blockquote><p>这里主要是学习一下程序在查找libc的时候的顺序 方便我们理解我们<code>patchelf</code>要修改哪些东西</p></blockquote><ul><li><p>优先寻找<code>dt_runpath</code> 如果不存在<code>dt_runpath</code>再去寻找<code>dt_rpath</code></p><ul><li><code>runpath</code>会ld忽略<code>ld_library_path</code>所以当程序由runpath后我们就算修改<code>ld_libary_path</code>也不会起效果</li></ul></li><li><p>然后就是寻找<code>ld_libary_path</code></p><blockquote><p>还有个和这个很相似的变量:<code>libray_path</code>这个变量是<code>程序编译期间</code>查找动态链接库时指定查找共享库的路径 也就是动态共享库的路径 所以说这个变量是开发的时候编译使用 为了让编译器能够找到对应的动态库<br><code>ld_libary_path</code>程序<code>加载运行期间</code>查找动态链接库的路径（系统默认系统之前查找）</p></blockquote></li><li><p>从路径:<code>/etc/ld.so.scache</code>中查找文件</p></li><li><p>从<code>/lib</code>寻找</p></li><li><p>从<code>/usr/lib</code>中寻找</p></li></ul><h2 id="linux程序加载简化流程" tabindex="-1"><a class="header-anchor" href="#linux程序加载简化流程" aria-hidden="true">#</a> linux程序加载简化流程</h2><ul><li><p>执行<code>exec(3)</code>系统调用</p></li><li><p>陷入系统内核操作 由操作系统加载该文件 内存映射将文件加载到内存中</p></li><li><p>如果文件头中存在<code>pt_interp</code>那么就会将ld找到 并且映射进入内存 然后准备对应环境 将控制权移交给ld、</p><ul><li>ld的作用</li></ul><ol><li><strong>解析依赖</strong>：动态链接器检查程序的头部，找出程序依赖的所有共享库。</li><li><strong>加载共享库</strong>：动态链接器查找这些共享库的位置，并将它们加载到内存中。</li><li><strong>符号解析</strong>：动态链接器解析程序中的符号引用，确保它们指向正确的地址。</li></ol></li></ul><h2 id="查看程序当前信息" tabindex="-1"><a class="header-anchor" href="#查看程序当前信息" aria-hidden="true">#</a> 查看程序当前信息</h2><blockquote><p>获取目前程序的ld和libc的路径信息</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ldd file_name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>可以得到libc.so.6的当前绑定地址</li><li>ld当前绑定地址</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ldd <span class="token parameter variable">--version</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>可以查看当前<code>libc</code>和<code>ld</code>的版本</li></ul><h2 id="修改程序的ld和libc地址" tabindex="-1"><a class="header-anchor" href="#修改程序的ld和libc地址" aria-hidden="true">#</a> 修改程序的<code>ld</code>和<code>libc</code>地址</h2><ul><li>修改<code>ld</code>的地址</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>patchelf --set-interpreter ld_addr file_name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>修改libc的地址</p><blockquote><p>这里old_libc就是ldd查到的那个ld地址(==&gt;之前)比如:libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 那么就是libc.so.6</p></blockquote></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>patchelf --replace-needed old_libc new_libc file_name
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>修改Libc的地址(不太稳定)</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>patchelf --set-rpath new_rpath your_file
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,18);function m(v,f){const a=c("ExternalLinkIcon");return o(),n("div",null,[t,l("blockquote",null,[l("p",null,[e("每次去使用xclibc的时候 都不是特别好使hhh 所以就重新了解一下patchelf的使用"),u,e("参考文章:"),l("a",h,[e("linux动态链接库的加载顺序_动态链接库顺序-CSDN博客"),d(a)]),e("和"),l("a",b,[e("man ld.so 的翻译_ld-linux.so的man手册-CSDN博客"),d(a)]),e("获取程序寻找libc的顺序"),p,e("["),l("a",_,[e("转] Linux下程序的加载、运行和终止流程 - JollyWing - 博客园 (cnblogs.com)"),d(a)]),e("获取linux加载程序的流程")])]),g])}const q=i(s,[["render",m],["__file","usePatchelf.html.vue"]]);export{q as default};
