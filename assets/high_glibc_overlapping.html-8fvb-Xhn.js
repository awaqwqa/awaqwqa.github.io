import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as e,e as l}from"./app-tn4u_VZT.js";const g={},p=l('<h1 id="记一次高版本glibc-2-34-下常规overlapping失败的原因-vctf-2024-apples" tabindex="-1"><a class="header-anchor" href="#记一次高版本glibc-2-34-下常规overlapping失败的原因-vctf-2024-apples" aria-hidden="true">#</a> 记一次高版本glibc(2.34)下常规overlapping失败的原因（vctf 2024 apples）</h1><blockquote><p>昨天做vctf被打自闭了 由于对glibc高版本的保护不熟悉 第二题apples 连leak libc都没实现</p><p>这里记录一下为什么常规overlapping会失效</p></blockquote><h2 id="版本" tabindex="-1"><a class="header-anchor" href="#版本" aria-hidden="true">#</a> 版本</h2><ul><li>glibc 2.34</li><li>off_by_one漏洞</li></ul><h2 id="读题" tabindex="-1"><a class="header-anchor" href="#读题" aria-hidden="true">#</a> 读题</h2><ul><li><p>首先是add user部分 存在off_by_one漏洞</p><figure><img src="https://awaqwqa.github.io/img/high_glibc_overlapping/image-20240317100413787.png" alt="image-20240317100413787" tabindex="0" loading="lazy"><figcaption>image-20240317100413787</figcaption></figure></li><li><p>delete部分无懈可击()</p><figure><img src="https://awaqwqa.github.io/img/high_glibc_overlapping/def73b9b58504d503336012d80f05fd4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure></li></ul><h2 id="错误思路" tabindex="-1"><a class="header-anchor" href="#错误思路" aria-hidden="true">#</a> 错误思路</h2><p>由于前段时间做了hgame的week3的一道overlapping 所以我就自然想到了这题先利用overlapping leak出来我们的libc地址</p><ul><li><p>大概思路就是:</p><ul><li><p>先malloc 11个（第十一个防止合并）chunk 然后free 7个chunk 占满tacache</p></li><li><p>然后free 第9chunk malloc回来 写入刚好size大小的数据（并且构造好prev_size） 让0溢出到 第10个chunk上</p></li><li><p>最后我们free 第10个chunk 就可以利用合并机制 将fd和bk包含在这个大chunk中 再利用分割机制就可以泄露libc</p></li></ul></li><li><p>简化后的流程图就是:</p><figure><img src="https://awaqwqa.github.io/img/high_glibc_overlapping/img.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure></li></ul><h2 id="失败原因" tabindex="-1"><a class="header-anchor" href="#失败原因" aria-hidden="true">#</a> 失败原因</h2><blockquote><p>主要是glibc在高版本下的安全检查机制</p></blockquote><ul><li><p>合并时对prev_chunk的size检查</p><blockquote><p>我们可以明显发现 这里多了一条if检查语句 用于检查计算prev_size得出的chunk的size大小是否等于我们的prev_size大小 这样就阻止了我们跨chunk进行合并</p></blockquote><ul><li><p>glic-2.27下</p><figure><img src="https://awaqwqa.github.io/img/high_glibc_overlapping/image-20240317101747206.png" alt="image-20240317101747206" tabindex="0" loading="lazy"><figcaption>image-20240317101747206</figcaption></figure></li><li><p>glibc-2.34下</p><figure><img src="https://awaqwqa.github.io/img/high_glibc_overlapping/image-20240317101823846.png" alt="image-20240317101823846" tabindex="0" loading="lazy"><figcaption>image-20240317101823846</figcaption></figure></li></ul></li></ul>',12),c=[p];function t(n,r){return a(),e("div",null,c)}const u=i(g,[["render",t],["__file","high_glibc_overlapping.html.vue"]]);export{u as default};
