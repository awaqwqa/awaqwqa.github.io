<!doctype html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.0" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.10" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://mister-hope.github.io/posts/sycKernel.html"><meta property="og:site_name" content="Blog"><meta property="og:title" content="面试准备(热更)"><meta property="og:description" content="面试准备(热更) 初入职场必备丨二进制面试问题汇总 - FreeBuf网络安全行业门户pwn方向的分析 预计中旬左右 秋招复习笔记——八股文部分：操作系统 - 知乎 (zhihu.com)"><meta property="og:type" content="article"><meta property="og:locale" content="en-US"><meta property="og:updated_time" content="2024-12-16T08:36:57.000Z"><meta property="article:author" content="Elegy"><meta property="article:tag" content="pwn"><meta property="article:modified_time" content="2024-12-16T08:36:57.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"面试准备(热更)","image":[""],"dateModified":"2024-12-16T08:36:57.000Z","author":[{"@type":"Person","name":"Elegy"}]}</script><title>面试准备(热更) | Blog</title><meta name="description" content="面试准备(热更) 初入职场必备丨二进制面试问题汇总 - FreeBuf网络安全行业门户pwn方向的分析 预计中旬左右 秋招复习笔记——八股文部分：操作系统 - 知乎 (zhihu.com)">
    <link rel="preload" href="/assets/style-I9UN-qkK.css" as="style"><link rel="stylesheet" href="/assets/style-I9UN-qkK.css">
    <link rel="modulepreload" href="/assets/app-mtXdL8hD.js"><link rel="modulepreload" href="/assets/sycKernel.html-1dm3tgDo.js"><link rel="modulepreload" href="/assets/sycKernel.html-IhYyCNZz.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-x3n3nnut.js">
    <link rel="prefetch" href="/assets/index.html-d64lF5z5.js" as="script"><link rel="prefetch" href="/assets/friendLink.html-zr_xV-0i.js" as="script"><link rel="prefetch" href="/assets/readme_standards.html-pEVNdxIX.js" as="script"><link rel="prefetch" href="/assets/snake.html-dud4GkR8.js" as="script"><link rel="prefetch" href="/assets/year_end.html-zRERDFuK.js" as="script"><link rel="prefetch" href="/assets/algorithm_1.html-Tgzo2WQt.js" as="script"><link rel="prefetch" href="/assets/REALWORLD_android.html-ilINxQLE.js" as="script"><link rel="prefetch" href="/assets/base.html-ECKQmzL9.js" as="script"><link rel="prefetch" href="/assets/frida反调试.html-_6yV3zBe.js" as="script"><link rel="prefetch" href="/assets/objection.html-oYsjUDpx.js" as="script"><link rel="prefetch" href="/assets/xml文件格式分析.html-HCR8DFFP.js" as="script"><link rel="prefetch" href="/assets/RSA.html-i3LWN_iw.js" as="script"><link rel="prefetch" href="/assets/db_study_1.html-hY-rcKqU.js" as="script"><link rel="prefetch" href="/assets/db_study_2.html-4M_NZzjW.js" as="script"><link rel="prefetch" href="/assets/goArchitecture.html-wH43_rkA.js" as="script"><link rel="prefetch" href="/assets/go_ass.html-gsvsmqr1.js" as="script"><link rel="prefetch" href="/assets/websocket.html-jgj4qoyh.js" as="script"><link rel="prefetch" href="/assets/build_specified_libc_docker.html-6leHLICp.js" as="script"><link rel="prefetch" href="/assets/git_standards.html-NHHv3Ez-.js" as="script"><link rel="prefetch" href="/assets/git_study.html-qpJp1DA0.js" as="script"><link rel="prefetch" href="/assets/asyncio.html-bNG7HEWb.js" as="script"><link rel="prefetch" href="/assets/c2018-HitCon-gundam(tcahe机制_泄露libc地址).html-ygG5hO5u.js" as="script"><link rel="prefetch" href="/assets/computeChunkSize.html-OabBS5TA.js" as="script"><link rel="prefetch" href="/assets/ez_chunk.html-bGTu0FU5.js" as="script"><link rel="prefetch" href="/assets/high_glibc_overlapping.html-x2iapavU.js" as="script"><link rel="prefetch" href="/assets/house_of_lore.html-e_lNhOgz.js" as="script"><link rel="prefetch" href="/assets/largeBinAttack.html-8I3fGqA1.js" as="script"><link rel="prefetch" href="/assets/studyHeap.html-k4lcrI12.js" as="script"><link rel="prefetch" href="/assets/studyHeapVedio.html-g78EyZnE.js" as="script"><link rel="prefetch" href="/assets/studyHeapVedio2.html-2umXXczC.js" as="script"><link rel="prefetch" href="/assets/thread_pwn.html-nvOQzQ5y.js" as="script"><link rel="prefetch" href="/assets/unsortedBinLeakLibc.html-XH7fxtfm.js" as="script"><link rel="prefetch" href="/assets/vctf_leak_libc.html-oaheUN0Z.js" as="script"><link rel="prefetch" href="/assets/xyctf_heap_pro.html-ZMtPwtuh.js" as="script"><link rel="prefetch" href="/assets/house_of_apple.html-PqYQUqHo.js" as="script"><link rel="prefetch" href="/assets/house_of_apple2.html-4ULQEKDx.js" as="script"><link rel="prefetch" href="/assets/io_file.html-Uim73Lpe.js" as="script"><link rel="prefetch" href="/assets/io_file_study2.html-BSDbfpSO.js" as="script"><link rel="prefetch" href="/assets/linux_kernel1.html-m4SZ1cIO.js" as="script"><link rel="prefetch" href="/assets/linux_kernel2.html-k2tlWpg-.js" as="script"><link rel="prefetch" href="/assets/socket.html-p7GxAPCV.js" as="script"><link rel="prefetch" href="/assets/php.html-yKr5yWYy.js" as="script"><link rel="prefetch" href="/assets/8byte(栈迁移).html-DI-O40Yh.js" as="script"><link rel="prefetch" href="/assets/one_byte_rop.html-WnXEfBPa.js" as="script"><link rel="prefetch" href="/assets/ret2dl.html-tO1F6hlv.js" as="script"><link rel="prefetch" href="/assets/IO偏移.html-ST5jP4eS.js" as="script"><link rel="prefetch" href="/assets/usePatchelf.html-d4-oWJvX.js" as="script"><link rel="prefetch" href="/assets/babyre.html-5Mnk2RGn.js" as="script"><link rel="prefetch" href="/assets/nc(file).html-FOCg92VM.js" as="script"><link rel="prefetch" href="/assets/siscn_pwn1(栈迁移_float数据格式).html-T8XbMrXX.js" as="script"><link rel="prefetch" href="/assets/xyctf.html-U7JXxgQE.js" as="script"><link rel="prefetch" href="/assets/404.html-GbdKBWVO.js" as="script"><link rel="prefetch" href="/assets/index.html-hSZUPkrO.js" as="script"><link rel="prefetch" href="/assets/index.html-pNGu0lUA.js" as="script"><link rel="prefetch" href="/assets/index.html-mVNhOYHE.js" as="script"><link rel="prefetch" href="/assets/index.html-tMDxqIZM.js" as="script"><link rel="prefetch" href="/assets/index.html-Xj4Q9xIB.js" as="script"><link rel="prefetch" href="/assets/index.html-PuHu6YHX.js" as="script"><link rel="prefetch" href="/assets/index.html-tLPcYGIY.js" as="script"><link rel="prefetch" href="/assets/index.html-4NfTkLWT.js" as="script"><link rel="prefetch" href="/assets/index.html-4cD2voHP.js" as="script"><link rel="prefetch" href="/assets/index.html-24FdbV0X.js" as="script"><link rel="prefetch" href="/assets/index.html-czMqdCgc.js" as="script"><link rel="prefetch" href="/assets/index.html-fSO7t_lT.js" as="script"><link rel="prefetch" href="/assets/index.html-iZBUR2OT.js" as="script"><link rel="prefetch" href="/assets/index.html-l5-YUSgT.js" as="script"><link rel="prefetch" href="/assets/index.html-LNcUfwr4.js" as="script"><link rel="prefetch" href="/assets/index.html-nEruGExL.js" as="script"><link rel="prefetch" href="/assets/index.html-9Aqdve0Y.js" as="script"><link rel="prefetch" href="/assets/index.html-WKQ9YVKS.js" as="script"><link rel="prefetch" href="/assets/index.html-tzE_FC09.js" as="script"><link rel="prefetch" href="/assets/index.html-6QmsITJo.js" as="script"><link rel="prefetch" href="/assets/index.html-ecknHaKX.js" as="script"><link rel="prefetch" href="/assets/index.html-dr1vm6Y5.js" as="script"><link rel="prefetch" href="/assets/index.html-oZ7OrbtP.js" as="script"><link rel="prefetch" href="/assets/index.html-uoti10BU.js" as="script"><link rel="prefetch" href="/assets/index.html-h74VB_iX.js" as="script"><link rel="prefetch" href="/assets/index.html-FX0FUsyi.js" as="script"><link rel="prefetch" href="/assets/index.html-5ejjnIEC.js" as="script"><link rel="prefetch" href="/assets/index.html-OOIKiO_Q.js" as="script"><link rel="prefetch" href="/assets/index.html-mjDNWrju.js" as="script"><link rel="prefetch" href="/assets/index.html-T1yxd-4C.js" as="script"><link rel="prefetch" href="/assets/index.html-vmnwGQ_x.js" as="script"><link rel="prefetch" href="/assets/index.html-kQVPBo8D.js" as="script"><link rel="prefetch" href="/assets/index.html-OJk1c0ek.js" as="script"><link rel="prefetch" href="/assets/index.html-5kdxgiAV.js" as="script"><link rel="prefetch" href="/assets/index.html-kYz9mkQs.js" as="script"><link rel="prefetch" href="/assets/index.html-T0M1RHdG.js" as="script"><link rel="prefetch" href="/assets/index.html-kZKZ9YNl.js" as="script"><link rel="prefetch" href="/assets/index.html-ToVv3Ha4.js" as="script"><link rel="prefetch" href="/assets/index.html-AIEp5aPZ.js" as="script"><link rel="prefetch" href="/assets/index.html-OjELZcvu.js" as="script"><link rel="prefetch" href="/assets/index.html-eNdUahdf.js" as="script"><link rel="prefetch" href="/assets/index.html-tf1pjMmD.js" as="script"><link rel="prefetch" href="/assets/index.html-5qmzGUj6.js" as="script"><link rel="prefetch" href="/assets/index.html-G-06IUJG.js" as="script"><link rel="prefetch" href="/assets/index.html-RbJyN7x6.js" as="script"><link rel="prefetch" href="/assets/index.html-wkxvpnTw.js" as="script"><link rel="prefetch" href="/assets/index.html-2qwayshd.js" as="script"><link rel="prefetch" href="/assets/index.html-Ix21QJuL.js" as="script"><link rel="prefetch" href="/assets/index.html-QJFi238y.js" as="script"><link rel="prefetch" href="/assets/index.html-wOO6TPmu.js" as="script"><link rel="prefetch" href="/assets/index.html-IRzW8Ehl.js" as="script"><link rel="prefetch" href="/assets/index.html-YZMti94B.js" as="script"><link rel="prefetch" href="/assets/index.html-2oe05wH4.js" as="script"><link rel="prefetch" href="/assets/index.html-tkJfiFUZ.js" as="script"><link rel="prefetch" href="/assets/index.html-c-XZEzeF.js" as="script"><link rel="prefetch" href="/assets/index.html-e9cfnpw9.js" as="script"><link rel="prefetch" href="/assets/index.html-hrNi8kdO.js" as="script"><link rel="prefetch" href="/assets/friendLink.html-WJiQGZAh.js" as="script"><link rel="prefetch" href="/assets/readme_standards.html-PDWDJ0FR.js" as="script"><link rel="prefetch" href="/assets/snake.html-PR9xM93B.js" as="script"><link rel="prefetch" href="/assets/year_end.html-AnRmwmrx.js" as="script"><link rel="prefetch" href="/assets/algorithm_1.html-Q01OWHpq.js" as="script"><link rel="prefetch" href="/assets/REALWORLD_android.html-Niqdm_TP.js" as="script"><link rel="prefetch" href="/assets/base.html-v3jyQYJL.js" as="script"><link rel="prefetch" href="/assets/frida反调试.html-SCPsSB2Z.js" as="script"><link rel="prefetch" href="/assets/objection.html-GiwikGRy.js" as="script"><link rel="prefetch" href="/assets/xml文件格式分析.html-T2MFAUSd.js" as="script"><link rel="prefetch" href="/assets/RSA.html-v0P7CXbs.js" as="script"><link rel="prefetch" href="/assets/db_study_1.html-qB403UQu.js" as="script"><link rel="prefetch" href="/assets/db_study_2.html-Q5LBhW0v.js" as="script"><link rel="prefetch" href="/assets/goArchitecture.html-kUn5B-7L.js" as="script"><link rel="prefetch" href="/assets/go_ass.html-c_lmhJsS.js" as="script"><link rel="prefetch" href="/assets/websocket.html-Uk-d3uuk.js" as="script"><link rel="prefetch" href="/assets/build_specified_libc_docker.html-7ZjObPZW.js" as="script"><link rel="prefetch" href="/assets/git_standards.html-h3hbcutY.js" as="script"><link rel="prefetch" href="/assets/git_study.html-QIu-9J-X.js" as="script"><link rel="prefetch" href="/assets/asyncio.html-rV2x0_yg.js" as="script"><link rel="prefetch" href="/assets/c2018-HitCon-gundam(tcahe机制_泄露libc地址).html-hzTyH71T.js" as="script"><link rel="prefetch" href="/assets/computeChunkSize.html-DDobQE5u.js" as="script"><link rel="prefetch" href="/assets/ez_chunk.html-dVpN2Abu.js" as="script"><link rel="prefetch" href="/assets/high_glibc_overlapping.html-UwGT5W7k.js" as="script"><link rel="prefetch" href="/assets/house_of_lore.html-Guje4vdY.js" as="script"><link rel="prefetch" href="/assets/largeBinAttack.html-ZY326H8e.js" as="script"><link rel="prefetch" href="/assets/studyHeap.html-jZ5kpve5.js" as="script"><link rel="prefetch" href="/assets/studyHeapVedio.html-L7BUIe2e.js" as="script"><link rel="prefetch" href="/assets/studyHeapVedio2.html-eeDe8LnM.js" as="script"><link rel="prefetch" href="/assets/thread_pwn.html-SwLJs61a.js" as="script"><link rel="prefetch" href="/assets/unsortedBinLeakLibc.html-7tGUjW1_.js" as="script"><link rel="prefetch" href="/assets/vctf_leak_libc.html-MzRvkVfP.js" as="script"><link rel="prefetch" href="/assets/xyctf_heap_pro.html-sMFPuuPG.js" as="script"><link rel="prefetch" href="/assets/house_of_apple.html-D8-AURGu.js" as="script"><link rel="prefetch" href="/assets/house_of_apple2.html-cDXW6we8.js" as="script"><link rel="prefetch" href="/assets/io_file.html-vx0oLM2S.js" as="script"><link rel="prefetch" href="/assets/io_file_study2.html-AWvUZLrU.js" as="script"><link rel="prefetch" href="/assets/linux_kernel1.html-bEY42Jk8.js" as="script"><link rel="prefetch" href="/assets/linux_kernel2.html-H5EfIiPd.js" as="script"><link rel="prefetch" href="/assets/socket.html-uJ1IsNgK.js" as="script"><link rel="prefetch" href="/assets/php.html-6dm0x_Om.js" as="script"><link rel="prefetch" href="/assets/8byte(栈迁移).html-8kULrniY.js" as="script"><link rel="prefetch" href="/assets/one_byte_rop.html-gu1uuTj3.js" as="script"><link rel="prefetch" href="/assets/ret2dl.html-LSD-9hTw.js" as="script"><link rel="prefetch" href="/assets/IO偏移.html-mngGCpvw.js" as="script"><link rel="prefetch" href="/assets/usePatchelf.html-RWpbPUFz.js" as="script"><link rel="prefetch" href="/assets/babyre.html-L-_q3vJ1.js" as="script"><link rel="prefetch" href="/assets/nc(file).html-5e1gnQ5U.js" as="script"><link rel="prefetch" href="/assets/siscn_pwn1(栈迁移_float数据格式).html-n5swGgjF.js" as="script"><link rel="prefetch" href="/assets/xyctf.html-5utO67Ii.js" as="script"><link rel="prefetch" href="/assets/404.html-CWaDeSaL.js" as="script"><link rel="prefetch" href="/assets/index.html-uHO74Jkg.js" as="script"><link rel="prefetch" href="/assets/index.html-5tHuytvS.js" as="script"><link rel="prefetch" href="/assets/index.html-ZKQlmhyc.js" as="script"><link rel="prefetch" href="/assets/index.html-4rrEYhqz.js" as="script"><link rel="prefetch" href="/assets/index.html-IP-JrjKi.js" as="script"><link rel="prefetch" href="/assets/index.html-1kdLVOXc.js" as="script"><link rel="prefetch" href="/assets/index.html-UEieUgL7.js" as="script"><link rel="prefetch" href="/assets/index.html-MRgWn4fm.js" as="script"><link rel="prefetch" href="/assets/index.html-OwrbORtY.js" as="script"><link rel="prefetch" href="/assets/index.html-DVPftjpR.js" as="script"><link rel="prefetch" href="/assets/index.html-a6f7WuZf.js" as="script"><link rel="prefetch" href="/assets/index.html-PSBNV9EW.js" as="script"><link rel="prefetch" href="/assets/index.html-gLQwJttF.js" as="script"><link rel="prefetch" href="/assets/index.html-KOZSmhku.js" as="script"><link rel="prefetch" href="/assets/index.html-EAVgd6dA.js" as="script"><link rel="prefetch" href="/assets/index.html-nBqzyTaR.js" as="script"><link rel="prefetch" href="/assets/index.html-uHarkMqe.js" as="script"><link rel="prefetch" href="/assets/index.html-9sEsXUMF.js" as="script"><link rel="prefetch" href="/assets/index.html-wXxkvYnc.js" as="script"><link rel="prefetch" href="/assets/index.html-xqvVrhfS.js" as="script"><link rel="prefetch" href="/assets/index.html--nvGtZyG.js" as="script"><link rel="prefetch" href="/assets/index.html-awMog83q.js" as="script"><link rel="prefetch" href="/assets/index.html-VNYAD7by.js" as="script"><link rel="prefetch" href="/assets/index.html-p0kdpIeX.js" as="script"><link rel="prefetch" href="/assets/index.html-2tNZX1HK.js" as="script"><link rel="prefetch" href="/assets/index.html-E1TaH0Wk.js" as="script"><link rel="prefetch" href="/assets/index.html-k4GPkRGv.js" as="script"><link rel="prefetch" href="/assets/index.html-Y4-TuK0f.js" as="script"><link rel="prefetch" href="/assets/index.html-7ILTcLNI.js" as="script"><link rel="prefetch" href="/assets/index.html-adh2kX_n.js" as="script"><link rel="prefetch" href="/assets/index.html-nLJ750fv.js" as="script"><link rel="prefetch" href="/assets/index.html-lVQLODl3.js" as="script"><link rel="prefetch" href="/assets/index.html-RpK2XSwy.js" as="script"><link rel="prefetch" href="/assets/index.html-BGkT7YKW.js" as="script"><link rel="prefetch" href="/assets/index.html-257h5xDH.js" as="script"><link rel="prefetch" href="/assets/index.html-6xjGGqw3.js" as="script"><link rel="prefetch" href="/assets/index.html-s8SmPel1.js" as="script"><link rel="prefetch" href="/assets/index.html-O6BqwaxY.js" as="script"><link rel="prefetch" href="/assets/index.html-TMU34Q3u.js" as="script"><link rel="prefetch" href="/assets/index.html-gHkQ4p4g.js" as="script"><link rel="prefetch" href="/assets/index.html-CiTxSbVN.js" as="script"><link rel="prefetch" href="/assets/index.html-kwU7EdMP.js" as="script"><link rel="prefetch" href="/assets/index.html-ISylQtJV.js" as="script"><link rel="prefetch" href="/assets/index.html-pZQznR6b.js" as="script"><link rel="prefetch" href="/assets/index.html-phL9fcHA.js" as="script"><link rel="prefetch" href="/assets/index.html-GANOOzXq.js" as="script"><link rel="prefetch" href="/assets/index.html-4wO2wi2c.js" as="script"><link rel="prefetch" href="/assets/index.html-TXuO7Nvu.js" as="script"><link rel="prefetch" href="/assets/index.html-HjyYPc8b.js" as="script"><link rel="prefetch" href="/assets/index.html-fgZVy2bF.js" as="script"><link rel="prefetch" href="/assets/index.html-xv84q3hU.js" as="script"><link rel="prefetch" href="/assets/index.html-DOkmt_C1.js" as="script"><link rel="prefetch" href="/assets/index.html-buBp2wdk.js" as="script"><link rel="prefetch" href="/assets/index.html-mOCUHDRc.js" as="script"><link rel="prefetch" href="/assets/index.html-5E9yUu1c.js" as="script"><link rel="prefetch" href="/assets/index.html-JZZnL7VG.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-08_zHRDQ.js" as="script"><link rel="prefetch" href="/assets/SearchResult-UQCPZAhs.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">Skip to main content</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/"><img class="vp-nav-logo" src="https://awaqwqa.github.io/石头门.jpg" aria-hidden><!----><span class="vp-site-name hide-in-pad">Blog</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="Blog Home" class="vp-link nav-link nav-link" href="/"><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span>Blog Home<!----></a></div><div class="nav-item hide-in-mobile"><a aria-label="文章" class="vp-link nav-link active nav-link active" href="/posts/"><span class="font-icon icon fa-fw fa-sm fas fa-article" style=""></span>文章<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/vuepress-theme-hope/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="search-pro-button" aria-label="Search"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">Search</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Android</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Development</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Pwn</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">Re</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">T O D O</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">T O D O(正在施工)</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="友情链接" class="vp-link nav-link vp-sidebar-link vp-sidebar-page nav-link vp-sidebar-link vp-sidebar-page" href="/posts/friendLink.html"><!---->友情链接<!----></a><ul class="vp-sidebar-sub-headers"></ul><!--]--></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><!----><span class="vp-sidebar-title">密码学</span><span class="vp-arrow end"></span></button><!----></section></li><li><!--[--><a aria-label="面试准备(热更)" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/posts/sycKernel.html"><!---->面试准备(热更)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="操作系统" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#操作系统"><!---->操作系统<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="软链接" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#软链接"><!---->软链接<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="匿名页（TODO）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#匿名页-todo"><!---->匿名页（TODO）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="mount挂载" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#mount挂载"><!---->mount挂载<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="回环设备（TODO）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#回环设备-todo"><!---->回环设备（TODO）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="套接字" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#套接字"><!---->套接字<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Linux 中内存管理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#linux-中内存管理"><!---->Linux 中内存管理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="tcp和udp区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#tcp和udp区别"><!---->tcp和udp区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="四种锁的区别(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#四种锁的区别-todo"><!---->四种锁的区别(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="cow 与row" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#cow-与row"><!---->cow 与row<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="虚拟内存" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#虚拟内存"><!---->虚拟内存<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="内存对齐" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#内存对齐"><!---->内存对齐<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="管道" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#管道"><!---->管道<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="并发与并行" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#并发与并行"><!---->并发与并行<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="文件描述符" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#文件描述符"><!---->文件描述符<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="fork函数" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#fork函数"><!---->fork函数<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="重定向" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#重定向"><!---->重定向<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="信号中断" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#信号中断"><!---->信号中断<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="GO底层" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#go底层"><!---->GO底层<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="面试技巧" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#面试技巧"><!---->面试技巧<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="结构体中指针函数和普通函数" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#结构体中指针函数和普通函数"><!---->结构体中指针函数和普通函数<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="字典实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#字典实现"><!---->字典实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="接口实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#接口实现"><!---->接口实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="数组实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#数组实现"><!---->数组实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="切片实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#切片实现"><!---->切片实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="函数调用规范" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#函数调用规范"><!---->函数调用规范<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="深/浅copy" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#深-浅copy"><!---->深/浅copy<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="闭包" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#闭包"><!---->闭包<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="一等公民" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#一等公民"><!---->一等公民<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Python" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#python"><!---->Python<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="asyncio(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#asyncio-todo"><!---->asyncio(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Pwn" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#pwn"><!---->Pwn<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="ret2dl" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#ret2dl"><!---->ret2dl<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="c - main函数参数含义" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#c-main函数参数含义"><!---->c - main函数参数含义<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="canary 多线程绕过" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#canary-多线程绕过"><!---->canary 多线程绕过<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="格式化字符串" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#格式化字符串"><!---->格式化字符串<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="ORW沙箱绕过总结" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#orw沙箱绕过总结"><!---->ORW沙箱绕过总结<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="arm架构函数调用规范 armv7和armv8的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#arm架构函数调用规范-armv7和armv8的区别"><!---->arm架构函数调用规范 armv7和armv8的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="mips架构的函数调用规范" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#mips架构的函数调用规范"><!---->mips架构的函数调用规范<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="phpPwn堆管理机制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#phppwn堆管理机制"><!---->phpPwn堆管理机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="cpp堆管理机制（todo）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#cpp堆管理机制-todo"><!---->cpp堆管理机制（todo）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="musl堆管理器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#musl堆管理器"><!---->musl堆管理器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="堆利用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#堆利用"><!---->堆利用<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="malloc函数中的一些检查机制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#malloc函数中的一些检查机制"><!---->malloc函数中的一些检查机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常见利用技巧" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#常见利用技巧"><!---->常见利用技巧<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="House of force(top chunk  利用)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#house-of-force-top-chunk-利用"><!---->House of force(top chunk  利用)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="House of kiwi" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#house-of-kiwi"><!---->House of kiwi<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="house of cat" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#house-of-cat"><!---->house of cat<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="printf/puts io调用链(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#printf-puts-io调用链-todo"><!---->printf/puts io调用链(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="linux Kernel" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#linux-kernel"><!---->linux Kernel<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="段保护模式/页保护模式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#段保护模式-页保护模式"><!---->段保护模式/页保护模式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="实/保护模式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#实-保护模式"><!---->实/保护模式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="进程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#进程"><!---->进程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="execve" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#execve"><!---->execve<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="oom机制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#oom机制"><!---->oom机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="linux的内存管理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#linux的内存管理"><!---->linux的内存管理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Pwn linux kernel" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#pwn-linux-kernel"><!---->Pwn linux kernel<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="调试" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#调试"><!---->调试<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常规保护机制" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#常规保护机制"><!---->常规保护机制<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常用利用结构体" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#常用利用结构体"><!---->常用利用结构体<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="堆喷/脏管道学习(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#堆喷-脏管道学习-todo"><!---->堆喷/脏管道学习(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="msg_msg消息队列(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#msg-msg消息队列-todo"><!---->msg_msg消息队列(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="kmalloc和vmalloc区别(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#kmalloc和vmalloc区别-todo"><!---->kmalloc和vmalloc区别(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="缺页内核和用户态(userfaultfd)（TODO）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#缺页内核和用户态-userfaultfd-todo"><!---->缺页内核和用户态(userfaultfd)（TODO）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="sk_buff(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#sk-buff-todo"><!---->sk_buff(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="dirty cow/pipe(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#dirty-cow-pipe-todo"><!---->dirty cow/pipe(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="smep和smap的绕过(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#smep和smap的绕过-todo"><!---->smep和smap的绕过(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="V8/jsc(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#v8-jsc-todo"><!---->V8/jsc(TODO)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="标记指针" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#标记指针"><!---->标记指针<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="压缩指针" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#压缩指针"><!---->压缩指针<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="编译整体流程(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#编译整体流程-todo"><!---->编译整体流程(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="如何调试(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#如何调试-todo"><!---->如何调试(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="编译原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#编译原理"><!---->编译原理<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="语法解析(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#语法解析-todo"><!---->语法解析(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="TOken生成(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#token生成-todo"><!---->TOken生成(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AST生成(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#ast生成-todo"><!---->AST生成(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="中间代码生成（TODO）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#中间代码生成-todo"><!---->中间代码生成（TODO）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="链接与库（TODO）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#链接与库-todo"><!---->链接与库（TODO）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="ld的链接(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#ld的链接-todo"><!---->ld的链接(TODO)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="开发框架(TODO)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#开发框架-todo"><!---->开发框架(TODO)<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="消息队列" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#消息队列"><!---->消息队列<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="postgreSQL(数据库)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#postgresql-数据库"><!---->postgreSQL(数据库)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="asyncio（异步框架）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#asyncio-异步框架"><!---->asyncio（异步框架）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="日志框架" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#日志框架"><!---->日志框架<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Android" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#android"><!---->Android<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="dex 和class文件的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#dex-和class文件的区别"><!---->dex 和class文件的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="全限定类名和非限定类名的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#全限定类名和非限定类名的区别"><!---->全限定类名和非限定类名的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="smail语法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#smail语法"><!---->smail语法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="res/raw和asset的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#res-raw和asset的区别"><!---->res/raw和asset的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="xml文件" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#xml文件"><!---->xml文件<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="objection和frida" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#objection和frida"><!---->objection和frida<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="IDA" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#ida"><!---->IDA<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="几种断点 软断点 硬件断点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#几种断点-软断点-硬件断点"><!---->几种断点 软断点 硬件断点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="360面试准备" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#_360面试准备"><!---->360面试准备<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="Arm中的特殊寄存器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#arm中的特殊寄存器"><!---->Arm中的特殊寄存器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="arm函数调用规范" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#arm函数调用规范"><!---->arm函数调用规范<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Mc实际分析" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/posts/sycKernel.html#mc实际分析"><!---->Mc实际分析<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->面试准备(热更)</h1><div class="page-info"><span class="page-author-info" aria-label="Author🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">Elegy</span></span><span property="author" content="Elegy"></span></span><!----><span class="page-date-info" aria-label="Writing Date📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-08-15T02:31:35.000Z"></span><!----><span class="page-reading-time-info" aria-label="Reading Time⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>About 48 min</span><meta property="timeRequired" content="PT48M"></span><!----><span class="page-tag-info" aria-label="Tag🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item tag0 clickable" role="navigation">pwn</span><!--]--><meta property="keywords" content="pwn"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">On This Page<button type="button" class="print-button" title="Print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#操作系统">操作系统</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#软链接">软链接</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#匿名页-todo">匿名页（TODO）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#mount挂载">mount挂载</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#回环设备-todo">回环设备（TODO）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#套接字">套接字</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#linux-中内存管理">Linux 中内存管理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#tcp和udp区别">tcp和udp区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#四种锁的区别-todo">四种锁的区别(TODO)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#cow-与row">cow 与row</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#虚拟内存">虚拟内存</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#内存对齐">内存对齐</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#管道">管道</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#并发与并行">并发与并行</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#文件描述符">文件描述符</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#fork函数">fork函数</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#重定向">重定向</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#信号中断">信号中断</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#go底层">GO底层</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#面试技巧">面试技巧</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#结构体中指针函数和普通函数">结构体中指针函数和普通函数</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#字典实现">字典实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#接口实现">接口实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#数组实现">数组实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#切片实现">切片实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#函数调用规范">函数调用规范</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#深-浅copy">深/浅copy</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#闭包">闭包</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#一等公民">一等公民</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#python">Python</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#asyncio-todo">asyncio(TODO)</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#pwn">Pwn</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#ret2dl">ret2dl</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#c-main函数参数含义">c - main函数参数含义</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#canary-多线程绕过">canary 多线程绕过</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#格式化字符串">格式化字符串</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#orw沙箱绕过总结">ORW沙箱绕过总结</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#arm架构函数调用规范-armv7和armv8的区别">arm架构函数调用规范 armv7和armv8的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#mips架构的函数调用规范">mips架构的函数调用规范</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#phppwn堆管理机制">phpPwn堆管理机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#cpp堆管理机制-todo">cpp堆管理机制（todo）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#musl堆管理器">musl堆管理器</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#堆利用">堆利用</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#malloc函数中的一些检查机制">malloc函数中的一些检查机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#常见利用技巧">常见利用技巧</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#house-of-force-top-chunk-利用">House of force(top chunk  利用)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#house-of-kiwi">House of kiwi</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#house-of-cat">house of cat</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#printf-puts-io调用链-todo">printf/puts io调用链(TODO)</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#linux-kernel">linux Kernel</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#段保护模式-页保护模式">段保护模式/页保护模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#实-保护模式">实/保护模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#进程">进程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#execve">execve</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#oom机制">oom机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#linux的内存管理">linux的内存管理</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#pwn-linux-kernel">Pwn linux kernel</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#调试">调试</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#常规保护机制">常规保护机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#常用利用结构体">常用利用结构体</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#堆喷-脏管道学习-todo">堆喷/脏管道学习(TODO)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#msg-msg消息队列-todo">msg_msg消息队列(TODO)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#kmalloc和vmalloc区别-todo">kmalloc和vmalloc区别(TODO)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#缺页内核和用户态-userfaultfd-todo">缺页内核和用户态(userfaultfd)（TODO）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#sk-buff-todo">sk_buff(TODO)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#dirty-cow-pipe-todo">dirty cow/pipe(TODO)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#smep和smap的绕过-todo">smep和smap的绕过(TODO)</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#v8-jsc-todo">V8/jsc(TODO)</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#标记指针">标记指针</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#压缩指针">压缩指针</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#编译整体流程-todo">编译整体流程(TODO)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#如何调试-todo">如何调试(TODO)</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#编译原理">编译原理</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#语法解析-todo">语法解析(TODO)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#token生成-todo">TOken生成(TODO)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#ast生成-todo">AST生成(TODO)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#中间代码生成-todo">中间代码生成（TODO）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#链接与库-todo">链接与库（TODO）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#ld的链接-todo">ld的链接(TODO)</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#开发框架-todo">开发框架(TODO)</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#消息队列">消息队列</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#postgresql-数据库">postgreSQL(数据库)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#asyncio-异步框架">asyncio（异步框架）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#日志框架">日志框架</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#android">Android</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#dex-和class文件的区别">dex 和class文件的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#全限定类名和非限定类名的区别">全限定类名和非限定类名的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#smail语法">smail语法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#res-raw和asset的区别">res/raw和asset的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#xml文件">xml文件</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#objection和frida">objection和frida</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#ida">IDA</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#几种断点-软断点-硬件断点">几种断点 软断点 硬件断点</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="#_360面试准备">360面试准备</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#arm中的特殊寄存器">Arm中的特殊寄存器</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#arm函数调用规范">arm函数调用规范</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="#mc实际分析">Mc实际分析</a></li><!----><!--]--></ul></li><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="面试准备-热更" tabindex="-1"><a class="header-anchor" href="#面试准备-热更" aria-hidden="true">#</a> 面试准备(热更)</h1><blockquote><p><a href="https://www.freebuf.com/vuls/346048.html" target="_blank" rel="noopener noreferrer">初入职场必备丨二进制面试问题汇总 - FreeBuf网络安全行业门户<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>pwn方向的分析 预计中旬左右</p><p><a href="https://zhuanlan.zhihu.com/p/691316449" target="_blank" rel="noopener noreferrer">秋招复习笔记——八股文部分：操作系统 - 知乎 (zhihu.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><h2 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统" aria-hidden="true">#</a> 操作系统</h2><blockquote><p>csapp:<a href="https://zhuanlan.zhihu.com/p/455061631" target="_blank" rel="noopener noreferrer">《深入理解计算机系统（CSAPP）》全书学习笔记（详细） - 知乎 (zhihu.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><h3 id="软链接" tabindex="-1"><a class="header-anchor" href="#软链接" aria-hidden="true">#</a> 软链接</h3><blockquote><p>https://blog.csdn.net/annita2019/article/details/105481449</p><p>https://blog.csdn.net/kfepiza/article/details/136095095</p></blockquote><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>ln <span class="token operator">-</span>s 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建软链接</p><p>然后区分一下/usr/bin和/usr/local/bin的区别</p><ul><li><code>/usr/bin</code>下面的都是系统预装的可执行程序，系统升级有可能会被覆盖.</li><li><code>/usr/local/bin</code> 目录是给用户放置自己的可执行程序.，不会被系统升级而覆盖同名文件。</li></ul><h3 id="匿名页-todo" tabindex="-1"><a class="header-anchor" href="#匿名页-todo" aria-hidden="true">#</a> 匿名页（TODO）</h3><h3 id="mount挂载" tabindex="-1"><a class="header-anchor" href="#mount挂载" aria-hidden="true">#</a> mount挂载</h3><blockquote><p>参考文章:<a href="https://blog.csdn.net/bandaoyu/article/details/123806859" target="_blank" rel="noopener noreferrer">【Linux】Linux的挂载原理 |MOUNT|挂载NAS|自动挂载-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://blog.csdn.net/jinking01/article/details/105683360" target="_blank" rel="noopener noreferrer">linux的mount结构与原理_linux mount原理-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>mkdir 命令加了-p后可以在多级目录的父目录不存在的时候创建目录比如</p><p>mkdir -p test/test2 如果test不存在就创建test</p><p>我们也可以通过fdisk -l 或者more /proc/partitiions查看系统硬盘分区情况</p></blockquote><ul><li><p>挂载mount /dev/sda3 /mnt</p><blockquote><p><strong>指的就是将设备文件中的顶级目录连接到Linux根目录下的某一目录，访问此目录就等同于访问设备文件</strong>。</p><p>值得注意的是挂载操作会使得原有目录中文件被隐藏,所以我们习惯于创建一个新的目录作为挂载点</p></blockquote><ul><li>/dev/sda3 是挂载的分区 根目录下的<code>/dev/</code>目录文件负责所有的硬件设备文件,当我们设备接入系统后,会在dev目录下创建一个目录文件比如/dev/sdb1 这个目录提供了一些基本的信息</li><li>/mnt是挂载点</li><li>出现报错:<strong>device is busy</strong> 可以用<code>lsof</code>指令(list open file)查看一下正在被使用的文件 也可以用<code>fuser-m</code></li></ul></li><li><p>解挂umount /mnt</p></li><li><p>参数</p><ul><li>-t 指定文件系统的类型</li><li>-o 用于描述设备的挂载方式 <ul><li>loop 把文件当作硬盘分区挂载上系统</li><li>ro 只读</li><li>rw读写</li></ul></li></ul></li></ul><h3 id="回环设备-todo" tabindex="-1"><a class="header-anchor" href="#回环设备-todo" aria-hidden="true">#</a> 回环设备（TODO）</h3><blockquote><p>参考文章:<a href="https://www.cnblogs.com/aozhejin/p/15867559.html" target="_blank" rel="noopener noreferrer">linux磁盘之回环设备 - jinzi - 博客园 (cnblogs.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>回环设备（ &#39;loopback device&#39;）允许用户以一个普通磁盘文件虚拟成一个块设备。(<strong>磁盘文件</strong> --&gt; <strong>块设备</strong>)</p></blockquote><h3 id="套接字" tabindex="-1"><a class="header-anchor" href="#套接字" aria-hidden="true">#</a> 套接字</h3><blockquote><p><a href="https://so.csdn.net/so/search?spm=a2c6h.13046898.publish-article.48.25e16ffaF3Jssg&amp;q=%E5%A5%97%E6%8E%A5%E5%AD%97" target="_blank" rel="noopener noreferrer">套接字<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>是一个重要的概念。套接字是一种用于网络通信的接口，它可以实现进程之间的通信和数据传输。在使用套接字进行网络编程时，关闭套接字是一个必要的操作。关闭套接字可以释放资源，避免程序出现内存泄漏等问题。在关闭套接字时，我们通常会用到 close() 和 shutdown() 函数。这两个函数虽然都能够关闭套接字，但是它们的使用方式和作用有所不同。</p></blockquote><p>当调用 <code>close()</code> 函数时，文件描述符的引用计数减1。只有当引用计数变为0时，文件描述符才真正被关闭，并且与其相关的资源被释放。</p><ul><li>在fork的时候 子进程会让所有文件描述符copy下来 并且引用计数+1 close本质是对文件描述符的引用计数进行的减1</li></ul><h3 id="linux-中内存管理" tabindex="-1"><a class="header-anchor" href="#linux-中内存管理" aria-hidden="true">#</a> Linux 中内存管理</h3><blockquote><p>这里有总结<a href="https://zhuanlan.zhihu.com/p/149581303" target="_blank" rel="noopener noreferrer">linux内存管理（详解） - 知乎 (zhihu.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 根据总结来进行学习</p></blockquote><h3 id="tcp和udp区别" tabindex="-1"><a class="header-anchor" href="#tcp和udp区别" aria-hidden="true">#</a> tcp和udp区别</h3><blockquote><p>直接看博客中写的文章 这里就不重复赘述了</p></blockquote><h3 id="四种锁的区别-todo" tabindex="-1"><a class="header-anchor" href="#四种锁的区别-todo" aria-hidden="true">#</a> 四种锁的区别(TODO)</h3><h3 id="cow-与row" tabindex="-1"><a class="header-anchor" href="#cow-与row" aria-hidden="true">#</a> cow 与row</h3><blockquote><p>这里涉及快照的概念 <a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100196336" target="_blank" rel="noopener noreferrer">COW、ROW快照技术原理 - 华为 (huawei.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 快照就用了cow</p><p><a href="https://zhuanlan.zhihu.com/p/452676926" target="_blank" rel="noopener noreferrer">写时复制技术详解(COW) - 知乎 (zhihu.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><p><strong>写时复制</strong>（<strong>Copy-on-write</strong>，简称<strong>COW</strong>）是一种计算机<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88" target="_blank" rel="noopener noreferrer">程序设计<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E9%80%8F%E6%98%8E" target="_blank" rel="noopener noreferrer">透明<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。性能较为低下 因为会导致父节点更新 导致<code>写放大</code>也就是本来期望修改一个节点 但是会导致需要修改4个节点之类</p><ul><li>简单来说就是 不修改就不拷贝 修改再单独拷贝</li></ul><h4 id="用途" tabindex="-1"><a class="header-anchor" href="#用途" aria-hidden="true">#</a> 用途</h4><ul><li>虚拟内存管理中的写时复制 <ul><li>一般共享访问的页面标记为可读 然后当一个task尝试写入数据的时候 <code>内存管理单元(MMU)</code>会抛出一个异常 内核处理该异常 并且为task分配一个物理内存并复制数据到次内存到中 重新向MMU发出执行该task的写操作</li></ul></li><li>数据存储的写时复制(cow) <ul><li>linux等文件管理系统采用了cow策略</li><li>数据库也采用了该策略</li></ul></li><li>软件应用的写时复制 <ul><li>cpp中std::string类 以前采用 后面禁止了</li></ul></li></ul><h3 id="虚拟内存" tabindex="-1"><a class="header-anchor" href="#虚拟内存" aria-hidden="true">#</a> 虚拟内存</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/691316449" target="_blank" rel="noopener noreferrer">秋招复习笔记——八股文部分：操作系统 - 知乎 (zhihu.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>[【操作系统基础】内存管理——虚拟内存概念及分页机制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/651057404#:~:text=通常一个页表项需要记录20bit的物理页号，因此这样一个虚拟内存管理系统分配给一个程序的页表至少需要2^20*20bit的容量，至少是2.6MByte，而如果是64bit的地址空间，一个页表至少是11%2C258%2C999GByte。 这种机制显然是不合理的。,因此操作系统通过多级页表的方法减少驻留在内存中的页面尺寸，减小页表。 具体来讲，高层页表的页表项并不保存物理页号，而是保存下一级页表的起始地址，如同页表基址寄存器的功能一样。 在这种方式下，操作系统不需要把所有的页表项都存放到内存中，部分页表项成为空洞，在需要用到这个页表项对应的空间时才进行填写。)</p></blockquote><p>操作系统通过多级页表的方法减少驻留在内存中的页面尺寸，减小页表。</p><ul><li>虚拟空间连续 但是物理空间不一定连续</li><li>当内存空间不足的时候 会把其他正在运行的进程 最近没有使用的内存页面释放暂时写在硬盘上 然后需要了就加载回来</li><li>和中断处理机制一样用了选择子和页内偏移的方式来寻址 我们通过页号来获取基础地址再加上页内偏移</li><li>多级页表 <ul><li>通过多级页表来实现逻辑地址到地址的映射</li></ul></li></ul><h4 id="虚拟地址的cow" tabindex="-1"><a class="header-anchor" href="#虚拟地址的cow" aria-hidden="true">#</a> 虚拟地址的cow</h4><ul><li>不同的进程是可以让虚拟地址共同映射到同一块物理内存地址的</li></ul><h3 id="内存对齐" tabindex="-1"><a class="header-anchor" href="#内存对齐" aria-hidden="true">#</a> 内存对齐</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/140063999" target="_blank" rel="noopener noreferrer">一文轻松理解内存对齐 - 知乎 (zhihu.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li>要是不对齐的话 系统需要花费额外的操作去读取 十分浪费性能 自然对齐性能利用率高 <ul><li>这里提及的额外的操作是因为比如32位机子 一次性读取数据就是32位也就是4字节 64位操作系统一次性读取是64位也就是8字节</li><li>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器。这需要做很多工作。</li></ul></li></ul><h3 id="管道" tabindex="-1"><a class="header-anchor" href="#管道" aria-hidden="true">#</a> 管道</h3><blockquote><p>[进程间通信(IPC) 系列 | 管道(pipe) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/423964093#:~:text=所谓管道，是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称 pipe,文件。 向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入管道；而接收管道输出的接收进程（即读进程），可从管道中接收数据。)</p></blockquote><p>管道中最重要的2个方法就是管道的读写。从上述的分析来看，读写进程共同操作内核中的数据缓冲区，若有缓冲区可写，则进程往缓冲区中写，若条件不允许写，则进程休眠让出 CPU。读操作同理。</p><p>从上述管道读写操作可知，父子进程之所以能够通过 pipe 进行通信，是因为在内核中共同指向了同一个pipe_inode_info 对象，共同操作同一个内存页。</p><p>返回的文件描述符是一个数组:fd[0] fd[1] 0表示读取 1表示写入</p><ul><li>pipe文件</li><li>互斥性 就是管道有一方进行读写操作的时候 另一方必须等待</li><li>同步性 管道必须写入后/读取后 然后进入睡眠 等待下一步操作</li><li>检测对方是否存在</li></ul><h3 id="并发与并行" tabindex="-1"><a class="header-anchor" href="#并发与并行" aria-hidden="true">#</a> 并发与并行</h3><blockquote><p>[并发与并行的区别（超级通俗易懂）_并发和并行区别秒懂-CSDN博客](https://blog.csdn.net/scarificed/article/details/114645082#:~:text=并发是指一个处理器同时处理多个任务。 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。,并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。)</p></blockquote><ul><li>并发是一个cpu同时处理多个任务 单一时间只能执行一种指令 但是在各个任务之间来回切换</li><li>并行是多个cpu同时执行多个任务 多个任务物理意义上的同时运行</li></ul><figure><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/操作系统/进程和线程/5-并发与并行.jpg" alt="并发与并行" tabindex="0" loading="lazy"><figcaption>并发与并行</figcaption></figure><h3 id="文件描述符" tabindex="-1"><a class="header-anchor" href="#文件描述符" aria-hidden="true">#</a> 文件描述符</h3><blockquote><p>件描述符（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4......[彻底弄懂 Linux 下的文件描述符（fd） - 锦瑟，无端 - 博客园 (cnblogs.com)](https://www.cnblogs.com/cscshi/p/15705033.html#:~:text=文件描述符（file,descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I%2FO操作的系统调用都通过文件描述符来实现。 同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。)</p></blockquote><ul><li>进程之间文件描述符相互独立 可以互不影响</li><li>可以通过fork让 不同的进程之间 同一个文件描述符指向 同一个文件</li></ul><p>本质也就是先用一个数组来存每个进程的空闲文件描述符数组 然后数组存储的是一个下标再指向真正的文件描述符数组 然后里面存储着详细信息 包含filenode等信息就可以找到文件本体了</p><h3 id="fork函数" tabindex="-1"><a class="header-anchor" href="#fork函数" aria-hidden="true">#</a> fork函数</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/130873706" target="_blank" rel="noopener noreferrer">论fork()函数与Linux中的多线程编程 - 知乎 (zhihu.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，</p><p><a href="https://zhuanlan.zhihu.com/p/475746296" target="_blank" rel="noopener noreferrer">有关 COW (CopyOnWrite) 的一切 - 知乎 (zhihu.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>操作系统需要将父进程虚拟内存空间中的大部分内容全部复制到子进程中（主要是数据段、堆、栈；代码段共享）</p><p>fork还是接触比较多 在程序中或者ctf题中 有时候fork可以带来一些新的思路</p></blockquote><ul><li><p>fork函数是创建一个新的进程 并且copy 父进程的栈堆代码等段信息</p></li><li><p>子进程会获取父进程的所有文件副本 所以文件描述符也是操作的对应一样的文件</p></li><li><p>当fork函数调用用了新的进程后 如果马上调用exec加载新的程序 那么fork之前执行的栈堆代码段等的拷贝就是白用工 胡总和说性能损失巨大 所以fork函数采用了cow技术 只有当进程尝试写入共享区域的某个页面的时候 才会为这个页面创建一个新的副本</p><ul><li>exec并不会导致pid的改变 直接将新的程序的用户空间代码和数据完全替换当前进程</li></ul></li><li><p><code>虚拟内存</code>管理技术</p><figure><img src="https://pic3.zhimg.com/v2-711fb9cdf6a5cd0c028b52b380e9a2b6_r.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><ul><li><p>只有当进程实际访问内存资源的时候才会建立<code>虚拟地址</code>和<code>物理地址</code>的映射 调入物理内存页</p></li><li><p>直接映射区</p><ul><li>前（最小）896mb的内核空间是与物理地址前896mb 直接进行的映射</li></ul></li><li><p>动态内存映射区</p><ul><li>该区域由<code>vmalloc</code>进行分配 线性空间连续 对应的物理空间不一定连续 可能是处于低端或者高端的内存中</li></ul></li><li><p>永久内存映射区</p><ul><li>这个区域可以访问高端内存 <code>alloc_page</code>分配高端内存页 kmap函数可以通过将高端的内存映射到该区域去</li></ul></li><li><p>固定内存映射区</p><ul><li>这里的地址有特殊用途</li></ul></li></ul></li></ul><h4 id="fork的cow技术" tabindex="-1"><a class="header-anchor" href="#fork的cow技术" aria-hidden="true">#</a> fork的cow技术</h4><ul><li><p>当创建子进程的时候父进程直接将<code>虚拟内存</code>到<code>物理内存</code>的映射关系复制到子进程中 并且将内存设置为<code>只读</code>这样写入的时候就会触发<code>缺页保护</code></p></li><li><p>当不同进程要对内存数据进行修改的时候就会触发<code>写时复制</code>(cow)机制 才会进行拷贝</p><figure><img src="https://awaqwqa.github.io/img/sycKernel/image-20240511234355582.png" alt="image-20240511234355582" tabindex="0" loading="lazy"><figcaption>image-20240511234355582</figcaption></figure></li><li><p>触发<code>缺页异常</code>后 内核在<code>缺页异常</code>的回调处理函数中进行物理内存页的复制 并且把内存页设置为<code>可读可写</code>状态</p></li></ul><h3 id="重定向" tabindex="-1"><a class="header-anchor" href="#重定向" aria-hidden="true">#</a> 重定向</h3><ul><li>1&gt;也就是标准输出流定向到某个文件种</li><li>2&gt;也就是错误输出流定向到某个文件种</li></ul><p>所以在禁用了1情况下可以通过重定向到0</p><p>以及其实直接向0输出也是可以的 但是pwntools在本地是无法接受到这个的</p><h3 id="信号中断" tabindex="-1"><a class="header-anchor" href="#信号中断" aria-hidden="true">#</a> 信号中断</h3><blockquote><p><a href="https://blog.csdn.net/Ding_0110M/article/details/89071793#:~:text=%E4%B8%AD%E6%96%AD%E6%98%AF%E6%8C%87%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C,%E4%BB%96%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener noreferrer">操作系统中的中断（详细介绍+图片理解）_系统运行中断情况监控图-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><h4 id="类型" tabindex="-1"><a class="header-anchor" href="#类型" aria-hidden="true">#</a> 类型</h4><blockquote><p>我们可以大致把中断分为中断和异常 异常还分为故障 陷阱 中止 中断还有:硬中断 软中断之分 硬中断也就是中断异常这类 而软中断比如:int 0x80之类的</p></blockquote><ul><li>中断是异步的 <ul><li>比如鼠标点击之类的</li></ul></li><li>异常是同步的 <ul><li>比如cpu的异常事件 缺页异常 错误指令异常等</li></ul></li><li>软件中断 <ul><li>与硬中断不同 硬中断是每完成一个生命周期后都会去检测一下有没有中断信号 然后去完成中断处理操作 而软中断是单独有个守护进程不断轮询标志位 软中断更类似于注册了一个对象列表 然后不断轮询这个列表查看标志位 如果标志位发生了改变 就去调用对应的处理函数 这是一种比较先进的思想</li><li>硬中断更像是响应 因为cpu的时间是宝贵的 所以会在响应后 交给软中断来处理 这样才能实现较高的利用效率</li></ul></li></ul><h4 id="处理" tabindex="-1"><a class="header-anchor" href="#处理" aria-hidden="true">#</a> 处理</h4><p>当接收到中断信号后 就会根据中断信号 去找中断描述符表(IDT 通过<code>idtr</code>寄存器找到IDT地址)中寻找段选择子和段内偏移 通过段选择子去全局描述符(GDT)中寻找基地址 然后加上偏移地址获取真正的地址 如果开了分页机制 那么再根据这个地址进行分页转化 也就是线性地址转向真实的物理地址（比如二级分页机制的话 前10位获取页目录项从而定位到页目录再通过中12位获取页目录中第几项获取其基础地址然后加上最后10位偏移地址获取真实的地址）</p><h2 id="go底层" tabindex="-1"><a class="header-anchor" href="#go底层" aria-hidden="true">#</a> GO底层</h2><blockquote><p>网站是看的这个:<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/" target="_blank" rel="noopener noreferrer">Introduction · 深入解析Go (gitbooks.io)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>书籍是<code>Go语言设计与实现</code></p></blockquote><h3 id="面试技巧" tabindex="-1"><a class="header-anchor" href="#面试技巧" aria-hidden="true">#</a> 面试技巧</h3><ul><li><p>协程，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态中执行）。</p></li><li><p>线程在切换的时候不会改变页表等，只需要进行寄存器的替换,但是进程在切换的时候需要把大量的内容给替换</p></li><li><p>切片是引用类型 而数组是值类型 []int这样定义是切片 [4]int这样定义是数组 然后数组传递过去不会导致原本的值改变 切片会导致</p></li></ul><h3 id="结构体中指针函数和普通函数" tabindex="-1"><a class="header-anchor" href="#结构体中指针函数和普通函数" aria-hidden="true">#</a> 结构体中指针函数和普通函数</h3><p>比如我定义一个结构体</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>type A struct {

}
func (a *A)Func1(){}
func (a A)Func2(){}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这里的a 其实由于golang都是值传递 所以在 func1 中a *则是a的指针被传递过去 然后对a进行操作的话 会修改变量的值 但是如果func2中对a进行操作就是对a的备份进行操作无法修改原本的值</li></ul><h3 id="字典实现" tabindex="-1"><a class="header-anchor" href="#字典实现" aria-hidden="true">#</a> 字典实现</h3><ul><li>是通过hash链表 大概就是首先通过链表把各个桶链接起来 然后对key进行取hash然后取余 得到下标如果下标一致 则直接在桶后面添加这个value</li></ul><h3 id="接口实现" tabindex="-1"><a class="header-anchor" href="#接口实现" aria-hidden="true">#</a> 接口实现</h3><ul><li>结构体中存储类型的hash值 并且存储一个unsafe指针 这样就可以实现各个类型的断言转化了</li></ul><h3 id="数组实现" tabindex="-1"><a class="header-anchor" href="#数组实现" aria-hidden="true">#</a> 数组实现</h3><ul><li>数组主要是结构体中存储了长度 然后存储数组指针</li></ul><h3 id="切片实现" tabindex="-1"><a class="header-anchor" href="#切片实现" aria-hidden="true">#</a> 切片实现</h3><ul><li>结构体中存储了长度和容量以及指针这样就可以实现动态扩容了</li></ul><h3 id="函数调用规范" tabindex="-1"><a class="header-anchor" href="#函数调用规范" aria-hidden="true">#</a> 函数调用规范</h3><p>先压入返回地址 然后压入参数最后压入返回参数 所以go的函数调用参数和返回值都是依赖于栈进行传递的</p><p>并且golang中的参数传递都是值传递 也就是拷贝一份</p><h3 id="深-浅copy" tabindex="-1"><a class="header-anchor" href="#深-浅copy" aria-hidden="true">#</a> 深/浅copy</h3><blockquote><p><a href="https://www.jianshu.com/p/372218aff8ef" target="_blank" rel="noopener noreferrer">Go语言讲解深拷贝与浅拷贝 - 简书 (jianshu.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li><p>深copy是复制对象的值 创建一个新的对象进行存储 所以修改新对象 不会影响原对象的值 内存地址不同</p></li><li><p>浅copy是复制对象的指针 这样新对象修改的时候老对象也会发生变化 比如Slice Map</p></li></ul><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	slices1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>
		<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	slices3 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>
		<span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	slices4 <span class="token operator">:=</span> slices3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
	slices4<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span>
	slice2 <span class="token operator">:=</span> slices1
	slice2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">6</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slices1<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>slices1<span class="token punctuation">)</span>
	<span class="token comment">//	[1 6 3 4]</span>
	<span class="token comment">//[1 6 3 4]</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h3><blockquote><p>在go语言中闭包函数 所引用的父类变量都不能在栈上分配 因为这样父函数执行完毕后栈上变量就失效了 所以这些变量都是在堆上分配的 会专门产生一个闭包结构体来存储这些外部引用变量</p></blockquote><h3 id="一等公民" tabindex="-1"><a class="header-anchor" href="#一等公民" aria-hidden="true">#</a> 一等公民</h3><blockquote><p><a href="https://cloud.tencent.com/developer/article/2356367" target="_blank" rel="noopener noreferrer">高阶函数编程：探索Go语言中的函数一等公民-腾讯云开发者社区-腾讯云 (tencent.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>在给定的编程语言设计中，一等公民是指支持所有通常可用于其他实体的操作的实体。这些操作通常包括作为参数传递、从函数返回和赋值给变量。</p></blockquote><ul><li>参数传递</li><li>函数返回值</li><li>赋值给变量</li></ul><h2 id="python" tabindex="-1"><a class="header-anchor" href="#python" aria-hidden="true">#</a> Python</h2><h3 id="asyncio-todo" tabindex="-1"><a class="header-anchor" href="#asyncio-todo" aria-hidden="true">#</a> asyncio(TODO)</h3><ul><li>await的for循环可能导致的runtimeError问题</li></ul><h2 id="pwn" tabindex="-1"><a class="header-anchor" href="#pwn" aria-hidden="true">#</a> Pwn</h2><h3 id="ret2dl" tabindex="-1"><a class="header-anchor" href="#ret2dl" aria-hidden="true">#</a> ret2dl</h3><ul><li>流程是 先执行跳转到GOT[3] 然后GOT[3]存储的是plt[1] 也就是先压reloc_arg参数 然后jmp到plt[0] plt[0]存储的是push link_map(GOT[1]) 然后跳转到_dl_runtime_resolve函数也就是GOT[2]</li><li>然后分析一下两个参数 一个是reloc_arg 我们可以通过这个知道我们要绑定的函数名字 也就是从reloc_arg为下标 然后rel_plt[reloc_arg]获取elf_rel信息 提取elf_rel.r_info信息 这个是个指针 然后解引 就获取了名字的下标 然后通过dynstr[st_nameh]获取函数的名字</li><li>那么我们如果可以伪造reloc_arg 然后让rel_plt表索引到bss段 我们可控区域 这样就可以伪造elf_rel的信息 从而伪造r_info的信息 让这个指针指向我们想要调用的函数 然后dynstr就可以直接调用我们的函数了</li></ul><h3 id="c-main函数参数含义" tabindex="-1"><a class="header-anchor" href="#c-main函数参数含义" aria-hidden="true">#</a> c - main函数参数含义</h3><ul><li>第一个参数argc 也就是传给程序的参数个数 包含了程序文件自己本身的名字 比如./new.exe a b 那么参数就是三个</li><li>argv 字符串数组指针 包含程序名称</li><li>envp 环境变量字符串数组的指针</li></ul><h3 id="canary-多线程绕过" tabindex="-1"><a class="header-anchor" href="#canary-多线程绕过" aria-hidden="true">#</a> canary 多线程绕过</h3><blockquote><p>参考文章:<a href="https://www.cnblogs.com/mumuhhh/p/17860207.html" target="_blank" rel="noopener noreferrer">(<em>´∇｀</em>) 欢迎回来！ (cnblogs.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>在创建新线程的时候 在为栈分配内存后，glibc在内存的高地址初始化TLS，在x86-64架构上，栈向下增长，将TLS放在栈顶部。 从TLS中减去一个特定的常量值，我们得到被新线程的stack register所使用的值。从TLS到pthread_create的函数参数传递栈帧的距离小于一页。 现在攻击者将不需要得到leak canary的值，而是直接栈溢出足够多的数据来复写TLS中的tcbhead_t.stack_guard的值，从而bypass canary。简单来说就是因此会顺便创建一个TLS，而且这个TLS会存储Canary的值，而TLS会保存在stack高地址的地方</p></blockquote><h3 id="格式化字符串" tabindex="-1"><a class="header-anchor" href="#格式化字符串" aria-hidden="true">#</a> 格式化字符串</h3><ol><li><code>%*25$d</code>从栈中取变量作为N，比如：栈<code>25$</code>处的值是<code>0x100</code>，那么这个格式化字符串就相当于<code>%256d</code>。（sample：<a href="http://taqini.space/2020/04/05/MidnightsunCTF-2020-pwn-pwn4" target="_blank" rel="noopener noreferrer">pwn4<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>-MidnightsunCTF-2020）</li></ol><h3 id="orw沙箱绕过总结" tabindex="-1"><a class="header-anchor" href="#orw沙箱绕过总结" aria-hidden="true">#</a> ORW沙箱绕过总结</h3><blockquote><p>[Pwn - Shellcode Summary | HeyGap&#39;s_Blog](https://heygap.github.io/2024/02/08/Pwn - Shellcode Summary/#1-1-shellcode-板子)</p><p>[沙箱绕过 | Brvc3&#39;s Base](https://brvc3.github.io/2021/05/03/沙箱绕过/#:~:text=绕过方式 禁用了execve或者system 通过 open read write 来读取flag example：,lgd 禁用了 open，write，read openat，所以直接 调用openat，然后除了 read，write，其实还有两个readv，和writev，这些就能绕过限制读取flag%2C有些连openat都禁用的可以 ptrace 修改syscall)</p></blockquote><h4 id="seccomp-bpf" tabindex="-1"><a class="header-anchor" href="#seccomp-bpf" aria-hidden="true">#</a> Seccomp BPF</h4><blockquote><p><code>linux2.6.23</code>内核用<code>ptctl</code>来代替<code>/proc/PID/seccomp</code>进行添加禁用 2012后linux 3.5 增加了新的模式 过滤模式 我们可以允许系统调用</p><p>2014年，Linux 3.17 引入了<code>seccomp()</code>系统调用，<code>seccomp()</code>在<code>prctl()</code>的基础上提供了现有功能的超集</p></blockquote><ul><li><p>BPF就是在内核层起了一层虚拟机 这个虚拟机 起到了过滤作用 这样每次系统调用就会经过该过滤器 此过程不可逆</p></li><li><p>然后prctl中第二个参数代表操作的对象 如果这个参数为1 则对所有的用户都起作用 会让子进程都受到这个过滤器的限制</p><ul><li>ptctl还可以让内核进入严格模式 进程可用的系统调用就只有4个 <em>read()</em>, <em>write()</em>, <em>_exit()</em>, 和 <em>sigreturn()</em></li></ul></li><li><p>docker也运用了这项技术 实现了沙盒禁止</p></li></ul><h4 id="常规绕过" tabindex="-1"><a class="header-anchor" href="#常规绕过" aria-hidden="true">#</a> 常规绕过</h4><ul><li><p>在禁用了大量函数的情况下 我们可以选择一些思路来进行绕过</p><ul><li>切换为32位 错开禁用号 进行调用 修改cs寄存器的值 我们一般采用refq 0x23就是32位运行模式 0x33就是64位运行模式</li></ul></li><li><p>fork一个新的线程 pipe + fork + exec: 创建一个管道</p></li><li><p>侧信道攻击（无write）</p></li><li><p>socket通讯 套接字函数来实现 当然前提是别是禁用所有用户</p></li><li><p>字节不够情况下</p><ul><li>观察堆栈 用pop push等栈传递 因为字节很小 一些长的寄存器可以改为短的寄存器</li></ul></li></ul><h4 id="io-uring利用" tabindex="-1"><a class="header-anchor" href="#io-uring利用" aria-hidden="true">#</a> io_uring利用</h4><blockquote><p><a href="https://www.cnblogs.com/yubo-guan/p/18104456" target="_blank" rel="noopener noreferrer">io_uring - guanyubo - 博客园 (cnblogs.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li><p>io_uring主要是两个环形缓冲区构成 sq 和cq 也就是submit queue 和completion queue 都是处于内核空间的 但是用户可以直接访问内核</p><ul><li>sq也就是存放用户提交的io请求</li><li>cq也就是处理完的sq中的io请求就会填充到cq中 并且通知用户空间i请求完成</li></ul></li><li><p>流程</p><ul><li><code>io_uring_setup()</code> 系统调用创建 <code>io_uring</code> 实例</li><li>提交请求:也就是将io写入sq <ul><li><strong>io_uring_enter()</strong> 提交io事件并且等待其完成 <strong>int io_uring_enter(int fd, unsigned to_submit, unsigned min_complete, unsigned flags, sigset_t *sig);</strong> fd也就是<code>io_uring_setup</code>的返回值 to_submit也就是要提交的事件数量 min_complete也就是函数返回之前要完成的事件最小数量 sig也就是信号集的指针 用于io完成的时候接受信号 返回值是完成的事件数量</li><li>**io_uring_register()**用于注册内核用户共享缓冲区，如文件描述符、缓冲区等。 成功返回0</li><li>**io_uring_unregister()**用于取消之前通过 <code>io_uring_register()</code> 注册的资源。</li><li>首先使用 <code>io_uring_prep_*()</code> 函数准备 I/O 操作，然后使用 <code>io_uring_submit()</code> 提交这些操作到 <code>io_uring</code> 中进行处理。 <ul><li><code>io_uring_prep_readv()</code>：准备读取操作。</li><li><code>io_uring_prep_writev()</code>：准备写入操作。</li><li><code>io_uring_prep_poll_add()</code>：注册一个轮询事件。</li></ul></li></ul></li><li>内核处理 内核会定期检查sq如果有新的请求就<code>并行</code>处理 也就是同时干</li><li>完成通知 当将内容填充进入cq 然后通知用户</li><li>用户顶级检查cq发现请求完成后 从cq中取出结果进行后续处理</li></ul></li><li><p>优点</p><ul><li>异步性</li><li>非堵塞性</li><li>批量处理</li><li>灵活性</li></ul></li></ul><h4 id="refq和retf详解" tabindex="-1"><a class="header-anchor" href="#refq和retf详解" aria-hidden="true">#</a> refq和retf详解</h4><blockquote><p>参考文章:<a href="https://blog.csdn.net/qq_42323183/article/details/104217210" target="_blank" rel="noopener noreferrer">汇编语言 Ret和retf指令_汇编ret和retf-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://developer.baidu.com/article/details/2728235" target="_blank" rel="noopener noreferrer">从汇编角度看retn和retf-百度开发者中心 (baidu.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li><p>retn (return near) 用栈中数据修改ip寄存器</p></li><li><p>retf (return far)用栈中数据修改cs:ip寄存器</p></li><li><p>retfq 和retf一样但是retfq是从64位转化到32位 retf是从32位转到64位</p><ul><li>先弹出栈顶给ip然后弹出给cs寄存器 0x33(64位) 0x22(32位)</li></ul></li></ul><h4 id="为什么用rax间接传参" tabindex="-1"><a class="header-anchor" href="#为什么用rax间接传参" aria-hidden="true">#</a> 为什么用rax间接传参</h4><p>比如我们没办法直接将一个较大的立即数通过push等直接推入栈 我们需要先赋值给rax 然后推入rax</p><h3 id="arm架构函数调用规范-armv7和armv8的区别" tabindex="-1"><a class="header-anchor" href="#arm架构函数调用规范-armv7和armv8的区别" aria-hidden="true">#</a> arm架构函数调用规范 armv7和armv8的区别</h3><blockquote><p><a href="https://blog.csdn.net/tilblackout/article/details/115179162" target="_blank" rel="noopener noreferrer">ARMv7和ARMv8架构比较-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>[<a href="https://bbs.kanxue.com/thread-272332.htm" target="_blank" rel="noopener noreferrer">原创] CTF 中 ARM &amp; AArch64 架构下的 Pwn-Pwn-看雪-安全社区|安全招聘|kanxue.com<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>[ARM pwn 环境搭建+基础入门 | Pwn进你的心 (ywhkkx.github.io)](https://ywhkkx.github.io/2022/08/29/ARM pwn 环境搭建+基础入门/)</p></blockquote><ul><li>armv7主要是32位指令集 armv8是64位指令集合</li></ul><h5 id="armv7" tabindex="-1"><a class="header-anchor" href="#armv7" aria-hidden="true">#</a> armv7</h5><ul><li><p>32位 是利用的r寄存器 一共16个 然后R0-3一啊不能用作函数的参数传递和返回值使用 也可以在程序中保存立即数</p><ul><li>r7存储系统调用号</li><li>r12 也就是ip r11作为栈指针用作栈底可用于栈回溯 r13sp栈指针 r14 lr链接寄存器 r15 pc 程序计数器</li><li>r0存储float返回值 r0-r1存储double</li><li>前四个参数都是r0-r3寄存器传递 然后后面通过栈传递</li><li>在进行bl等指令的时候 pc存入lr 然后更新pc 就可以通过lr寄存器进行恢复</li><li>返回值会被优化 也就是当返回值是一个结构体的时候那么r0就不是第一个参数而是返回值的指针</li><li>返回是通过pop {pc}进行的返回</li></ul></li><li><p>函数调用规范</p><ul><li>也就是先保存栈底和下一个指令地址</li><li>然后r11设置为栈顶 然后sp展开 这里和x86不同的是arm架构是先进行栈帧展开 再进行的函数跳转</li></ul><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>push {r11, lr} 		/* 序幕的开始,将帧指针和LR保存到堆栈 */
add r11, sp, #0 	/* 设置栈底帧 */
sub sp, sp, #16 	/* 序幕结束,在堆栈上分配一些缓冲区(这也为堆栈帧分配空间) */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>然后就是寄存器赋值</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mov r0, #1 			/* 设置局部变量 (a=1)。 这也用作设置函数 max */ 的第一个参数
mov r1, #2 			/* 设置局部变量 (b=2)。 这也用作设置函数 max */ 的第二个参数
bl max 				/* 调用/分支到函数 max */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>返回的时候 也就是将sp变回栈底 然后将栈底和pc返回原本的值</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sub sp, r11, #0 		/* 结尾的开始,重新调整堆栈指针 */
pop {r11, pc} 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>arm中ldr是load register str也就是store register</p><ul><li>load register 也就是将指针的值存入寄存器中</li><li>store register 也就是将寄存器的值存入指针中</li></ul></li><li><p>arm中str r2 ,[r1 ,#2]也就是存入r+2的位置 但是r1的值不改变</p><ul><li>str r2,[r1,#2]!也就是r1的值会发生改变 也就是将最后的地址写入原寄存器中 所以就是+4 !的意思是请求回写</li><li>ldr r2,[r1],#-2 也就是r1直接赋值给r2 然后r1减去2</li></ul></li></ul><h5 id="armv8" tabindex="-1"><a class="header-anchor" href="#armv8" aria-hidden="true">#</a> armv8</h5><ul><li>arm64架构大差不差 也就是把lr和栈底压入栈 然后栈减去</li><li>寄存器名字叫做X了 X0-x7用作参数传递 X0用作函数返回值 x8用作调用号 x32是pc寄存器 x30也就是函数返回值 然后函数调用的时候直接将原本的sp压栈 然后sp减去一定值 最后再回来</li><li>BR指令 BLR指令</li></ul><h5 id="基础指令" tabindex="-1"><a class="header-anchor" href="#基础指令" aria-hidden="true">#</a> 基础指令</h5><table><thead><tr><th>指令</th><th>目的</th><th>源</th><th>描述</th></tr></thead><tbody><tr><td>MOV</td><td>R0</td><td>R1</td><td>将 R1 里面的数据复制到 R0 中。</td></tr><tr><td>MRS</td><td>R0</td><td>CPSR</td><td>将特殊寄存器 CPSR 里面的数据复制到 R0 中。</td></tr><tr><td>MSR</td><td>CPSR</td><td>R1</td><td>将 R1 里面的数据复制到特殊寄存器 CPSR 里中。</td></tr></tbody></table><ul><li>立即数用#十六进制数据来表示</li><li>LDR</li></ul><h3 id="mips架构的函数调用规范" tabindex="-1"><a class="header-anchor" href="#mips架构的函数调用规范" aria-hidden="true">#</a> mips架构的函数调用规范</h3><p>mips是存在叶子函数的 叶子函数也就是函数中不会去调用其他任何函数 非叶子函数就是还会调用其他的函数</p><ul><li>a调用b的情况 非叶子函数 会将返回地址存入栈中 <ul><li>叶子函数的话 则返回a的i地址存储再ra寄存器中</li></ul></li><li>当函数返回的时候 如果是非叶子函数 则从堆栈中取出返回地址 然后存入ra寄存器 然后再跳转返回 <ul><li>叶子函数则直接ra进行跳转</li></ul></li><li>返回值存储再v0-v1中</li></ul><blockquote><p>[mips pwn | p1Kk&#39;s World!](https://p1kk.github.io/2020/01/01/异构pwn/mips pwn/#缓冲区溢出分析示例)</p></blockquote><ul><li>调用者把参数都保存在a0-a3寄存器 也就是前4个用寄存器保存后面用栈保存</li><li>返回地址存储再ra寄存器上</li></ul><h3 id="phppwn堆管理机制" tabindex="-1"><a class="header-anchor" href="#phppwn堆管理机制" aria-hidden="true">#</a> phpPwn堆管理机制</h3><blockquote><p>[第5章 内存管理 - 5.1 Zend内存池 - 《<a href="https://www.bookstack.cn/read/php7-internal/5-zend_alloc.md" target="_blank" rel="noopener noreferrer">试读] PHP7内核剖析》 - 书栈网 · BookStack<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><p>php中针对内存的操作进行了一层封装 用于替换内存操作 实现malloc free等操作 也就是参考了tcmalloc函数</p><p>php内存管理中有三种颗粒度的内存块 也就是chunk page slot 每个chunk占2m 然后page占比4kb 一个chunk会被分配为page 然后page再分配为slot</p><p>也就是申请大于2m则申请chunk 大于3/4page就申请page 然后小于3/4page 就申请slot</p><ul><li><strong>Huge(chunk):</strong> 申请内存大于2M，直接调用系统分配，分配若干个chunk</li><li><strong>Large(page):</strong> 申请内存大于3092B(3/4 page_size)，小于2044KB(511 page_size)，分配若干个page</li><li><strong>Small(slot):</strong> 申请内存小于等于3092B(3/4 page_size)，内存池提前定义好了30种同等大小的内存(8,16,24,32，…3072)，他们分配在不同的page上(不同大小的内存可能会分配在多个连续的page)，申请内存时直接在对应page上查找可用位置</li></ul><p>都是受到heap结构体管理 用于管理上面三种内存的分配 <code>main_chunk</code>属性是chunk链表 <code>free_slot</code>就是一些固定大小的slot链表 类似于lagrebin的管理模式 2024d3中phppwn那题就是通过劫持slot链表来进行任意写</p><ul><li>这里利用的是mmap函数进行的申请内存 而非malloc函数的brk等</li></ul><h3 id="cpp堆管理机制-todo" tabindex="-1"><a class="header-anchor" href="#cpp堆管理机制-todo" aria-hidden="true">#</a> cpp堆管理机制（todo）</h3><h3 id="musl堆管理器" tabindex="-1"><a class="header-anchor" href="#musl堆管理器" aria-hidden="true">#</a> musl堆管理器</h3><blockquote><p>参考文章:<a href="https://blog.csdn.net/canpool/article/details/121064482" target="_blank" rel="noopener noreferrer">musl 知：内存管理_musl-1.1.20-r5-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><p>轻量级的嵌入式开发glibc库</p><h2 id="堆利用" tabindex="-1"><a class="header-anchor" href="#堆利用" aria-hidden="true">#</a> 堆利用</h2><blockquote><p>因为太过重要 以及知识点体系过于庞大 所以单独拿出来 house系列主要是这个<a href="https://roderickchan.github.io/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/" target="_blank" rel="noopener noreferrer">Glibc堆利用之house of系列总结 - roderick - record and learn! (roderickchan.github.io)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>文章进行总结得很好 这里大量直接进行copy</p><p>然后总结文章:<a href="https://blog.csdn.net/songchuwang1868/article/details/89951543" target="_blank" rel="noopener noreferrer">一篇文章彻底讲懂malloc的实现（ptmalloc）_malloc过程-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li>有一些很容易想要的一些利用方式这里就不单独列出来了 比如修改fd 控制malloc到的数据 主要是总结一些利用难度较高 比较成体系的利用方式</li></ul><h3 id="malloc函数中的一些检查机制" tabindex="-1"><a class="header-anchor" href="#malloc函数中的一些检查机制" aria-hidden="true">#</a> malloc函数中的一些检查机制</h3><blockquote><p>这个主要是写在源码注释中了 翻阅源码即可然后找到一个很好用的网站写了源码中的宏定义<a href="https://kiprey.github.io/2020/04/heap-5-heap_definitions/" target="_blank" rel="noopener noreferrer">heap - 5 - malloc、free函数相关的宏定义 | Kiprey&#39;s Blog<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><h3 id="常见利用技巧" tabindex="-1"><a class="header-anchor" href="#常见利用技巧" aria-hidden="true">#</a> 常见利用技巧</h3><ul><li><code>overlapping</code>: 这个技巧主要是通过<code>off_by_null</code>漏洞进行控制size位的prev_inused这个位 这个操作十分方便 我可以间接利用然后实现<code>劫持</code>正在使用的合法chunk 然后我们就可以绕过一些题目中的<code>free</code>检查 比如有一些题必须free 表中记录正在使用的chunk才是合法的 无法直接double free 我们可以通过劫持合法chunk轻松实现<code>double free</code> 具体就是让我们要劫持的chunk刚好处于合并区间之间比如:malloc 五个chunk<code>chunk1</code>,<code>chunk2</code>,<code>chunk3</code>,<code>chunk4</code>,<code>chunk5</code>然后chunk1的内容部分构造好<code>fakechunk</code>根据版本的安全检查进行构造 如果版本较高我们需要计算并且构造好size区域 <code>fd</code> 以及<code>bk</code>然后<code>chunk2</code>就为我们要劫持的chunk 我们通过<code>chunk3</code>写入内容覆盖<code>chunk4</code>完成覆写p位并且构造好<code>prev_size</code>让它刚好指向我们的<code>fakechunk</code>然后最后我们free chunk4触发合并机制 让<code>chunk4</code>到<code>fake chunk</code>之间的内容全部进入unsortedbin中 这样我们malloc下来就可以进行劫持了 这个方法较为好用</li></ul><h3 id="house-of-force-top-chunk-利用" tabindex="-1"><a class="header-anchor" href="#house-of-force-top-chunk-利用" aria-hidden="true">#</a> House of force(top chunk 利用)</h3><blockquote><p>主要是我们能溢出数据到<code>topchunk</code>的<code>size</code>区域 然后malloc的时候malloc一个超大值让它刚好到我们想要控制的地址附近去</p></blockquote><ul><li>范围:<code>2.23</code>——<code>2.29</code></li><li>因为2.29后加入了对size区域的检查 导致我们没办法再通过直接获取任意地址</li></ul><h4 id="largebin-attack" tabindex="-1"><a class="header-anchor" href="#largebin-attack" aria-hidden="true">#</a> largebin attack</h4><blockquote><p>主要是利用了unsoretdbin 的入链机制 也就是当我们所需要的chunk不属于fastbin tcachebin 已有chunk大小 需要从unsrotedbin中取chunk的时候 触发unsortedbin分类合并机制 如果unsortedbin中chunk有一个chunk属于largebin的范围 并且比largebin chunk的最小的chunk还小 我们如果可以劫持largebin 最小的那个chunk 就可以触发一个任意写已知地址 并且还可以实现堆地址的泄露 十分好用的技巧</p></blockquote><h4 id="smallbin-attack-todo" tabindex="-1"><a class="header-anchor" href="#smallbin-attack-todo" aria-hidden="true">#</a> smallbin attack(todo)</h4><h3 id="house-of-kiwi" tabindex="-1"><a class="header-anchor" href="#house-of-kiwi" aria-hidden="true">#</a> House of kiwi</h3><blockquote><p>利用<code>malloc_assert</code>的fflush(stderr);来触发调用链</p></blockquote><ul><li>通过触发assert函数中的fflush 然后调用<code>_io_file_jumps</code>的<code>_io_FILE_SYNC</code>指针 并且rdx恒为<code>_IO_helper_jumps</code>指针</li><li>我们可以将<code>_io_file_sync</code>指针调整为<code>setcontext+61</code>触发rdx到寄存器的赋值 然后我们劫持<code>_IO_helper_jumps</code>(0xa0 0xa8)实现 <ul><li>修改<code>IO_helper_jumps + 0xA0 and 0xA8</code>分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移</li></ul></li></ul><h3 id="house-of-cat" tabindex="-1"><a class="header-anchor" href="#house-of-cat" aria-hidden="true">#</a> house of cat</h3><ul><li><p>可以打fsop 也就是打main函数返回 程序执行exit libc执行abort(高版本已经删除) __malloc_assert则是在malloc中触发，通常是修改top chunk的大小。</p></li><li><p>触发<code>__malloc_assert</code>调用<code>__fxprintf</code></p><ul><li>主要是想办法调用<code>_IO_xxx_jumps</code></li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token function">__malloc_assert</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>assertion<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> line<span class="token punctuation">,</span>
		 <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>function<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">__fxprintf</span> <span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">&quot;%s%s%s:%u: %s%sAssertion `%s&#39; failed.\n&quot;</span><span class="token punctuation">,</span>
		     __progname<span class="token punctuation">,</span> __progname<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
		     file<span class="token punctuation">,</span> line<span class="token punctuation">,</span>
		     function <span class="token operator">?</span> function <span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> function <span class="token operator">?</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span>
		     assertion<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fflush</span> <span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">abort</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>然后__fxprintf又调用<code>__vfxprintf</code>函数 然后调用<code>locked_vfxprintf</code> 然后调用<code>__vfwprintf_internal</code>然后调用对应的vtable函数</p><ul><li><img src="https://awaqwqa.github.io/img/sycKernel/image-20240602023528121.png" alt="image-20240602023528121" tabindex="0" loading="lazy"><figcaption>image-20240602023528121</figcaption></li></ul></li></ul><h3 id="printf-puts-io调用链-todo" tabindex="-1"><a class="header-anchor" href="#printf-puts-io调用链-todo" aria-hidden="true">#</a> printf/puts io调用链(TODO)</h3><h2 id="linux-kernel" tabindex="-1"><a class="header-anchor" href="#linux-kernel" aria-hidden="true">#</a> linux Kernel</h2><blockquote><p>kernel部分比较重要需要重新梳理一下 以及理顺一些脉络</p></blockquote><h3 id="段保护模式-页保护模式" tabindex="-1"><a class="header-anchor" href="#段保护模式-页保护模式" aria-hidden="true">#</a> 段保护模式/页保护模式</h3><blockquote><p>一般来说我们的逻辑地址会经历转化才回到真正的物理地址去</p><p><a href="https://www.xiaolincoding.com/os/3_memory/vmem.html#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" target="_blank" rel="noopener noreferrer">4.1 为什么要有虚拟内存？ | 小林coding (xiaolincoding.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li>虚拟地址-&gt;线性地址-&gt;物理地址</li><li>32位我们比较熟悉 在复习中断的时候 我们已经大概的复习了一下两级分页机制 然后下面图是大佬博客里面的四级分页机制的图 讲解得很仔细<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/操作系统/内存管理/四级分页.png" alt="img" loading="lazy"></li></ul><h4 id="虚拟地址转化为线性地址" tabindex="-1"><a class="header-anchor" href="#虚拟地址转化为线性地址" aria-hidden="true">#</a> 虚拟地址转化为线性地址</h4><p>依赖于段选择子也就是段寄存器 段选择子再去</p><h3 id="实-保护模式" tabindex="-1"><a class="header-anchor" href="#实-保护模式" aria-hidden="true">#</a> 实/保护模式</h3><p>实模式就是简单通过cs:ip这样的方式直接访问内存</p><p>保护模式就是通过段机制 来间接访问内存</p><h3 id="进程" tabindex="-1"><a class="header-anchor" href="#进程" aria-hidden="true">#</a> 进程</h3><blockquote><p><a href="https://www.xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81" target="_blank" rel="noopener noreferrer">5.1 进程、线程基础知识 | 小林coding (xiaolincoding.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>一般多线程 如果一个线程挂了就会导致全部线程崩溃 因为线程是共享内存的 如果一个线程崩溃了就会导致内存有错误 不确定会带来一些难以想象的后果 所以其他线程也会更随着崩溃</p></blockquote><ul><li>操作系统通过<code>pcb</code>进程控制块来描述进程 <code>pcb</code>通常是相同状态的链表链接在一起的</li><li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；</li></ul><h3 id="execve" tabindex="-1"><a class="header-anchor" href="#execve" aria-hidden="true">#</a> execve</h3><ul><li>是先将程序头写入进入新的内存 然后通过cow进行copy其他代码部分</li><li>覆盖原有的进程 会改变代码段</li></ul><h3 id="oom机制" tabindex="-1"><a class="header-anchor" href="#oom机制" aria-hidden="true">#</a> oom机制</h3><blockquote><p><a href="https://www.xiaolincoding.com/os/3_memory/mem_reclaim.html#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84" target="_blank" rel="noopener noreferrer">4.3 内存满了，会发生什么？ | 小林coding (xiaolincoding.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><blockquote><p>当进行申请内存 内存不够 并且回收一些内存（kswapd）后依旧不够就会杀死一个物理内存占用较高的进程 直到释放足够的内存位置</p></blockquote><ul><li>回收内存(lru算法): <ul><li>内存页(大多数内存页都是可以直接释放的 以后有需要了 在进行重新读取即可 如果已经被程序修改过了 并且暂时没有写入磁盘的数据(脏页) 会先写入磁盘 然后再进行内存的释放)</li><li>匿名页:比如栈堆等 这些内存随时有可能再次被访问所以不能直接回收所以会利用<code>swap</code>机制先写入磁盘中 然后再释放内存</li></ul></li></ul><h4 id="如何保护一个进程不被-oom-杀掉呢" tabindex="-1"><a class="header-anchor" href="#如何保护一个进程不被-oom-杀掉呢" aria-hidden="true">#</a> 如何保护一个进程不被 OOM 杀掉呢？</h4><ul><li>oom主要是根据进程的得分来进行评估是否要杀掉 <ul><li>第一，进程已经使用的物理内存页面数。</li><li>第二，每个进程的 OOM 校准值 oom_score_adj。它是可以通过 <code>/proc/[pid]/oom_score_adj</code> 来配置的。我们可以在设置 -1000 到 1000 之间的任意一个数值，调整进程被 OOM Kill 的几率。</li></ul></li><li>所以我们可以通过<code> oom_score_adj</code>来避免被杀 比如把这个值设置位-1000</li></ul><h3 id="linux的内存管理" tabindex="-1"><a class="header-anchor" href="#linux的内存管理" aria-hidden="true">#</a> linux的内存管理</h3><blockquote><p>32位操作系统和64位操作系统在内核内存的分布是不一样的</p></blockquote><ul><li><p>首先在32位操作系统中内核虚拟内存和进程虚拟内存是无缝衔接的 而64位操作系统内核和用户空间是存在一大块空洞空间的</p><ul><li>存在原因是因为64位用高16位作为标记 也就是0x0000 7fff ffff f000以下为用户 0xffff 8000 0000 0000以上是内核</li></ul></li><li><p>32位是4g 64位是16 EB</p></li><li><p>32位内核内存分布</p><ul><li>最先是896mb（直接映射区域）是和物理内存一一对应的 但是其还是使用的虚拟地址并且也要通过映射转化为物理地址 <ul><li>其中前16mb是DMA区域 用于存放</li><li>剩下就是NORMAL区域</li></ul></li><li>高端内存也就是896mb之上的区域（128mb）采用的是动态映射技术 <ul><li>vmalloc 区域 也就是使用vmalloc进行申请的区域</li><li>永久映射区 也就是允许建立与物理高端内存的长期映射关系 比如内核通过<code>alloc_pages</code>函数申请物理内存页 这些物理内存页通过kmap映射到永久映射区</li><li>固定映射区</li><li>临时映射区 也就是缓冲区的作用比如做一些copy操作的时候</li></ul></li><li><img src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTQxKjhIG7yiaBooWo0d4VPwd7lvblpzKYx192ibwVB1kY5CDBUhNWa1gw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></li></ul></li><li><p>64位内核内存分布</p><blockquote><p>64位的由于空间巨大 不需要和32位一样精细规划 所以相对而言简单一些</p></blockquote><ul><li>64t的直接映射区</li><li>32t的vmalloc区域</li><li>1t虚拟内存映射区</li><li>512mb代码段</li></ul></li><li><p>伙伴算法</p><ul><li>分配内存页使用<code>alloc_pages</code>来完成 而<code>alloc_pages</code>是通过<code>rmqueue()</code>来分配内存页</li></ul></li></ul><h4 id="如果4g物理内存的机子上面申请8g内存会怎样" tabindex="-1"><a class="header-anchor" href="#如果4g物理内存的机子上面申请8g内存会怎样" aria-hidden="true">#</a> 如果4g物理内存的机子上面申请8g内存会怎样</h4><blockquote><p><a href="https://www.xiaolincoding.com/os/3_memory/alloc_mem.html#_64-%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener noreferrer">4.4 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？ | 小林coding (xiaolincoding.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li>如果32位操作系统的情况下 我们申请就会失败 因为32位操作系统虚拟内存也就4g</li><li>64位操作系统是成功的 因为cow的关系 我们只有真的写的时候才会影响实际的物理内存</li></ul><h2 id="pwn-linux-kernel" tabindex="-1"><a class="header-anchor" href="#pwn-linux-kernel" aria-hidden="true">#</a> Pwn linux kernel</h2><h3 id="调试" tabindex="-1"><a class="header-anchor" href="#调试" aria-hidden="true">#</a> 调试</h3><p>环境拿下来后可以通过指令直接运行起内核 然后通过调试</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>qemu<span class="token operator">-</span>system<span class="token operator">-</span>x86_64 <span class="token operator">-</span>initrd rootfs<span class="token punctuation">.</span>cpio <span class="token operator">-</span>kernel bzImage <span class="token operator">-</span>append &#39;console<span class="token operator">=</span>ttyS0 root<span class="token operator">=</span><span class="token operator">/</span>dev<span class="token operator">/</span>ram oops<span class="token operator">=</span>panic panic<span class="token operator">=</span><span class="token number">1</span>&#39; <span class="token operator">-</span>monitor <span class="token operator">/</span>dev<span class="token operator">/</span>null <span class="token operator">-</span>m <span class="token number">128</span>M <span class="token operator">--</span>nographic <span class="token operator">-</span>s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>当题目中不存在vmlinux文件的时候 我们要调试内核或者查看rop链的时候 可以用 extract-vmlinux 命令可以从 bzImage种提取vmlinux</p></li><li><p>一般情况下我们需要提取出来ko文件 目前linux kernel文件系统 主要分为两种:<code>ext4</code>和<code>cpio</code> 两种我们的提取方式不同</p><blockquote><p><a href="https://xz.aliyun.com/t/7625?time__1311=n4%2BxnD0G0%3DG%3Dn4Gwx05%2B4o%3D0QGCFQQDRnoD&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F" target="_blank" rel="noopener noreferrer">Linux Kernel Pwn 初探 - 先知社区 (aliyun.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li><code>ext4</code> 直接将文件系统挂载在已有的目录中 <ul><li><code>mkdir ./rootfs</code></li><li><code>sudo mount rootfs.img ./rootfs</code></li><li>此时这个时候这个目录下就已经有了我们的文件目录</li></ul></li><li><code>cpio</code> 这个稍微多一步也就是 解压文件系统 重打包 <ul><li><code>mkdir extracted; cd extracted</code></li><li><code>cpio -i --no-absolute-filenames -F ../rootfs.cpio</code></li><li>此时与其它文件系统相同，找到<code>rcS</code>文件，查看加载的驱动，拿出来</li><li><code>find . | cpio -o --format=newc &gt; ../rootfs.cpio</code></li></ul></li></ul></li></ul><h3 id="常规保护机制" tabindex="-1"><a class="header-anchor" href="#常规保护机制" aria-hidden="true">#</a> 常规保护机制</h3><blockquote><p><a href="https://xz.aliyun.com/t/7625?time__1311=n4%2BxnD0G0%3DG%3Dn4Gwx05%2B4o%3D0QGCFQQDRnoD&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F" target="_blank" rel="noopener noreferrer">Linux Kernel Pwn 初探 - 先知社区 (aliyun.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li><code>KPTI</code>：Kernel PageTable Isolation，内核页表隔离</li><li><code>KASLR</code>：Kernel Address space layout randomization，内核地址空间布局随机化 <ul><li>也就是<code>kernel</code>的<code>ASLR</code></li></ul></li><li><code>SMEP</code>：Supervisor Mode Execution Prevention，管理模式执行保护 <ul><li>也就是内核状态下不允许执行用户态的代码</li></ul></li><li><code>SMAP</code>：Supervisor Mode Access Prevention，管理模式访问保护 <ul><li>也就是内核状态下不允许访问用户态的数据</li></ul></li></ul><p><code>SMEP</code>与<code>SMAP</code>这两个都是通过<code>cr4</code>寄存器来进行判断开启关闭的 所以我们如果可以修改<code>cr4</code>的值 我们就可以实现绕过这两个保护</p><ul><li><code>Stack Protector</code>：Stack Protector又名canary，stack cookie</li><li><code>kptr_restrict</code>：允许查看内核函数地址</li><li><code>dmesg_restrict</code>：允许查看<code>printk</code>函数输出，用<code>dmesg</code>命令来查看</li><li><code>MMAP_MIN_ADDR</code>：不允许申请<code>NULL</code>地址 <code>mmap(0,....)</code></li></ul><h3 id="常用利用结构体" tabindex="-1"><a class="header-anchor" href="#常用利用结构体" aria-hidden="true">#</a> 常用利用结构体</h3><ul><li>tss_struct 中cr3主要是存储页目录的物理地址 cs寄存器末尾存储当前的权限等级</li></ul><h4 id="mm-struct" tabindex="-1"><a class="header-anchor" href="#mm-struct" aria-hidden="true">#</a> mm_struct</h4><blockquote><p>主要负责对内存区域的大致划分结构体属性存储的就是各个内存区域的边界</p></blockquote><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImTcWU7wiaNM09r9pblewZhVPCvyicMIv9WhP1UXq4OxrKRf5f3ptIXwDLw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h4 id="vm-arena-struct结构体-双向链表" tabindex="-1"><a class="header-anchor" href="#vm-arena-struct结构体-双向链表" aria-hidden="true">#</a> vm_arena_struct结构体(双向链表)</h4><blockquote><p>描述一个内存区域的开始结束 权限 是否能共享(mmap)等信息 以及存储了虚表指针(open close 等)</p></blockquote><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUbGGUk2MUSBRrJEtYOJzImT9micXwnnJLk1icdR1KJeSMqiarDJX8venibtYAMAl0LG4lMlSpNDlRUFCg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片" tabindex="0" loading="lazy"><figcaption>图片</figcaption></figure><h4 id="cred结构体" tabindex="-1"><a class="header-anchor" href="#cred结构体" aria-hidden="true">#</a> cred结构体</h4><blockquote><p>创建一个新进程的时候 内核会申请一个<code>cred</code>结构体 存放进程信息 主要是一些权限信息之类的</p></blockquote><h4 id="tty-struct" tabindex="-1"><a class="header-anchor" href="#tty-struct" aria-hidden="true">#</a> tty_struct</h4><blockquote><p>学习文章:<a href="https://blog.csdn.net/rockrockwu/article/details/24035303" target="_blank" rel="noopener noreferrer">tty_struct数据结构_ttystruct-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/104577501" target="_blank" rel="noopener noreferrer">linux kernel pwn学习之伪造tty_struct执行任意函数_tty struct-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>tty_driver 是驱动通过alloc_tty_driver函数分配的 也就是调用kzalloc tty0也就是控制台的文件体现</p></blockquote><ul><li><p>tty_driver的flags等在未被赋值的时候所有值都是0</p></li><li><p>当open(ptmx)的时候会初始化<code>tty_struct</code></p></li><li><p>攻击手段就是利用在调用对<code>ptmx</code>驱动进行write操作的时候我们是利用的<code>tty_struct</code>结构体中虚表进行的操作 所以我们如果可以伪造这个vtable然后指向我们的可控区域 来实现函数的调用</p></li></ul><h3 id="堆喷-脏管道学习-todo" tabindex="-1"><a class="header-anchor" href="#堆喷-脏管道学习-todo" aria-hidden="true">#</a> 堆喷/脏管道学习(TODO)</h3><h3 id="msg-msg消息队列-todo" tabindex="-1"><a class="header-anchor" href="#msg-msg消息队列-todo" aria-hidden="true">#</a> msg_msg消息队列(TODO)</h3><h3 id="kmalloc和vmalloc区别-todo" tabindex="-1"><a class="header-anchor" href="#kmalloc和vmalloc区别-todo" aria-hidden="true">#</a> kmalloc和vmalloc区别(TODO)</h3><h3 id="缺页内核和用户态-userfaultfd-todo" tabindex="-1"><a class="header-anchor" href="#缺页内核和用户态-userfaultfd-todo" aria-hidden="true">#</a> 缺页内核和用户态(userfaultfd)（TODO）</h3><blockquote><p>如果要提升条件竞争的概率,可以采用userfaultfd</p></blockquote><h3 id="sk-buff-todo" tabindex="-1"><a class="header-anchor" href="#sk-buff-todo" aria-hidden="true">#</a> sk_buff(TODO)</h3><h3 id="dirty-cow-pipe-todo" tabindex="-1"><a class="header-anchor" href="#dirty-cow-pipe-todo" aria-hidden="true">#</a> dirty cow/pipe(TODO)</h3><h3 id="smep和smap的绕过-todo" tabindex="-1"><a class="header-anchor" href="#smep和smap的绕过-todo" aria-hidden="true">#</a> smep和smap的绕过(TODO)</h3><h2 id="v8-jsc-todo" tabindex="-1"><a class="header-anchor" href="#v8-jsc-todo" aria-hidden="true">#</a> V8/jsc(TODO)</h2><h3 id="标记指针" tabindex="-1"><a class="header-anchor" href="#标记指针" aria-hidden="true">#</a> 标记指针</h3><ul><li>v8中利用指针标记技术在v8的堆指针中存储额外的数据 比如32位操作系统下最低有效位用来区分smis/堆指针 第二个最低有效位来区分强引用和弱引用 64位操作系统用前32位进行当作负载 <ul><li>强引用也即是垃圾回收器不会去回收这个对象 内存不足也不会去回收 必须是显式释放</li><li>软引用用于描述一些有用但不是必须的对象 内存不足有可能被回收比如java中用new SoftReference来进行引用</li><li>弱引用 下次垃圾回收就有可能被回收</li></ul></li></ul><h3 id="压缩指针" tabindex="-1"><a class="header-anchor" href="#压缩指针" aria-hidden="true">#</a> 压缩指针</h3><ul><li>v8 将高32位存储在r13寄存器中</li></ul><h4 id="js对象基础属性" tabindex="-1"><a class="header-anchor" href="#js对象基础属性" aria-hidden="true">#</a> js对象基础属性</h4><ul><li>prototype 也就是js对象都是继承自另外个对象 也就是父对象 父对象被称之为原型对象(null除外 它没有自己的原型对象)</li><li>所以当调用对象的函数或者属性的时候 如果没有该属性或者方法就会去原型对象上面查找 如果找到不到就一直向上寻找直到最顶层的Object.prototype 如果最自己本身具备就不会去找原型</li></ul><h3 id="编译整体流程-todo" tabindex="-1"><a class="header-anchor" href="#编译整体流程-todo" aria-hidden="true">#</a> 编译整体流程(TODO)</h3><h3 id="如何调试-todo" tabindex="-1"><a class="header-anchor" href="#如何调试-todo" aria-hidden="true">#</a> 如何调试(TODO)</h3><h2 id="编译原理" tabindex="-1"><a class="header-anchor" href="#编译原理" aria-hidden="true">#</a> 编译原理</h2><ul><li>编译器主要是四个阶段 <ul><li>预处理 <ul><li>比如对宏进行展开</li></ul></li><li>编译 <ul><li>生成汇编语言 <ul><li>语法分析(syntax analyzing)</li><li>语义分析()</li><li>生成中间代码</li><li>代码生成</li></ul></li></ul></li><li>汇编</li><li>链接</li></ul></li></ul><h3 id="语法解析-todo" tabindex="-1"><a class="header-anchor" href="#语法解析-todo" aria-hidden="true">#</a> 语法解析(TODO)</h3><h3 id="token生成-todo" tabindex="-1"><a class="header-anchor" href="#token生成-todo" aria-hidden="true">#</a> TOken生成(TODO)</h3><ul><li>ebnf语法</li></ul><h3 id="ast生成-todo" tabindex="-1"><a class="header-anchor" href="#ast生成-todo" aria-hidden="true">#</a> AST生成(TODO)</h3><h4 id="字面量语法树" tabindex="-1"><a class="header-anchor" href="#字面量语法树" aria-hidden="true">#</a> 字面量语法树</h4><h4 id="一元运算抽象语法树" tabindex="-1"><a class="header-anchor" href="#一元运算抽象语法树" aria-hidden="true">#</a> 一元运算抽象语法树</h4><h4 id="二元运算抽象语法树" tabindex="-1"><a class="header-anchor" href="#二元运算抽象语法树" aria-hidden="true">#</a> 二元运算抽象语法树</h4><h3 id="中间代码生成-todo" tabindex="-1"><a class="header-anchor" href="#中间代码生成-todo" aria-hidden="true">#</a> 中间代码生成（TODO）</h3><h3 id="链接与库-todo" tabindex="-1"><a class="header-anchor" href="#链接与库-todo" aria-hidden="true">#</a> 链接与库（TODO）</h3><h3 id="ld的链接-todo" tabindex="-1"><a class="header-anchor" href="#ld的链接-todo" aria-hidden="true">#</a> ld的链接(TODO)</h3><h2 id="开发框架-todo" tabindex="-1"><a class="header-anchor" href="#开发框架-todo" aria-hidden="true">#</a> 开发框架(TODO)</h2><h3 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列" aria-hidden="true">#</a> 消息队列</h3><h4 id="kafka" tabindex="-1"><a class="header-anchor" href="#kafka" aria-hidden="true">#</a> kafka</h4><ul><li>senfile</li><li>零copy技术</li></ul><h4 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq" aria-hidden="true">#</a> RabbitMQ</h4><h4 id="rocketmq" tabindex="-1"><a class="header-anchor" href="#rocketmq" aria-hidden="true">#</a> RocketMQ</h4><h3 id="postgresql-数据库" tabindex="-1"><a class="header-anchor" href="#postgresql-数据库" aria-hidden="true">#</a> postgreSQL(数据库)</h3><ul><li>其中的notify推送机制</li></ul><h3 id="asyncio-异步框架" tabindex="-1"><a class="header-anchor" href="#asyncio-异步框架" aria-hidden="true">#</a> asyncio（异步框架）</h3><ul><li><p>从<code>状态机</code>角度分析</p><blockquote><p><a href="https://www.cnblogs.com/yaopengfei/p/12848795.html" target="_blank" rel="noopener noreferrer">第十七节：从状态机的角度async和await的实现原理(新) - Yaopengfei - 博客园 (cnblogs.com)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote></li></ul><h3 id="日志框架" tabindex="-1"><a class="header-anchor" href="#日志框架" aria-hidden="true">#</a> 日志框架</h3><h2 id="android" tabindex="-1"><a class="header-anchor" href="#android" aria-hidden="true">#</a> Android</h2><blockquote><p>主要是应对这次的360面试,准备一些面试可能会考察的内容</p></blockquote><h3 id="dex-和class文件的区别" tabindex="-1"><a class="header-anchor" href="#dex-和class文件的区别" aria-hidden="true">#</a> dex 和class文件的区别</h3><blockquote><p>参考文章:<a href="https://blog.csdn.net/itermeng/article/details/79218060" target="_blank" rel="noopener noreferrer">Android Dex VS Class：实例图解剖析两种格式文件结构、优劣_dex文件格式-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><p>当正常java程序编译后生成的是class字节码文件</p><ul><li>class文件只存储一个类的信息</li><li>class文件其实不止可以是java文件文件生成的也可以是其他语言生成的 <ul><li>python</li><li>scale</li><li>...</li></ul></li></ul><h4 id="class文件" tabindex="-1"><a class="header-anchor" href="#class文件" aria-hidden="true">#</a> class文件</h4><ul><li><p>包含信息</p><ul><li><p><strong>magic</strong> 无符号4字节类型，是一个加密段，类似md5，用来判断class文件是否被篡改过</p></li><li><p><strong>minor_version</strong> 会显示最小适配的<strong>JDK</strong>版本</p></li><li><p><strong>major_version</strong> class文件生成的<strong>JDK</strong>版本</p></li><li><p>等其他相关信息</p></li></ul></li><li><p>弊端</p><ul><li>class文件加载速度慢 (<strong>堆栈的加栈模式</strong>)</li><li>因为class文件只能存储一个类文件,所以一个程序的class文件会非常多</li></ul></li></ul><h4 id="dex文件" tabindex="-1"><a class="header-anchor" href="#dex文件" aria-hidden="true">#</a> dex文件</h4><blockquote><p>其实我这里的理解就是dex文件就是针对移动设备进行优化后的文件</p><p>dex文件时包含了整个<strong>工程</strong>中所有类文件的信息,也就是可以有多个类集成在一个dex文件中</p></blockquote><p>dex可以被<strong>DVM</strong>识别,加载并执行的文件格式.同时也不仅仅是java才能编译为dex,c/c++也可以编译为dex文件</p><p>dex文件结构相对而言对于class文件是比较复杂的,dex文件会去除class文件中冗余的信息整合后复用.</p><p>一般可以通过<code>dx</code>指令将<code>class</code>文件生成为<code>dex</code>文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>dx <span class="token parameter variable">--dex</span> -- output Hello.dex Hello.class
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://img-blog.csdn.net/20180126233025202?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSVRlcm1lbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" tabindex="0" loading="lazy"><figcaption>这里写图片描述</figcaption></figure><ul><li>可以发现dex文件中有个索引区 这里面记录了各种数据的索引 并且包含了对外部数据的索引</li></ul><h3 id="全限定类名和非限定类名的区别" tabindex="-1"><a class="header-anchor" href="#全限定类名和非限定类名的区别" aria-hidden="true">#</a> 全限定类名和非限定类名的区别</h3><blockquote><p>参考文章:<a href="https://blog.csdn.net/weixin_36873225/article/details/117060872" target="_blank" rel="noopener noreferrer">什么叫做java类的全限定名-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><p>全限定类名：就是类名全称，带包路径的用点隔开，例如: java.lang.String。全限定名 = 包名+类型</p><p>非限定类名也叫短名，就是我们平时说的类名.</p><h3 id="smail语法" tabindex="-1"><a class="header-anchor" href="#smail语法" aria-hidden="true">#</a> smail语法</h3><blockquote><p>dex文件反编译之后就是Smali代码，所以说，Smali语言是Android虚拟机的反汇编语言</p></blockquote><h3 id="res-raw和asset的区别" tabindex="-1"><a class="header-anchor" href="#res-raw和asset的区别" aria-hidden="true">#</a> res/raw和asset的区别</h3><blockquote><p>参考文章:<a href="https://blog.csdn.net/weixin_52173250/article/details/141808125" target="_blank" rel="noopener noreferrer">1-1.Android 下的 XML 文件（概念理解、存储位置理解）_android的xml文件-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li>res/raw和asset都是存放一些不需要被系统编译为二进制形式的文件,raw有原始的意思</li><li>在<strong>raw</strong>文件夹的内容都会被映射到<strong>R.java</strong>中,所以我们可以直接通过<strong>资源ID</strong>进行访问即 R.raw.xxxxx</li><li><strong>raw</strong>的子文件夹内容,<strong>asset</strong>文件夹不会被映射到R.java中</li><li>相对而言<strong>raw</strong>的访问速度要比<strong>assets</strong>速度快一些</li></ul><h3 id="xml文件" tabindex="-1"><a class="header-anchor" href="#xml文件" aria-hidden="true">#</a> xml文件</h3><blockquote><p>我们主要研究的android下的xml文件,通常有一些通用的元素组成</p><p>参考文章:<a href="https://blog.csdn.net/weixin_52173250/article/details/141808125" target="_blank" rel="noopener noreferrer">1-1.Android 下的 XML 文件（概念理解、存储位置理解）_android的xml文件-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><p>在安卓里面<strong>xml</strong>文件被广泛使用</p><ul><li>布局文件 (<code>res/layout</code>)</li><li>字符串资源文件(<code>res/values/strings.xml</code>)</li><li>颜色资源文件 (<code>res/values/colors.xml</code>)</li><li>尺寸资源文件 (<code>res/values/dimens.xml</code>)</li><li>安卓程序入口(<code>AndroidManifest.xml</code>)</li></ul><p>其中<code>AndroidManifest.xml</code>应该是最特殊的文件,这个文件里面包含了Android程序的入口,声明了一个android程序最基本的属性(<code>四大组件</code>),权限,API级别等</p><h3 id="objection和frida" tabindex="-1"><a class="header-anchor" href="#objection和frida" aria-hidden="true">#</a> objection和frida</h3><h2 id="ida" tabindex="-1"><a class="header-anchor" href="#ida" aria-hidden="true">#</a> IDA</h2><h3 id="几种断点-软断点-硬件断点" tabindex="-1"><a class="header-anchor" href="#几种断点-软断点-硬件断点" aria-hidden="true">#</a> 几种断点 软断点 硬件断点</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/620612511" target="_blank" rel="noopener noreferrer">软断点、硬件断点和内存断点(逆向基础知识) - 知乎<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><ul><li><p>软断点</p><ul><li>其实就是将目标地址改指令为中断指令让cpu执行到这里的时候停下来,然后再替换为原来的指令从而实现断点的功能</li></ul></li><li><p>硬件断点</p><ul><li>是通过cpu上一组特殊的寄存器来实现的,比如x86就是DR0-DR7寄存器 <ul><li>DR0-R3都是硬件断点的内存地址,可以使用4个硬件断点</li></ul></li></ul></li><li><p>内存断点,本质不是真正的断点,而是改变内存的内存权限,类似于却也中断 我们应该可以通过userfaultfd这种机制来实现一个较为完善的内存缺页中断</p></li></ul><h2 id="_360面试准备" tabindex="-1"><a class="header-anchor" href="#_360面试准备" aria-hidden="true">#</a> 360面试准备</h2><h3 id="arm中的特殊寄存器" tabindex="-1"><a class="header-anchor" href="#arm中的特殊寄存器" aria-hidden="true">#</a> Arm中的特殊寄存器</h3><ul><li>sp寄存器也就是栈顶寄存器用于保存栈顶的值</li><li>fp( x29寄存器) 栈基址寄存器用于保存栈底的地址</li><li>lr (x30寄存器) 专门用来保存bl指令的下一条指令的内存地址</li><li>zr( x31寄存器) xzr/wzr 也就是固定为0 写进去表明丢弃结果,读取就是0</li><li>pc寄存器 也就是保存将要执行的指令的地址</li></ul><h3 id="arm函数调用规范" tabindex="-1"><a class="header-anchor" href="#arm函数调用规范" aria-hidden="true">#</a> arm函数调用规范</h3><h4 id="_64位" tabindex="-1"><a class="header-anchor" href="#_64位" aria-hidden="true">#</a> 64位</h4><ul><li><p>传参</p><ul><li>x0-x7用于存放函数的前8个参数,其余的压栈.</li></ul></li><li><p>返回值</p><ul><li>函数返回值</li></ul></li><li></li></ul><h3 id="mc实际分析" tabindex="-1"><a class="header-anchor" href="#mc实际分析" aria-hidden="true">#</a> Mc实际分析</h3><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>SUB             SP, SP, #0x90
STP             X24, X23, [SP,#0x80+var_30]
STP             X22, X21, [SP,#0x80+var_20]
STP             X20, X19, [SP,#0x80+var_10]
STP             X29, X30, [SP,#0x80+var_s0]
ADD             X29, SP, #0x80
MRS             X23, #3, c13, c0, #2
LDR             X8, [X23,#0x28]
MOV             X20, X0
STUR            X8, [X29,#var_38]
ADRP            X8, #0xE33F000
LDR             X8, [X8,#0xBB8]
CBZ             X8, loc_4A3FF00
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>SUB 将sp指针展开</li><li>再开始从栈中取值 从而获取变量</li></ul><h4 id="stp-ldr指令" tabindex="-1"><a class="header-anchor" href="#stp-ldr指令" aria-hidden="true">#</a> STP &amp; LDR指令</h4><blockquote><p>参考文章:<a href="https://blog.csdn.net/sinat_32960911/article/details/131533128" target="_blank" rel="noopener noreferrer">【ARM 常见汇编指令学习 2 -- 存储指令 STP 与 LDP】_arm stp-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><a href="https://blog.csdn.net/wmzjzwlzs/article/details/124513127" target="_blank" rel="noopener noreferrer">stp 指令_stp指令-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>stp指令可以理解为str指令的变种也就是pair 一对寄存器</p></blockquote><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>STP &lt;Wt1&gt;, &lt;Wt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
STP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
# LDP指令
LDP &lt;Wt1&gt;, &lt;Wt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
LDP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>wt1表示32位寄存器</li><li>xt1表示64位寄存器</li></ul><p>STP一般是一次性将两个寄存器的值存储到目标的内存地址中,</p><p>比如执行下方指令</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>stp x29, x30, [sp, #0x10]  ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>就是在sp指向地址偏向0x10位置的地方开始依次向高地址存储x29,x30寄存器</li></ul><p>如果在操作后面添加!符号那么就多了一层含义</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>stp q6, q7, [sp, #-32]!
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>就等效为</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>sub sp, sp, #32
stp q6, q7, [sp]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>也就是在进行存储操作后sp寄存器的值发生了改变</li></ul><h4 id="b-bl-blr-br-brk-ret指令" tabindex="-1"><a class="header-anchor" href="#b-bl-blr-br-brk-ret指令" aria-hidden="true">#</a> B BL BLR BR BRK RET指令</h4><p><strong>B</strong></p><p>相当于直接跳转到某个地址也就是JMP的操作,并且这个操作不会改变x30寄存器的值也就是lr寄存器的值</p><p>还可以配合条件一起使用</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>CMP R1 ，＃ 0 ；  当 CPSR 寄存器中的 Z 条件码置位时，程序跳转到标号 Label 处执行
BEQ Label
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>BL</strong></p><p>先将下一条指令保存到寄存器LR(x30)中,然后再进行跳转 一般用于不同函数直接进行调用 同样和B一样可以带条件进行跳转</p><p><strong>BR</strong></p><p>跳转到某个寄存器指向的地址,不会改变LR寄存器的值也就是x30寄存器</p><h4 id="cbz指令" tabindex="-1"><a class="header-anchor" href="#cbz指令" aria-hidden="true">#</a> CBZ指令</h4><blockquote><p>参考文章:<a href="https://blog.csdn.net/mmbb26/article/details/132196832" target="_blank" rel="noopener noreferrer">ARM64 指令用法学习整理_cbz指令-CSDN博客<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><p>也是一种条件分支指令,用于在寄存器上进行比较,如果该寄存器的值为0 则直接跳转到目标地址</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>CBZ X0, Label     ; 如果X0的值为零，跳转到Label标签处
...               ; 如果X0的值不为零，继续执行下一条指令
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="arm架构的立即数" tabindex="-1"><a class="header-anchor" href="#arm架构的立即数" aria-hidden="true">#</a> Arm架构的立即数</h4><p><strong>ARM指令是精简指令集，指令长度固定都是32位</strong> 所以能表示的立即数范围是很有限制的,我们只能通过其他间接的方式去传递</p></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope/edit/main/src/posts/sycKernel.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page on GitHub" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page on GitHub<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">Last update: </span><!----></div><div class="contributors"><span class="label">Contributors: </span><!--[--><!--[--><span class="contributor" title="email: 88972629+awaqwqa@users.noreply.github.com">Elegy</span>,<!--]--><!--[--><span class="contributor" title="email: 88972629+awaqwqa@users.noreply.github.com">awaqwqa</span><!--]--><!--]--></div></div></footer><!----><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">Default footer</div><div class="vp-copyright">Copyright © 2024 Elegy</div></footer></div><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-mtXdL8hD.js" defer></script>
  </body>
</html>
